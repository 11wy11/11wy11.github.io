[{"title":"QGIS二次开发-QT Designer使用技巧点","date":"2021-01-15T08:06:24.000Z","path":"2021/01/15/qt-develop-skill-1/","text":"Qt Designer 加入资源文件Qt Designer中如果在设计UI界面的时候要加入一些图素，图标等资源的时候是不能直接添加进去的，需要在Qt开发目录下编写QRC文件 qrc文件格式如下： 123456&lt;RCC&gt; &lt;qresource prefix=&quot;/images&quot;&gt; &lt;file&gt;mActionPan.png&lt;/file&gt; &lt;file&gt;Themes/mActionPanSelected.svg&lt;/file&gt; &lt;/qresource&gt;&lt;/RCC&gt; 第一步： 选择 “资源浏览器” img 点击类似铅笔的button 第二步： 从编辑资源选择击鼠标右键， img 新建一个image.qrc文件， 第三步： 添加资源，先选择一个新前缀，然后添加文件 img 确定之后就可以在需要资源的地方引用资源浏览器的图片或文件了！ QGIS工程添加qrc文件在创建的QT工程中，引入qgis，在使用qgis的图标时，在QtDesigner中能够看到图标，运行后，看不到，需要在Resource Files 下添加 images 文件夹下的image.qrc","tags":[{"name":"QGIS","slug":"QGIS","permalink":"http://11wy11.github.io/tags/QGIS/"},{"name":"QT","slug":"QT","permalink":"http://11wy11.github.io/tags/QT/"}]},{"title":"资料整理裂变","date":"2021-01-09T05:02:13.000Z","path":"2021/01/09/resource-collection/","text":"DXF文件格式详解：https://wenku.baidu.com/view/45beee5886c24028915f804d2b160b4e767f81cc.html","tags":[{"name":"其他","slug":"其他","permalink":"http://11wy11.github.io/tags/其他/"}]},{"title":"QGIS 文件结构解析及符号化类结构解析","date":"2021-01-02T03:43:08.000Z","path":"2021/01/02/qgis-develop-filestruct/","text":"分析QGS文件格式及符号及注记组织结构 QGS 文件结构QGS xml结构 ProjectLayers 结构包括图层属性，符号规则，注记规则 QLR 图层定义文件 qlr QML文件 qml MapLayerStyleCategory image-20210103220709620 QgsMapLayerStyleManager 管理与一个地图层一起使用的样式。 存储的样式由其名称标识。管理器始终跟踪当前处于活动状态的已存储样式。更改当前样式后，新样式将应用于关联的图层。 QgsMapLayerStyleManagerWidget QgsSymbolLayerproperty PropertySize 符号大小。 PropertyAngle 符号角度。 PropertyName 名称，例如简单标记的形状名称。 PropertyFillColor 填色。 PropertyStrokeColor 描边颜色。 PropertyStrokeWidth 行程宽度。 PropertyStrokeStyle 笔触样式（例如，实线，虚线） PropertyOffset 符号偏移量。 PropertyCharacter 字符，例如用于字体标记符号层。 PropertyWidth 符号宽度。 PropertyHeight 符号高度。 PropertyPreserveAspectRatio 保留宽度和高度之间的长宽比。 PropertyFillStyle 填充样式（例如，实心，点） PropertyJoinStyle 线联接样式。 PropertySecondaryColor 次要颜色（例如用于渐变填充） PropertyLineAngle 线角或哈希线符号的哈希线角度。 PropertyLineDistance 行之间的距离，或散列线符号的行长。 PropertyGradientType 渐变填充类型。 PropertyCoordinateMode 渐变坐标模式。 PropertyGradientSpread 梯度扩散模式。 PropertyGradientReference1X 渐变参考点1 x。 PropertyGradientReference1Y 梯度参考点1 y。 PropertyGradientReference2X 渐变参考点2 x。 PropertyGradientReference2Y 梯度参考点2 y。 PropertyGradientReference1IsCentroid 渐变参考点1是质心。 PropertyGradientReference2IsCentroid 渐变参考点2为质心。 PropertyBlurRadius Shapeburst模糊半径。 PropertyShapeburstUseWholeShape Shapeburst使用整个形状。 PropertyShapeburstMaxDistance 边缘距离处的Shapeburst填充。 PropertyShapeburstIgnoreRings Shapeburst忽略环。 PropertyFile 文件名，例如svg文件。 PropertyDistanceX 点之间的水平距离。 PropertyDistanceY 点之间的垂直距离。 PropertyDisplacementX 水平位移。 PropertyDisplacementY 垂直位移。 PropertyOpacity 不透明度。 PropertyCustomDash 自定义破折号模式。 PropertyCapStyle 线帽样式。 PropertyPlacement 线标记放置。 PropertyInterval 行标记间隔。 PropertyOffsetAlongLine 沿线偏移。 PropertyAverageAngleLength 长度到平均符号角度。 PropertyHorizontalAnchor 水平锚点。 PropertyVerticalAnchor 垂直锚点。 PropertyLayerEnabled 是否启用符号层。 PropertyArrowWidth 箭头尾巴宽度。 PropertyArrowStartWidth 箭头尾部开始宽度。 PropertyArrowHeadLength 箭头长度。 PropertyArrowHeadThickness 箭头的厚度。 PropertyArrowHeadType 箭头类型。 PropertyArrowType 箭头类型。 PropertyOffsetX 水平偏移。 PropertyOffsetY 垂直偏移。 PropertyPointCount 点数。 PropertyRandomSeed 随机数种子。 PropertyClipPoints 标记是否应修剪到多边形边界。 PropertyDensityArea 密度区域。 PropertyFontFamily 字体系列。 PropertyFontStyle 字体样式。 PropertyDashPatternOffset 虚线图案偏移量。 QgsSymbol dir_66f89767e42cf8b00ce6054c6b00ac7c_dep qgssymbol_8h__incl 整体功能结构 dir_aebb8dcc11953d78e620bbef0b9e2183_dep","tags":[{"name":"QGIS","slug":"QGIS","permalink":"http://11wy11.github.io/tags/QGIS/"}]},{"title":"QGIS插件开发学习","date":"2020-12-26T15:09:17.000Z","path":"2020/12/26/qgis-develop-6/","text":"python PyQGIS插件开发代码学习片段 QGIS设置支持mdb点击设置》选项》系统，在环境，勾选使用自定义变量，添加两个环境： OGR_SKIP ODBC， PGEO_DRIVER_TEMPLATE DRIVER=Microsoft Access Driver (.mdb, .accdb);DBQ=%s image-20201226231641904 D:\\OSGeo4W64\\include;D:\\OSGeo4W64\\apps\\Qt5\\include\\QtXml;D:\\OSGeo4W64\\apps\\Qt5\\include\\QtWidgets;D:\\OSGeo4W64\\apps\\Qt5\\include\\QtQml;D:\\OSGeo4W64\\apps\\Qt5\\include\\QtGui;D:\\OSGeo4W64\\apps\\Qt5\\include\\QtPrintSupport;D:\\OSGeo4W64\\apps\\Qt5\\include\\QtQmlDebug;.\\;.\\qgslib\\ui;D:\\OSGeo4W64\\apps\\gdal-dev\\include;D:\\OSGeo4W64\\apps\\Qt5\\include\\qt5keychain;D:\\OSGeo4W64\\apps\\Qt5\\include\\QtCrypto;D:\\OSGeo4W64\\apps\\Qt5\\include\\QtSql;D:\\OSGeo4W64\\apps\\Qt5\\include\\QtCore;.\\qgslib\\core;.\\qgslib\\app\\layout;.\\qgslib\\gui;.\\qgslib\\app;D:\\OSGeo4W64\\apps\\qgis\\include;%(AdditionalIncludeDirectories)","tags":[{"name":"QGIS","slug":"QGIS","permalink":"http://11wy11.github.io/tags/QGIS/"}]},{"title":"QGIS 按照官方指南编译源码","date":"2020-12-22T06:35:20.000Z","path":"2020/12/22/qgis-develop-5/","text":"最终成功编译QGIS的详细步骤，可以不用来cmake-gui界面，就可以配置 软件环境准备VS2015需要安装的开发工具Select “Custom” install and add the following packages: “Common Tools for Visual C++ 2015” under “Visual C++” “Tools (1.4.1) and Windows 10 SDK (10.0.14393)” under “Universal Windows App Development Tools”. 下载软件包 Tool Website CMake https://cmake.org/files/v3.7/cmake-3.7.2-win64-x64.msi cygwin http://cygwin.com/setup-x86.exe (32bit) or http://cygwin.com/setup-x86_64.exe (64bit) OSGeo4W http://download.osgeo.org/osgeo4w/osgeo4w-setup-x86.exe (32bit) or http://download.osgeo.org/osgeo4w/osgeo4w-setup-x86_64.exe (64bit) ninja https://github.com/ninja-build/ninja/releases/download/v1.7.2/ninja-win.zip 对于cygwin和OSGeo4W，下载完后都是选择高级安装。 在选包界面的搜索栏输入文档中给出的包名，目前官方文档给出的是： 1.cygwin- bison- flex image-20201122191237032 设置环境变量：Path中添加C:\\cygwin64\\bin image-20201122191332862 检查是否安装成功flex和bison,见下图 image-20201122191537468 2.OSGeo4W: 下载地址： http://download.osgeo.org/osgeo4w/osgeo4w-setup-x86.exe (32bit) or http://download.osgeo.org/osgeo4w/osgeo4w-setup-x86_64.exe (64bit) 选择Advance Install ,在线下载时，使用镜像http://gwmodel.whu.edu.cn/mirrors/osgeo4w，不然会下载特别缓慢 另外之后编译的过程中如果发现有缺失的包也是可以重新在这里补充下载的。 搜索qgis-dev-deps img 直接下一步完成安装即可。 3.安装CMakehttps://cmake.org/download/ image-20201122184022077 4.ninja(https://github.com/ninja-build/ninja/releases/download/v1.7.2/ninja-win.zip)下载后解压，将ninja.exe 拷贝到 配置环境变量1.path中添加cmake,osgeo4W64等环境变量C:\\OSGeo4W64\\bin D:\\cygwin64\\bin D:\\cmake-3.19.0-win64-x64\\bin 2.开发python插件所需要的环境变量配置 image-20201225191859911 QGIS源码编译1. 克隆或者下载源代码官方例子放在了OSGeo4W下， 12cd C:\\OSGeo4W64git clone git://github.com/qgis/QGIS.git 2. 在OSGeo4W64下，创建OSGeo4W-dev.bat文件首先运行OSGeo4W64下的bat,设置qt等环境变量，然后保存并运行该批处理文件 123 @echo off call C:\\OSGeo4W64\\QGIS\\ms-windows\\osgeo4w\\msvc-env.bat x86_64@cmd 3.使用configonly.bat创建VS工程如果遇到提示cmake 非法命令，可以修改msvc-env.bat中path的设置， 12cd C:\\OSGeo4W64\\QGIS\\ms-windows\\osgeo4wconfigonly.bat 如果提示Flex报错等，可以检查msvc-env.bat中的设置默认是c:\\cygwin64\\bin,如果不是，注意修改路径 image-20201225192436078 4.编译QGIS在运行了OSGeo4W-dev.bat文件之后，在创建编译的工程，确保所有的环境变量被正确设置 运行 call gdal-dev-env.bat 来添加gdal和proj库路径 输入 devenv打开VS 4.编译过程报错解决1.error LNK2019 error LNK2019: 无法解析的外部符号 “declspec(dllimport) public: static class QString cdecl QgsOpenClUtils::deviceInfo(enum QgsOpenClUtils::Info,class cl::Device)” (_imp?deviceInfo@QgsOpenClUtils@@SA?AVQString@@W4Info@1@VDevice@cl@@@Z)，该符号在函数 解决方案1：由于项目字符集设置问题，根据提示将指定项目的字符集设置为与DLL一致，具体设置如下：项目属性-&gt;配置属性–&gt;常规-&gt;项目默认值-&gt;字符集中设置字符集（测试没有用） 最终解决：再解决了问题2中的重定义问题后，问题1也修复 2.PJ_CONTEXT重定义比较坑的地方是OSGeo4W64/include 以及OSGeo4W64/app/proj-dev/include 均有proj.h，需要看你工程里配置的proj库是哪个路径，我的需要修改的是OSGeo4W64/include 下的proj.h设置#pragma once，注意看include 的引入顺序，默认生成的引用顺序为先定义了proj-dev/include 后定义了OSGeo4W64/include，调整顺序为下图所示： image-20201229172653562 总结： 1. 修改OSGeo4W64/include 下的proj.h，在文件开头 添加代码：#pragma once 2. 调整c++/常规，附加包含目录，include顺序，先根目录C:\\OSGeo4W64\\include，再C:\\OSGeo4W64\\apps\\proj-dev\\include 3.步骤2需要设置的工程包括：qgis_core,qgis_gui,qgis_app,qgis_process 3.如果编译过程中提示找不到PyQT5的module等错误运行OSGeo4W-dev.bat，执行call gdal-dev-env.bat,使用devenv命令启动vs2015,再打开工程 成功之后，设置qgis为启动项，运行，就可以看到QGIS界面了 image-20201229184038694 image-20201229185257473 参考文档官方github下的install.md","tags":[{"name":"QGIS","slug":"QGIS","permalink":"http://11wy11.github.io/tags/QGIS/"}]},{"title":"QGIS二次开发-配置python环境","date":"2020-12-07T06:42:14.000Z","path":"2020/12/07/qgis-develop-5-python-env/","text":"使用QGIS PluginBuilder 来创建Python模板的qgis 插件 Plugin Builder 创建插件创建完成后，如果提示没有pyrcc5， 12pyuic5 -o WYFirstPlugin_dialog.py WYFirstPlugin_dialog_base.uipyrcc5 -o resources.py resources.qrc 使用QGIS控制台脚本 python查看application查看安装路径 QgsApplication.prefixPath()","tags":[{"name":"QGIS","slug":"QGIS","permalink":"http://11wy11.github.io/tags/QGIS/"}]},{"title":"QGIS编译可能遇到的问题","date":"2020-12-04T11:21:13.000Z","path":"2020/12/04/qgis-development-problem/","text":"QGIS编译源码可能遇到的问题 [TOC] 1. 修改不识别的符号先在资源管理器中找到qgis项目，右击该项目，选择“设为启动项目” 接着，你可以先试着第一次生成解决方案，以排除所有页面不识别的错误 你应会遇到大量报错，请等待生成完毕。在错误中会出现例如“错误 C2143 语法错误: 缺少“)”(在“;”的前面) ”“错误 C2001 常量中有换行符 ”……这些错误的原因是因为页面不支持(“′”)(“″”)的符号 在错误列表关闭错误，仅查看警告，并点击“说明”让其聚类。大体上将出现会三种警告类型。对于以下这两种，我们忽视掉——“警告 C4718 “QMapNode&lt;int,QgsRasterIterator::RasterPartInfo&gt;::doDestroySubTree”: 递归调用无副作用，正在删除 ”“警告 C4702 无法访问的代码 ” 而对于——“警告 C4819 该文件包含不能在当前代码页(936)中表示的字符。请将该文件保存为 Unicode 格式以防止数据丢失 ” 我们点双击其文件一栏的文件名，进入对应的.cpp或.h文件 Ctrl+A 全选文件内容，点击上方“文件”，找到“高级保存设置” 将其从无签名改为带签名 修改后—— 修改所有出现此类警告的.cpp和.h文件，再次生成“qgis”项目，大部分报错将会消失。（也有可能直接编译通过） 2. 可能报错的其他问题2.1与qtmain.lib有关的未初始化的定义解决方法：找到例如此的警告信息LNK4099 未找到 PDB“qtmain.pdb”(使用“qtmain.lib(qtmain_win.obj)正在链接对象，如同没有调试信息一样得到该警告来源的项目名，如“qgiscrashhandle” 右击“qgiscrashhandle项目”-&gt;“属性”-&gt;“连接器”-&gt;“输入”附加依赖项中修改添加D:\\QGIS\\OSGeo4W64\\apps\\Qt5\\lib\\qtmain.lib 2.2 qgis_gui项目中出现未定义的标识符 “QWebElement”解决方法：“qgis_gui项目”-&gt;“属性”-&gt;“C/C++”-&gt;“常规”附加包含目录中修改添加D:\\QGIS\\OSGeo4W64\\apps\\Qt5\\include\\QtWebKit 注释掉报错函数关于QWebElemen类的内容，并在qgismaptip.cpp文件开头注释掉——//#if WITH_QTWEBKIT//#endif（因为原代码中WITH_QTWEBKIT未定义，头文件 不可被识别；又因WITH_QTWEBKIT未定义，QWebElemen类中部分函数无法被调用，故也注释掉） 2.3 qgis_gui项目中出现CORE_EXPORT显式实例化声明无效解决方法：对于报错的位置——qgsoptionalexpression.h文件中，在template后添加class 重新生成解决方案。如果完整的下载了链接库并正确引入路径，此时，不会再遇到其他问题。 我们可以在输出路径下发现生成的qgis.exe文件（路径：D:\\QGIS\\qgis-3.2.2-build\\output\\bin\\RelWithDebInfo） 2.4 C1083 keychain.h无法打开包含文件检查qgis_core中链接器，输入中添加附加包含目录Qt5Keychain.lib 3. 其他可能的问题（来源于网络统计）如果出现问题，优先选择从gis_core项目、qgis_analysis项目、qgis_gui项目依次调试（其他项目均依赖于他们）此时仍然有可能出现： 3.1 error MSB6006: “rc.exe”已退出，代码为 5在C盘下直接搜索该应用，将其路径配置到项目中即可。 3.2 MSVCRT.lib(exe_winmain.obj) : error LNK2019: 无法解析的外部符号 WinMain这是因为——新建项目是控制台应用程序，而程序通过的是WinMian（及windows入口函数）可以在“qgis_core项目”-&gt;“属性”-&gt;“连接器”-&gt;“输入”附加依赖项中修改添加D:\\QGIS\\OSGeo4W64\\apps\\Qt5\\lib\\qtmain.lib 重新生成即可。 3.4 链接错误或者缺少有关附加库问题通常表现为——无法解析的外部符号；找不到、打不开.lib文件等这与个人的主机环境有关，可以在“项目”-&gt;“属性”-&gt;“连接器”-&gt;“输入”附加依赖项中修改。附上我的部分属性情况 Lib问题，检查附加依赖项可以在“项目”-&gt;“属性”-&gt;“连接器”-&gt;“输入”附加依赖项中查看修改； 对于Release或者RelWithDebInfo版本，Lib路径基本如下图列举对于Debug版本，部分Lib库名后有d标识如下图的Qt5Cored即为Debug版本（Debug版本与Release（RelWithDebInfo）版本的Lib名称不同，但路径一致。在工程修改版本环境时会自动更新链接，更改库名。无需手动更改。） 3.5 缺少可执行文件或者环境路径问题Dll问题，检查可执行文件目录，即检查环境路径可以在“项目”-&gt;“属性”-&gt;“VC++目录”-&gt;“可执行文件目录”中编辑查看主要检查有无以下路径：D:\\QGIS\\OSGeo4W64\\apps\\qt5\\binD:\\QGIS\\OSGeo4W64\\apps\\Python37D:\\QGIS\\OSGeo4W64\\apps\\Python37\\ScriptsD:\\QGIS\\OSGeo4W64\\binD:\\Program Files\\CMake\\binD:\\QGIS\\cygwin64\\binC:\\WINDOWS\\system32C:\\WINDOWSC:\\WINDOWS\\system32\\WBem 3.6 error MSB6006 cmd.exe已退出，代码为1查看输出，主要是在构建qtpython中报错 3.7 error MSB23073编译过程中找不到一些模块 1234567891011严重性 代码 说明 项目 文件 行 禁止显示状态错误 MSB3073 命令“setlocalC:\\cmake-3.19.0-win64-x64\\bin\\cmake.exe -P J:/QGISDEV/QGISBuild1/python/plugins/db_manager/stageinstall.cmakeif %errorlevel% neq 0 goto :cmEnd:cmEndendlocal &amp; call :cmErrorLevel %errorlevel% &amp; goto :cmDone:cmErrorLevelexit /b %1:cmDoneif %errorlevel% neq 0 goto :VCEnd:VCEnd”已退出，代码为 1。 zzz-db_manager-stageinstall C:\\Program Files (x86)\\MSBuild\\Microsoft.Cpp\\v4.0\\V140\\Microsoft.CppCommon.targets 133 QQmlComponent: Component is not ready79&gt; file:///J:/QGISDEV/QGISBuild1/src/quickgui/plugin/typelist.qml:2:1: plugin cannot be loaded for module “QgsQuick”: Cannot load library J:\\QGISDEV\\QGISBuild1\\src\\quickgui\\plugin\\QgsQuick\\qgis_quick_plugin.dll: 找不到指定的模块。 4. python相关Debug方式编译生成解决方案时，提示缺少python37_d.lib，需要安装python debug版本，如果没有，可以修改已经安装的python，如下图所示 勾选最后一项，然后install，安装后可以在附加依赖项中添加python37_d.lib 4.1 在python中执行from PyQt5.QtCore import * 提示引入模块找不到 from qgis._core import *ImportError: DLL load failed: 找不到指定的程序。 【解决方案】:使用镜像安装sip,pyqt5,pyqt5-tools pip install pyqt5 pyqt5-tools -i http://pypi.douban.com/simple/ --trusted-host pypi.douban.com 4.2 在python中执行from PyQt5.Qsci import * 提示引入模块找不到【解决方案】:使用镜像安装QScintilla 4.3 Python ImportError：DLL load failed： %1不是有效的win32应用程序错误本身是因为python版本位数 pywin32版本不一致，网上说是因为需要下载安装对应版本pywin32 我遇到的问题是，在编译qgis的时候，同时通过exe的方式安装了其他版本的qt,在查找使用包的时候使用了另一个qgis版本下的 https://github.com/mhammond/pywin32/releases 可以下载安装试试，我目前还没尝试 4.4 qgis_quick_plugin4.5 C2248 python_module_qgis_core sip_corepart6.cpp QgsAuthManager 无法访问protected 成员运行成果 配置运行环境编译好的qgis.exe会在目录D:\\QGIS\\qgis-3.2.2-build\\output\\bin\\RelWithDebInfo下 但打开qgis.exe时会出现报错 此时，把OSGeo4W64\\apps\\Qt5\\bin和OSGeo4W64\\bin下的dll文件全部拷贝到exe文件同目录下即可 同时，把OSGeo4W64\\apps\\Qt5\\plugins文件下的platforms文件夹也拷贝到exe文件同目录下当程序运行时，找不到正确支持图标格式（svg）的库文件。这里需要把OSGeo4W64\\apps\\Qt5\\plugins文件下的imageformats文件夹也拷贝到exe文件同目录下 再次打开运行qgis.exe","tags":[{"name":"QGIS","slug":"QGIS","permalink":"http://11wy11.github.io/tags/QGIS/"}]},{"title":"QT5.11.2+vs2015+qgis 搭建qgis二次开发环境","date":"2020-11-20T09:51:05.000Z","path":"2020/11/20/qgis-develop-4/","text":"结合网上资料以及自己的尝试，整理一个搭建环境的详细步骤 基本软件下载1.OSGeo4W下载OSGeo4W http://download.osgeo.org/osgeo4w/osgeo4w-setup-x86.exe (32bit) or http://download.osgeo.org/osgeo4w/osgeo4w-setup-x86_64.exe (64bit) 选择Advance Install ,在线下载时，使用镜像http://gwmodel.whu.edu.cn/mirrors/osgeo4w，不然会下载特别缓慢 2. QT5会在安装qgis的时候，同时下载QT5.11.2，默认安装路径为：C:\\OSGeo4W64\\apps\\Qt5 3.VS2015安装QT插件方式一：通过工具》扩展与更新》联机，搜索QT，但在新建QT工程时，只有QTWidgetsApplication,没有QTGUIApplication，想使用QT GUI Application模板创建，则卸载方式一安装的插件方式二：进入下边网站下载，点击安装即可。（本次下载的是2.4.3） https://download.qt.io/official_releases/vsaddin/2.4.3/ VS 创建QT工程新建项目，C++下QT,使用QT GUI Application模板创建，勾选XML。，经过测试，直接使用方式一安装的插件，创建QT WidgetsApplication也可以 配置项目属性1.C/C++下，附加包含目录，设置qt相关的include，以及OSGeo4W，QGIS的include目录 1C:\\OSGeo4W64\\include;C:\\OSGeo4W64\\apps\\Qt5\\include\\QtXml;C:\\OSGeo4W64\\apps\\Qt5\\include\\QtWidgets;C:\\OSGeo4W64\\apps\\Qt5\\include\\QtGui;C:\\OSGeo4W64\\apps\\qgis\\include;%(AdditionalIncludeDirectories) 2.链接器，设置附加库目录 1C:\\OSGeo4W64\\apps\\Qt5\\lib;C:\\OSGeo4W64\\apps\\qgis\\lib;%(AdditionalLibraryDirectories) 3.链接器下，输入，设置附加依赖项 1qgis_core.lib;qgis_app.lib;qgis_gui.lib;Qt5Widgets.lib;Qt5Xml.lib;%(AdditionalDependencies) 4.在项目工程目录下，与EXE同级目录下，将OSGeo4W的bin,apps/qgis/bin,apps/QT5/bin下的所有dll拷贝到exe同级目录。 image-20201121132810671 image-20201121132901385 image-20201121133711149 image-20201121133749867 5.将qt中plugins拷贝到4所述的路径下，否则编译会报错，提示no QT Platform的错误，如果不知道，就都拷，考虑到项目大小，使用其他QT工程自动拷贝dll的方法，自动添加qt拷贝 image-20201121133113855 image-20201121133135496 其他QT工程自动拷贝dll的方法在当前工程的exe目录下，可以在按住shift,右键Release目录，选择在powershell窗口打开,执行以下命令：QtGuiApplication1为创建的qt工程项目 C:\\OSGeo4W64\\apps\\Qt5\\bin\\windeployqt.exe QtGuiApplication1.exe 运行第一个QGIS项目找不到M_PI主要是C++默认不包含科学库，需要设置预处理器，、、、、 image-20201121143633512 第一个qgis项目1.在main.app中改QtApplication的主函数为QgisApplication 123456789101112131415161718#include \"QtGuiApplication1.h\"#include &lt;QtWidgets/QApplication&gt;#include &lt;qgsapplication.h&gt;int main(int argc, char *argv[])&#123; /*QApplication a(argc, argv); QtGuiApplication1 w; w.show(); return a.exec();*/ QgsApplication a(argc, argv, true); QgsApplication::setPrefixPath(\"C:/OSGeo4W/apps/qgis\", true); QgsApplication::initQgis(); //初始化QGIS应用 QtGuiApplication1 w; w.show(); return a.exec();&#125; 2.在窗体主文件中，头文件，定义mapcanvas，以及图层 123456789101112131415161718192021222324252627282930313233#pragma once#include &lt;QtWidgets/QMainWindow&gt;#include \"ui_QtGuiApplication1.h\"#include &lt;qmenu.h&gt;#include &lt;qaction.h&gt;#include &lt;qgsmapcanvas.h&gt;class QtGuiApplication1 : public QMainWindow&#123; Q_OBJECTpublic: QtGuiApplication1(QWidget *parent = Q_NULLPTR);private: Ui::QtGuiApplication1Class ui; // create the menus and then add the actions to them. QMenu *fileMenu; QAction *openFileAction; //map canvas QgsMapCanvas *mapCanvas; QList&lt;QgsMapLayer *&gt; layers; public slots: void on_openFileAction_triggered(); //public: void addVectorLayer();&#125;; 3.cpp文件中 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include \"QtGuiApplication1.h\"#include &lt;qmenubar.h&gt;#include &lt;qmessagebox.h&gt;#include &lt;qfiledialog.h&gt;#include &lt;qgsvectorlayer.h&gt;QtGuiApplication1::QtGuiApplication1(QWidget *parent) : QMainWindow(parent)&#123; ui.setupUi(this); this-&gt;resize(600, 400); // create the menus and then add the actions to them. fileMenu = this-&gt;menuBar()-&gt;addMenu(\"File\"); openFileAction = new QAction(\"Open\", this); this-&gt;connect(openFileAction, SIGNAL(triggered(bool)), this, SLOT(on_openFileAction_triggered())); fileMenu-&gt;addAction(openFileAction); // initialize the map canvas mapCanvas = new QgsMapCanvas(); this-&gt;setCentralWidget(mapCanvas); mapCanvas-&gt;setCanvasColor(QColor(255, 255, 255)); mapCanvas-&gt;setVisible(true); mapCanvas-&gt;enableAntiAliasing(true);&#125;void QtGuiApplication1::on_openFileAction_triggered() &#123; addVectorLayer();&#125;void QtGuiApplication1::addVectorLayer()&#123; QString fileName = QFileDialog::getOpenFileName(this, tr(\"Open shape file\"), \"\", \"*.shp\"); QStringList temp = fileName.split('/'); QString basename = temp.at(temp.size() - 1); QgsVectorLayer* vecLayer = new QgsVectorLayer(fileName, basename, \"ogr\"); if (!vecLayer-&gt;isValid()) &#123; QMessageBox::critical(this, \"error\", QString(\"layer is invalid: \\n\") + fileName); return; &#125; mapCanvas-&gt;setExtent(vecLayer-&gt;extent()); layers.append(vecLayer); mapCanvas-&gt;setLayers(layers); mapCanvas-&gt;refresh();&#125; 可能遇到的错误及解决1、提示qgis相关库找不到， image-20201121141305726 解决方案：,将qgis/bin下dll拷贝到项目编译后exe所在目录 同理，可能会提示找不到OSGeo4W下例如gdal,sqlite3等库dll,将OSGeo4W/bin下dll拷贝到项目编译后exe所在目录 2.Release版本可以运行，但在Debug模式，新建地图画布mapcanvas报错将include和lib,使用qgis-dev路径下的文件 其次，如果在debug模式下编译提示无法找到某个dll,也可以在网上下载提示的dll，像gdal303.dll，在app/gdal-dev中，proj_8_0.dll，在proj-dev里 3.warning C4003 引入头文件顺序错误11&gt;d:\\osgeo4w64\\apps\\qgis\\include\\qgsdatetimestatisticalsummary.h(148): warning C4003: “min”宏的实参不足 (编译源文件 MapRepApp.cpp) c/c++ 附加包含目录中定义的目录顺序有关，尝试调整相关库顺序 &lt;windows.h&gt;头文件中的宏 min(或者max)与QT的类QTimer 中的宏min(或者max)冲突 4.error C3646未知重写说明符1.h 1.cpp 2.h 2.cpp 在1.h 中#include了 2.h ，然后在2.h 中又#include了 1.h ，然后这个错误就出现了 出现这个提示，一般情况是：①本错误所在文档加载的某个头文件中，文件的最后缺失了一个分号。②缺少定义，未包含相应的头文件；③类的定义的先后顺序有误 5.dll链接不一致不允许定义dllimport静态数据成员QGIS 二次开发在Release模式开发使用断点 链接器》调试，设置生成调试信息，生成完整程序数据库文件，生成映射文件，即时导出，如下图所示 设置C/C++常规调试信息格式：用于“编辑并继续”的程序数据库 设置C/C++ 优化：已禁用 image-20210116223206885","tags":[{"name":"QGIS","slug":"QGIS","permalink":"http://11wy11.github.io/tags/QGIS/"}]},{"title":"QGIS二次开发学习（二）-测试demo","date":"2020-11-18T13:37:21.000Z","path":"2020/11/18/qgis-develop-3/","text":"收集的QGIS Demo代码 测试DemoDemo11234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include &lt;qgis.h&gt;#include \"MainWindow.h\"#include &lt;QApplication&gt;#include &lt;qgis_core.h&gt;#include &lt;qgis_gui.h&gt;#include &lt;qgsdatasourceuri.h&gt;#include &lt;qgsproviderregistry.h&gt;#include &lt;QDebug&gt;#include &lt;QSqlDatabase&gt;#include &lt;QSqlError&gt;#include &lt;QSqlQuery&gt;#include &lt;qgssinglesymbolrenderer.h&gt;#include &lt;qgsapplication.h&gt; #define pluginsPath \"F:\\\\OSGeo4W64\\\\apps\\\\qgis-dev\\\\plugins\" //using namespace QgsGuiUtils; int main(int argc, char* argv[]) &#123; QgsApplication myApp(argc, argv, true); myApp.setPrefixPath(\"F:\\\\OSGeo4W64\\\\apps\\\\qgis\",true); QgsProviderRegistry::instance(\"F:\\\\OSGeo4W64\\\\apps\\\\qgis\\\\plugins\"); QString file(\"E:\\\\Beijing.osm.shp\\\\Beijing-shp\\\\shape\\\\roads.shp\"); QList&lt;QgsMapLayer*&gt; listVecLayer; QgsVectorLayer Vectorlayer; Vectorlayer.setProviderEncoding(\"GBK2312\"); Vectorlayer.setMinimumScale(1.0); Vectorlayer.setDataSource(file,QFileInfo(file).completeBaseName(),\"ogr\",true); //QgsFeature feature(); //QgsFeatureList FeatureList; //FeatureList.append(); //QgsVectorLayer usetLayer; //usetLayer.addFeatures(); listVecLayer.append(&amp;Vectorlayer); qDebug()&lt;&lt;Vectorlayer.featureCount(); QgsProject::instance()-&gt;addMapLayers(listVecLayer); QgsMapCanvas QGSMC; QGSMC.setLayers(listVecLayer); QGSMC.setExtent(Vectorlayer.extent()); QGSMC.enableAntiAliasing(true); QGSMC.freeze(false); QGSMC.setDragMode(QGraphicsView::RubberBandDrag); QGSMC.setVisible(true); QGSMC.zoomToFullExtent(); QGSMC.refresh(); QGSMC.show(); //QgsMapLayer* testlayer = new QgsMapLayer(); testlayer.show(); //QgsDataSourceUri GS_DATASURL; // setConnection（const QString＆aHost，const QString＆aPort，const QString＆aDatabase，const QString＆aUsername，const QString＆aPassword，SslMode sslmode = SslPrefer，const QString＆authConfigId = QString（）） //GS_DATASURL.setConnection(\"192.168.2.205\",\"3306\", \"beijin_map\", \"root\", \"root\", QgsDataSourceUri::SslMode::SslDisable); //GS_DATASURL.setDriver(\"Mysql\"); //qDebug() &lt;&lt; \"exit\" &lt;&lt; GS_DATASURL.table(); QSqlDatabase db = QSqlDatabase::addDatabase(\"QMYSQL\"); db.setHostName(\"192.168.2.205\"); db.setDatabaseName(\"beijing_map\"); db.setUserName(\"root\"); db.setPassword(\"root\"); if (db.open()) &#123; QSqlQuery qsql = QSqlQuery(db); if(qsql.exec(\"select COLUMN_NAME from information_schema.COLUMNS where table_name = 'testmap'\")) &#123; while (qsql.next()) &#123; qDebug() &lt;&lt; qsql.value(0).toString(); &#125; &#125; &#125; else qDebug() &lt;&lt; db.lastError(); //MainWindow MW; //MW.show(); //QgsMapLayoutConfigWidget QMLCW; //QMLCW.show(); return myApp.exec();&#125; Demo2123456789101112131415//// QGIS Includes//#include &lt;qgsapplication.h&gt;#include &lt;qgsproviderregistry.h&gt;#include &lt;qgssinglesymbolrenderer.h&gt;#include &lt;qgsmaplayerregistry.h&gt;#include &lt;qgsvectorlayer.h&gt;#include &lt;qgsmapcanvas.h&gt;//// Qt Includes//#include &lt;QString&gt;#include &lt;QApplication&gt;#include &lt;QWidget&gt; 我们用QgsApplication代替Qt中的QApplication来创建应用程序，这样可以方便地调用QGIS中的许多静态方法，比如得到库文件所在的路径等等。 各种数据的提供商plugins通过提供商注册表(QgsProviderRegistry)来管理，它会根据提供商自动加载相应的plugins，我们所需要做的就是指定plugins所存放的目录，让应用程序实例化这样的提供商注册表。 QgsSingleSymbolRenderer是最基本的符号类，它用一种颜色表示点、线、多边形对象。默认情况下颜色是随机选取的，当然，你也可以自己设定希望显示的颜色。每一个矢量图层都有一个对应的符号。 地图图层注册表（QgsMapLayerRegistry）用来管理现在正在使用的图层。QgsVectorLayer 继承自QgsMapLayer，添加了矢量数据特有的功能。 最后，地图画布（QgsMapCanvas）才是问题的关键，我们的地图将被绘制在这个工具上。 现在，我们开始初始化我们的应用程序： 123456789int main(int argc, char ** argv)&#123; // Start the Application QgsApplication app(argc, argv, true); QString myPluginsDir = &quot;/home/timlinux/apps/lib/qgis&quot;; QString myLayerPath = &quot;/home/timlinux/gisdata/brazil/BR_Cidades/&quot;; QString myLayerBaseName = &quot;Brasil_Cap&quot;; QString myProviderName = &quot;ogr&quot;; 这样我们就得到了一个qgsapplication。 变量myLayerPath指定了plugins所在的目录。 变量myLayerPath和myLayerBaseName指向要使用的shape文件。 变量myProviderName很重要，它告诉qgis加载数据文件需要使用哪个数据提供商。一般为”ogr”或”postgres”。 现在我们可以开始创建图层了： 121 // Instantiate Provider Registry2 QgsProviderRegistry::instance(myPluginsDir); 首先我们需要初始化提供商注册表。QgsMapLayerRegistry是一个单类（singleton class），因此我们使用它的静态函数instance()传递供应商插件库的路径，在此之后它将在这个路径下查找提供商的插件。 接下来我们继续创建图层： 12345678910111213141516171819QgsVectorLayer * mypLayer = new QgsVectorLayer(myLayerPath, myLayerBaseName, myProviderName); QgsSingleSymbolRenderer *mypRenderer = new QgsSingleSymbolRenderer(mypLayer-&gt;geometryType()); QList &lt;QgsMapCanvasLayer&gt; myLayerSet; mypLayer-&gt;setRenderer(mypRenderer); if (mypLayer-&gt;isValid()) &#123; qDebug(&quot;Layer is valid&quot;); &#125; else &#123; qDebug(&quot;Layer is NOT valid&quot;); &#125; // Add the Vector Layer to the Layer Registry QgsMapLayerRegistry::instance()-&gt;addMapLayer(mypLayer, TRUE); // Add the Layer to the Layer Set myLayerSet.append(QgsMapCanvasLayer(mypLayer, TRUE)); 1234567891011// Create the Map Canvas QgsMapCanvas * mypMapCanvas = new QgsMapCanvas(0, 0); mypMapCanvas-&gt;setExtent(mypLayer-&gt;extent()); mypMapCanvas-&gt;enableAntiAliasing(true); mypMapCanvas-&gt;setCanvasColor(QColor(255, 255, 255)); mypMapCanvas-&gt;freeze(false); // Set the Map Canvas Layer Set mypMapCanvas-&gt;setLayerSet(myLayerSet); mypMapCanvas-&gt;setVisible(true); mypMapCanvas-&gt;refresh(); return app.exec(); Demo3 首先，main.cpp 1234567891011121314#include &quot;gisTest2.h&quot;#include &lt;qgsapplication.h&gt;int main(int argc, char *argv[])&#123; QgsApplication a(argc, argv, true); QgsApplication::setPrefixPath(&quot;C:/OSGeo4W/apps/qgis&quot;, true); QgsApplication::initQgis(); //初始化QGIS应用 gisTest2 w; //创建一个窗体，类似于Qt w.show(); return a.exec();&#125; gisTest2.cpp代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &quot;gisTest2.h&quot;#include &lt;qmenubar.h&gt;#include &lt;qmessagebox.h&gt;#include &lt;qfiledialog.h&gt;#include &lt;qgsvectorlayer.h&gt;gisTest2::gisTest2(QWidget *parent) : QMainWindow(parent)&#123; this-&gt;resize(600, 400); // create the menus and then add the actions to them. fileMenu = this-&gt;menuBar()-&gt;addMenu(&quot;File&quot;); openFileAction = new QAction(&quot;Open&quot;, this); this-&gt;connect(openFileAction, SIGNAL(triggered(bool)), this, SLOT(on_openFileAction_triggered())); fileMenu-&gt;addAction(openFileAction); // initialize the map canvas mapCanvas = new QgsMapCanvas(); this-&gt;setCentralWidget(mapCanvas); mapCanvas-&gt;setCanvasColor(QColor(255, 255, 255)); mapCanvas-&gt;setVisible(true); mapCanvas-&gt;enableAntiAliasing(true);&#125;void gisTest2::on_openFileAction_triggered() &#123; addVectorLayer();&#125;void gisTest2::addVectorLayer()&#123; QString fileName = QFileDialog::getOpenFileName(this, tr(&quot;Open shape file&quot;), &quot;&quot;, &quot;*.shp&quot;); QStringList temp = fileName.split(&apos;/&apos;); QString basename = temp.at(temp.size() - 1); QgsVectorLayer* vecLayer = new QgsVectorLayer(fileName, basename, &quot;ogr&quot;); if (!vecLayer-&gt;isValid()) &#123; QMessageBox::critical(this, &quot;error&quot;, QString(&quot;layer is invalid: \\n&quot;) + fileName); return; &#125; mapCanvas-&gt;setExtent(vecLayer-&gt;extent()); layers.append(vecLayer); mapCanvas-&gt;setLayers(layers); mapCanvas-&gt;refresh();&#125; gisTest2.h代码 123456789101112131415161718192021222324252627282930313233#pragma once#include &lt;QtWidgets/QMainWindow&gt;#include &quot;ui_gisTest2.h&quot;#include &lt;qmenu.h&gt;#include &lt;qaction.h&gt;#include &lt;qgsmapcanvas.h&gt;class gisTest2 : public QMainWindow&#123; Q_OBJECTpublic: gisTest2(QWidget *parent = Q_NULLPTR);private: // create the menus and then add the actions to them. QMenu *fileMenu; QAction *openFileAction; //map canvas QgsMapCanvas *mapCanvas; QList&lt;QgsMapLayer *&gt; layers; public slots: void on_openFileAction_triggered(); //public: void addVectorLayer();&#125;; 参考资料https://www.cnblogs.com/loongfee/archive/2012/05/25/2518483.html","tags":[{"name":"QGIS","slug":"QGIS","permalink":"http://11wy11.github.io/tags/QGIS/"}]},{"title":"QGIS源码编译","date":"2020-11-18T13:14:18.000Z","path":"2020/11/18/qgis-develop-2/","text":"QGIS 源码编译，为学习开源软件以及二次开发做准备 资料收集于网络资源，后经测试，通过官方自带的批处理能够方便的编译出qgis工程 使用老的方式，通过cmake-gui配置环境变量编译qgis 源码，很麻烦，会有各种各样的错 VS2015需要安装的开发工具Select “Custom” install and add the following packages: “Common Tools for Visual C++ 2015” under “Visual C++” “Tools (1.4.1) and Windows 10 SDK (10.0.14393)” under “Universal Windows App Development Tools”. 下载软件包 Tool Website CMake https://cmake.org/files/v3.7/cmake-3.7.2-win64-x64.msi cygwin http://cygwin.com/setup-x86.exe (32bit) or http://cygwin.com/setup-x86_64.exe (64bit) OSGeo4W http://download.osgeo.org/osgeo4w/osgeo4w-setup-x86.exe (32bit) or http://download.osgeo.org/osgeo4w/osgeo4w-setup-x86_64.exe (64bit) ninja https://github.com/ninja-build/ninja/releases/download/v1.7.2/ninja-win.zip 对于cygwin和OSGeo4W，下载完后都是选择高级安装。 在选包界面的搜索栏输入文档中给出的包名，目前官方文档给出的是： 1.cygwin- bison- flex image-20201122191237032 设置环境变量：Path中添加C:\\cygwin64\\bin image-20201122191332862 检查是否安装成功flex和bison,见下图 image-20201122191537468 2.OSGeo4W: 下载地址： http://download.osgeo.org/osgeo4w/osgeo4w-setup-x86.exe (32bit) or http://download.osgeo.org/osgeo4w/osgeo4w-setup-x86_64.exe (64bit) 选择Advance Install ,在线下载时，使用镜像http://gwmodel.whu.edu.cn/mirrors/osgeo4w，不然会下载特别缓慢 另外之后编译的过程中如果发现有缺失的包也是可以重新在这里补充下载的。 img 直接下一步完成安装即可。 注:如果不需要编译源码，只需要下载qgis相关即可，后续如果还需要编译源码，需要下载一些编译依赖库： Qt &gt;= 4.5.0（QT5随OSGeo4W自动安装，在OSGeo4W目录下apps中） Proj &gt;= 4.4.x（随OSGeo4W自动安装，在OSGeo4W目录下apps中） GEOS &gt;= 3.0， Sqlite3 &gt;= 3.0.0(暂没用到) GDAL/OGR &gt;= 1.4.x（随OSGeo4W自动安装，在OSGeo4W目录下apps中） Qwt &gt;= 5.0 &amp; (&lt; 6.1 with internalQwtPolar)(随OSGeo4W自动安装，在OSGeo4W目录下) expat &gt;= 1.95(随OSGeo4W自动安装，在OSGeo4W目录下) - QScintilla2- QCA- qtkeychain (&gt;= 0.5) 可选依赖库：- GRASS驱动和插件支持 - GRASS &gt;= 6.0.0. QGIS可以和GRASS6或者GRASS7共同编译. 它也可以同时支持这两个版本的GRASS如果安装了rpath的话，具体使用的版本是由LD_LIBRARY_PATH或者PATH变量在运行时决定。- georeferencer - GSL &gt;= 1.8- postgis数据库支持 - PostgreSQL &gt;= 8.0.x- gps插件 - gpsbabel- mapserver导出以及PyQGIS - Python &gt;= 3.3- python支持 - SIP &gt;= 4.12, PyQt &gt;= 5.3 并且要与Qt版本吻合, Qscintilla2- qgis mapserver - FastCGI- oracle驱动 - Oracle OCI library 安装完cygwin和OSGeo4W后，将ninja.exe复制到之前安装OSGeo4W目录的OSGeo4W64\\bin\\下。、 img 安装CMakehttps://cmake.org/download/ image-20201122184022077 新建CMAKE_ROOT的环境变量 打开CMakeGUI程序，选择QGIS源码（https://github.com/qgis/QGIS），以及存放编译生成的工程的文件夹路径 编译源码官方提供了两种方法，使用Trugonly.cmd创建MSVC解决方案文件或者使用cmake-gui 由于各种路径设置的原因，笔者建议还是使用传统的cmake进行编译。 1.运行 C:\\OSGeo4W64\\bin下的o4w_env.bat文件，安装好环境变量不难发现，其中涉及到的重要的环境变量主要有： OSGEO4W_ROOT（OSGeo4W的根目录） PF86（软件默认安装目录） VS140COMNTOOLS（调用VS的vcvarsall.bat批处理文件） GRASS7（这个的路径中是【/】而不是【\\】，要注意） PYTHONPATH（SIP包所在路径） LIB（OSGeo4W依赖库头文件） INCLUDE（OSGeo4W静态库文件） 如果之前更改了路径，修改相应的环境变量即可。 其中，VS140COMNTOOLS是VS2015的变量名， 打开cmake-gui，设置好源码路径和要输出的路径，然后点击Configure image-20201122185955306 另外在CMAKE卡中设置项目要安装的路径，推荐设置在一个新的空目录中，避免导致混乱 img 出现错误也是正常的，关键还是路径的问题，所以说前面环境变量的设置十分重要 配置环境变量一步一步的指定缺失的路径，首先是flex和bison，这一步，主要在安装cygwin并下载flex和bision后，将cygwin/bin路径添加到Path中即可 img img 然后是各个库 image-20201122192309206 img 这个基本在安装OSGeo4W64时已经全部安装过了，设置路径即可 image-20201122205035392 image-20201122211026744 设置完成后继续点Configure，有错误则设置好需要的路径直到出现 img 然后点击Generate，其实这三个按钮点依次点过去，没问题的话就OK了，成功的话可以在指定的文件夹中看到编译成功的项目，用VS打开项目并且重新生成就可以了，当然这可能需要比较长的一段时间。 将活动解决方案设置为RelWithDebInfo，带有调试信息的Release版本。 img 将启动项目设置成【qgis】，选择核心的项目生成即可，这里我参考了https://blog.csdn.net/quinta_2018_01_09/article/details/79084001这篇博客。但通过查看看依赖项我发现【qgis】还需要依赖【qgis_native】这个项目，因此也把它加上去了。 img img 然后单独编译生成【qgis_core】,如果出现以下问题，定位到出问题的cpp文件，利用记事本对其进行编辑（其他方法亦可），将其编码改为【Unicode】，虽然错误看起来很多，但是实际上几条错误都是在同一个文件中的，实际上需要修改的文件并不多，逐一修改即可。成功生成【qgis_core】后，生成其它项目，出现语法错误处理方式同上，最后生成【qgis】项目。 img img 其他问题尤其是确保不要安装msinttypes软件包，它会安装stdint.h文件到OSGeo4W[64]/include目录下，进而导致与Visual Studio本身的stdint.h文件冲突，致使编译某些模块失败。 编译的时候，遇到缺少一些python包，需要通过pip安装一下 遇到安装了PyQT5","tags":[{"name":"QGIS","slug":"QGIS","permalink":"http://11wy11.github.io/tags/QGIS/"}]},{"title":"QGIS二次开发学习（一）","date":"2020-11-18T12:59:11.000Z","path":"2020/11/18/qgis-develop-1/","text":"QGIS git https://github.com/qgis QGIS 快速指南 QGIS Python 开发手册 QGIS C++ 开发手册 QGIS API https://qgis.org/api/3.14/api_break.html QgsDiagramRendererV2 通过 QgsVectorLayer 的 setDiagramRenderer() 方法，传入一个 QgsDiagramRendererV2 的实例，当前的矢量图层就会以设置的方法来渲染显示图表。 其中 QgsLinearlyInterpolatedDiagramRenderer和QgsSingleCategoryDiagramRenderer 分别是具体的渲染方法类， Diagram类 QGis当中提供的图表类包括三个，QgsPieDiagram、QgsTextDiagram 和 QgsHistogramDiagram，它们分别对应于饼状图、文本图和柱状图，都是继承自 QgsDiagram 类 具体来说，有两个，一个是QgsDiagramSettings，用于配置针对图表的参数，另一个是 QgsDiagramLayerSettings，是更高一级的参数，将图表类作为一个图层，配置与矢量要素的显示关系. Name 说明 angleOffset 起始角度（仅饼状图） backgroundColor 背景颜色 barWidth 柱宽度（仅柱状图） categoryAttributes \\ categoryColors 用于控制不同属性显示不同颜色 diagramOrientation 图表方向 font 字体（仅文本图） labelPlacementMethod 图表中文本的显示位置（仅文本图），包括Hight和XHight maxScaleDenominator \\ minScaleDenominator 显示尺度。大于或小于缩放尺度，图表将不再显示 minimumSize 图表显示的最小尺寸。小于这个尺寸的图表会放大到这个尺寸显示 penColor \\ penWidth 控制轮廓的颜色和宽度 scaleByArea 是否根据要素面积进行缩放图表（仅polygon要素） size 图表大小 sizeType 图表大小的单位，包括 MM 和 MapUnits transparency 透明度 基本代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112void qgis_dev_layerPropDialog::setDiagramProperty()&#123; // 这一句是获取当前图层，修改成你自己获取当前图层的方式 QgsVectorLayer* layer = qobject_cast&lt;QgsVectorLayer*&gt;( activeLayer() ); QgsDiagram* diagram = 0; QString diagramType = \"Hist\"; // 这一句修改成获取图表类型的代码 bool scaleAttributeValueOk = false; QgsVectorDataProvider* provider = layer-&gt;dataProvider(); double maxVal = 0; int fld = 2; if ( fld != -1 ) &#123; bool ok = false; double val = provider-&gt;maximumValue( fld ).toDouble( &amp;ok ); // 获取该字段的最大值 if ( ok ) &#123; maxVal = val; &#125; &#125; bool mValueLineEdit = false; if ( diagramType == \"Text\" ) &#123; //diagram = new QgsTextDiagram(); &#125; else if ( diagramType == \"Pie\" ) &#123; //diagram = new QgsPieDiagram(); &#125; else // if ( diagramType == DIAGRAM_NAME_HISTOGRAM ) &#123; diagram = new QgsHistogramDiagram(); &#125; #pragma region 设置diagram属性 QgsDiagramSettings ds; // diagram的设置项 //ds.font = mDiagramFont; // 设置字体 ds.transparency = 0; // 设置透明度 QList&lt;QColor&gt; categoryColors; // 颜色 QList&lt;QString&gt; categoryAttributes; // 属性 QColor color = QColor( 255, 0, 0 ); color.setAlpha( 255 - ds.transparency ); categoryColors.append( color ); categoryAttributes.append( \"ELEV\" ); ds.categoryColors = categoryColors; ds.categoryAttributes = categoryAttributes; ds.size = QSizeF( 1, 1 ); ds.sizeType = static_cast&lt;QgsDiagramSettings::SizeType&gt;( 0 ); ds.labelPlacementMethod = static_cast&lt;QgsDiagramSettings::LabelPlacementMethod&gt;( 1 ); ds.scaleByArea = true; ds.minimumSize = 0; ds.backgroundColor = QColor( 0, 0, 0 ); // 背景色 ds.penColor = QColor( 0, 0, 0 ); // 轮廓颜色 ds.penWidth = 1; // 轮廓宽度 ds.minScaleDenominator = -1; ds.maxScaleDenominator = -1; // Diagram 方向 (histogram) ds.angleOffset = 1440; ds.diagramOrientation = static_cast&lt;QgsDiagramSettings::DiagramOrientation&gt;( 0 ); ds.barWidth = 5; // 宽度 #pragma endregion 设置diagram属性 QgsLinearlyInterpolatedDiagramRenderer* dr = new QgsLinearlyInterpolatedDiagramRenderer(); dr-&gt;setLowerValue( 0.0 ); dr-&gt;setLowerSize( QSizeF( 0.0, 0.0 ) ); dr-&gt;setUpperValue( 2 ); dr-&gt;setUpperSize( QSizeF( 2, 2 ) ); bool isExpression = true; dr-&gt;setClassificationAttributeIsExpression( isExpression ); dr-&gt;setClassificationAttributeExpression( \"\" ); dr-&gt;setDiagram( diagram ); dr-&gt;setDiagramSettings( ds ); layer-&gt;setDiagramRenderer( dr ); QgsDiagramLayerSettings dls; dls.dist = 0; dls.priority = 5; dls.xPosColumn = -1; dls.yPosColumn = -1; dls.placement = static_cast&lt;QgsDiagramLayerSettings::Placement&gt;( 0 ); dls.placementFlags = 0; layer-&gt;setDiagramLayerSettings( dls ); layer-&gt;setTitle( \"\" ); QgsVectorSimplifyMethod simplifyMethod = m_layer-&gt;simplifyMethod(); simplifyMethod.setSimplifyHints( QgsVectorSimplifyMethod::NoSimplification ); simplifyMethod.setThreshold( 1 ); simplifyMethod.setForceLocalOptimization( true ); simplifyMethod.setMaximumScale( 1 ); layer-&gt;setSimplifyMethod( simplifyMethod ); layer-&gt;triggerRepaint(); m_mapCanvas-&gt;refresh(); // 改成你自己的 map canvas&#125;","tags":[{"name":"QGIS","slug":"QGIS","permalink":"http://11wy11.github.io/tags/QGIS/"}]},{"title":"arcgis-vs-qgis","date":"2020-10-08T11:17:25.000Z","path":"2020/10/08/arcgis-vs-qgis/","text":"转载 https://blog.csdn.net/sf2gis2/article/details/54864292?utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2~all~first_rank_v2~rank_v25-3-54864292.nonecase&amp;utm_term=qgis%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6&amp;spm=1000.2123.3001.4430 QGIS和ArcGIS的比较 QGIS VS ArcGIS 你也许伴随着ArcGIS或者QGIS而成长。每天你都坐在电脑然后做着同样的事情：你打开你的ArcGIS软件或者新的QGIS软件。但是你有问过自己：我能不能通过其他的GIS软件获取更多的东西?我们建议你阅读这些ArcGIS与QGIS之间的不同来使你成为一个更为优秀的地理信息工作者。这是GIS产业中两个明星产品的对决ArcGIS VS QGIS。 1.QGIS容纳更多的数据格式ArcGIS没有支持所有的数据格式，毫无疑问，QGIS在处理各种类型的数据时非常顺手，QGIS在数据格式方面是个多面手，在使用数据方面是它的长处。QGIS使用GDAL/OGR库来读取和写入地理信息数据格式，支持超过70种矢量格式。QGIS一开始就是为了与PostGIS协作而诞生的，而支持的名单随着数据格式的增多而逐渐变长：ENC，shapefile，geodatabase,MapInfo格式、Microstation文件格式，AutoCAD格式、SpatiaLite、Oracle Spatial、MSSQL空间数据库、WKT等等。QGIS还支持NetCDF文件。QGIS的接口允许你在一天之内还原一个工程。在设置习惯性分界符方面QGIS甚至比微软的Office还要优秀。不用理清多种数据格式的冲突和纠结于数据格式，简单地使用过QGIS就可以处理它！ QGIS文件格式 QGIS在数据格式方面明显胜出。 2.简洁的用户体验你也许从没认识到ArcGIS中“Add Data”按钮的功能有多强大。是的，只是一个简单的“Add Data”按钮。你也许觉得很可笑，但等笑完以后请思考这个问题：这个按钮可以简单地完成影像加载是因为它能识别所有的图像格式。你想加入一个电子表格吗？你想加入一个栅格影像吗？点击“Add Data”按钮，这很简单。在QGIS中你想添加一个电子表格？单击“Add Vector”按钮，选择所需要的格式。QGIS中提供的按钮种类较多让人眼花缭乱。 QGIS的按钮 还记得ArcMap中打开界面以后立即显示的最近编辑的地图文件吗？QGIS的另一个更改就是在“工程-&gt;打开最近文件”添加了这一功能。因此，ArcGIS的简洁性更加优秀。 3.使用ArcCatalog和QGIS浏览器管理你的地理数据。QGIS浏览器和ArcCatalog都是独立的地理信息数据管理软件。这些应用程序帮助管理栅格、矢量的地理数据。提供简单的数据浏览功能，但核心是数据查询和管理。使用搜索工具和过滤器可以帮我们找到需要的数据文件，这就像你自己私人的Google搜索引擎。使用ArcCatalog不仅可以管理数据，还可以管理地图、模型和工具。管理数据的一项重要工作就是创建元数据。它是什么时候创建的呢？谁创建的呢？它是如何创建的呢？都可以在元数据里找到我们需要的答案。 ArcCatalog 近些年来，元数据也进化成了多种格式（ISO,FGDC,INSPIRE和NAP）。ArcCatalog向用户提供数据的元数据标准选项。QGIS中的QGIS浏览器和ArcGIS中的ArcCatalog都提供了非常简便的文件系统和地理数据管理功能。 QGIS Browser 这项比较中，ArcCatalog凭借其可选择性更胜一筹。 4.在ArcMap和QGIS中放心地加入表格当你为空间数据加入一个属性表的时候，你一行一行地填写数据。在ArcGIS中加入表格是非常直观的。在ArcMap中，你可以右键点击一个图层并且选择“join”，你也可以通过图层属性加入信息。 ArcGIS join 在QGIS中也同样简单。在QGIS中，你可以使用图层属性加入表格。当你在QGIS中添加一个表关联的时候，可以选择性地重新命名特定关联的前缀。对于复杂关联这是很有效的。 QGIS join 这点上两者打成平手。 5.ArcGIS和QGIS都成功地解决了坐标系统和投影的问题你在ArcGIS中加入的第一个数据集决定了你使用的坐标系统。当再次添加其他数据集时，ArcGIS将会对其进行在初始坐标系统上的重投影。一个“未知的空间参考系”代表存在数据冲突。在这种情况下，“未知单位”将会在ArcMap的右下角显示，这时，应该使用定义投影工具对其进行修正。QGIS支持2700多种已知的坐标参考系统。它允许你方便地定义全球和工程范围的坐标参考系统。它同样允许你定义自定义参考系。 坐标系统 QGIS和ArcGIS都对非常友好地对坐标系统进行了处理，虽然过去的QGIS在对.prj的支持上有点小问题。 6.ArcGIS Online为你提供全世界真实的地理数据QGIS在OpenLayers插件中提供了一些底图，但远不如ArcGIS Online详细。当你打开ArcGIS Online的数据目录的时候，令你开心的是：里面有成千上万的政府数据、详细底图和密集的信息。基本的ArcGIS许可允许你链接到ArcGIS Online——一个地理信息数据的宝库。一个简单的关于“enviroment”的搜索返回了超过2887条地理数据集：美国农业部的林火检测信息、海洋局的台风数据、全世界气候年鉴、海底深度底图等。这将会使任何环境研究变得方便。我们想要强调的是ArcGIS Online是一个丰富的地理信息资源库，能帮助你分析和决策。记住，方便使用的同时也伴随着责任，请小心使用这个强大的工具。 ArcGIS Online 7.地理处理许可“处理许可”听起来像是一个不好的东西，ArcGIS会向我们要求使用许可而QGIS则是开源的。ArcGIS拥有很好的地理处理框架，无缝而且易于拓展。但是你的许可水平决定你可以使用其中的哪些模块。一个基础的许可让你能够使用一些非常强大的模块。一个高级许可能够让你使用任何模块。而QGIS的使用不需要任何许可！开源的QGIS软件不限制能够使用的模块。如果你想在ArcGIS10中使用清除工具，你必须要有一个高级许可。如果没有办法获得高级许可，就无法使用清除工具。而在 QGIS中的擦除工具在矢量分析工具箱中。（在difference工具里，这是与GRASS和SAGAGIS相互结合的一个工具，能够提供处理地理空间问题的必要的功能）这个功能是在基本的ArcGIS许可中是不能使用的。QGIS的地理处理平台的开放性令人印象深刻。而在ArcGIS却必须受限于许可，真是让人感到无奈。因此在这个方面QGIS是绝对的赢家。 8.不用害怕，有插件我们都知道，使用插件可以完成专题化地分析。 QGIS拥有能够处理各种GIS问题的插件集合，总数达到约300个。 QGIS plugins 但是你也许不知道，ArcGIS也同样具有插件。这些插件也可以帮助我们解决各种GIS问题。Esri公司最新推出了一款自己的应用商店——ArcGIS MarketPlace，，能够与R统计、海洋附加工具、网络公用数据表单、ET地理魔术师ArcGIS补丁等模块的良好交互，更多的插件后续将会按时推出。 ArcGIS MarketPlace 这里有几乎你能想到的所有的空间问题的付费或免费的解决方案。Esri几乎检查了该商店中所有产品的有效性，现在你应该明白Esri为什么在帮助你解决地理空间问题上为什么是一枝独秀了吧。QGIS拥有一个极为精简的矢量处理机制，但是在模块的丰富程度上就不如Esri了。 9.QGIS和ArcGIS中的栅格处理都同样傻瓜化空间分析扩展工具中包含了大量的栅格数据处理过程。不管是简单数学计算，统计或者生成表面，ArcGIS栅格处理工具都是紧密封装的，空间分析工具箱同样提供了地下水、水文，成本表面、太阳辐射等专题化工具。其他可选择的模块有过滤（重分类工具）和简化数据（归一化工具）。QGIS中的栅格计算器可以使用简单的代数计算和三角函数。QGIS中提供了多种插值方法。常规的克里金方法在QGIS中是一个独立模块，而在ArcGIS中克里金工具则是其中的一个单选选项。GRASS中的r.cost模块是用来生成成本表面的。QGIS的优势在于拥有更多的过滤选项，比如地下水和太阳辐射，但并不像ArcGIS那样全面。 QGIS Toolbox 很难在这两者之间决出一个胜者，因为他们都提供了相当多的栅格处理工具选择。 10.ArcGIS地理统计工具箱更好,因为它教你统计你在组装家具的时候会看说明书吗？一般不看，是不是？当你运行ArcGIS地理统计工具箱的时候，说明和输出的解释非常清楚。比如：当你运行Moran’s I 的时候，输出的报告传递了一个简单的解释。你就知道你的数据是不是被正确地处理了。 I' 在QGIS中你在使用一种工具前必须需要对它有一定的了解。这不完全是坏事，但明显不如ArcGIS方便。ArcGIS中的回归分析工具箱制作得非常好用，因为其输出允许使用者把统计结果与其他数据结合起来，这为接下来的分析节省了时间。QGIS中的组统计插件是非常简洁的，就像是在QGIS中内嵌的一个表格生成器一样。列代表统计的种类（平均值、最小值、变化幅度等），行是绝对字段如各种地名或者水域。添加一个字段并且进行计算，瞧，表格就生成了。 GroupStats 当你能够理解文章中的晦涩概念的时候，你就理解了我这篇文章。ArcGIS更胜一筹因为其引导式的地理统计。 11.使用QGIS的遥感工具箱时你能拥有X射线的视野在寂静的外太空，卫星在轨道上运行并使用多光谱传感器获取地面影像。例如Sentinel2a和Landset-8生产的卫星影像在GIS分析中得到了大量使用。QGIS和ArcGIS都提供了大量的遥感工具。其中一些是手动工具，像chisel，能量分析工具像electric drill。QGIS的半导体自动分类插件能让你下载Landset影像并且自动分类。欧菲奥工具箱（Orfeo toolbox）提供了从滤波、处理和操作栅格数据的工具。Lastools可以处理LiDAR数据。 Semi-Automatic Classfication Plugin 当ArcGIS10.1添加了图像分析工具箱的时候，它自带了遥感分析工具，提供采样、监督和非监督分类功能、融合、计算NDVI、正射纠正、亮度对比度透明度调整等等功能。Las数据集是一个处理LiDAR数据的尴尬的中间媒介，还有许多工作需要完成。那么QGIS在遥感处理领域更胜一筹。 12.使用ArcGIS设计你下一次的钓鱼路线在日常生活中，几乎每个人都有规划路径的体验。 最近的啤酒店在哪儿？ 去这个啤酒点的最短路线是什么？ 在ArcGIS中，只需要打开网络分析功能，把数据集加入，建立简单的拓扑关系可能稍微有点难度，但完成之后你就可以准备出发了。使用“道路图”插件，QGIS计算最短路径。QGIS缺少一些ArcGIS网络分析中的一些工具-位置分配、新OD成本矩阵等ArcGIS网络分析扩展工具是顶级水准。 13.使用ArcGIS模型建立器指导工作流你曾经想过使用画图式的方法建立自动工作的工作流吗？想一下：当你按照安排好的模型运行任务的时候，即使你一整天都躺在卧室也能完成工作。ArcGIS的模块建立器是最直观，模块化，实用的自动的地理处理工作的实现方法。 ArcGIS Model-Builder 把一系列的工具在建立器中串接起来，然后就可以实现自动处理了。只是简单地把模块拖出来按照流程图一样把他们串起来就好了，十分简单。再进一步：把你的模型导出并且分享给别人，或者导出成Python代码并且修改它。ArcGIS脚本都通过Arcpy模块工作,在Arcpy中编写代码是非常地简单的，基本上ArcGIS中的所有工具在其中都有同样名字的引用脚本，你可以在Esri的网站上找到并且粘贴使用。一切都是自动的。QGIS中也有和ArcGIS中模型建立器一样的工具，叫做图形式模块。你可以像画图一样把一系列的模块按照一定的顺序拖动。不过，QGIS在使用这个模块的时候经常会崩溃，所以最好提前保存一下。 QGIS Model 对于QGIS来说，你可以使用PyQGIS模块和GDAL，你也可能会用到其他工程提供的大量模块。尽管存在各种bug，你还是可以得到你想要的结果。我们喜欢模型建立器，我们喜欢Arcpy，这是ArcGIS的两个闪光点。 14.在ArcGIS和QGIS中设计一个制图杰作开源怀疑者认为ArcGIS才是做出漂亮地图的唯一工具。但是QGIS也是一个可行的优秀制图工具。QGIS地图接口叫做“印刷工”，它简直就像是一个独立的应用程序一样。但是当你一旦在图层上加入符号和特征以后，你就会发现QGIS是制图的理想工具。 print ArcGIS的制图工具就是教你使用各种模板并导出地图产品。ArcGIS可以将其导出成为各种格式，如PDF,JPG,SVG,AI,PNG,EPS和EMF。ArcGIS制图工具是非常实用的。它可以非常容易地精确指定你的标签，使用简单的矩形连接数据框架。我们认为QGIS和ArcGIS都达到了制图目的。 15.在QGIS中使用符号ArcGIS的启动画面非常漂亮，我们喜欢各种被严格定义的符号，它们使得点线面状地物更加生动。ArcMap中的符号真的非常漂亮、有用和充足。QGIS在这方面就略显不足。当然，在某些方面QGIS还是不错的，比如铁路和阴影多边形。而且，你可以从互联网上下载并且加载符号模板。QGIS强力推荐的一个功能是其ps式的填充选项。具有一个远超符号库的混合选项：淡化、全屏、躲避、加深、复制、燃烧（burn）、覆盖、轻微变亮、差异。 options 梯度填充使得QGIS对于制图员来说非常的轻松。你可以使用两个或多个颜色简单地创造梯度。添加不同的种类的梯度计算方式：线性式、辐射式、圆锥式。QGIS的图层样式文件可以保存为.qml格式。而且更好的消息是颜色拾取器能够让用户手动选择颜色，而不用苦逼地输入rgb数字了。QGIS有一些非常高级的符号，ArcGIS非常的实用。二者再次打平。 16.在QGIS中设计漂亮的标签和标注在QGIS中添加标签是很方便的。QGIS的样式水平达到了一个新的高度。 文字边缘添加了缓冲区（更好看） 为样式点添加了后置阴影 设置透明度、混合样式和偏移 这些不易察觉的改变让标签变得更加美观。而ArcGIS中的标签不如一些QGIS美观，你可以使用ArcGIS中的图像标签引擎来放置标签。获得想要添加标签特征的图层的控制权，设置标签的位置和比例尺。设置曲线标签和平行标签在ArcGIS中是很容易的。它非常智能。画图工具箱在ArcGIS中控制着注释组。为注记设置一个单独的工具箱也许不是很直观。但是只要稍许练习你就能调整注记的组归属。 place QGIS凭借其漂亮的标签更胜一筹。但是注记和属性的放置方面ArcGIS更加优秀。为了对质量负责我只能先发一半了=.=,各位大大原谅我….. 本文续借上一篇译文 17.使用数据驱动框自动地组织制图如果你正在制作一幅图，你肯定需要用到ArcGIS中的数据驱动框，它是你自动生产地图的得力工具。数据驱动框是在相互独立的不同图层页面之间进行切换的工具。制图员们经常使用数据驱动框和制图工具箱来完成制图过程。 Data Driven Pages 制图工具箱是用来制作带状的地图的，如果你的地图横跨多个投影，需要使用UTM区域计算工具。QGIS的开发人员在程序中集成了一个非常好用的地图集切换工具箱。 Atlas-Toolbar 选中图层中包含的一些地理图形和字段，使用地图集生成工具，会得到一个新的只包含这些地理图形和字段的页面。与地理图形想关联的字段比如文字标签等都可以被使用。地图集切换工具的功能很强大，QGIS和ArcGIS的数据驱动框都很棒。 18.在ArcGlobe和ArcScene中观看三维场景是时候告别二维平面世界，而走向三维了。ArcGlobe和ArcScene都是标准独立的三维分析扩展程序，能够展示一个三维的立体世界。ArcScene用于小型场景的研究，可以通过竖轴因子调节物体的高度。 ArcScene ArcGlobe则是展示全球数据的良好媒介，支持模拟飞行地对地浏览。 ArcGlobe 当然，使用这些模块需要一个三维分析的许可。虽然QGIS本身缺乏一个像样的三维模块，但Qgis2threejs插件可以以三维形式展现场景。该插件可以向你的浏览器中导出地形数据，三维地图遮盖图和矢量数据。 QGIS 3DViewer 但是别觉得这个插件能够像ArcGlobe和ArcScene那样强大，ArcGIS的三维功能还是要比QGIS强太多了。 19.设计一个宏大的网页地图来讲述故事网页地图正在蓬勃发展。许多政府和企业应用网页地图来讲述宏大的史诗故事。在ArcGIS中设计网页地图是很简单的，制图员只需要通过ArcGISOnline把数据发送到网页上就可以了。ArcGIS Online for webmaps是这些在线地图在Esri的地理信息云中的存储位置。而且更为方便的是ArcGIS推出的ArcGIS story maps，它能够非常方便地帮助我们利用地图讲述我们的故事。 ArcGIS-Webmap QGIS服务器提供WMS（网页地图服务），该服务与QGIS桌面端使用同样的库。所以QGIS桌面端提供的地图和打印模板只需要简单地将QGIS的工程文件复制到服务端文件夹就能够以网页地图的形式发布了。 QGIS-Webmap 20.使用ArcGIS animations来动态展现数据你有没有想过动态地展现你的数据？直观地看到北极冰雪随时间融化，展现全球的气候变化。ArcGIS中的动画工具箱使得数据从静态的变成动态的。各种地理信息随时间的变化可以在ArcGIS中非常容易的展现出来。如果你有一个时间相关的字段，只需要将时间轴从左拖到右就能够直观地看出你的数据随时间的变化。当然，这需要一些并不繁重的准备工作（如填写字段），之后你就可以把生成的动画导出为影音格式让你的老板印象深刻。 Time-Series-Animation 时间管理插件为QGIS添加了时间控制功能。你可以使用时间控制器让矢量特征随时间属性而变化。该时间控制器还支持实验栅格层和两点之间插值。你可以直接在地图窗口创造动画并且导出图像序列。 Time-Manager-QGIS 21.制造颜色编码的主题地图社会科学家经常制作专题图，来展现一些与地理区域相关的特殊主题。QGIS为制作专题地图提供了一系列的工具：渐变色、渐变符号、比例符号和密集点，以及线状、块状和专栏的数据化符号、直方图和文本流程图等等。 Equal-Interval-Classification QGIS中有一个非常独特的工具：热力图。根据一个点集立刻创建出一个矢量的热力图。热力图渲染工具修正半径、色差、透明度和融合模式，最后在点图层产生一个动态的热力图。你可以在QGIS中通过“设置列描述”或者“规则描述”来使众多字段符号化。而在ArcGIS中，使用“唯一值，多字段”也可以轻松达到类似的效果。点云图和大量图表是ArcMap的独一无二的优势。QGIS和ArcGIS都具有良好的专题图制作功能。 22.使用ArcMap的高级编辑工具创造一览无余的详细编辑ArcGIS和QGIS的编辑功能稍有不同。比如，你在QGIS中点击右键完成快速的矢量创建，而在ArcGIS中则需要双击。你会觉得单击右键是很方便而且不易出错的，而双击则容易在绘制大量矢量的时候出现不必要的错误。QGIS提供一系列编辑工具如图形改造、切割和追踪还可以删除要素中的一部分形成一个环。使用捕捉选项可以捕捉要素点。QGIS的cad工具插件提供了13个高级工具，其中一个闪亮点是撤销编辑。在ArcMap中只能在进行矢量编辑的时候进行回退。 QGIS-Toolbar 在ArcMap中创建数据是相当轻松的，ArcGIS有许多高级编辑的选项。你可以通过要素模板创建一个新的要素。高级编辑还包括多块型要素打碎，曲线剔除、修剪或扩张，替换图形等。ArcMap中的边界追踪工具真得非常棒。 Editor-Toolbar 23.拓扑关系不是问题 这个点在多边形上吗 是否存在覆盖呢 这些线是否与多边形边界重合了？ 我所能想到的，能够描述ArcGIS中拓扑功能的词就是：完美。如果你担心你的地理信息数据有错误（重叠、缝隙等），ArcGIS提供一个丰富、完整的拓扑关系错误检查工具。它将对你的数据进行超过三十种规则的检查，来保证拓扑关系的正确。 ArcGIS-Topology 一旦你的数据被导入地理数据库中，你就可以创建拓扑关系了。QGIS包含一系列拓扑规则：“必须包含”、“绝不能重叠”、“绝不能有缝隙”、“绝不能有无效图形”、“绝不能有多区域型图形”、“觉不能覆盖”和“绝不能覆盖XX”。你可以用这些规则检查地理图形，但你如何修正它？ QGIS-Topology ArcGIS的拓扑修正是交互式的，你可以一个接一个地查看错误并修正它们。拓扑检查和修正编辑功能是ArcGIS的一个闪光点。 24.以工程的形式表现数据记录QGIS和ArcGIS都拥有精简的地理数据记录管理机制，他们都提供相似的功能。当你在QGIS中创建一个shapefile的时候，你需要立刻设定一些字段（文本、小数或者日期）。使用ArcGIS的时候你可以之后再创建字段-除非你是在ArcCatalog中。 atrribute-table-exmaple 在QGIS中创建字段以后，你可以使用表管理插件重新命名它们。也许你认为在ArcGIS中不得不重新建立一个字段并把原来字段的值拷贝过来，其实数据管理功能中的“替换字段”可以完成这个过程。在地理数据库中，用户可以设置数据记录的类型、归属和默认值，当用户开始输入属性信息的时候，可以使用下拉列表来选择。当地理信息统计出现问题时常使用这种方法来寻找无效的数据记录。 Domain-ArcGIS 通过地理位置的搜索功能通过交互式的选择工具已经有了很大提高。当记录被选中的时候，他们就被过滤出来了（并可以添加和移除）。字段计算工具支持Python和VB脚本。ArcGIS中必须停止编辑才能进行字段计算是广为诟病的。 25.通过地理编码确定XY坐标地理编码是给予街道地址XY坐标的过程。地理编码可以通过ArcGIS Online Geocoding来实现。这是一个付费服务而且需要使用执照。 ArcGIS Online Geocoding ArcGIS桌面程序有其自己的方式来实现对你的数据进行地理编码。只需要通过地理编码工具箱就可以找到目标的地理，再添加一个标签，你就完成了位置的标识。如果你不想看到填满标识信息的表格，在QGIS中你有两种不错的选择。MMQGIS是一个很好的批量地理编码的工具，它支持包含地址信息的独立表格格式的数据，并把它们在地图中以点的形式标识出来。 QGIS-Geocoding 地理编码插件需要先输入地址，然后点击ok,瞧，地点就在地图上标出来了。 Geocoding Result 五五开，平手！我们不想为地理编码增加预算了，使用QGIS简单又实惠。 26.使用数据转化工具替换地理图形要素图形化对于制图员来说是经常要用到的，但是替换要素却不是那么容易。但是在QGIS中，就不会很麻烦。在QGIS中，你可以把线段转化成多边形，点转多边形或者任意两者之间的转化。 QGIS-conversion 在ArcMap中，你也许需要一个高级的许可来完成数据转化的功能。QGIS有一些相当酷的常规化工具：简化线、统计点和多边形。 27.ArcGIS的文档相当详尽ArcGIS的文档非常棒。ArcGIS不仅提供工具的使用文档，还提供了一些示例数据让你实际操作一遍。这并不代表QGIS的文档不好，它也提供了很多信息，也写的很规范，很实用，但它就是没有ArcGIS的文档好。 Geonet Esri有Geonet，而QGIS又GIS Stack Exchange作为社区。 GIS-stack-exchange QGIS的支持非常活跃，一个非常专注的志愿社区支持着QGIS项目，而ArcGIS的社区则主要是雇员和用户。他们都提供了问题反馈的场所和手段。 总结地理信息系统的设计的核心需求仅仅只有4个：创建地理数据、管理它、分析它并显示它。现有的软件都能够很好地完成这些基本功能。所以说QGIS和ArcGIS并无一定的高下之分。 QGIS-vs-ArcGIS-small QGIS是免费的，而且有众多语言的支持。依赖于志愿者的努力，QGIS的社区十分活跃。你使用的越多，令你惊奇的发现也就越多：交互式的组状态表，支持csv的快捷导入，令人惊愕的制图符号和标记选项等等。ArcGIS几乎是最好的GIS软件。它是可以扩展的，而且有全世界最大的用户社区。它提供样例数据和使用教程来帮助你获得实际操作的经验。模块设计器和自动化运行是顶级的功能，各各具特色的ArcGIS拓展软件也为其增光添彩。但也许一个不懂行的人会问：ArcGIS赢在哪儿了？QGIS有什么优点吗？","tags":[]},{"title":"python入门","date":"2020-10-06T08:31:16.000Z","path":"2020/10/06/python-getting-start-1/","text":"python 安装使用tesseract，完成验证码图像识别；使用ssenium下载Chromedriver 模拟浏览器 pytesseract/tesserortesseract 下载地址：https://digi.bib.uni-mannheim.de/tesseract/ 遇到的问题: 1.FileNotFoundError: [WinError 2] 系统找不到指定的文件 解决方法: 方法1[推荐]: 将tesseract.exe添加到环境变量PATH中， 例如: D:\\Tesseract-OCR,默认路径为C:\\Program Files (x86)\\Tesseract-OCR 注意: 为了使环境变量生效，需要关闭cmd窗口或是关闭pycharm等ide重新启动 方法2: 修改pytesseract.py文件，指定tesseract.exe安装路径 12# CHANGE THIS IF TESSERACT IS NOT IN YOUR PATH, OR IS NAMED DIFFERENTLYtesseract_cmd = &apos;C:\\\\Program Files (x86)\\\\Tesseract-OCR\\\\tesseract.exe‘ 方法3: 在实际运行代码中指定 1pytesseract.pytesseract.tesseract_cmd = &apos;D:\\\\Tesseract-OCR\\\\tesseract.exe&apos; 2.pytesseract.pytesseract.TesseractError: (1, ‘Error opening data file \\Tesseract-OCR\\tessdata/eng.traineddata’) 解决方法: 方法1[推荐]: 将tessdata目录的上级目录所在路径(默认为tesseract-ocr安装目录)添加至TESSDATA_PREFIX环境变量中 例如: C:\\Program Files (x86)\\Tesseract-OCR 1Please make sure the TESSDATA_PREFIX environment variable is set to the parent directory of your &quot;tessdata&quot; directory. 方法2: 在.py文件配置中指定tessdata-dir 123tessdata_dir_config = &apos;--tessdata-dir &quot;D:\\\\Tesseract-OCR\\\\tessdata&quot;&apos;# tessdata_dir_config = &apos;--tessdata-dir &quot;&apos;C:\\\\Program Files (x86)\\\\Tesseract-OCR\\\\tessdata&quot;&apos;pytesseract.image_to_string(image, config=tessdata_dir_config) sessnium环境安装1234567891011121314python+selenium+pycharm+webdriver 1、 python安装包:https://www.python.org/getit/ 2、 PyCharm 安装包:http://www.jetbrains.com/pycharm/download/ 3、 Selenium安装包:https://pypi.python.org/pypi/selenium selenium安装方式一: 安装python包，选择全部组件(pip、安装过程中配置环境变量) 然后执行pip install -U selenium 联网安装Selenium; 安装方式二: 安装python包，选择全部组件(pip、安装过程中配置环境变量) 解压selenium-3.13.0.tar.gz，然后用cmd进入解压目录，使用命令 Python setup.py install 安装Selenium。 4、 webdriver配置(以chromedriver为例): Chromedriver下载地址：http://npm.taobao.org/mirrors/chromedriver/ ***版本与浏览器版本保持一致 配置方式一: 1)把下载好的chromedriver.exe程序放置到python的安装路径下 2)在python中代码编写如下即可:driver = webdriver.Chrome() # Firefox、Ie、Edge等配置方式二: 1)把下载好的chromedriver.exe程序放置到python项目中(其它路径也可) 2)在python中代码编写如下即可:chromePath = chromedriver.exe路径 os.environ[‘webdriver.chrome.driver’] = chromePath # gecko ie等driver = webdriver.Chrome(executable_path=chromePath) # Firefox、Ie等 安装后需要，下载对应的Chromedriver驱动https://sites.google.com/a/chromium.org/chromedriver/downloads/version-selection 使用webDriver API https://selenium-python.readthedocs.io/api.html#module-selenium.webdriver.common.action_chains 识别元素三、识别元素 基本元素定位 driver.find_element_by_id(&#39;id_value&#39;).send_keys(&#39;最新疫情咨讯&#39;) #通过id定位driver.find_element_by_name(‘name_value’).send_keys(‘最新疫情咨讯’) #通过name定位driver.find_element_by_class_name(&#39;class_name_value&#39;).send_keys(&#39;最新疫情信息&#39;) #通过class元素定位 driver.find_element_by_tag_name(&#39;input&#39;).send_key(&#39;最新疫情咨讯&#39;) #通过tag_name定位，&lt;缺点：tag_name值不唯一&gt; driver.find_element_by_link_text(‘新闻’).click() #link_text链接中的文本 &lt;缺点：只对标签生效&gt; driver.find_element_by_partial_link_text(&#39;新&#39;).click() #partial_link_text部分链接中的文本 &lt;缺点：只对标签生效&gt; xpath定位元素","tags":[{"name":"python","slug":"python","permalink":"http://11wy11.github.io/tags/python/"}]},{"title":"360前端星计划学习笔记（一）","date":"2020-04-08T12:40:47.000Z","path":"2020/04/08/360-learn-note-1/","text":"360前端星计划学习笔记（一）HTML&amp;前端&amp;CSS 前端什么是前端： 使用Web技术栈解决多端的图形界面人机交互问题–360奇舞讲师团 image-20200407154302122 &amp;lt!doctype html&amp;gt渲染模式和HTML版本HTML语法：标签和属性不区分大小写，推荐小写，可以不闭合，image /&gt;,属性值用双引号包裹，可省略。文本标签引用：blockquote长引用,cite作品名等短引用，q前文引用强调：strong 强调突出，重要严重紧急，em重音，突出的词内容划分：head nav main article aside(导航链接，推荐，广告等，不属于页面主要内容) footer语义化：HTML中元素，属性，属性值都拥有某些含义。谁在使用HTML，语义化好处开发者：修改。维护页面-代码可读性，可维护性浏览器：渲染页面搜素引擎：提供关键词，排序-搜素引擎优化屏幕阅读器：给盲人获得页面-提升无障碍性传达内容，而不是样式如何做到语义化：了解标签属性含义，思考什么标签最适合描述这个内容，尽量不用可视化工具生成代码而是手写代码 CSS基础Cascading style sheets 选择器 属性+属性值=声明{；；} 声明块选择器{；；} 规则引入方式外链（推荐，利于维护），嵌入，内联 image-20200408101508689 选择器Selector 标签，类名，ID，DOM中的位置 通配选择器* 标签选择器：h1,p,img… id 选择器：#ID值，唯一 类选择器：.done ,class的值可以多个， 属性选择器：eg. [disabled] ​ 根据属性值选择 eg. input[type=”password”] ​ 高级用法：a[href^=#]以#开头，$以什么结尾 伪类pseudo-classes 不基于标签和属性定位元素 两种伪类： 状态伪类 a :link &amp;:visited &amp;:hover &amp;:active,input:focus 结构性伪类 li:first-child &amp;:last-child 组合器（combinator） 直接组合 AB 同时满足A，B input.error 后代组合 A B 选中B，如果它是A的子孙 article p 亲子组合 A&gt;B 选中B，如果它是A的子元素 article&gt;p 组合可多级 选择器组 设置文字样式 颜色： #16进制 rgb:（0-255,0-255,0-255） HSL: (Hue色相 0-360；Saturation：饱和度0-100%；Lightness：亮度0-100%) eg. hsl(44,60%,50%) 颜色关键字：grey，black，white， alpha 透明度 0-1，rgba，hsla 字体 font-family 一般指定多个字体的值，尽可能的保证在各种设备上都能显示。 通用字体族：serif 某一类字体，sans-Serif 无衬线体（Arial,黑体），Fantasy(手写体)，Monospace（等宽字体，编辑器里一般用） 推荐：最后要写通用字体族；英文字体放在中文字体前面（中文一般包含英文字符，放在前面会无法使用英文） Web Fonts 在服务器放置字体文件：.woff2,.ttf, 中文字体文件一般比较大，会用字体处理工具，提取页面中用到的字符生成一个小的文件 字体大小font-size 关键字：small middle large 长度：px em（相对于父元素 ） 百分比 相对于父元素 font-style: normal itail font-weight: 100-900,normal(400),bold(700),一般页面常用关键字，因为浏览器没有那么多字重的字体 line-height 行字体基线的距离：①px,②1.6 自身字体大小的倍数 font: style weight size family 可省略其他属性 设置对齐 text-align: left center right justify(两端分散对齐) spacing ：letter-spacing 字母间间距，Word-spacing：词间距 text-indent : 首行文字缩进 text-decoration: none, underline, line-through, overline white-space :空格和换行行为 normal 多空行合并一个，nowrap 不换行，pre 保留原有空格,空行，pre-wrap:只有显示不下换行 pre-line 保留原有空行 继承布局选择器的特异度（Specificity） #nav .list li a:link 122 .hd ul.links a 022 高优先级会覆盖低优先级样式 继承 某些属性会自动继承其父元素的计算值，除非显式指定一个值 显示继承 123456789* &#123; box-sizing: inherit&#125;html &#123; box-sizing: border-box;&#125;some &#123; box-sizing: content-box;&#125; 初始值 background-color :transparent background-color: initial 显示重置为初始值 CSS 求值过程 image-20200408110157615 image-20200408110322465 image-20200408110616811 过滤：规则匹配 cascading层叠值:优先级排序 cascaded value=”” defaulting resolving 将相对值，关键字转换为绝对值 computed Value 从代码上即能推断 formatting: 关键字，百分比转为绝对值 值 使用值 进行实际时 constaining 400.2px -400px 实际值 布局Layout 盒模型 content width content box 宽度，取值 长度，百分比，auto（由内容计算） height 容器有指定的高度，百分数才生效，循环依赖是不会生效的 padding border 三种属性 border-width border-style border-color 四个方向 可组合 绘制三角形等 margin 指定四个方向，值：长度，百分数(相对于容器的宽度)，auto， 使用margin: auto 水平居中 margin collapse：折叠，垂直方向，取较大的值，负值是绝对值的大小 box-sizing: border-box 指定的宽度包含border和padding的宽度 overflow: visible hidden scroll 块级 Block Level Box 不和其他盒子并列摆放 块级元素 生成块级盒子 body，article，div，main，section，h1-6p ul li display:block 行级 Inline Level Box 放置一行或拆分多行 行级元素 生成行级盒子，内容分散在多个行盒 span em string cite code display:inline 常规流 ​ 根元素、浮动和绝对定位的元素会脱离常规流 其他元素都在常规流之内 块级Block Formatting Context (BFC) 流的容器 新的流摆放布局内容 根元素 浮动、绝对定位、inline-block Flex和Grid子项 overflow值不为visible的块盒 内部排版规则 盒子从上到下 垂直margin合并 内部盒子的margin不会与外面合并 不会和浮动元素重叠 行级上下文Inline Formatting Context (IFC) 只包含行级盒子的容器会创建IFC 排版规则 text-aligin vertical-aligin 避开浮动元素 table flex display: flex 一种新的排版上下文 摆放的流向flex-direction: row,row-reverse,column,column-reverse 摆放顺序 order 盒子宽高 水平垂直对齐 flexibility 弹性 可以设置子项的弹性，有剩余空间 flex-grow 扩展能力 都是1 内容的多的基准多，更宽一些 flex-shrink 收缩能力 flex-shrink:0不具备收缩能力 flex-basis 基本值展示 可以覆盖width，关键字：content 内容的宽度 flex 合并上述三个属性 flex: 1 1 auto flex-wrap nowrap,wrap 主轴 justify-content: flex-start, flex-end,center,space-between,space-around,space-evenly 相等的空格区分开 侧轴 align-items strentch(default 占满容器高度 )，baseline基线对齐 子元素特殊对齐align-self grid ​ 二维布局方式，划分网格 display：grid grid-template grid-template-columns: 30% 30% auto/100px 1fr 1fr (剩下的两列平分) grid-template-rows : 100px auto/ 100px 1fr(剩余) 设置子元素占用网格行列 网格线 1 1 2, 3, 4 ​ 2 网格区域 grid-area 1/1/3/3 浮动 文字环绕图片 绝对定位 position static 非定位元素 默认值 relative 不脱离文档流，相对于自身进行偏离 absolute 脱离常规流，不会对流内元素产生影响，相对于非static的祖先元素 fixed 相对于浏览器窗口定位，不随页面滚动发生位置变化 变形transform 可设置多种变形函数 translate 位移 元素移动不影响其他元素，按照自身原来位置进行计算摆放 transform-origin 设置原点，旋转中心,默认自身中心点 rotate 0.5turn 半圈 90deg scale 自身坐标系 skew 倾斜 3d变形 perspective(100px)设置视角，人眼距离屏幕的距离 ​ 离屏幕更近，效果更明显 translate3d transition 过渡 transition-property 指定哪些属性变化需要过渡 transition-duration 时间 transition-timing-function 快慢 linear ease,ease-in,ease-out, ease-in-out, steps transition-delay 延迟 @keyframes down{ from 50% to}关键帧 animation：关键帧名字 duration ease infinite(无限) animation–name animation-duration 时间 animation–timing-function 快慢 animation-delay 延迟 animation-iteration-count 次数 animation-direction 正序播放，逆序播放 normal: from&gt;to,alternate正反交替 响应式布局viewport 通过meta设置视口 content=”width=device-width” 图片尺寸设置：max-width: 100% 背景图片： background-size: cover 保证背景图片完整覆盖容器（展示内容类重要的图，商品图） background-size: contain 把图片缩放到容器内，完整的显示出来（装饰背景） media query ​ @media screen and (min-width: 480px) 使用不同尺寸的图片 img srcset=”large.jpg 1200w” sizes=”(max-width:320px) 400px” src=”默认图片” 字体大小：rem做单位，用@media调整根节点html的font-size","tags":[{"name":"基础","slug":"基础","permalink":"http://11wy11.github.io/tags/基础/"}]},{"title":"css基础知识","date":"2020-04-05T07:04:00.000Z","path":"2020/04/05/css-base-knowledge-1/","text":"","tags":[]},{"title":"前端基础复习-JavaScript-5","date":"2020-04-04T15:07:00.000Z","path":"2020/04/04/js-base-knowledge5/","text":"前端自检清单JavaScript基础5–语法和API 语法和API1.理解ECMAScript和JavaScript的关系JavaScript包括核心语法，DOM，BOM，而核心语法实际上就是指ECMAScript，而JS又是不断在发展的, 而这个发展实际上最主要的就是ECMAScript版本的更新, 而DOM 和 BOM的更新较少, 因此, 可以认为 ECMAScript是JavaScript的参照, 而JavaScript是ECMAScript的一个实现. 例如ECMAScript2015简称ES6 2.熟练运用es5、es6提供的语法规范3.熟练掌握JavaScript提供的全局对象（例如Date、Math）、全局函数（例如decodeURI、isNaN）、全局属性（例如Infinity、undefined）4.熟练应用map、reduce、filter 等高阶函数解决问题5.setInterval需要注意的点，使用settimeout实现setInterval回调函数在计时之后才开始执行, 如果主线程执行时间过长，时间间隔未必准确， 1234567function myInterval(callback,delay)&#123; function interval()&#123; setTimeout(interval, delay); callback(); &#125; setTimeout(interval, delay)&#125; 6.JavaScript提供的正则表达式API、可以使用正则表达式（邮箱校验、URL解析、去重等）解决常见问题手机号码正则表达式正则验证手机号，忽略前面的0，支持130-139，150-159。忽略前面0之后判断它是11位的。 1/^0*1(3|5)\\d&#123;9&#125;$/ 使用正则表达式实现删除字符串中的空格 1234funtion trim(str) &#123; let reg = /^\\s+|\\s+$/g return str.replace(reg, '');&#125; 限制文本框只能输入数字和两位小数点等等 1/^\\d*\\.\\d&#123;0,2&#125;$/ 只能输入小写的英文字母和小数点，和冒号，正反斜杠(：./) 1/^[a-z\\.:\\/\\\\]*$/ 替换小数点前内容为指定内容例如：infomarket.php?id=197 替换为 test.php?id=197 123var reg = /^[^\\.]+/;var target = '---------';str = str.replace(reg, target) 只匹配中文的正则表达式 1/[\\u4E00-\\u9FA5\\uf900-\\ufa2d]/ig 返回字符串的中文字符个数先去掉非中文字符，再返回length属性。 123456function cLength(str)&#123; var reg = /[^\\u4E00-\\u9FA5\\uf900-\\ufa2d]/g; //匹配非中文的正则表达式 var temp = str.replace(reg,''); return temp.length;&#125; 正则表达式取得匹配IP地址前三段只要匹配掉最后一段并且替换为空字符串就行了 1234function getPreThrstr(str) &#123; let reg = /\\.\\d&#123;1,3&#125;$/; return str.replace(reg,'');&#125; 匹配与之间的内容 1/&lt;ul&gt;[\\s\\S]+?&lt;/ul&gt;/i 用正则表达式获得文件名c:\\images\\tupian\\006.jpg可能是直接在盘符根目录下，也可能在好几层目录下，要求替换到只剩文件名。首先匹配非左右斜线字符0或多个，然后是左右斜线一个或者多个。 123456function getFileName(str)&#123; var reg = /[^\\\\\\/]*[\\\\\\/]+/g; // xxx\\ 或是 xxx/ str = str.replace(reg,''); return str;&#125; 绝对路径变相对路径“http://23.123.22.12/image/somepic.gif&quot;转换为：&quot;/image/somepic.gif&quot; 12var reg = /http:\\/\\/[^\\/]+/;str = str.replace(reg,\"\"); 用户名正则用于用户名注册，，用户名只 能用 中文、英文、数字、下划线、4-16个字符。 1/^[\\u4E00-\\u9FA5\\uf900-\\ufa2d\\w]&#123;4,16&#125;$/ 匹配英文地址规则如下:包含 “点”, “字母”,”空格”,”逗号”,”数字”，但开头和结尾不能是除字母外任何字符。 1/^[a-zA-Z][\\.a-zA-Z,0-9]*[a-zA-Z]$/ 正则匹配价格开头数字若干位，可能有一个小数点，小数点后面可以有两位数字。 1/^\\d+(\\.\\d&#123;2&#125;)?$/ 身份证号码的匹配身份证号码可以是15位或者是18位，其中最后一位可以是X。其它全是数字 1/^(\\d&#123;14&#125;|\\d&#123;17&#125;)(X|x)$/ 单词首字母大写每单词首字大写，其他小写。如blue idea转换为Blue Idea，BLUE IDEA也转换为Blue Idea 12345function firstCharUpper(str) &#123; str = str.toLowerCase(); let reg = /\\b(\\w)/g; return str.replace(reg, m =&gt; m.toUpperCase());&#125; 正则验证日期格式yyyy-mm-dd格式4位数字，横线，1或者2位数字，再横线，最后又是1或者2位数字。 1/^\\d&#123;4&#125;-\\d&#123;1,2&#125;-\\d&#123;1,2&#125;$/ 去掉文件的后缀名www.abc.com/dc/fda.asp 变为 www.abc.com/dc/fda 123function removeExp(str) &#123; return str.replace(/\\.\\w$/,'')&#125; 验证邮箱的正则表达式开始必须是一个或者多个单词字符或者是-，加上@，然后又是一个或者多个单词字符或者是-。然后是点“.”和单词字符和-的组合，可以有一个或者多个组合。 1/^[\\w-]+@\\w+\\.\\w+$/ 正则判断标签是否闭合例如：&lt;img xxx=”xxx” 就是没有闭合的标签； p的内容，同样也是没闭合的标签。 标签可能有两种方式闭合， 或者是 xxx 。 1/&lt;([a-z]+)(\\s*\\w*?\\s*=\\s*\".+?\")*(\\s*?&gt;[\\s\\S]*?(&lt;\\/\\1&gt;)+|\\s*\\/&gt;)/i 正则判断是否为数字与字母的混合不能小于12位，且必须为字母和数字的混 1/^(([a-z]+[0-9]+)|([0-9]+[a-z]+))[a-z0-9]*$/i 将阿拉伯数字替换为中文大写形式 12345function replaceReg(reg,str)&#123; let arr=[\"零\",\"壹\",\"贰\",\"叁\",\"肆\",\"伍\",\"陆\",\"柒\",\"捌\",\"玖\"]; let reg = /\\d/g; return str.replace(reg,function(m)&#123;return arr[m];&#125;)&#125; 去掉标签的所有属性 ***变成没有任何属性的 ***思路：非捕获匹配属性，捕获匹配标签，使用捕获结果替换掉字符串。正则如下： 7.JavaScript异常处理的方式，统一的异常处理方案Javascript 异常处理的演进https://zhuanlan.zhihu.com/p/25245932 Promise 异常处理 不仅是 reject，抛出的异常也会被作为拒绝状态被 Promise 捕获。在微任务中抛出的异常能够被捕获，宏任务中抛出异常无法被捕获，因为已经离开了函数的执行上下文 1234567891011function fetch(callback) &#123; return new Promise((resolve, reject) =&gt; &#123; throw Error('用户不存在') &#125;)&#125;fetch().then(result =&gt; &#123; console.log('请求处理', result) // 永远不会执行&#125;).catch(error =&gt; &#123; console.log('请求处理异常', error) // 请求处理异常 用户不存在&#125;) 12345678910111213141516function fetch(callback) &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; throw Error('用户不存在') &#125;) &#125;)&#125;fetch().then(result =&gt; &#123; console.log('请求处理', result) // 永远不会执行&#125;).catch(error =&gt; &#123; console.log('请求处理异常', error) // 永远不会执行&#125;)// 程序崩溃// Uncaught Error: 用户不存在 Promise 的异常处理有了比较清晰的答案，只要注意在 macrotask 级别回调中使用 reject，就没有抓不住的异常。 Async Await 异常 不论是同步、异步的异常，await 都不会自动捕获，但好处是可以自动中断函数，我们大可放心编写业务逻辑，而不用担心异步异常后会被执行引发雪崩. 我们可以使用 try catch 捕获异常。 因为此时的异步其实在一个作用域中，通过 generator 控制执行顺序，所以可以将异步看做同步的代码去编写，包括使用 try catch 捕获异常。 try..catch 但无法捕获异步的错误 业务场景 统一的异常处理方案：我们来编写类级别装饰器，专门捕获 async 函数抛出的异常： 12345678910111213const asyncClass = (errorHandler?: (error?: Error) =&gt; void) =&gt; (target: any) =&gt; &#123; Object.getOwnPropertyNames(target.prototype).forEach(key =&gt; &#123; const func = target.prototype[key] target.prototype[key] = async (...args: any[]) =&gt; &#123; try &#123; await func.apply(this, args) &#125; catch (error) &#123; errorHandler &amp;&amp; errorHandler(error) &#125; &#125; &#125;) return target&#125; 将类所有方法都用 try catch 包裹住，将异常交给业务方统一的 errorHandler 处理： 12345678910111213141516171819202122232425262728293031const successRequest = () =&gt; Promise.resolve(&apos;a&apos;)const failRequest = () =&gt; Promise.reject(&apos;b&apos;)const iAsyncClass = asyncClass(error =&gt; &#123; console.log(&apos;统一异常处理&apos;, error) // 统一异常处理 b&#125;)@iAsyncClassclass Action &#123; async successReuqest() &#123; const result = await successRequest() console.log(&apos;successReuqest&apos;, &apos;处理返回值&apos;, result) &#125; async failReuqest() &#123; const result = await failRequest() console.log(&apos;failReuqest&apos;, &apos;处理返回值&apos;, result) // 永远不会执行 &#125; async allReuqest() &#123; const result1 = await successRequest() console.log(&apos;allReuqest&apos;, &apos;处理返回值 success&apos;, result1) const result2 = await failRequest() console.log(&apos;allReuqest&apos;, &apos;处理返回值 success&apos;, result2) // 永远不会执行 &#125;&#125;const action = new Action()action.successReuqest()action.failReuqest()action.allReuqest() 我们也可以编写方法级别的异常处理： 123456789101112131415const asyncMethod = (errorHandler?: (error?: Error) =&gt; void) =&gt; (target: any, propertyKey: string, descriptor: PropertyDescriptor) =&gt; &#123; const func = descriptor.value return &#123; get() &#123; return (...args: any[]) =&gt; &#123; return Promise.resolve(func.apply(this, args)).catch(error =&gt; &#123; errorHandler &amp;&amp; errorHandler(error) &#125;) &#125; &#125;, set(newValue: any) &#123; return newValue &#125; &#125;&#125; 业务方用法类似，只是装饰器需要放在函数上： 123456789101112131415161718192021222324252627282930const successRequest = () =&gt; Promise.resolve(&apos;a&apos;)const failRequest = () =&gt; Promise.reject(&apos;b&apos;)const asyncAction = asyncMethod(error =&gt; &#123; console.log(&apos;统一异常处理&apos;, error) // 统一异常处理 b&#125;)class Action &#123; @asyncAction async successReuqest() &#123; const result = await successRequest() console.log(&apos;successReuqest&apos;, &apos;处理返回值&apos;, result) &#125; @asyncAction async failReuqest() &#123; const result = await failRequest() console.log(&apos;failReuqest&apos;, &apos;处理返回值&apos;, result) // 永远不会执行 &#125; @asyncAction async allReuqest() &#123; const result1 = await successRequest() console.log(&apos;allReuqest&apos;, &apos;处理返回值 success&apos;, result1) const result2 = await failRequest() console.log(&apos;allReuqest&apos;, &apos;处理返回值 success&apos;, result2) // 永远不会执行 &#125;&#125;const action = new Action()action.successReuqest()action.failReuqest()action.allReuqest() 在 nodejs 端，记得监听全局错误，兜住落网之鱼： 1234567process.on(&apos;uncaughtException&apos;, (error: any) =&gt; &#123; logger.error(&apos;uncaughtException&apos;, error)&#125;)process.on(&apos;unhandledRejection&apos;, (error: any) =&gt; &#123; logger.error(&apos;unhandledRejection&apos;, error)&#125;) 在浏览器端，记得监听 window 全局错误，兜住漏网之鱼： 123456window.addEventListener(&apos;unhandledrejection&apos;, (event: any) =&gt; &#123; logger.error(&apos;unhandledrejection&apos;, event)&#125;)window.addEventListener(&apos;onrejectionhandled&apos;, (event: any) =&gt; &#123; logger.error(&apos;onrejectionhandled&apos;, event)&#125;)","tags":[{"name":"js基础","slug":"js基础","permalink":"http://11wy11.github.io/tags/js基础/"}]},{"title":"前端基础复习-JavaScript-4","date":"2020-04-04T15:05:04.000Z","path":"2020/04/04/js-base-knowledge4/","text":"前端自检清单JavaScript基础4–执行机制 执行机制1.为何try里面放return，finally还会执行，理解其内部机制当try和finally里都有return时，会忽略try的return，而使用finally的return。 JVM 采用异常表的方式来处理 try catch 的跳转逻辑 finally 的实现采用拷贝 finally 语句块的方式来实现 finally 一定会执行的语义逻辑 2.JavaScript如何实现异步编程，可以详细描述EventLoop机制一个 Event Loop 中，可以有一个或者多个任务队列(task queue)，一个任务队列便是一系列有序任务(task)的集合；每个任务都有一个任务源(task source)，源自同一个任务源的 task 必须放到同一个任务队列，从不同源来的则被添加到不同队列。 setTimeout/Promise 等API便是任务源，而进入任务队列的是他们指定的具体执行任务。 浏览器为了能够使得JS内部(macro)task与DOM任务能够有序的执行，会在一个(macro)task执行结束后，在下一个(macro)task 执行开始前，对页面进行重新渲染，流程如下： (macro)task-&gt;渲染-&gt;(macro)task-&gt;... microtask（又称为微任务），可以理解是在当前 task 执行结束后立即执行的任务。也就是说，在当前task任务后，下一个task之前，在渲染之前，执行所有microtask 执行一个宏任务（栈中没有就从事件队列中获取） 执行过程中如果遇到微任务，就将它添加到微任务的任务队列中 宏任务执行完毕后，立即执行当前微任务队列中的所有微任务（依次执行） 当前宏任务执行完毕，开始检查渲染，然后GUI线程接管渲染 渲染完毕后，JS线程继续接管，开始下一个宏任务（从事件队列中获取） 3.宏任务和微任务分别有哪些宏任务(macro)task主要包含：script(整体代码)、setTimeout、setInterval、I/O、UI交互事件、postMessage、MessageChannel、setImmediate(Node.js 环境) 微任务：Promise.then、MutationObserver(在指定的DOM发生变化时被调用)、process.nextTick(Node.js 环境) 4.可以快速分析一个复杂的异步嵌套逻辑，并掌握分析方法理解好任务队列，宏任务和微任务 5.使用Promise实现串行在promise中返回一个promise对象就是一个串行。 1234567891011121314151617181920212223242526//实现Promise串行function makePromise(value)&#123; return new Promise(resolve=&gt;&#123; setTimeout(()=&gt;&#123; resolve(value) &#125;,Math.random()*1000) &#125;)&#125;function print(value)&#123; console.log(value);&#125;let promises = [1, 3, 4, 5, 6].map((item, index) =&gt; &#123; return makePromise(item) &#125;); // 串行执行let parallelPromises = promises.reduce( (total, currentValue) =&gt; total.then(() =&gt; currentValue.then(print)),Promise.resolve() ) parallelPromises.then(() =&gt; &#123; console.log('total then done')&#125;).catch(() =&gt; &#123; console.log('done')&#125;) 6.Node与浏览器EventLoop的差异 img timers 阶段：这个阶段执行timer（setTimeout、setInterval）的回调 I/O callbacks 阶段：执行一些系统调用错误，比如网络通信的错误回调 idle, prepare 阶段：仅node内部使用 poll 阶段：获取新的I/O事件, 适当的条件下node将阻塞在这里，当已有超时timer，执行它的回调函数 check 阶段：执行 setImmediate() 的回调 close callbacks 阶段：执行 socket 的 close 事件回调 浏览器环境下，microtask的任务队列是每个macrotask执行完之后执行。 而在Node.js中，microtask会在事件循环的各个阶段之间执行，也就是一个阶段执行完毕，就会去执行microtask队列的任务。 在nodejs中递归的调用process.nextTick()会导致I/O starving，官方推荐使用setImmediate() 7.如何在保证页面运行流畅的情况下处理海量数据8.js的单线程模式单线程，js的主要用途是与用户互动，以及操作DOM，如果使用多线程，容易产生复杂的同步问题。 所有的同步任务都在主线程上执行，形成一个执行栈， 主线程之外，存在一个任务队列，当异步任务有了运行结果，则会在任务队列中放置一个事件 一旦”执行栈”中的所有同步任务执行完毕，系统就会读取”任务队列”，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。 主线程不断重复上面的第三步。","tags":[{"name":"js基础","slug":"js基础","permalink":"http://11wy11.github.io/tags/js基础/"}]},{"title":"前端基础复习-JavaScript-3","date":"2020-04-04T15:04:57.000Z","path":"2020/04/04/js-base-knowledge3/","text":"前端自检清单JavaScript基础3–作用域和闭包 作用域和闭包1.理解词法作用域和动态作用域词法作用域是由写代码时将变量和块作用域写在哪里决定的，函数的词法作用域由函数声明所处位置决定的 查找 词法作用域查找只会查找一级标识符 遮蔽 从内逐级向外查找作用域，直到遇到第一个匹配的标识符为止，在多层嵌套作用域内定义同名标识符，产生遮蔽效应 动态作用域是运行时确定的，关注函数从何处调用 注js只有词法作用域，只是this的某种机制像动态作用域 123456789function foo()&#123; console.log(a);//3(而不是2！)//动态作用域是应该是3，但是运行js代码输出的还是2&#125;function bar()&#123; var a=3; foo();&#125;var a=2;bar(); 2.理解JavaScript的作用域和作用域链全局作用域 局部作用域 全局变量的作用域是全局的，在代码的任何地方都是有定义的。然而函数的参数和局部变量只在函数体内有定义。另外局部变量的优先级要高于同名的全局变量,也就是说当局部变量与全局变量重名时，局部变量会覆盖全局变量。 作用域链 作用域链就是由多个作用域组成的，当在自身作用域内找不到该变量的时候，会沿着作用域链逐步向上查找，若在全局作用域内部仍找不到该变量，则会抛出异常。 3.理解JavaScript的执行上下文栈，可以应用堆栈信息快速定位问题执行期上下文 当函数执行时（准确来说，是在函数发生预编译的前一刻），会创建一个执行期上下文的内部对象。一个执行期上下文定义了一个函数执行时的环境。 每调用一次函数，就会创建一个新的上下文对象，他们之间是相互独立且独一无二的。当函数执行完毕，它所产生的执行期上下文会被销毁。 4.this的原理以及几种不同使用场景的取值this代表函数调用相关联的对象，通常称之为执行上下文。 作为函数直接调用，非严格模式下，this指向window，严格模式下，this指向undefined； 作为某对象的方法调用，this通常指向调用的对象。 使用apply、call、bind 可以绑定this的指向。 在构造函数中，this指向新创建的对象 箭头函数没有单独的this值，this在箭头函数创建时确定，它与声明所在的上下文相同。 5.闭包的实现原理和作用，可以列举几个开发中闭包的实际应用闭包的概念：指有权访问另一个函数作用域中的变量的函数，一般情况就是在一个函数中包含另一个函数。 闭包的作用：访问函数内部变量、保持函数在环境中一直存在，不会被垃圾回收机制处理 产生闭包： 将一个函数作为另一个函数的返回值 将函数作为实参传递给另一个函数调用 变量私有化 应用：防抖函数，计数器 6.理解堆栈溢出和内存泄漏的原理，如何防止内存泄漏：占用的内存没有及时释放。 注意，内存泄露的次数积累多了，就容易导致内存溢出。 常见的内存泄露： 1.意外的全局变量 2.没有及时清理的计时器或回调函数 3.闭包 7.如何处理循环的异步操作for循环 递归处理异步函数 8.理解模块化解决的实际问题，可列举几个模块化方案并理解其中原理CommonJS规范，NodeJS使用，加载时运行，输出值的拷贝，会缓存结果，模块可多次加载，但只有第一次加载运行一次 AMD，Asynchronous Moudle Definition “异步模块定义”，需要在声明的时候指定所有的依赖，通过形参传递依赖到模块内容中，特点：提前执行（异步加载依赖先执行）+延迟执行 123define(id?, dependencies, factory);//使用require(&apos;id&apos;) CMD，与AMD主要区别在于定于模块与依赖引入部分。支持动态引入，特点：延迟执行（运行到需加载，根据顺序执行） 1234define(funtion(require, exports, moudle) &#123;&#125;requirerequire.async ES6 Module 编译时运行，输出值的引用","tags":[{"name":"js基础","slug":"js基础","permalink":"http://11wy11.github.io/tags/js基础/"}]},{"title":"前端基础复习-JavaScript-2","date":"2020-04-03T10:43:24.000Z","path":"2020/04/03/js-base-knowledge2/","text":"前端自检清单JavaScript基础2–原型原型链 原型和原型链1.理解原型设计模式以及JavaScript中的原型规则原型模式 ：是指原型实例指向创建对象的种类，并通过拷贝这些原型创建新的对象，是一种用来创建对象的模式，也就是创建一个对象作为另一个对象的prototype属性。 创建方式：Object.create(prototype, optionalDescriptorObjects) ②prototype 原型原则： ①所有的引用类型（数组，对象，函数）都有对象属性，都可以自由扩展属性。null除外； ②所有的引用类型（数组，对象，函数）都有对象属性，对象均有__proto__属性，属性值是一个普通的对象，__proto__的含义是隐式原型; ③所有的函数，均有一个prototype属性，属性值是一个普通的对象，prototype的含义是显式原型; ④所有的引用类型（数组，对象，函数）的属性__proto__指向它的构造函数prototype值 ⑤当获得一个对象的属性时，首先在对象本身查找，如果没有会去它的__proto__中查找 2.instanceof的底层实现原理，手动实现一个instanceof将对象的__proto__指向与构造函数的prototype判断 123456789101112function new_instance_of(leftVaule, rightVaule) &#123; let rightProto = rightVaule.prototype; // 取右表达式的 prototype 值 leftVaule = leftVaule.__proto__; // 取左表达式的__proto__值 while (true) &#123; if (leftVaule === null) &#123; return false; &#125; if (leftVaule === rightProto) &#123; return true; &#125; leftVaule = leftVaule.__proto__ &#125; 4.实现继承的几种方式以及他们的优缺点构造函数：Parent.call(this)，优点：可以继承父类属性，避免引用类型的属性被所有子类共享，可以向父类构造函数里传参；缺点：无法继承Parent原型链上的属性和方法，②方法都在构造函数中定义，每次创建实例都会创建一遍方法 原型链继承：Child.prototype=new Parent()把prototype设置为父类的实例，缺点：①无法向父类构造函数里传参数②父类原型上的引用属性被所有子类共享， 组合继承:可以继承父类属性及原型链属性，也可向父类构造函数传参数，融合了构造函数和原型链继承的优点，缺点：父类构造函数被调用了两次 123456789function Child()&#123; Parent.call(this)&#125;Child.prototype=new Parent();//优化function Child()&#123; Parent.call(this)&#125;Child.prototype=Parent.prototype;//缺点：因为原型上有个属性constructor，子类的实例constructor也是parent，无法区分实例对象是父类还是子类，子类原型上添加属性影响父类 寄生继承: 优点可以添加方法和属性 123456function createChild(p)&#123; var o=Object.create(p); o.newMethod=function()&#123; &#125; return o;&#125; 寄生组合继承 1234567891011121314function object(o) &#123; function F() &#123;&#125; F.prototype = o; return new F();&#125;function inheritPrototype(subClass,superClass)&#123; var p=object(superClass.prototype); p.constructor=subClass; subClass.prototype=p;&#125;function Child()&#123; Parent.apply(this,arguments);&#125;inheritPrototype(Child, Parent); 优点：只调用了一次Parent构造函数，并且因此避免了在 Parent.prototype 上面创建不必要的、多余的属性。与此同时，原型链还能保持不变； ES6 class extends 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283class Parent &#123; constructor(x,y)&#123; this.x = x; this.y = y; &#125; toString()&#123; &#125;&#125;class Child extends Parent&#123; constructor(x,y,color)&#123; super(x,y); this.color = color; &#125; toString()&#123; return super.toString(); &#125;&#125;/** 通过extends关键字继承了Parent类所有的属性和方法。* 子类的constructor方法 和 toString方法中都出现了super关键字,* 在这里表示父类的构造函数，用来新建父类的this对象。* 子类必须在constructor方法中调用super方法，因为子类的this对象必须通过父类的构造函数完成创建，* 并且得到与父类同样的实例属性和方法。如果不调用，子类就得不到this对象，就不能进行二次加工。* 要注意的一个地方是，在子类的构造函数中，只有调用super才可以使用this关键字，* 所以this关键字要放到super关键字之后，* 是因为子类实例的构建，基于父类实例，只有super方法能调用父类实例。*//** ES5的继承实质是先创建子类的实例对象this，然后再将父类的方法添加到this上面(Parent.apply(this))* ES6的继承实质是先将父类实例对象的属性和方法加到this上面(所以需先调用super方法)，然后再用子类构造函数修改this*/class Child extends Parent&#123;&#125;//等同于class Child extends Parent&#123; constructor(...args)&#123; super(...args); &#125;&#125;/** 如果子类没有定义constructor方法，这个方法会被默认添加，* 也就是说不管有没有显示的定义，子类都有constructor方法。*/class Parent &#123;&#125;class Child extends Parent&#123; constructor()&#123; super(); &#125;&#125;/** super这个关键字既可以当做函数使用，也可以当做对象使用* 作为函数调用时，代表父类的构造函数，子类构造函数必须执行一次super函数* super虽然代表了父类Parent的构造函数，但是返回的是子类Child的实例* 即super内部的this指的是Child，super在这里就相当于：* Parent.prototype.constructor.call(this)* super作为函数使用时，super()只能用在子类的构造函数中*/class Parent &#123; outPut()&#123; console.log(1) &#125;&#125;class Child extends Parent&#123; constructor()&#123; super(); console.log(super.outPut()) &#125;&#125;/** super作为对象时，在普通方法中指向父类的原型对象，静态方法中指向父类* super在普通方法中代表Parent.prototype,所以super.outPut()就相当于* Parent.prototype.outPut()* 注意，父类实例上的方法或属性是无法通过super调用的*/ 5.至少说出一种开源项目(如Node)中应用原型继承的案例6.可以描述new一个对象的详细过程，手动实现一个new操作符①创建一个空对象 ②将父类构造函数this指针指向创建的Object ③如何父类构造函数有返回的对象，返回该对象，否则，就返回新建的对象 12345function myNewOpt(Obj,args)&#123; var o=Object.create(Obj.prototype); Obj.apply(o,args); return o;&#125; 7.理解es6 class构造以及继承的底层实现原理123456789class Parent &#123; constructor(name,age)&#123; this.name = name; this.age = age; &#125; speakSomething()&#123; console.log(&quot;I can speek chinese&quot;); &#125;&#125; class在babel编译后， 12345678910111213141516171819202122232425262728293031323334353637383940414243&quot;use strict&quot;;var _createClass = function () &#123; function defineProperties(target, props) &#123; for (var i = 0; i &lt; props.length; i++) &#123; var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (&quot;value&quot; in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); &#125; &#125; return function (Constructor, protoProps, staticProps) &#123; if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; &#125;;&#125;();function _classCallCheck(instance, Constructor) &#123; if (!(instance instanceof Constructor)) &#123; throw new TypeError(&quot;Cannot call a class as a function&quot;); &#125;&#125;var Parent = function () &#123; function Parent(name, age) &#123; _classCallCheck(this, Parent); this.name = name; this.age = age; &#125; _createClass(Parent, [&#123; key: &quot;speakSomething&quot;, value: function speakSomething() &#123; console.log(&quot;I can speek chinese&quot;); &#125; &#125;]); return Parent;&#125;(); 在子类构造时，先调用父类构造函数设置this的属性和方法，然后子类构造中扩展修改this，底层实现使用了寄生组合继承 继承 1234567891011121314151617181920212223242526class Parent &#123; static height = 12 constructor(name,age)&#123; this.name = name; this.age = age; &#125; speakSomething()&#123; console.log(\"I can speek chinese\"); &#125;&#125;Parent.prototype.color = 'yellow'//定义子类，继承父类class Child extends Parent &#123; static width = 18 constructor(name,age)&#123; super(name,age); &#125; coding()&#123; console.log(\"I can code JS\"); &#125;&#125;var c = new Child(\"job\",30);c.coding() 转码之后的代码变成了这样 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596\"use strict\";var _createClass = function () &#123; function defineProperties(target, props) &#123; for (var i = 0; i &lt; props.length; i++) &#123; var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); &#125; &#125; return function (Constructor, protoProps, staticProps) &#123; if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; &#125;;&#125;();function _possibleConstructorReturn(self, call) &#123; if (!self) &#123; throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); &#125; return call &amp;&amp; (typeof call === \"object\" || typeof call === \"function\") ? call : self;&#125;function _inherits(subClass, superClass) &#123; if (typeof superClass !== \"function\" &amp;&amp; superClass !== null) &#123; throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); &#125; subClass.prototype = Object.create(superClass &amp;&amp; superClass.prototype, &#123; constructor: &#123; value: subClass, enumerable: false, writable: true, configurable: true &#125; &#125;); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;&#125;function _classCallCheck(instance, Constructor) &#123; if (!(instance instanceof Constructor)) &#123; throw new TypeError(\"Cannot call a class as a function\"); &#125;&#125;var Parent = function () &#123; function Parent(name, age) &#123; _classCallCheck(this, Parent); this.name = name; this.age = age; &#125; _createClass(Parent, [&#123; key: \"speakSomething\", value: function speakSomething() &#123; console.log(\"I can speek chinese\"); &#125; &#125;]); return Parent;&#125;();Parent.height = 12;Parent.prototype.color = 'yellow';//定义子类，继承父类var Child = function (_Parent) &#123; _inherits(Child, _Parent); function Child(name, age) &#123; _classCallCheck(this, Child); return _possibleConstructorReturn(this, (Child.__proto__ || Object.getPrototypeOf(Child)).call(this, name, age)); &#125; _createClass(Child, [&#123; key: \"coding\", value: function coding() &#123; console.log(\"I can code JS\"); &#125; &#125;]); return Child;&#125;(Parent);Child.width = 18;var c = new Child(\"job\", 30);c.coding(); 原理： 1234function F()&#123;&#125;F.prototype = superClass.prototypesubClass.prototype = new F()subClass.prototype.constructor = subClass","tags":[{"name":"js基础","slug":"js基础","permalink":"http://11wy11.github.io/tags/js基础/"}]},{"title":"前端基础复习-JavaScript-1","date":"2020-04-03T10:36:11.000Z","path":"2020/04/03/js-base-knowledge1/","text":"前端自检清单JavaScript基础1–变量和类型 变量和类型1.JavaScript规定了几种语言类型7种， undefined,null,Number,Boolean, String,Object,Symbol 2.JavaScript对象的底层数据结构是什么Null (js中的数据在底层是以二进制存储，如果前三位为0，那么就会判定为object，而null的所有都为0) js基本类型数据都是直接按值存储在栈中的(Undefined、Null、不是new出来的布尔、数字和字符串) js引用类型数据被存储于堆中 (如对象、数组、函数等，它们是通过拷贝和new出来的），引用类型的数据的地址指针存储于栈中，地址指针指向堆中的数据 Object&gt;HeapObject（存储）&gt;JSReceiver(用于原型查找)-&gt;(FixedArrayBase-&gt;FixedArray)+JSObject-&gt;JSArray+JSCollection+(JSFunction&gt;JSMap+JSSet) 3.Symbol类型在实际开发中的应用、可手动实现一个简单的Symbol应用场景：1.使用Symbol来作为对象属性名（key） 2.使用Symbol来替代常量 3.使用Symbol定义类的私有属性和方法 symbol 类型的key不能被Object.keys和for—of 4.JavaScript中的变量在内存中的具体存储形式JavaScript 中的变量分为基本类型和引用类型: 基本类型: 保存在栈内存中的简单数据段，它们的值都有固定的大小，保存在栈空间，通过按值访问 引用类型: 保存在堆内存中的对象，值大小不固定，栈内存中存放的该对象的访问地址指向堆内存中的对象，JavaScript 不允许直接访问堆内存中的位置，因此操作对象时，实际操作对象的引用 5.基本类型对应的内置对象，以及他们之间的装箱类型的拆箱操作String，Number，Boolean 12345678910// 隐式装箱： 每当读取一个基本类型的值时，后台会创建一个该基本类型所对应的对象。 // 在这个基本类型上调用方法，其实是在这个基本类型对象上调用方法。 // 这个基本类型的对象是临时的，它只存在于方法调用那一行代码执行的瞬间，执行方法后立刻被销毁。 let num=123; num.toFixed(2); // &apos;123.00&apos;//上方代码在后台的真正步骤为 var c = new Number(123); c.toFixed(2); c = null; // 显式装箱: 通过内置对象 Boolean、Object、String 等可以对基本类型进行显示装箱。 var obj = new String(&apos;123&apos;); 6.理解值类型和引用类型赋值传引用地址，值类型直接赋值 7.null和undefined的区别undefined类型表示未定义，值只有一个undefined， undefined是一个变量，而非关键字。 而Null只有一个值，null，表示空值，是关键字，可以通过null关键字来获取null值 8.至少可以说出三种判断JavaScript数据类型的方式，以及他们的优缺点，如何准确的判断数组类型typeof instanceof constructor Object,prototype.toString.call([])==’[object Array]’ Array.isArray() 9.可能发生隐式类型转换的场景以及转换原则，应如何避免或巧妙应用 isNaN () 自增/自减运算符：++、—- 正号/负号：+a、-a 加号：+ 运算符：-、*、/ ==在不同类型时进行隐式类型转换 会先判断是否在对比 null 和 undefined，是的话就会返回 true 判断两者类型是否为 string 和 number，是的话就会将字符串转换为 number 判断其中一方是否为 boolean，是的话就会把 boolean 转为 number 再进行判断 判断其中一方是否为 object 且另一方为 string、number 或者 symbol，是的话就会把 object 转为原始类型再进行判断 两边都是对象的话，那么只要不是同一对象的不同引用，都为false 逻辑运算符：&amp;&amp;、||、！ 。非布尔值进行与或运算时，会先将其转换为布尔值，然后再运算，但运算结果是原值。具体可以看下一篇文章《运算符》。 关系运算符：&lt;、&gt; &lt;= &gt;=等。关系运算符，得到的运算结果都是布尔值：要么是true，要么是false。 10.出现小数精度丢失的原因，JavaScript可以存储的最大数字、最大安全数字，JavaScript处理大数字的方法、避免精度丢失的方法 精度丢失原因，说是 JavaScript 使用了 IEEE 754 规范，二进制储存十进制的小数时不能完整的表示小数 能够表示的最大数字 Number.MAX_VALUE 等于 1.7976931348623157e+308 ,最大安全数字 Number.MAX_SAFE_INTEGER 等于 9007199254740991 避免精度丢失 计算小数时，先乘 100 或 1000，变成整数再运算 如果值超出了安全整数，有一个最新提案，BigInt 大整数，它可以表示任意大小的整数，注意只能表示整数，而不受安全整数的限制","tags":[{"name":"js基础","slug":"js基础","permalink":"http://11wy11.github.io/tags/js基础/"}]},{"title":"emmet-grammar","date":"2020-03-30T03:04:52.000Z","path":"2020/03/30/emmet-grammar/","text":"emmet是一个提高前端开发效率的工具。 使用方法后代&gt;nav&gt;ul&gt;li 兄弟+div+p 上级^div+div&gt;p^span 12345&lt;div&gt;&lt;/div&gt; &lt;div&gt; &lt;p&gt;&lt;/p&gt; &lt;/div&gt; &lt;span&gt;&lt;/span&gt; 分组()div&gt;(header&gt;ul&gt;li*2)+content+footer 12345678910&lt;div&gt; &lt;header&gt; &lt;ul&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/header&gt; &lt;content&gt;&lt;/content&gt; &lt;footer&gt;&lt;/footer&gt; &lt;/div&gt; 乘法*自增符号$ul&gt;li.item$*5 12345&lt;ul&gt; &lt;li class=\"item1\"&gt;&lt;/li&gt; &lt;li class=\"item2\"&gt;&lt;/li&gt; &lt;li class=\"item3\"&gt;&lt;/li&gt; &lt;/ul&gt; $@- 倒着的 $@x x开头 ID和类属性#xxx, .xxx form#search.wide 自定义属性img[data-src=”xxx”] 文本{} p{click}+a{here} 12&lt;p&gt;click&lt;/p&gt;&lt;a href=\"\"&gt;here&lt;/a&gt; HTML! a a:link a:mail link:css input:password","tags":[{"name":"工具","slug":"工具","permalink":"http://11wy11.github.io/tags/工具/"}]},{"title":"日常技巧","date":"2020-03-28T14:11:05.000Z","path":"2020/03/28/daily-skill-1/","text":"使用百度搜索资源平台的链接提交工具，推送博文，增加搜索可能。 #百度搜索资源平台 https://ziyuan.baidu.com/linksubmit/ 目前由于GitHub的机制，GitHub.io 的博客无法被有效爬虫搜索，一般只提交CSDN同步的一些博文。 以前可以的，现在需要先注册主站，才能解锁一些功能。恩，是时候搭建一个自己的站点了。 网上找到的，将自己的博文地址贴到下方的网址里，可以主动向百度搜索推送，加快抓取速度。不过亲测关键还是得自己博文写得能够吸引人，能真的解决大家的问题。 https://ziyuan.baidu.com/linksubmit/url","tags":[{"name":"搜索","slug":"搜索","permalink":"http://11wy11.github.io/tags/搜索/"}]},{"title":"VueAreaLinkage 设置默认值无效修改办法","date":"2020-03-28T11:01:48.000Z","path":"2020/03/28/vue-linkage-bug/","text":"关于使用VueAreaLinkage，自定义数据，动态设置绑定的数组后，行政区划组件上的label不发生变化的解决办法。 组件基本介绍及使用场景 [vueAreaLinkage]https://www.npmjs.com/package/vue-area-linkage “vueAreaLinkage” VueAreaLinkage安装使用5.0版本之后，可以通过npm install vue-area-linkage --save和npm install area-data --save安装依赖，在main.js种引入 12345678910import VueAreaLinkage from 'vue-area-linkage';import 'vue-area-linkage/dist/index.css' Vue.use(VueAreaLinkage) 在页面组件内import &#123; pca, pcaa &#125; from 'area-data'; // 城市数据 // 在data中定义数据：selected: [],pca: pca, pcaa: pcaa 下面主要介绍之前版本直接将源代码引入项目中并根据需要修改代码，符合自己的应用场景。 使用场景实现市，县，乡三级联动，并通过点击地图区域，动态设置行政区划选择默认值。未修改的代码使用是，第一次设置默认值是生效的，之后通过修改绑定的selected数组，无法改变行政区划选择器上的label显示，下面主要介绍如何通过修改组件源码，实现设置默认值，行政区划自动更新。 自定义的region数据结构如下： image-20200328205049168 VueAreaLinkage修改绑定Label不更新解决方案以area-cascader组件为例 根据自己的region数据，修改area-cascader中index.vue中的getActiveLabels函数，将获取provinces的Key设置为自己的，以贵阳市为例，修改源代码中的86为52.area-select组件做类似处理 修改area-cascader&gt;index.vue,修改SetDefaultValue函数，源代码中setDefaultValue只动态设置provinceCode和province，但因为业务需求只有一个市，所以动态设置selected数组时，label不及时更新，因为不会激活设置SetDefaultCode函数，因此，这里首先需要修改动态添加默认值所选中的县和乡。修改代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107setDefaultValue() &#123; let provinceCode = \"\"; let cityCode = \"\"; let areaCode = \"\"; if (this.isCode) &#123; provinceCode = this.defaults[0]; cityCode = this.defaults[1]; areaCode = this.defaults[2]; this.curCityCode = cityCode; this.curAreaCode = areaCode; &#125; else &#123; const province = find( this.provinces, item =&gt; item === this.defaults[0] ); assert(province, `城市 $&#123;this.defaults[0]&#125; 不存在`); provinceCode = find( Object.keys(this.provinces), item =&gt; this.provinces[item] === this.defaults[0] ); &#125; this.curProvinceCode = provinceCode; //-------------------------修改start //手动激活县变化 this.citys = this.data[this.curProvinceCode]; if (!this.citys) &#123; this.citys = &#123; [this.curProvinceCode]: this.curProvince &#125;; this.curCity = this.curProvince; this.curCityCode = this.curCityCode; return; &#125; let curCity = Object.values(this.citys)[0]; let curCityCode = Object.keys(this.citys)[0]; if (this.defaults[1]) &#123; if (this.isCode) &#123; curCityCode = find( Object.keys(this.citys), item =&gt; item === this.defaults[1] ); assert( curCityCode, `城市 $&#123;this.defaults[1]&#125; 不存在于省份 $&#123;this.defaults[0]&#125; 中` ); curCity = this.citys[curCityCode]; &#125; else &#123; curCity = find(this.citys, item =&gt; item === this.defaults[1]); assert( curCity, `城市 $&#123;this.defaults[1]&#125; 不存在于省份 $&#123;this.defaults[0]&#125; 中` ); curCityCode = find( Object.keys(this.citys), item =&gt; this.citys[item] === this.defaults[1] ); &#125; &#125; this.curCity = curCity; this.curCityCode = curCityCode; //手动添加镇 this.areas = this.data[this.curCityCode]; if (!this.areas) &#123; this.areas = &#123; [this.curCityCode]: this.curCity &#125;; this.curArea = this.curCity; this.curAreaCode = this.curCityCode; return; &#125; let curArea = Object.values(this.areas)[0]; let curAreaCode = Object.keys(this.areas)[0]; if (this.defaults[2]) &#123; if (this.isCode) &#123; curAreaCode = find( Object.keys(this.areas), item =&gt; item == this.defaults[2] ); assert( curAreaCode, `乡镇 $&#123;this.defaults[2]&#125; 不存在于县区 $&#123;this.defaults[1]&#125; 中` ); curArea = this.areas[curAreaCode]; &#125; else &#123; curArea = find(this.areas, item =&gt; item == this.defaults[2]); assert( curArea, `乡镇 $&#123;this.defaults[2]&#125; 不存在于县区 $&#123;this.defaults[1]&#125; 中` ); curAreaCode = find( Object.keys(this.areas), item =&gt; this.areas[item] === this.defaults[2] ); &#125; &#125; this.curArea = curArea; this.curAreaCode = curAreaCode; //-------------------------修改end //this.$refs.cascader.setValue(this.defaultsAreaCodes) // 还原默认值，避免用户选择出错 this.$nextTick(() =&gt; &#123; this.defaults = []; // this.isCode = false; &#125;); &#125;, 源代码为了避免循环调用SetDefaultCode函数，有一个isSetDefault的变量，标识是否已经更新设置行政区划，这里也需要改一下，因为源代码中curAreaCode的watch监听中没有将其设置为false，因此，即使手动设置了curAreaCode值，但因为没有改变绑定的defaultAreaCodes因此组件内部没有更新。 1234567curAreaCode(val) &#123; this.curArea = this.areas[val]; this.curAreaCode = val; //0328 add by weiyuan to resolve setDefault not to change this.isSetDefault=false this.setDefaultsCodes(); &#125; 至此，完美解决修改绑定的数组值，VueAreaLinkage组件Label不更新问题。 项目使用实例代码首先main.js中注册组件并初始化region， 1234import region from &apos;./assets/area-data/region&apos;import VueAreaLinkage from &apos;./components/area-utils/index&apos;Vue.use(VueAreaLinkage)Vue.prototype.$region = region 使用area-cascader封装cityPicker组件,这里还增加了根据权限过滤region数据，实现行政区划选择性显示 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107&lt;template&gt; &lt;div&gt; &lt;area-cascader :level=&quot;level&quot; v-model=&quot;valueArray&quot; :data=&quot;permissionData&quot; v-if=&quot;Object.keys(permissionData).length&quot; /&gt; &lt;!--&lt;div&gt;&#123;&#123;selected&#125;&#125;&lt;/div&gt;--&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import AreaCascader from &quot;./area-cascader/cascader&quot;;export default &#123; name: &quot;CityPicker&quot;, props: &#123; level: &#123; type: Number, required: false, default: 0 &#125;, selected: &#123; type: Array, default: [&quot;5201&quot;, &quot;520100&quot;] &#125; &#125;, component: &#123; &quot;area-cascader&quot;: AreaCascader &#125;, data() &#123; return &#123; valueArray: [], permissionData: &#123;&#125; &#125;; &#125;, created() &#123; this.valueArray = [].concat(this.selected); &#125;, mounted() &#123; //需要根据权限筛选region数据 let user = JSON.parse(window.sessionStorage.getItem(&quot;access-user&quot;)); if(!user)&#123; this.permissionData = this.$region; return &#125; this.userName = user.username; this.role = user.role; this.regionid = user.pac; if (this.regionid != undefined &amp;&amp; this.regionid != &quot;5201&quot;) &#123; let allRegion = Object.assign(&#123;&#125;, this.$region); if (this.regionid.length == 6) &#123; //县级 let city = allRegion[&quot;5201&quot;]; for (var key in city) &#123; if (key != this.regionid) &#123; delete city[key]; &#125; &#125; for (var key in allRegion) &#123; if (key.length &lt; 6) &#123; continue; &#125; if (key != this.regionid) &#123; delete allRegion[key]; &#125; &#125; this.permissionData = allRegion; &#125; else &#123; //镇级 this.permissionData = []; let countyId = this.regionid.substring(0, 6); let city = allRegion[&quot;5201&quot;]; let county = allRegion[countyId]; for (var key in city) &#123; if (key != countyId) &#123; delete city[key]; &#125; &#125; for (var key in allRegion) &#123; if (key.length &lt; 6) &#123; continue; &#125; if (key != countyId) &#123; delete allRegion[key]; &#125; &#125; for (var key in county) &#123; if (key != this.regionid) &#123; delete county[key]; &#125; &#125; this.permissionData = allRegion; &#125; &#125; else &#123; this.permissionData = this.$region; &#125; &#125;, watch: &#123; valueArray(curVal, oldVal) &#123; if(curVal!=oldVal)&#123;this.$emit(&quot;selected&quot;, curVal); &#125; &#125;, selected(curVal, oldVal) &#123; this.valueArray = [].concat(this.selected); &#125; &#125;&#125;;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; 使用 1234567&lt;CityPicker style=&quot;width:100%&quot; @selected=&quot;selectSearchRegion&quot; :selected=&quot;searchRegionArray&quot; :level=&quot;1&quot; /&gt;//需要动态修改是直接给searchRegionArray赋值即可，注意数组长度需要和联动级数匹配，即三级联动，数组需要长度为三 效果","tags":[{"name":"Vue 组件","slug":"Vue-组件","permalink":"http://11wy11.github.io/tags/Vue-组件/"}]},{"title":"日常知识--NodeJS进阶（一）","date":"2019-06-17T03:48:55.000Z","path":"2019/06/17/daily-nodejs-1/","text":"","tags":[]},{"title":"日常知识点整理--MongoDB数据库初探","date":"2019-06-17T01:46:55.000Z","path":"2019/06/17/daily-mongodb-first/","text":"mongodb数据库初次使用 MongoDB安装网上相关资料很多，需要自取，这里我使用ZIP安装包，解压到你想安装的目录，然后将bin目录的路径添加到环境变量中，可以在命令行中执行 mongod –help 查看是否配置成功 设置数据目录等可以新建一个MongoDBData的文件夹，里面创建log和db两个子文件夹，在命令行工具中打开到bin目录，执行 1mongod --logpath &quot;I:\\Program Files\\MongoDBData\\log\\mongodb.log&quot; --logappend --dbpath &quot;I:Program Files\\MongoDBData\\db&quot; --directoryperdb --install 命令行下运行MongoDB1net start MongoDB 连接MongoDB运行mongo.exe 1I:\\Program Files\\mongodb-4.0.10\\bin&gt;mongo.exe 配置MongoDB服务12345systemLog: destination: file path: I:\\Program Files\\MongoDBData\\log\\mongodb.logstorage: dbPath: I:\\Program Files\\MongoDBData\\db 12I:\\Program Files\\mongodb-4.0.10\\bin&gt;mongo.exe&gt;--config &quot;C:\\mongodb\\mongod.cfg&quot; --install 但是我失败了，不管了，目测和设置数据目录等最找效果是一样的O(∩_∩)O MongoDB设置密码 进入mongo.exe之后，执行show dbs可以查看现有数据库 use admin进入admin数据库 创建管理员账户 1db.createUser(&#123; user: \"admin\", pwd: \"adminpassword\", roles: [&#123; role: \"userAdminAnyDatabase\", db: \"admin\" &#125;] &#125;) mongodb中的用户是基于身份role的，该管理员账户的 role是 userAdminAnyDatabase。 ‘userAdmin’代表用户管理身份，’AnyDatabase’ 代表可以管理任何数据库。 验证用户是否成功添加 db.auth(&quot;admin&quot;, &quot;adminpassword&quot;) 如果返回1，则表示成功。 exit退出 此时可以使用创建的用户和密码通过MongoDB Compass连接数据库，进行相关操作了","tags":[{"name":"数据库","slug":"数据库","permalink":"http://11wy11.github.io/tags/数据库/"}]},{"title":"日常整理之mysql密码重置","date":"2019-06-16T13:29:36.000Z","path":"2019/06/16/daily-mysql-reset-password/","text":"本人没有保管号自己mysql的密码，致使无法登陆上 mysql密码重置1. 修改my.ini 文件在安装目录（如 I:\\Program Files\\mysql-8.0.15-winx64）下找到或新建my.ini；在[mysqld]段下面加入skip-grant-tables，并关闭mysql服务 12345678910111213141516171819[mysql]# 设置mysql客户端默认字符集default-character-set=utf8 [mysqld]skip-grant-tables# 设置3306端口port = 3306# 设置mysql的安装目录basedir=I:\\\\Program Files\\\\mysql-8.0.15-winx64# 设置 mysql数据库的数据的存放目录，MySQL 8+ 不需要以下配置，系统自己生成即可，否则有可能报错datadir=I:\\\\Program Files\\\\mysql-8.0.15-winx64\\data# datadir=C:\\\\web\\\\sqldata# 允许最大连接数max_connections=20# 服务端使用的字符集默认为8比特编码的latin1字符集character-set-server=utf8# 创建新表时将使用的默认存储引擎default-storage-engine=INNODB 2. 使用cd指令切换到mysql的bin目录3. 执行mysqld –console –skip-grant-tables –shared-memory 1560692598969 4. 在以管理员身份打开一个cmd命令行工具，输入mysql此时不需要密码几个直接进入 5. 使用 use mysql,然后执行一下命令可以查看密码1select user,host,authentication_string from user 6. 修改密码 ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;新密码&#39;; 1560693166712 7. 执行flush privileges8. quit 退出9. 回到第一个命名行窗口 ctrl+c，停止，可以将my.ini中skip-grant-tables删除，之后再使用net start mysql启动10. mysql -u root -p 输入新密码登录","tags":[{"name":"mysql","slug":"mysql","permalink":"http://11wy11.github.io/tags/mysql/"}]},{"title":"日常知识--初识NodeJS","date":"2019-06-15T12:57:01.000Z","path":"2019/06/15/daily-nodejs/","text":"整理来自菜鸟教程中nodejs入门知识 0. Webstorm设置nodejs提示File&gt;Settings&gt;Languages &amp; Frameworks&gt;javaScript&gt;Libraries, Add Nodejs提示库 设置图 1. 模块系统Node.js 中自带了一个叫做 http 的模块，我们在我们的代码中请求它并把返回值赋给一个本地变量。 这把我们的本地变量变成了一个拥有所有 http 模块所提供的公共方法的对象。 Node.js 的 require 方法中的文件查找策略如下： 由于 Node.js 中存在 4 类模块（原生模块和3种文件模块），尽管 require 方法极其简单，但是内部的加载却是十分复杂的，其加载优先级也各自不同。如下图所示： img 1.1 从文件模块缓存中加载尽管原生模块与文件模块的优先级不同，但是都会优先从文件模块的缓存中加载已经存在的模块。 1.2 从原生模块加载原生模块的优先级仅次于文件模块缓存的优先级。require 方法在解析文件名之后，优先检查模块是否在原生模块列表中。以http模块为例，尽管在目录下存在一个 http/http.js/http.node/http.json 文件，require(“http”) 都不会从这些文件中加载，而是从原生模块中加载。 原生模块也有一个缓存区，同样也是优先从缓存区加载。如果缓存区没有被加载过，则调用原生模块的加载方式进行加载和执行。 1.3 从文件加载当文件模块缓存中不存在，而且不是原生模块的时候，Node.js 会解析 require 方法传入的参数，并从文件系统中加载实际的文件，这里我们将详细描述查找文件模块的过程，其中，也有一些细节值得知晓。 require方法接受以下几种参数的传递： http、fs、path等，原生模块。 ./mod或../mod，相对路径的文件模块。 /pathtomodule/mod，绝对路径的文件模块。 mod，非原生模块的文件模块。 在路径 Y 下执行 require(X) 语句执行顺序： 123456789101112131415161718192021222324252627282930313233343536373839404142434445461. 如果 X 是内置模块 a. 返回内置模块 b. 停止执行2. 如果 X 以 '/' 开头 a. 设置 Y 为文件根路径3. 如果 X 以 './' 或 '/' or '../' 开头 a. LOAD_AS_FILE(Y + X) b. LOAD_AS_DIRECTORY(Y + X)4. LOAD_NODE_MODULES(X, dirname(Y))5. 抛出异常 \"not found\"LOAD_AS_FILE(X)1. 如果 X 是一个文件, 将 X 作为 JavaScript 文本载入并停止执行。2. 如果 X.js 是一个文件, 将 X.js 作为 JavaScript 文本载入并停止执行。3. 如果 X.json 是一个文件, 解析 X.json 为 JavaScript 对象并停止执行。4. 如果 X.node 是一个文件, 将 X.node 作为二进制插件载入并停止执行。LOAD_INDEX(X)1. 如果 X/index.js 是一个文件, 将 X/index.js 作为 JavaScript 文本载入并停止执行。2. 如果 X/index.json 是一个文件, 解析 X/index.json 为 JavaScript 对象并停止执行。3. 如果 X/index.node 是一个文件, 将 X/index.node 作为二进制插件载入并停止执行。LOAD_AS_DIRECTORY(X)1. 如果 X/package.json 是一个文件, a. 解析 X/package.json, 并查找 \"main\" 字段。 b. let M = X + (json main 字段) c. LOAD_AS_FILE(M) d. LOAD_INDEX(M)2. LOAD_INDEX(X)LOAD_NODE_MODULES(X, START)1. let DIRS=NODE_MODULES_PATHS(START)2. for each DIR in DIRS: a. LOAD_AS_FILE(DIR/X) b. LOAD_AS_DIRECTORY(DIR/X)NODE_MODULES_PATHS(START)1. let PARTS = path split(START)2. let I = count of PARTS - 13. let DIRS = []4. while I &gt;= 0, a. if PARTS[I] = \"node_modules\" CONTINUE b. DIR = path join(PARTS[0 .. I] + \"node_modules\") c. DIRS = DIRS + DIR d. let I = I - 15. return DIRS 2. 函数传递在JavaScript中，一个函数可以作为另一个函数的参数。我们可以先定义一个函数，然后传递，也可以在传递参数的地方直接定义函数。 Node.js中函数的使用与Javascript类似，举例来说，你可以这样做： 123456789function say(word) &#123; console.log(word);&#125;function execute(someFunction, value) &#123; someFunction(value);&#125;execute(say, \"Hello\"); 以上代码中，我们把 say 函数作为execute函数的第一个变量进行了传递。这里传递的不是 say 的返回值，而是 say 本身！ 这样一来， say 就变成了execute 中的本地变量 someFunction ，execute可以通过调用 someFunction() （带括号的形式）来使用 say 函数。 当然，因为 say 有一个变量， execute 在调用 someFunction 时可以传递这样一个变量。 1234567var http = require(\"http\");http.createServer(function(request, response) &#123; response.writeHead(200, &#123;\"Content-Type\": \"text/plain\"&#125;); response.write(\"Hello World\"); response.end();&#125;).listen(8888); 3. 路由我们要为路由提供请求的 URL 和其他需要的 GET 及 POST 参数，随后路由需要根据这些数据来执行相应的代码。我们需要的所有数据都会包含在 request 对象中，该对象作为 onRequest() 回调函数的第一个参数传递。但是为了解析这些数据，我们需要额外的 Node.JS 模块，它们分别是 url 和 querystring 模块。 12345678910111213 url.parse(string).query | url.parse(string).pathname | | | | | ------ -------------------http://localhost:8888/start?foo=bar&amp;hello=world --- ----- | | | | querystring.parse(queryString)[\"foo\"] | | querystring.parse(queryString)[\"hello\"] 12345678910111213141516171819var http=require(\"http\");var url=require(\"url\");function start(route)&#123; function onRequest(request,response) &#123; // 发送 HTTP 头部 // HTTP 状态值: 200 : OK // 内容类型: text/plain var pathname=url.parse(request.url).pathname; console.log(\"Request for \" + pathname + \" received.\"); route(pathname); response.writeHead(200, &#123;'Content-Type': 'text/plain'&#125;); // 发送响应数据 \"Hello World\" response.end('Hello World\\n'); &#125; http.createServer(onRequest).listen(8888); // 终端打印如下信息 console.log('Server running at http://127.0.0.1:8888/');&#125;exports.start=start; 4. 全局变量4.1 Node.js 全局对象JavaScript 中有一个特殊的对象，称为全局对象（Global Object），它及其所有属性都可以在程序的任何地方访问，即全局变量。 在浏览器 JavaScript 中，通常 window 是全局对象， 而 Node.js 中的全局对象是 global，所有全局变量（除了 global 本身以外）都是 global 对象的属性。 在 Node.js 我们可以直接访问到 global 的属性，而不需要在应用中包含它。 4.2 全局对象与全局变量global 最根本的作用是作为全局变量的宿主。按照 ECMAScript 的定义，满足以下条 件的变量是全局变量： 在最外层定义的变量； 全局对象的属性； 隐式定义的变量（未定义直接赋值的变量）。 当你定义一个全局变量时，这个变量同时也会成为全局对象的属性，反之亦然。需要注 意的是，在 Node.js 中你不可能在最外层定义变量，因为所有用户代码都是属于当前模块的， 而模块本身不是最外层上下文。 注意： 永远不要使用 var 定义变量以避免引入全局变量，因为全局变量会污染 命名空间，提高代码的耦合风险。 __filename process setTimeout(cb, ms) clearTimeout(t) setInterval(cb, ms) console 5. 常用工具 inherits util.inherits(constructor, superConstructor) 是一个实现对象间原型继承的函数。 JavaScript 的面向对象特性是基于原型的，与常见的基于类的不同。JavaScript 没有提供对象继承的语言级别特性，而是通过原型复制来实现的 1234567891011121314151617181920212223var util = require('util'); function Base() &#123; this.name = 'base'; this.base = 1991; this.sayHello = function() &#123; console.log('Hello ' + this.name); &#125;; &#125; Base.prototype.showName = function() &#123; console.log(this.name);&#125;; function Sub() &#123; this.name = 'sub'; &#125; util.inherits(Sub, Base); var objBase = new Base(); objBase.showName(); objBase.sayHello(); console.log(objBase); var objSub = new Sub(); objSub.showName(); //objSub.sayHello(); console.log(objSub); 注意：Sub 仅仅继承了Base 在原型中定义的函数，而构造函数内部创造的 base 属 性和 sayHello 函数都没有被 Sub 继承。 isArray inspect isRegExp isDate isError 6. 文件系统6.1 异步和同步123456789101112131415var fs = require(\"fs\");// 异步读取fs.readFile('input.txt', function (err, data) &#123; if (err) &#123; return console.error(err); &#125; console.log(\"异步读取: \" + data.toString());&#125;);// 同步读取var data = fs.readFileSync('input.txt');console.log(\"同步读取: \" + data.toString());console.log(\"程序执行完毕。\"); 6.2 打开文件，读写文件以下为在异步模式下打开文件的语法格式： 1fs.open(path, flags[, mode], callback) 参数 参数使用说明如下： path - 文件的路径。 flags - 文件打开的行为。具体值详见下文。 mode - 设置文件模式(权限)，文件创建默认权限为 0666(可读，可写)。 callback - 回调函数，带有两个参数如：callback(err, fd)。 flags 参数可以是以下值： Flag 描述 r 以读取模式打开文件。如果文件不存在抛出异常。 r+ 以读写模式打开文件。如果文件不存在抛出异常。 rs 以同步的方式读取文件。 rs+ 以同步的方式读取和写入文件。 w 以写入模式打开文件，如果文件不存在则创建。 wx 类似 ‘w’，但是如果文件路径存在，则文件写入失败。 w+ 以读写模式打开文件，如果文件不存在则创建。 wx+ 类似 ‘w+’， 但是如果文件路径存在，则文件读写失败。 a 以追加模式打开文件，如果文件不存在则创建。 ax 类似 ‘a’， 但是如果文件路径存在，则文件追加失败。 a+ 以读取追加模式打开文件，如果文件不存在则创建。 ax+ 类似 ‘a+’， 但是如果文件路径存在，则文件读取追加失败。 6.3 主要方法 序号 方法 &amp; 描述 1 fs.rename(oldPath, newPath, callback) 异步 rename().回调函数没有参数，但可能抛出异常。 2 fs.ftruncate(fd, len, callback) 异步 ftruncate().回调函数没有参数，但可能抛出异常。 3 fs.ftruncateSync(fd, len) 同步 ftruncate() 4 fs.truncate(path, len, callback) 异步 truncate().回调函数没有参数，但可能抛出异常。 5 fs.truncateSync(path, len) 同步 truncate() 6 fs.chown(path, uid, gid, callback) 异步 chown().回调函数没有参数，但可能抛出异常。 7 fs.chownSync(path, uid, gid) 同步 chown() 8 fs.fchown(fd, uid, gid, callback) 异步 fchown().回调函数没有参数，但可能抛出异常。 9 fs.fchownSync(fd, uid, gid) 同步 fchown() 10 fs.lchown(path, uid, gid, callback) 异步 lchown().回调函数没有参数，但可能抛出异常。 11 fs.lchownSync(path, uid, gid) 同步 lchown() 12 fs.chmod(path, mode, callback) 异步 chmod().回调函数没有参数，但可能抛出异常。 13 fs.chmodSync(path, mode) 同步 chmod(). 14 fs.fchmod(fd, mode, callback) 异步 fchmod().回调函数没有参数，但可能抛出异常。 15 fs.fchmodSync(fd, mode) 同步 fchmod(). 16 fs.lchmod(path, mode, callback) 异步 lchmod().回调函数没有参数，但可能抛出异常。Only available on Mac OS X. 17 fs.lchmodSync(path, mode) 同步 lchmod(). 18 fs.stat(path, callback) 异步 stat(). 回调函数有两个参数 err, stats，stats 是 fs.Stats 对象。 19 fs.lstat(path, callback) 异步 lstat(). 回调函数有两个参数 err, stats，stats 是 fs.Stats 对象。 20 fs.fstat(fd, callback) 异步 fstat(). 回调函数有两个参数 err, stats，stats 是 fs.Stats 对象。 21 fs.statSync(path) 同步 stat(). 返回 fs.Stats 的实例。 22 fs.lstatSync(path) 同步 lstat(). 返回 fs.Stats 的实例。 23 fs.fstatSync(fd) 同步 fstat(). 返回 fs.Stats 的实例。 24 fs.link(srcpath, dstpath, callback) 异步 link().回调函数没有参数，但可能抛出异常。 25 fs.linkSync(srcpath, dstpath) 同步 link(). 26 fs.symlink(srcpath, dstpath[, type], callback) 异步 symlink().回调函数没有参数，但可能抛出异常。 type 参数可以设置为 ‘dir’, ‘file’, 或 ‘junction’ (默认为 ‘file’) 。 27 fs.symlinkSync(srcpath, dstpath[, type]) 同步 symlink(). 28 fs.readlink(path, callback) 异步 readlink(). 回调函数有两个参数 err, linkString。 29 fs.realpath(path[, cache], callback) 异步 realpath(). 回调函数有两个参数 err, resolvedPath。 30 fs.realpathSync(path[, cache]) 同步 realpath()。返回绝对路径。 31 fs.unlink(path, callback) 异步 unlink().回调函数没有参数，但可能抛出异常。 32 fs.unlinkSync(path) 同步 unlink(). 33 fs.rmdir(path, callback) 异步 rmdir().回调函数没有参数，但可能抛出异常。 34 fs.rmdirSync(path) 同步 rmdir(). 35 fs.mkdir(path[, mode], callback) S异步 mkdir(2).回调函数没有参数，但可能抛出异常。 访问权限默认为 0777。 36 fs.mkdirSync(path[, mode]) 同步 mkdir(). 37 fs.readdir(path, callback) 异步 readdir(3). 读取目录的内容。 38 fs.readdirSync(path) 同步 readdir().返回文件数组列表。 39 fs.close(fd, callback) 异步 close().回调函数没有参数，但可能抛出异常。 40 fs.closeSync(fd) 同步 close(). 41 fs.open(path, flags[, mode], callback) 异步打开文件。 42 fs.openSync(path, flags[, mode]) 同步 version of fs.open(). 43 fs.utimes(path, atime, mtime, callback) 44 fs.utimesSync(path, atime, mtime) 修改文件时间戳，文件通过指定的文件路径。 45 fs.futimes(fd, atime, mtime, callback) 46 fs.futimesSync(fd, atime, mtime) 修改文件时间戳，通过文件描述符指定。 47 fs.fsync(fd, callback) 异步 fsync.回调函数没有参数，但可能抛出异常。 48 fs.fsyncSync(fd) 同步 fsync. 49 fs.write(fd, buffer, offset, length[, position], callback) 将缓冲区内容写入到通过文件描述符指定的文件。 50 fs.write(fd, data[, position[, encoding]], callback) 通过文件描述符 fd 写入文件内容。 51 fs.writeSync(fd, buffer, offset, length[, position]) 同步版的 fs.write()。 52 fs.writeSync(fd, data[, position[, encoding]]) 同步版的 fs.write(). 53 fs.read(fd, buffer, offset, length, position, callback) 通过文件描述符 fd 读取文件内容。 54 fs.readSync(fd, buffer, offset, length, position) 同步版的 fs.read. 55 fs.readFile(filename[, options], callback) 异步读取文件内容。 56 fs.readFileSync(filename[, options]) 57 fs.writeFile(filename, data[, options], callback) 异步写入文件内容。 58 fs.writeFileSync(filename, data[, options]) 同步版的 fs.writeFile。 59 fs.appendFile(filename, data[, options], callback) 异步追加文件内容。 60 fs.appendFileSync(filename, data[, options]) The 同步 version of fs.appendFile. 61 fs.watchFile(filename[, options], listener) 查看文件的修改。 62 fs.unwatchFile(filename[, listener]) 停止查看 filename 的修改。 63 fs.watch(filename[, options][, listener]) 查看 filename 的修改，filename 可以是文件或目录。返回 fs.FSWatcher 对象。 64 fs.exists(path, callback) 检测给定的路径是否存在。 65 fs.existsSync(path) 同步版的 fs.exists. 66 fs.access(path[, mode], callback) 测试指定路径用户权限。 67 fs.accessSync(path[, mode]) 同步版的 fs.access。 68 fs.createReadStream(path[, options]) 返回ReadStream 对象。 69 fs.createWriteStream(path[, options]) 返回 WriteStream 对象。 70 fs.symlink(srcpath, dstpath[, type], callback) 异步 symlink().回调函数没有参数，但可能抛出异常。 7. Get/Post请求7.1 获得get请求1234567891011121314151617function onGetRequest(request,response) &#123; // 发送 HTTP 头部 // HTTP 状态值: 200 : OK // 内容类型: text/plain var pathname=url.parse(request.url).pathname; console.log(\"Request for \" + pathname + \" received.\"); route(pathname); response.writeHead(200, &#123;'Content-Type': 'text/plain;charset=utf-8'&#125;); // 发送响应数据 \"Hello World\" // 解析 url 参数 var params = url.parse(request.url, true).query; for(let key in params)&#123; response.write(key+\":\"+params[key]+\"\\n\"); &#125; response.end(util.inspect(url.parse(request.url, true))); &#125; http.createServer(onGetRequest).listen(8888); 7.2 获得post请求12345678910111213141516171819202122232425262728293031var postHTML = '&lt;html&gt;&lt;head&gt;&lt;meta charset=\"utf-8\"&gt;&lt;title&gt; Node.js 实例&lt;/title&gt;&lt;/head&gt;' + '&lt;body&gt;' + '&lt;form method=\"post\"&gt;' + '名称： &lt;input name=\"name\"&gt;&lt;br&gt;' + '邮件： &lt;input name=\"email\"&gt;&lt;br&gt;' + '地址： &lt;input name=\"address\"&gt;&lt;br&gt;' + '&lt;input type=\"submit\"&gt;' + '&lt;/form&gt;' + '&lt;/body&gt;&lt;/html&gt;';function onPostRequest(request,response) &#123; // 定义了一个post变量，用于暂存请求体的信息 var post = ''; request.on('data', function(chunk)&#123; post += chunk; &#125;); // 在end事件触发后，通过querystring.parse将post解析为真正的POST请求格式，然后向客户端返回。 request.on('end', function()&#123; post = qs.parse(post); response.writeHead(200, &#123;'Content-Type': 'text/html; charset=utf8'&#125;); if(post.name) &#123; // 输出提交的数据 for(let key in post)&#123; response.write(key+\":\"+post[key]+\"\\n\"); &#125; &#125; else &#123; // 输出表单 response.write(postHTML); &#125; response.end(); &#125;);&#125;http.createServer(onPostRequest).listen(8888); 7.3 发送Get请求1234567891011121314151617181920212223242526272829303132//发送get请求var http = require('http');var qs = require('querystring');var data = &#123; a: 123, time: new Date().getTime()&#125;;//这是需要提交的数据var content = qs.stringify(data);var options = &#123; hostname: '127.0.0.1', port: 8888, path: '/pay/pay_callback?' + content, method: 'GET'&#125;;var req = http.request(options, function (res) &#123; console.log('STATUS: ' + res.statusCode); console.log('HEADERS: ' + JSON.stringify(res.headers)); res.setEncoding('utf8'); res.on('data', function (chunk) &#123; console.log('BODY: ' + chunk); &#125;);&#125;);req.on('error', function (e) &#123; console.log('problem with request: ' + e.message);&#125;);req.end(); 7.4 发送Post请求123456789101112131415161718192021222324252627//发送postvar contents = qs.stringify(&#123; name:'byvoid', email:'byvoid@byvoid.com', address:'Zijing'&#125;);var options = &#123; host:'127.0.0.1', port:8888, path:'/', method:'POST', headers:&#123; 'Content-Type':'application/x-www-form-urlencoded', 'Content-Length':contents.length &#125;&#125;var req = http.request(options, function(res)&#123; res.setEncoding('utf8'); res.on('data',function(data)&#123; console.log(\"data:\",data); //一段html代码 &#125;);&#125;);req.write(contents);req.end(); 8. 工具模块 序号 模块名 &amp; 描述 1 OS 模块 提供基本的系统操作函数。 2 Path 模块 提供了处理和转换文件路径的工具。 3 Net 模块 用于底层的网络通信。提供了服务端和客户端的的操作。 4 DNS 模块 用于解析域名。 5 Domain 模块 简化异步代码的异常处理，可以捕捉处理try catch无法捕捉的。 9. Express框架 body-parser - node.js 中间件，用于处理 JSON, Raw, Text 和 URL 编码的数据。 cookie-parser - 这就是一个解析Cookie的工具。通过req.cookies可以取到传过来的cookie，并把它们转成对象。 multer - node.js 中间件，用于处理 enctype=”multipart/form-data”（设置表单的MIME编码）的表单数据。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576var express=require(\"express\")var app=express();// 主页输出 \"Hello World\"app.get('/',function (req,res) &#123; console.log(\"主页 GET 请求\"); res.send('hello get');&#125;)// POST 请求app.post('/', function (req, res) &#123; console.log(\"主页 POST 请求\"); res.send('Hello POST');&#125;);// /del_user 页面响应app.get('/del_user', function (req, res) &#123; console.log(\"/del_user 响应 DELETE 请求\"); res.send('删除页面');&#125;)// /list_user 页面 GET 请求app.get('/list_user', function (req, res) &#123; console.log(\"/list_user GET 请求\"); res.send('用户列表页面');&#125;)// 对页面 abcd, abxcd, ab123cd, 等响应 GET 请求app.get('/ab*cd', function(req, res) &#123; console.log(\"/ab*cd GET 请求\"); res.send('正则匹配');&#125;)app.get('/index.html', function (req, res) &#123; res.sendFile( __dirname + \"/public/html/\" + \"index.html\" );&#125;)var fs = require(\"fs\");var multer=require(\"multer\");var util = require('util');var cookieParser = require('cookie-parser')app.use(cookieParser())// 创建 application/x-www-form-urlencoded 编码解析var urlencodedParser = bodyParser.urlencoded(&#123; extended: false &#125;)app.use(bodyParser.urlencoded(&#123; extended: false &#125;))app.use(multer(&#123;dest:'/tmp/'&#125;).array('image'));app.post('/process_post', urlencodedParser, function (req, res) &#123; // 输出 JSON 格式 var response = &#123; \"first_name\":req.body.first_name, \"last_name\":req.body.last_name &#125;; console.log(response); console.log(\"Cookies: \" + util.inspect(req.cookies)); res.end(JSON.stringify(response));&#125;)var server =app.listen(8081,function () &#123; var host=server.address().address; var port=server.address().port; console.log(\"应用实例，访问地址为 http://%s:%s\", host, port)&#125;)app.post('/file_upload',function (req,res) &#123; console.log(req.files[0]); var des_file=__dirname+\"/\"+req.files[0].originalname; fs.readFile(req.files[0].path,function (err,data) &#123; fs.watchFile(des_file,data,function (err) &#123; if(err)&#123; console.log(err); &#125;else&#123; response=&#123; message:'File uploaded successfully', filename: req.files[0].originalname &#125; &#125; console.log(response); res.end(JSON.stringify(response)); &#125;) &#125;)&#125;) 10. RESTful API12345678910111213141516171819202122232425262728293031323334353637383940414243444546/测试restful api//添加的新用户数据var user = &#123; \"user4\" : &#123; \"name\" : \"mohit\", \"password\" : \"password4\", \"profession\" : \"teacher\", \"id\": 4 &#125;&#125;app.post('/adduser',urlencodedParser,function (req,res) &#123; var newData=req.body; fs.readFile(__dirname+\"/public/static/users.json\",\"utf-8\",function (err,data) &#123; data = JSON.parse( data ); data[\"user4\"] = newData; console.log( data ); res.end( JSON.stringify(data)); &#125;)&#125;)// /del_user 页面响应app.get('/del_user/:id', function (req, res) &#123; // First read existing users. fs.readFile( __dirname + \"/public/static/\" + \"users.json\", 'utf8', function (err, data) &#123; data = JSON.parse( data ); delete data[\"user\" +req.params.id]; console.log( data ); res.end( JSON.stringify(data)); &#125;);&#125;)// /list_user 页面 GET 请求app.get('/list_user', function (req, res) &#123; console.log(\"/list_user GET 请求\"); fs.readFile(__dirname+\"/public/static/\"+\"users.json\",\"utf-8\",function (err,data) &#123; res.end(data); &#125;)&#125;)app.get('/:id',function (req,res) &#123; // 首先我们读取已存在的用户 fs.readFile( __dirname + \"/public/static/\" + \"users.json\", 'utf8', function (err, data) &#123; data = JSON.parse( data ); var user = data[\"user\" + req.params.id] console.log( user ); res.end( JSON.stringify(user)); &#125;);&#125;) 11. 多进程exec() 方法child_process.exec 123456789101112131415161718const fs = require('fs');const child_process = require('child_process');for(var i=0; i&lt;3; i++) &#123; var workerProcess = child_process.exec('node support.js '+i, function (error, stdout, stderr) &#123; if (error) &#123; console.log(error.stack); console.log('Error code: '+error.code); console.log('Signal received: '+error.signal); &#125; console.log('stdout: ' + stdout); console.log('stderr: ' + stderr); &#125;); workerProcess.on('exit', function (code) &#123; console.log('子进程已退出，退出码 '+code); &#125;);&#125; spawn() 方法1234567891011121314const fs = require('fs');const child_process = require('child_process');for(var i=0; i&lt;3; i++) &#123;var workerProcess = child_process.spawn('node', ['support.js', i]);workerProcess.stdout.on('data', function (data) &#123;console.log('stdout: ' + data);&#125;);workerProcess.stderr.on('data', function (data) &#123;console.log('stderr: ' + data);&#125;);workerProcess.on('close', function (code) &#123;console.log('子进程已退出，退出码 '+code);&#125;);&#125; ork 方法child_process.fork 是 spawn() 方法的特殊形式，用于创建进程，语法格式如下： 1child_process.fork(modulePath[, args][, options]) 12345678const fs = require('fs');const child_process = require('child_process');for(var i=0; i&lt;3; i++) &#123;var worker_process = child_process.fork(\"support.js\", [i]); worker_process.on('close', function (code) &#123;console.log('子进程已退出，退出码 ' + code);&#125;);&#125; 12. Node.js 连接 MySQL安装驱动1cnpm install mysql 连接数据库123456789101112var mysql = require('mysql');var connection = mysql.createConnection(&#123;host : 'localhost',user : 'root',password : '123456',database : 'test'&#125;);connection.connect();connection.query('SELECT 1 + 1 AS solution', function (error, results, fields) &#123;if (error) throw error;console.log('The solution is: ', results[0].solution);&#125;); 数据库操作( CURD )使用connection.query执行sql语句，实现增删改查 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455var mysql=require(&quot;mysql&quot;);var connection =mysql.createConnection(&#123; host:&quot;localhost&quot;, user:&quot;root&quot;, password:&quot;123456&quot;, database:&apos;nodejsBase&apos;&#125;);connection.connect();//查询connection.query(&apos;select * from websites&apos;,function (error,results) &#123; if(error)&#123; console.log(&apos;[SELECT ERROR] - &apos;,error.message); return; &#125; console.log(results);&#125;);//插入var addSql = &apos;INSERT INTO websites(Id,name,url,alexa,country) VALUES(0,?,?,?,?)&apos;;var addSqlParams = [&apos;菜鸟工具&apos;, &apos;https://c.runoob.com&apos;,&apos;23453&apos;, &apos;CN&apos;];connection.query(addSql,addSqlParams,function (err,result) &#123; if(err)&#123; console.log(&apos;[INSERT ERROR] - &apos;,err.message); return; &#125; console.log(&apos;--------------------------INSERT----------------------------&apos;); //console.log(&apos;INSERT ID:&apos;,result.insertId); console.log(&apos;INSERT ID:&apos;,result); console.log(&apos;-----------------------------------------------------------------\\n\\n&apos;);&#125;);//更新var updateSql=&apos;update websites set name=?,url=? where id=?&apos;;var updateParams=[&apos;菜鸟移动站&apos;, &apos;https://m.runoob.com&apos;,6];connection.query(updateSql,updateParams,function (err,result) &#123; if(err)&#123; console.log(&apos;[UPDATE ERROR] - &apos;,err.message); return; &#125; console.log(&apos;--------------------------UPDATE----------------------------&apos;); console.log(&apos;UPDATE affectedRows&apos;,result.affectedRows); console.log(&apos;-----------------------------------------------------------------\\n\\n&apos;);&#125;);//删除var deleteSql=&apos;delete from websites where id=7&apos;;connection.query(deleteSql,function (err, result) &#123; if(err)&#123; console.log(&apos;[DELETE ERROR] - &apos;,err.message); return; &#125; console.log(&apos;--------------------------DELETE----------------------------&apos;); console.log(&apos;DELETE affectedRows&apos;,result.affectedRows); console.log(&apos;-----------------------------------------------------------------\\n\\n&apos;);&#125;);connection.end(); 13. Node.js 连接MongoDBcnpm install mongodb –save 创建数据库 创建集合 增删改查数据 聚合（连接）操作 删除集合 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117var MongoClient = require('mongodb').MongoClient;var url = \"mongodb://localhost:27017/nodejsBase\";MongoClient.connect(url, &#123; useNewUrlParser: true &#125;, function(err, db) &#123; if (err) throw err; console.log(\"数据库已创建!\"); var dbase = db.db(\"nodejsBase\"); // dbase.createCollection('site', function (err, res) &#123; // if (err) throw err; // console.log(\"创建集合!\"); // db.close(); // &#125;); var myobj = &#123; name: \"菜鸟教程\", url: \"www.runoob\" &#125;; dbase.collection(\"site\").insertOne(myobj, function(err, res) &#123; if (err) throw err; console.log(\"文档插入成功\"); //db.close(); &#125;); // myobj = [ // &#123; name: '菜鸟工具', url: 'https://c.runoob.com', type: 'cn'&#125;, // &#123; name: 'Google', url: 'https://www.google.com', type: 'en'&#125;, // &#123; name: 'Facebook', url: 'https://www.google.com', type: 'en'&#125; // ]; // dbase.collection(\"site\").insertMany(myobj, function(err, res) &#123; // if (err) throw err; // console.log(\"插入的文档数量为: \" + res.insertedCount); // //db.close(); // &#125;); //查询全部 // dbase.collection(\"site\").find(&#123;&#125;).toArray(function (err,result) &#123; // if (err) throw err; // console.log(result); // //db.close(); // &#125;) //更新 var whereStr = &#123;\"name\":'菜鸟教程'&#125;; // 查询条件 var updateStr = &#123;$set: &#123; \"url\" : \"https://www.runoob.com\" ,type:'cn'&#125;&#125;; dbase.collection(\"site\").updateMany(whereStr,updateStr,function (err,result) &#123; console.log(\"更新————————————————————————\"); if (err) throw err; console.log(result.result.nModified + \" 条文档被更新\"); //db.close(); &#125;); // //条件 // dbase.collection(\"site\").find(&#123;name:\"菜鸟教程\"&#125;).toArray(function (err,result) &#123; // console.log(\"查询————————————————————————\"); // if (err) throw err; // console.log(result); // //db.close(); // &#125;); // //删除 // dbase.collection(\"site\").deleteMany(whereStr, function(err, result) &#123; // console.log(\"删除————————————————————————\"); // if (err) throw err; // console.log(result.result.n + \" 条文档被删除\"); // db.close(); // &#125;); //查询排序 分页skip 跳过指定条数 limit条数 // var mysort = &#123; type: 1 &#125;;//1升序，-1降序 // dbase.collection(\"site\").find().sort(mysort).skip(2).limit(5).toArray(function(err, result) &#123; // if (err) throw err; // console.log(result); // db.close(); // &#125;); //连接操作 // dbase.createCollection('orders', function (err, res) &#123; // if (err) throw err; // console.log(\"创建orders集合!\"); // db.close(); // &#125;); // dbase.createCollection('products', function (err, res) &#123; // if (err) throw err; // console.log(\"创建products集合!\"); // db.close(); // &#125;); // let orderData=&#123;_id:1,product_id:154,status:1&#125; // dbase.collection(\"orders\").insertOne(orderData,function (err,result) &#123; // if (err) throw err; // console.log(result.result.n); // &#125;) // let productData=[ &#123; _id: 154, name: '笔记本电脑' &#125;, // &#123; _id: 155, name: '耳机' &#125;, // &#123; _id: 156, name: '台式电脑' &#125;]; // dbase.collection(\"products\").insertMany(productData,function (err,result) &#123; // if (err) console.log(err); // console.log(result.result.n); // &#125;) dbase.collection(\"orders\") .aggregate([&#123; $lookup: &#123; from: 'products', // 右集合 localField: 'product_id', // 左集合 join 字段 foreignField: '_id', // 右集合 join 字段 as: 'orderdetails' // 新生成字段（类型array） &#125; &#125;]) .toArray(function(err, res) &#123; if (err) throw err; console.log(JSON.stringify(res)); db.close(); &#125;); //分组等 dbase.collection(\"site\") .aggregate([&#123; $group:&#123;_id:'$name',num:&#123;$sum:1&#125;&#125; &#125;]) .toArray(function(err, res) &#123; if (err) throw err; console.log(JSON.stringify(res)); db.close(); &#125;); //其他操作类似，查看mongodb操作相关内容&#125;);","tags":[{"name":"nodejs","slug":"nodejs","permalink":"http://11wy11.github.io/tags/nodejs/"}]},{"title":"日常知识点整理--CSS基础","date":"2019-06-14T02:07:40.000Z","path":"2019/06/14/daily-css/","text":"我所不熟悉的CSS属性 [TOC] 我所不熟悉的CSS属性before 选择器:before 选择器向选定的元素前插入内容 使用content 属性来指定要插入的内容。 after 选择器:after 选择器向选定的元素之后插入内容。 例如插入下三角 1234567891011121314151617181920212223242526272829303132333435&lt;style&gt;select&#123; height: 40px; padding: 5px; background-color:#ececec; border: 0; outline: none; font-size: 16px; width: 240px; -webkit-appearance: none; -moz-appearance: none; appearance: none;&#125;.select:after &#123; content:\"▼\"; padding: 12px 8px; position: absolute; right: 10px; top: 0; z-index: 1; text-align: center; width: 10%; height: 100%; pointer-events: none; box-sizing: border-box; &#125;&lt;/style&gt;&lt;div class=\"select\"&gt; &lt;select name=\"select\"&gt; &lt;option&gt;select&lt;/option&gt; &lt;option&gt;option&lt;/option&gt; &lt;option&gt;option&lt;/option&gt; &lt;option&gt;option&lt;/option&gt; &lt;option&gt;option&lt;/option&gt; &lt;option&gt;option&lt;/option&gt; &lt;option&gt;option&lt;/option&gt; &lt;/select&gt;&lt;/div&gt; filter(滤镜) 属性 Filter 描述 none 默认值，没有效果。 blur(px) 给图像设置高斯模糊。”radius”一值设定高斯函数的标准差，或者是屏幕上以多少像素融在一起， 所以值越大越模糊； 如果没有设定值，则默认是0；这个参数可设置css长度值，但不接受百分比值。 brightness(%) 给图片应用一种线性乘法，使其看起来更亮或更暗。如果值是0%，图像会全黑。值是100%，则图像无变化。其他的值对应线性乘数效果。值超过100%也是可以的，图像会比原来更亮。如果没有设定值，默认是1。 contrast(%) 调整图像的对比度。值是0%的话，图像会全黑。值是100%，图像不变。值可以超过100%，意味着会运用更低的对比。若没有设置值，默认是1。 drop-shadow(h-shadow v-shadow blur spread color) 给图像设置一个阴影效果。阴影是合成在图像下面，可以有模糊度的，可以以特定颜色画出的遮罩图的偏移版本。 函数接受(在CSS3背景中定义)类型的值，除了”inset”关键字是不允许的。该函数与已有的box-shadow box-shadow属性很相似；不同之处在于，通过滤镜，一些浏览器为了更好的性能会提供硬件加速。&lt;shadow&gt;参数如下：` (必须)这是设置阴影偏移量的两个 值. 设定水平方向距离. 负值会使阴影出现在元素左边. 设定垂直距离.负值会使阴影出现在元素上方。查看可能的单位.如果两个值都是0, 则阴影出现在元素正后面 (如果设置了 and/or ，会有模糊效果). (可选)这是第三个code&gt;值. 值越大，越模糊，则阴影会变得更大更淡.不允许负值 若未设定，默认是0 (则阴影的边界很锐利). (可选)这是第四个 值. 正值会使阴影扩张和变大，负值会是阴影缩小.若未设定，默认是0 (阴影会与元素一样大小). 注意: Webkit, 以及一些其他浏览器 不支持第四个长度，如果加了也不会渲染。 (可选)查看 该值可能的关键字和标记。若未设定，颜色值基于浏览器。在Gecko (Firefox), Presto (Opera)和Trident (Internet Explorer)中， 会应用colorcolor属性的值。另外, 如果颜色值省略，WebKit中阴影是透明的。` grayscale(%) 将图像转换为灰度图像。值定义转换的比例。值为100%则完全转为灰度图像，值为0%图像无变化。值在0%到100%之间，则是效果的线性乘子。若未设置，值默认是0； hue-rotate(deg) 给图像应用色相旋转。”angle”一值设定图像会被调整的色环角度值。值为0deg，则图像无变化。若值未设置，默认值是0deg。该值虽然没有最大值，超过360deg的值相当于又绕一圈。 invert(%) 反转输入图像。值定义转换的比例。100%的价值是完全反转。值为0%则图像无变化。值在0%和100%之间，则是效果的线性乘子。 若值未设置，值默认是0。 opacity(%) 转化图像的透明程度。值定义转换的比例。值为0%则是完全透明，值为100%则图像无变化。值在0%和100%之间，则是效果的线性乘子，也相当于图像样本乘以数量。 若值未设置，值默认是1。该函数与已有的opacity属性很相似，不同之处在于通过filter，一些浏览器为了提升性能会提供硬件加速。 saturate(%) 转换图像饱和度。值定义转换的比例。值为0%则是完全不饱和，值为100%则图像无变化。其他值，则是效果的线性乘子。超过100%的值是允许的，则有更高的饱和度。 若值未设置，值默认是1。 sepia(%) 将图像转换为深褐色。值定义转换的比例。值为100%则完全是深褐色的，值为0%图像无变化。值在0%到100%之间，则是效果的线性乘子。若未设置，值默认是0； url() URL函数接受一个XML文件，该文件设置了 一个SVG滤镜，且可以包含一个锚点来指定一个具体的滤镜元素。例如：filter: url(svg-url#element-id) initial 设置属性为默认值，可参阅： CSS initial 关键字 inherit 从父元素继承该属性，可参阅：CSS inherit 关键字 伪类anchor伪类在支持 CSS 的浏览器中，链接的不同状态都可以以不同的方式显示 1a:link &#123;color:#FF0000;&#125; /* 未访问的链接 */ a:visited &#123;color:#00FF00;&#125; /* 已访问的链接 */ a:hover &#123;color:#FF00FF;&#125; /* 鼠标划过链接 */ a:active &#123;color:#0000FF;&#125; /* 已选中的链接 */ 注意： 在CSS定义中，a:hover 必须被置于 a:link 和 a:visited 之后，才是有效的。 注意： 在 CSS 定义中，a:active 必须被置于 a:hover 之后，才是有效的。 CSS 属性 选择器下面的例子是把包含标题（title）的所有元素变为蓝色： 实例 1[title] &#123; color:blue; &#125;","tags":[{"name":"CSS","slug":"CSS","permalink":"http://11wy11.github.io/tags/CSS/"}]},{"title":"日常知识点整理——js基础","date":"2019-06-13T03:43:50.000Z","path":"2019/06/13/daily-js/","text":"手写图片瀑布流及图片懒加载 随机获得照片地址http://lorempixel.com/1600/900 https://unsplash.it/1600/900?random（国内加载略慢） https://uploadbeta.com/api/pictures/random/?key=BingEverydayWallpaperPicture【返回必应图片】 http://cn.bing.com/HPImageArchive.aspx?format=js&amp;idx=0&amp;n=1（必应返回JSON数据，具体百度","tags":[{"name":"js","slug":"js","permalink":"http://11wy11.github.io/tags/js/"}]},{"title":"日常知识点整理——正则表达式regex","date":"2019-06-12T08:00:27.000Z","path":"2019/06/12/daily-regex/","text":"转载 开心师姐的博客 转载https://rosychen.com/2019/06/10/2019-06-10-%E3%80%90JS%E5%9F%BA%E7%A1%80%E3%80%91%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/ 正则表达式 了解正则表达式基本语法 能够使用JavaScript的正则对象 正则表达式简介什么是正则表达式正则表达式：用于匹配规律规则的表达式，正则表达式最初是科学家对人类神经系统的工作原理的早期研究，现在在编程语言中有广泛的应用。正则表通常被用来检索、替换那些符合某个模式(规则)的文本。正则表达式是对字符串操作的一种逻辑公式，就是用事先定义好的一些特定字符、及这些特定字符的组合，组成一个“规则字符串”，这个“规则字符串”用来表达对字符串的一种过滤逻辑。 正则表达式的作用 给定的字符串是否符合正则表达式的过滤逻辑(匹配) 可以通过正则表达式，从字符串中获取我们想要的特定部分(提取) 强大的字符串替换能力(替换) 正则表达式的特点 灵活性、逻辑性和功能性非常的强 可以迅速地用极简单的方式达到字符串的复杂控制 对于刚接触的人来说，比较晦涩难懂 正则表达式的测试 在线测试正则 正则表达式的组成 普通字符 特殊字符(元字符)：正则表达式中有特殊意义的字符 示例： \\d 匹配数字 ab\\d 匹配 ab1、ab2 元字符串通过测试工具演示下面元字符的使用 常用元字符串 元字符 说明 . 匹配除换行符以外的任意单个字符 \\d 匹配数字 \\D 匹配任意非数字的字符 \\w 匹配字母或数字或下划线 \\W 匹配任意不是字母，数字，下划线 \\s 匹配任意的空白符 \\S 匹配任意不是空白符的字符 ^ 表示匹配行首的文本(以谁开始) $ 表示匹配行尾的文本(以谁结束) 限定符 限定符 说明 * 重复零次或更多次 + 重复一次或更多次 ? 重复零次或一次 {n} 重复n次 {n,} 重复n次或更多次 {n,m} 重复n到m次 其它1234567[] 字符串用中括号括起来，表示匹配其中的任一字符，相当于或的意思[^] 匹配除中括号以内的内容\\ 转义符| 或者，选择两者中的一个。注意|将左右两边分为两部分，而不管左右两边有多长多乱() 从两个直接量中选择一个，分组 eg：gr(a|e)y匹配gray和grey[\\u4e00-\\u9fa5] 匹配汉字 案例验证手机号： 1^\\d&#123;11&#125;$ 验证邮编： 1^\\d&#123;6&#125;$ 验证日期 2012-5-01 1^\\d&#123;4&#125;-\\d&#123;1,2&#125;-\\d&#123;1,2&#125;$ 验证邮箱 xxx@itcast.cn： 1^\\w+@\\w+\\.\\w+$ 验证IP地址 192.168.1.10 1^\\d&#123;1,3&#125;\\(.\\d&#123;1,3&#125;)&#123;3&#125;$ 使用正则表达式 提取网址协议，域名，IP, 端口等参数 123456789101112var url = &quot;http://192.168.1.111:8888/#/statistic/htmel/dkdkd/dksdkldsl.html&quot;;var patt = /(\\w+):\\/\\/([^/:]+):(\\d*)\\/#\\/(\\S+)/;arr = url.match(patt);for (let i = 0; i &lt; arr.length; i++) &#123; console.log(arr[i])&#125;var index = arr[arr.length - 1];// var arrIndex = index.split(&quot;/&quot;)var arrIndex = index.match(/(\\w+)/g);for (let i = 0; i &lt; arrIndex.length; i++) &#123; console.log(arrIndex[i])&#125; JavaScript 中使用正则表达式创建正则对象方式1： 12var reg = new Regex('\\d', 'i');var reg = new Regex('\\d', 'gi'); 方式2： 12var reg = /\\d/i;var reg = /\\d/gi; 参数 标志 说明 i 忽略大小写 g 全局匹配 gi 全局匹配+忽略大小写 正则匹配1234// 匹配日期var dateStr = '2015-10-10';var reg = /^\\d&#123;4&#125;-\\d&#123;1,2&#125;-\\d&#123;1,2&#125;$/console.log(reg.test(dateStr)); 匹配正则表达式123456789101112131415161718192021//console.log(/./.test(\"除了回车换行以外的任意字符\"));//true// console.log(/.*/.test(\"0个到多个\"));//true// console.log(/.+/.test(\"1个到多个\"));//true// console.log(/.?/.test(\"哈哈\"));//true// console.log(/[0-9]/.test(\"9527\"));//true// console.log(/[a-z]/.test(\"what\"));//true// console.log(/[A-Z]/.test(\"Are\"));//true// console.log(/[a-zA-Z]/.test(\"干啥子\"));//false// console.log(/[0-9a-zA-Z]/.test(\"9ebg\"));//true// console.log(/b|(ara)/.test(\"abra\"));//true// console.log(/[a-z]&#123;2,3&#125;/.test(\"arfsf\"));//trueconsole.log(/\\d/.test(\"998\"));//trueconsole.log(/\\d*/.test(\"998\"));//trueconsole.log(/\\d+/.test(\"998\"));//trueconsole.log(/\\d&#123;0,&#125;/.test(\"998\"));//trueconsole.log(/\\d&#123;2,3&#125;/.test(\"998\"));//trueconsole.log(/\\D/.test(\"eat\"));//trueconsole.log(/\\s/.test(\" \"));//trueconsole.log(/\\S/.test(\"嘎嘎\"));//trueconsole.log(/\\w/.test(\"_\"));//trueconsole.log(/\\W/.test(\"_\"));//true 正则表达式案例1.验证密码强弱2.验证邮箱：[0-9a-zA-Z_.-]+[@][0-9a-zA-Z._-]+([.][a-zA-Z]+){1,2}3.验证中文名字[\\u4e00-\\u9fa5] 正则提取12345678910111213141516171819202122232425262728293031323334353637383940// 1. 提取工资var str = \"张三：1000，李四：5000，王五：8000。\";var array = str.match(/\\d+/g);console.log(array);// 2. 提取email地址var str = \"123123@xx.com,fangfang@valuedopinions.cn 286669312@qq.com 2、emailenglish@emailenglish.englishtown.com 286669312@qq.com...\";var array = str.match(/\\w+@\\w+\\.\\w+(\\.\\w+)?/g);console.log(array);// 3. 分组提取 // 3. 提取日期中的年部分 2015-5-10var dateStr = '2016-1-5';// 正则表达式中的()作为分组来使用，获取分组匹配到的结果用Regex.$1 $2 $3....来获取var reg = /(\\d&#123;4&#125;)-\\d&#123;1,2&#125;-\\d&#123;1,2&#125;/;if (reg.test(dateStr)) &#123; console.log(RegExp.$1);&#125;// 4. 提取邮件中的每一部分var reg = /(\\w+)@(\\w+)\\.(\\w+)(\\.\\w+)?/;var str = \"123123@xx.com\";if (reg.test(str)) &#123; console.log(RegExp.$1); console.log(RegExp.$2); console.log(RegExp.$3);&#125;//5. 提取网址URI组件var str = \"http://www.runoob.com:80/html/html-tutorial.html\";var patt1 = /(\\w+):\\/\\/([^/:]+)(:\\d*)?([^# ]*)/;arr = str.match(patt1);for (var i = 0; i &lt; arr.length ; i++) &#123; document.write(arr[i]); document.write(\"&lt;br&gt;\");&#125;//out // http// www.runoob.com // :80 // /html/html-tutorial.html 正则替换123456789// 1. 替换所有空白var str = \" 123AD asadf asadfasf adf \";str = str.replace(/\\s/g,\"xx\");console.log(str);// 2. 替换所有,|，var str = \"abc,efg,123，abc,123，a\";str = str.replace(/,|，/g, \".\");console.log(str); 案例：表单验证12345QQ号：&lt;input type=\"text\" id=\"txtQQ\"&gt;&lt;span&gt;&lt;/span&gt;&lt;br&gt;邮箱：&lt;input type=\"text\" id=\"txtEMail\"&gt;&lt;span&gt;&lt;/span&gt;&lt;br&gt;手机：&lt;input type=\"text\" id=\"txtPhone\"&gt;&lt;span&gt;&lt;/span&gt;&lt;br&gt;生日：&lt;input type=\"text\" id=\"txtBirthday\"&gt;&lt;span&gt;&lt;/span&gt;&lt;br&gt;姓名：&lt;input type=\"text\" id=\"txtName\"&gt;&lt;span&gt;&lt;/span&gt;&lt;br&gt; 12345678910111213141516171819202122232425262728293031323334353637383940//获取文本框var txtQQ = document.getElementById(\"txtQQ\");var txtEMail = document.getElementById(\"txtEMail\");var txtPhone = document.getElementById(\"txtPhone\");var txtBirthday = document.getElementById(\"txtBirthday\");var txtName = document.getElementById(\"txtName\");//txtQQ.onblur = function () &#123; //获取当前文本框对应的span var span = this.nextElementSibling; var reg = /^\\d&#123;5,12&#125;$/; //判断验证是否成功 if(!reg.test(this.value) )&#123; //验证不成功 span.innerText = \"请输入正确的QQ号\"; span.style.color = \"red\"; &#125;else&#123; //验证成功 span.innerText = \"\"; span.style.color = \"\"; &#125;&#125;;//txtEMailtxtEMail.onblur = function () &#123; //获取当前文本框对应的span var span = this.nextElementSibling; var reg = /^\\w+@\\w+\\.\\w+(\\.\\w+)?$/; //判断验证是否成功 if(!reg.test(this.value) )&#123; //验证不成功 span.innerText = \"请输入正确的EMail地址\"; span.style.color = \"red\"; &#125;else&#123; //验证成功 span.innerText = \"\"; span.style.color = \"\"; &#125;&#125;; 表单验证部分，封装成函数： 12345678910111213141516171819var regBirthday = /^\\d&#123;4&#125;-\\d&#123;1,2&#125;-\\d&#123;1,2&#125;$/;addCheck(txtBirthday, regBirthday, \"请输入正确的出生日期\");//给文本框添加验证function addCheck(element, reg, tip) &#123; element.onblur = function () &#123; //获取当前文本框对应的span var span = this.nextElementSibling; //判断验证是否成功 if(!reg.test(this.value) )&#123; //验证不成功 span.innerText = tip; span.style.color = \"red\"; &#125;else&#123; //验证成功 span.innerText = \"\"; span.style.color = \"\"; &#125; &#125;;&#125; 通过给元素增加自定义验证属性对表单进行验证： 1234567&lt;form id=\"frm\"&gt; QQ号：&lt;input type=\"text\" name=\"txtQQ\" data-rule=\"qq\"&gt;&lt;span&gt;&lt;/span&gt;&lt;br&gt; 邮箱：&lt;input type=\"text\" name=\"txtEMail\" data-rule=\"email\"&gt;&lt;span&gt;&lt;/span&gt;&lt;br&gt; 手机：&lt;input type=\"text\" name=\"txtPhone\" data-rule=\"phone\"&gt;&lt;span&gt;&lt;/span&gt;&lt;br&gt; 生日：&lt;input type=\"text\" name=\"txtBirthday\" data-rule=\"date\"&gt;&lt;span&gt;&lt;/span&gt;&lt;br&gt; 姓名：&lt;input type=\"text\" name=\"txtName\" data-rule=\"cn\"&gt;&lt;span&gt;&lt;/span&gt;&lt;br&gt;&lt;/form&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475// 所有的验证规则var rules = [ &#123; name: 'qq', reg: /^\\d&#123;5,12&#125;$/, tip: \"请输入正确的QQ\" &#125;, &#123; name: 'email', reg: /^\\w+@\\w+\\.\\w+(\\.\\w+)?$/, tip: \"请输入正确的邮箱地址\" &#125;, &#123; name: 'phone', reg: /^\\d&#123;11&#125;$/, tip: \"请输入正确的手机号码\" &#125;, &#123; name: 'date', reg: /^\\d&#123;4&#125;-\\d&#123;1,2&#125;-\\d&#123;1,2&#125;$/, tip: \"请输入正确的出生日期\" &#125;, &#123; name: 'cn', reg: /^[\\u4e00-\\u9fa5]&#123;2,4&#125;$/, tip: \"请输入正确的姓名\" &#125;];addCheck('frm');//给文本框添加验证function addCheck(formId) &#123; var i = 0, len = 0, frm =document.getElementById(formId); len = frm.children.length; for (; i &lt; len; i++) &#123; var element = frm.children[i]; // 表单元素中有name属性的元素添加验证 if (element.name) &#123; element.onblur = function () &#123; // 使用dataset获取data-自定义属性的值 var ruleName = this.dataset.rule; var rule =getRuleByRuleName(rules, ruleName); var span = this.nextElementSibling; //判断验证是否成功 if(!rule.reg.test(this.value) )&#123; //验证不成功 span.innerText = rule.tip; span.style.color = \"red\"; &#125;else&#123; //验证成功 span.innerText = \"\"; span.style.color = \"\"; &#125; &#125; &#125; &#125;&#125;// 根据规则的名称获取规则对象function getRuleByRuleName(rules, ruleName) &#123; var i = 0, len = rules.length; var rule = null; for (; i &lt; len; i++) &#123; if (rules[i].name == ruleName) &#123; rule = rules[i]; break; &#125; &#125; return rule;&#125; 菜鸟工具部分例子 Email地址：^\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*$ 域名：[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(/.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+/.? InternetURL：[a-zA-z]+://[^\\s]* 或 ^http://([\\w-]+\\.)+[\\w-]+(/[\\w-./?%&amp;=]*)?$ 手机号码：^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\\d{8}$ 电话号码(“XXX-XXXXXXX”、”XXXX-XXXXXXXX”、”XXX-XXXXXXX”、”XXX-XXXXXXXX”、”XXXXXXX”和”XXXXXXXX)：^(\\(\\d{3,4}-)|\\d{3.4}-)?\\d{7,8}$ 国内电话号码(0511-4405222、021-87888822)：\\d{3}-\\d{8}|\\d{4}-\\d{7} 电话号码正则表达式（支持手机号码，3-4位区号，7-8位直播号码，1－4位分机号）: ((\\d{11})|^((\\d{7,8})|(\\d{4}|\\d{3})-(\\d{7,8})|(\\d{4}|\\d{3})-(\\d{7,8})-(\\d{4}|\\d{3}|\\d{2}|\\d{1})|(\\d{7,8})-(\\d{4}|\\d{3}|\\d{2}|\\d{1}))$) 身份证号(15位、18位数字)，最后一位是校验位，可能为数字或字符X：(^\\d{15}$)|(^\\d{18}$)|(^\\d{17}(\\d|X|x)$) 帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]{4,15}$ 密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：^[a-zA-Z]\\w{5,17}$ 强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在 8-10 之间)：^(?=.*\\d)(?=.*[a-z])(?=.*[A-Z])[a-zA-Z0-9]{8,10}$ 强密码(必须包含大小写字母和数字的组合，可以使用特殊字符，长度在8-10之间)：^(?=.*\\d)(?=.*[a-z])(?=.*[A-Z]).{8,10}$ 日期格式：^\\d{4}-\\d{1,2}-\\d{1,2} 一年的12个月(01～09和1～12)：^(0?[1-9]|1[0-2])$ 一个月的31天(01～09和1～31)：^((0?[1-9])|((1|2)[0-9])|30|31)$ 钱的输入格式： 有四种钱的表示形式我们可以接受:”10000.00” 和 “10,000.00”, 和没有 “分” 的 “10000” 和 “10,000”：^[1-9][0-9]*$ 这表示任意一个不以0开头的数字,但是,这也意味着一个字符”0”不通过,所以我们采用下面的形式：^(0|[1-9][0-9]*)$ 一个0或者一个不以0开头的数字.我们还可以允许开头有一个负号：^(0|-?[1-9][0-9]*)$ 这表示一个0或者一个可能为负的开头不为0的数字.让用户以0开头好了.把负号的也去掉,因为钱总不能是负的吧。下面我们要加的是说明可能的小数部分：^[0-9]+(.[0-9]+)?$ 必须说明的是,小数点后面至少应该有1位数,所以”10.”是不通过的,但是 “10” 和 “10.2” 是通过的：^[0-9]+(.[0-9]{2})?$ 这样我们规定小数点后面必须有两位,如果你认为太苛刻了,可以这样：^[0-9]+(.[0-9]{1,2})?$ 这样就允许用户只写一位小数.下面我们该考虑数字中的逗号了,我们可以这样：^[0-9]{1,3}(,[0-9]{3})*(.[0-9]{1,2})?$ 1到3个数字,后面跟着任意个 逗号+3个数字,逗号成为可选,而不是必须：^([0-9]+|[0-9]{1,3}(,[0-9]{3})*)(.[0-9]{1,2})?$ 备注：这就是最终结果了,别忘了”+”可以用”*”替代如果你觉得空字符串也可以接受的话(奇怪,为什么?)最后,别忘了在用函数时去掉去掉那个反斜杠,一般的错误都在这里 xml文件：^([a-zA-Z]+-?)+[a-zA-Z0-9]+\\\\.[x|X][m|M][l|L]$ 中文字符的正则表达式：[\\u4e00-\\u9fa5] 双字节字符：[^\\x00-\\xff] (包括汉字在内，可以用来计算字符串的长度(一个双字节字符长度计2，ASCII字符计1)) 空白行的正则表达式：\\n\\s*\\r (可以用来删除空白行) HTML标记的正则表达式：&lt;(\\S*?)[^&gt;]*&gt;.*?|&lt;.*? /&gt;( 首尾空白字符的正则表达式：^\\s*|\\s*$或(^\\s*)|(\\s*$)(可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式) 腾讯QQ号：[1-9][0-9]{4,} (腾讯QQ号从10000开始) 中国邮政编码：[1-9]\\d{5}(?!\\d) (中国邮政编码为6位数字) IP地址：((?:(?:25[0-5]|2[0-4]\\\\d|[01]?\\\\d?\\\\d)\\\\.){3}(?:25[0-5]|2[0-4]\\\\d|[01]?\\\\d?\\\\d))","tags":[{"name":"前端","slug":"前端","permalink":"http://11wy11.github.io/tags/前端/"},{"name":"日常","slug":"日常","permalink":"http://11wy11.github.io/tags/日常/"}]},{"title":"AI组件开发（十）--中文乱码问题解决方案","date":"2019-04-19T13:51:01.000Z","path":"2019/04/19/ai-chinese-note/","text":"","tags":[{"name":"AI","slug":"AI","permalink":"http://11wy11.github.io/tags/AI/"}]},{"title":"AI组件开发（九）--AIDocumentListSuite","date":"2019-04-19T12:41:28.000Z","path":"2019/04/19/ai-nine-documentlist-note/","text":"DocumentListSuite创建文档 使用场景，通常我们写的插件在创建图层或者绘制时，需要判断当前时候存在文档且文档是否处于激活状态，没有这需要创建然后进行之后的操作 AIDocumentListSuite中的New方法能够很好的满足我们的需要。 1234567//判断当前是否有文档 AIDocumentHandle currentDocument; ai::int32 count=0; sAIDocumentList-&gt;Count(&amp;count); if (count == 0)&#123; sAIDocumentList-&gt;New(ai::UnicodeString(&quot;&quot;), NULL, kDialogNone, &amp;currentDocument); &#125; 使用默认设置创建1sAIDocumentList-&gt;New(ai::UnicodeString(&quot;&quot;), NULL, kDialogOff, &amp;currentDocument); 自定义文档属性创建这里比较坑，根据官网api文档，如果文档参数不为空时，必须完整的定义NewDocumentPreset实现如下所示1234567891011121314AINewDocumentPreset newDocumentPreset; newDocumentPreset.docTitle = ai::UnicodeString(L&quot;新建文档&quot;); newDocumentPreset.docWidth = 500; newDocumentPreset.docHeight = 250; newDocumentPreset.docNumArtboards = 1; newDocumentPreset.docArtboardLayout = kAIArtboardLayoutCol; newDocumentPreset.docArtboardSpacing = 1; newDocumentPreset.docArtboardRowsOrCols = 1; newDocumentPreset.docColorMode = kAICMYKColorModel; newDocumentPreset.docUnits = kMillimetersUnits; newDocumentPreset.docPreviewMode = kAIPreviewModeDefault; newDocumentPreset.docTransparencyGrid = kAITransparencyGridNone; newDocumentPreset.docRasterResolution = kAIRasterResolutionHigh; sAIDocumentList-&gt;New(ai::UnicodeString(L&quot;新建文档&quot;) , &amp;newDocumentPreset, kDialogOff, &amp;currentDocument);","tags":[{"name":"AI","slug":"AI","permalink":"http://11wy11.github.io/tags/AI/"}]},{"title":"C#打包更新设置","date":"2019-04-19T10:47:20.000Z","path":"2019/04/19/cplusplus-release-update-note/","text":"C#打包更新设置我的是Setup1.的General Information文件，如我左边圈住的有三个重要的项，如下图。 Product Version：你本次产品的版本号，每次发布新产品，这个的Version号，要增加一下。我上次的版本是1.02，所以这次我设置为1.03. Product Code：这就是一个guid，相当于产品的唯一识别码，每一次发布新版本，需要变更，可点击该行右边的{…}按钮进行随机分配。 Upgrade Code：这个是产品的升级码，同一个产品共用一个升级码，这里要保持不变。就像所有的vs2010都用的同一个Upgrade Code，每此vs2010有update，它只是改的Product Code。 测试无效，仍在探索新方法","tags":[{"name":"C#","slug":"C","permalink":"http://11wy11.github.io/tags/C/"}]},{"title":"微信小程序初探(一)","date":"2019-04-16T12:47:24.000Z","path":"2019/04/16/wx-mini-application-first-note/","text":"按钮绑定事件传参数使用自定义属性，然后获取 列表嵌套或指定子项设置属性值对于json数组中的某个属性赋值微信小程序云开发第一步 在使用开发者工具创建一个新的小程序并勾选小程序-云开发，会生成一个小程序云开发的QuickStart的小程序应用 按照官方提示要将cloudfunctions下的login 创建并部署到云端，然后才能获取到用户的Openid 刚开始尝试发现，不管是点击创建并部署云端安装依赖，还是创建并部署所有文件，点击页面中获得用户id的按钮还是会报 errcode -404011，-504002的错误，提示你云函数没有部署成功 【解决方案】 在开发者工具中点击云开发，在云函数中创建同名函数，在右键login部署后，发现功能可以正常使用了 需要用到的帮助文档 云开发Server API文档 https://developers.weixin.qq.com/miniprogram/dev/wxcloud/reference-server-api/ 云开发指引文档 https://developers.weixin.qq.com/miniprogram/dev/wxcloud/basis/getting-started.html 服务端接口文档 https://developers.weixin.qq.com/miniprogram/dev/api-backend/ 小程序API文档 https://developers.weixin.qq.com/miniprogram/dev/api/ 小程序组件文档 https://developers.weixin.qq.com/miniprogram/dev/component/ 小程序基础指南 https://developers.weixin.qq.com/miniprogram/dev/","tags":[{"name":"微信小程序","slug":"微信小程序","permalink":"http://11wy11.github.io/tags/微信小程序/"}]},{"title":"mysql安装步骤（备忘）","date":"2019-04-15T07:24:52.000Z","path":"2019/04/15/mysql-install-note/","text":"使用archive 解压版安装 下载安装包 在window安装MySQL,MySQL下载在页面最下方找到ZIP Archive 安装包截图 将文件解压到你想安装的位置 在解压文件夹I:\\Program Files\\mysql-8.0.15-winx64下，创建my.ini,配置以下信息 1234567891011121314151617[mysql]# 设置mysql客户端默认字符集default-character-set=utf8 [mysqld]# 设置3306端口port = 3306# 设置mysql的安装目录basedir=I:\\\\Program Files\\\\mysql-8.0.15-winx64# 设置 mysql数据库的数据的存放目录，MySQL 8+ 不需要以下配置，系统自己生成即可，否则有可能报错# datadir=C:\\\\web\\\\sqldata# 允许最大连接数max_connections=20# 服务端使用的字符集默认为8比特编码的latin1字符集character-set-server=utf8# 创建新表时将使用的默认存储引擎default-storage-engine=INNODB 以管理员身份打开 cmd 命令行工具，切换目录：初始化数据库： 123&gt;&gt;i:I:&gt;&gt;cd I:\\Program Files\\mysql-8.0.15-winx64\\binI:\\Program Files\\mysql-8.0.15-winx64\\bin&gt;&gt; mysqld --initialize --console 执行完成后，会输出 root 用户的初始默认密码，如：bl&amp;;bUgwl9WM就是初始密码，后续登录需要用到，你也可以在登陆后修改密码。 输入以下安装命令： 1mysqld install 启动输入以下命令即可： 1net start mysql 登录MySQL 当 MySQL 服务已经运行时, 我们可以通过 MySQL 自带的客户端工具登录到 MySQL 数据库中, 首先打开命令提示符, 输入以下格式的命名: 1mysql -h 主机名 -u 用户名 -p 参数说明： -h : 指定客户端所要登录的 MySQL 主机名, 登录本机(localhost 或 127.0.0.1)该参数可以省略; -u : 登录的用户名; -p : 告诉服务器将会使用一个密码来登录, 如果所要登录的用户名密码为空, 可以忽略此选项。 若密码存在, 输入密码登录, 不存在则直接按回车登录。登录成功后你将会看到 Welecome to the MySQL monitor… 的提示语。 然后命令提示符会一直以 mysq&gt; 加一个闪烁的光标等待命令的输入, 输入 exit 或 quit 退出登录。 修改默认密码 进入数据库后，执行 1update user set password=password(&quot;新密码&quot;) where user=&quot;root&quot; 设置环境变量更方便的启动和停止等 右键我的电脑-&gt;属性-&gt;高级系统设置-&gt;环境变量-&gt;path-&gt;编辑，将你的mysql软件下的bin目录的全路径放里面。 最后在那个目录的路径后面加个英文的分号（;）保存就行了。如D:\\mysql\\mysql-x.x.xx-winx64\\bin; 其他常用命令 12345show databases;//查看数据库use 数据库名;//切换数据库目录show tables;//查看表select * from 表名;//sql查询exit 退出 常见问题及解决方案 navicat连接mysql8后报1251的错误【解决方案1】：原因：在网上查的是,出现这个原因是mysql8 之前的版本中加密规则是mysql_native_password,而在mysql8之后,加密规则是caching_sha2_password,解决问题方法有两种,一种是升级navicat驱动,一种是把mysql用户登录密码加密规则还原成mysql_native_password.第二种：ALTER USER ‘root‘@’localhost’ IDENTIFIED BY ‘password’ PASSWORD EXPIRE NEVER; #修改加密规则ALTER USER ‘root‘@’localhost’ IDENTIFIED WITH mysql_native_password BY ‘password’; #更新一下用户的密码FLUSH PRIVILEGES; #刷新权限","tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://11wy11.github.io/tags/MySQL/"}]},{"title":"C# 使用NLog显示和输出日志","date":"2019-04-10T03:15:48.000Z","path":"2019/04/10/cplusplus-log-note/","text":"使用NLog插件显示和输出日志，记录用户使用情况等1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859 public static Logger logger;private void initLogger() &#123; // Step 1. Create configuration object LoggingConfiguration logConfig = new LoggingConfiguration(); // Step 2. Create targets and add them to the configuration RichTextBoxTarget rtbTarget = new RichTextBoxTarget(); logConfig.AddTarget(&quot;richTextBox&quot;, rtbTarget); rtbTarget.FormName = &quot;MainForm&quot;; // your winform class name rtbTarget.ControlName = &quot;richTextBox1&quot;; // your RichTextBox control/variable name //rtbTarget.UseDefaultRowColoringRules = false; rtbTarget.RowColoringRules.Add( new RichTextBoxRowColoringRule( &quot;level == LogLevel.Error&quot;, //condition &quot;DarkRed&quot;, // font color &quot;Control&quot;, //backgroud color FontStyle.Bold ) ); rtbTarget.RowColoringRules.Add( new RichTextBoxRowColoringRule( &quot;level == LogLevel.Warn&quot;, //condition &quot;Navy&quot;, // font color &quot;Control&quot;, //backgroud color FontStyle.Bold ) ); FileTarget fileTarget = new FileTarget(); logConfig.AddTarget(&quot;logFile&quot;, fileTarget); // Step 3. Set target properties //string commonLayout = &quot;$&#123;date:format=MM-dd HH\\\\:mm\\\\:ss&#125; $&#123;logger&#125; $&#123;message&#125;&quot;; string commonLayout = &quot;$&#123;date:format=HH\\\\:mm&#125; $&#123;logger&#125; $&#123;message&#125;&quot;; rtbTarget.Layout = commonLayout; //string curDatetimeStr = DateTime.Now.ToString(); DateTime curDateTime = DateTime.Now; string curDatetimeStr = String.Format(&quot;&#123;0:yyyy-MM-dd_HHmmss&#125;&quot;, curDateTime); //&quot;2013-06-11_142102&quot; fileTarget.FileName = &quot;$&#123;basedir&#125;/logfile/&quot; + curDatetimeStr + &quot;_log.txt&quot;; //&#123;&apos;$&#123;basedir&#125;/2013-06-11_142102_log.txt&apos;&#125; fileTarget.Layout = commonLayout; // Step 4. Define rules LoggingRule ruleRichTextBox = new LoggingRule(&quot;*&quot;, LogLevel.Debug, rtbTarget); logConfig.LoggingRules.Add(ruleRichTextBox); LoggingRule ruleFile = new LoggingRule(&quot;*&quot;, LogLevel.Debug, fileTarget); logConfig.LoggingRules.Add(ruleFile); // Step 5. Activate the configuration LogManager.Configuration = logConfig; // Example usage logger = LogManager.GetLogger(&quot;&quot;); &#125;//使用 logger.Info(&quot;Info:开始进行文件夹目录结构检查&quot;); logger.Error(&quot;XXXXXXX&quot;);","tags":[{"name":"C#","slug":"C","permalink":"http://11wy11.github.io/tags/C/"}]},{"title":"C#读取txt和xml文件等","date":"2019-04-10T03:05:59.000Z","path":"2019/04/10/cplusplus-txt-xml-read-note/","text":"读取txt和xml等，生成Dictionary等 TXT文件读取pac文件格式：11000,XX省11100,XX市11101,XXXX区11102,XXXX1区 12345678910111213public static Dictionary&lt;string, string&gt; countyPacMap = new Dictionary&lt;string, string&gt;();//存储区域PAC码对应信息 FileStream file = new FileStream(&quot;Config/PAC.txt&quot;, FileMode.OpenOrCreate); StreamReader reader = new StreamReader(file, UnicodeEncoding.GetEncoding(&quot;UTF-8&quot;)); string strLine = string.Empty; while ((strLine = reader.ReadLine()) != null) &#123; strLine = strLine.Trim().ToString(); string[] nameAndCode = strLine.Split(&apos;,&apos;); string name = nameAndCode[1]; string pac = nameAndCode[0]; countyPacMap.Add(name, pac); &#125; file.Close(); XML读取XML格式：1234567&lt;Directory Name=&quot;XX&quot; &gt; &lt;Directory Name=&quot;1-采样数据&quot; &gt; &lt;File DestinationDirectory=&quot;1-采样数据&quot; isCheckAttribute=&quot;true&quot; type=&quot;1&quot; sheetNum=&quot;1&quot; &gt;XXX.txt&lt;/File&gt; &lt;File DestinationDirectory=&quot;1-采样数据&quot;&gt;2-登记表.pdf&lt;/File&gt; &lt;File DestinationDirectory=&quot;1-采样数据&quot;&gt;3-送样单.pdf&lt;/File&gt; &lt;/Directory&gt;&lt;/Directory&gt; 读取XML123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475 public static List&lt;FieldModel&gt; getFieldsFromXml(String xmlName, int index) &#123; string m_strConfig = &quot;Tables/&quot;; List&lt;FieldModel&gt; result = new List&lt;FieldModel&gt;(); XmlDocument doc = new XmlDocument(); doc.Load(m_strConfig + xmlName + &quot;.xml&quot;); XmlNode root = doc.SelectSingleNode(&quot;Table&quot;); XmlNode sheet = root.ChildNodes[index]; // 得到根节点的所有子节点 XmlNodeList xnl = sheet.ChildNodes; foreach (XmlNode xn in xnl) &#123; FieldModel fieldModel = new FieldModel(); // 将节点转换为元素，便于得到节点的属性值 XmlElement xe = (XmlElement)xn; fieldModel.FieldName = xe.GetAttribute(&quot;Name&quot;).ToString(); fieldModel.FieldType = xe.GetAttribute(&quot;Type&quot;).ToString(); fieldModel.RuleType = xe.GetAttribute(&quot;RuleType&quot;).ToString(); fieldModel.RuleParms = xe.GetAttribute(&quot;RuleParms&quot;).ToString(); result.Add(fieldModel); &#125; return result; &#125; public static string[] getFieldCNames(ArrayList array) &#123; int nums = array.Count; string[] names = new string[nums]; for (int i = 0; i &lt; nums; i++) &#123; FieldModel fieldModel = (FieldModel)array[i]; names[i] = fieldModel.FieldName; &#125; return names; &#125;//FieldModel类class FieldModel &#123; public FieldModel() &#123; &#125; private string fieldName; public string FieldName &#123; get &#123; return fieldName; &#125; set &#123; fieldName = value; &#125; &#125; private string ruleType; public string RuleType &#123; get &#123; return ruleType; &#125; set &#123; ruleType = value; &#125; &#125; private string fieldType; public string FieldType &#123; get &#123; return fieldType; &#125; set &#123; fieldType = value; &#125; &#125; private string ruleParms; public string RuleParms &#123; get &#123; return ruleParms; &#125; set &#123; ruleParms = value; &#125; &#125; &#125;","tags":[{"name":"C#","slug":"C","permalink":"http://11wy11.github.io/tags/C/"}]},{"title":"C#读取，生成Excel","date":"2019-04-10T02:58:28.000Z","path":"2019/04/10/cplusplus-excel-note/","text":"使用NPOI开源插件读取和操作Excel等 ExcelUtils123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215using GDZLCHECK.Forms;using NPOI.HSSF.UserModel;using NPOI.SS.UserModel;using NPOI.SS.Util;using NPOI.XSSF.UserModel;using System;using System.Collections.Generic;using System.Data;using System.IO;using System.Linq;using System.Text;using System.Threading.Tasks;using System.Windows.Forms;namespace GDZLCHECK.Utils&#123; class ExcelUtils &#123; public static IWorkbook GetWorkbook(string filePath) &#123; IWorkbook workbook; string fileType = System.IO.Path.GetExtension(filePath); if (string.IsNullOrEmpty(fileType)) return null; try &#123; using (FileStream file = new FileStream(filePath, FileMode.Open, FileAccess.Read)) &#123; if (fileType == &quot;.xls&quot;) &#123; workbook = new HSSFWorkbook(file) as IWorkbook; &#125; else if (fileType == &quot;.xlsx&quot;) &#123; workbook = new XSSFWorkbook(file); &#125; else &#123; return null; &#125; file.Close(); return workbook; &#125; &#125; catch (Exception ex) &#123; MessageBox.Show(&quot;打开excel失败，文件可能正被打开&quot;); Console.WriteLine( ex.Message.ToString()); // MainForm.logger.Error(&quot;Error: 打开&quot;+filePath+&quot; excel失败，文件可能正被打开&quot;); return null; &#125; &#125; /// &lt;summary&gt; /// 判断指定行列所在的单元格是否为合并单元格， /// &lt;/summary&gt; /// &lt;param name=&quot;sheet&quot;&gt;Excel工作表&lt;/param&gt; /// &lt;param name=&quot;rowIndex&quot;&gt;行索引，从0开始&lt;/param&gt; /// &lt;param name=&quot;columnIndex&quot;&gt;列索引，从0开始&lt;/param&gt; /// &lt;returns&gt;返回是否为合并单元格的布尔(Boolean)值&lt;/returns&gt; public static bool IsMergeCell(ISheet sheet, int rowIndex, int columnIndex) &#123; for (int i = 0; i &lt; sheet.NumMergedRegions; i++) &#123; CellRangeAddress range = sheet.GetMergedRegion(i); sheet.IsMergedRegion(range); //这种算法只有当指定行列索引刚好是合并单元格的第一个跨度行第一个跨度列时才能取得合并单元格的跨度 //if (range.FirstRow == rowIndex &amp;&amp; range.FirstColumn == columnIndex) //&#123; // dimension.DataCell = sheet.GetRow(range.FirstRow).GetCell(range.FirstColumn); // dimension.RowSpan = range.LastRow - range.FirstRow + 1; // dimension.ColumnSpan = range.LastColumn - range.FirstColumn + 1; // dimension.FirstRowIndex = range.FirstRow; // dimension.LastRowIndex = range.LastRow; // dimension.FirstColumnIndex = range.FirstColumn; // dimension.LastColumnIndex = range.LastColumn; // break; //&#125; if ((rowIndex &gt;= range.FirstRow &amp;&amp; range.LastRow &gt;= rowIndex) &amp;&amp; (columnIndex &gt;= range.FirstColumn &amp;&amp; range.LastColumn &gt;= columnIndex)) &#123; break; &#125; &#125; bool result; if (rowIndex &gt;= 0 &amp;&amp; sheet.LastRowNum &gt; rowIndex) &#123; IRow row = sheet.GetRow(rowIndex); if (columnIndex &gt;= 0 &amp;&amp; row.LastCellNum &gt; columnIndex) &#123; ICell cell = row.GetCell(columnIndex); result = cell.IsMergedCell; &#125; else &#123; result = false; &#125; &#125; else &#123; result = false; &#125; return result; &#125; public static object GetCellValue(ICell cell) &#123; object value = &quot;&quot;; try &#123; if (cell.CellType != CellType.Blank) &#123; switch (cell.CellType) &#123; case CellType.Numeric: // Date comes here if (DateUtil.IsCellDateFormatted(cell)) &#123; value = cell.DateCellValue; &#125; else &#123; // Numeric type value = cell.NumericCellValue; &#125; break; case CellType.Boolean: // Boolean type value = cell.BooleanCellValue; break; case CellType.Formula: value = cell.CellFormula; break; default: // String type value = cell.StringCellValue; break; &#125; &#125; &#125; catch (Exception) &#123; value = &quot;&quot;; &#125; return value; &#125; //判断是否为空 public static bool isEmptyRow(ICell cell) &#123; if (cell == null) return true; else &#123; if (cell.CellType == CellType.Blank || string.IsNullOrEmpty(cell.ToString().Trim())) return true; else return false; &#125; &#125; public static DataTable ExportToDataTable(ISheet sheet) &#123; DataTable dt = new DataTable(); //默认，第一行是字段 IRow headRow = sheet.GetRow(0); //设置datatable字段 for (int i = headRow.FirstCellNum, len = headRow.LastCellNum; i &lt; len; i++) &#123; dt.Columns.Add(headRow.Cells[i].StringCellValue); &#125; //遍历数据行 for (int i = (sheet.FirstRowNum + 1), len = sheet.LastRowNum + 1; i &lt; len; i++) &#123; IRow tempRow = sheet.GetRow(i); DataRow dataRow = dt.NewRow(); //遍历一行的每一个单元格 for (int r = 0, j = tempRow.FirstCellNum, len2 = tempRow.LastCellNum; j &lt; len2; j++, r++) &#123; ICell cell = tempRow.GetCell(j); if (cell != null) &#123; switch (cell.CellType) &#123; case CellType.String: dataRow[r] = cell.StringCellValue; break; case CellType.Numeric: dataRow[r] = cell.NumericCellValue; break; case CellType.Boolean: dataRow[r] = cell.BooleanCellValue; break; default: dataRow[r] = &quot;&quot;; break; &#125; &#125; &#125; dt.Rows.Add(dataRow); &#125; return dt; &#125; &#125;&#125;","tags":[{"name":"C#","slug":"C","permalink":"http://11wy11.github.io/tags/C/"}]},{"title":"C#winform程序全局异常处理","date":"2019-04-10T02:39:18.000Z","path":"2019/04/10/cplusplus-exception-note/","text":"全局处理未处理异常 program.cs入口1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162using GDZLCHECK.Forms;using NLog;using System;using System.Collections.Generic;using System.Linq;using System.Threading.Tasks;using System.Windows.Forms;namespace GDZLCHECK&#123; static class Program &#123; /// &lt;summary&gt; /// 应用程序的主入口点。 /// &lt;/summary&gt; [STAThread] static void Main() &#123; try &#123; Application.EnableVisualStyles(); Application.SetCompatibleTextRenderingDefault(false); //处理未捕获的异常 Application.SetUnhandledExceptionMode(UnhandledExceptionMode.CatchException); //处理UI线程异常 Application.ThreadException += new System.Threading.ThreadExceptionEventHandler(Application_ThreadException); //处理非UI线程异常 AppDomain.CurrentDomain.UnhandledException += new UnhandledExceptionEventHandler(CurrentDomain_UnhandledException); ESRI.ArcGIS.RuntimeManager.Bind(ESRI.ArcGIS.ProductCode.EngineOrDesktop); Application.EnableVisualStyles(); Application.SetCompatibleTextRenderingDefault(false); Application.Run(new MainForm()); glExitApp = true; &#125; catch (Exception e) &#123; MessageBox.Show(&quot;请确保安装有ArcGIS和Office,且ArcGIS License已启动&quot;); Application.Exit(); &#125; &#125; static bool glExitApp = false; static void CurrentDomain_UnhandledException(object sender, UnhandledExceptionEventArgs e) &#123; MessageBox.Show(&quot;抱歉，您的操作没有能够完成，请再试一次或者联系软件提供商&quot;); Logger logger = LogManager.GetCurrentClassLogger(); logger.Error(&quot;CurrentDomain_UnhandledException&quot;); logger.Error(&quot;IsTerminating:&quot; + e.IsTerminating.ToString()); logger.Error(e.ExceptionObject.ToString()); &#125; static void Application_ThreadException(object sender, System.Threading.ThreadExceptionEventArgs e) &#123; MessageBox.Show(&quot;抱歉，您的操作没有能够完成，请再试一次或者联系软件提供商&quot;); Logger logger = LogManager.GetCurrentClassLogger(); logger.Error(&quot;Application_ThreadException:&quot;+e.Exception.Message); logger.Error(e.Exception); //throw new NotImplementedException(); &#125; &#125;&#125;","tags":[{"name":"C#","slug":"C","permalink":"http://11wy11.github.io/tags/C/"}]},{"title":"C#读取word模板填充数据生成带水印的pdf","date":"2019-04-10T01:32:08.000Z","path":"2019/04/10/cplusplus-wordtemplete-note/","text":"使用Microsoft Office 的COM组件,方便快捷，较好的复用和使用模板快速生成较复杂的文档不足在于对于环境依赖较高 Word相关处理类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251using System;using System.Collections.Generic;using System.ComponentModel;using System.Data;using System.Drawing;using System.Linq;using System.Text;using Microsoft.Office.Interop.Word;using System.Windows.Forms;using System.Threading;namespace GDZLCHECK.Utils&#123; class CreateWord &#123; private _Application wordApp= null; private _Document wordDoc= null; public _Application Application &#123; get &#123; return wordApp; &#125; set &#123; wordApp = value; &#125; &#125; public _Document Document &#123; get &#123; return wordDoc; &#125; set &#123; wordDoc = value; &#125; &#125; //保存新文件 public void SaveDocument(string filePath) &#123; // killWinWordProcess(); object oMissing = System.Reflection.Missing.Value; //SaveFileDialog sfd = new SaveFileDialog(); //sfd.Filter = &quot;Word Document(*.doc)|*.doc|PDF(*.pdf)|*.pdf&quot;; //sfd.DefaultExt = &quot;Word Document(*.doc)|*.doc&quot;; //if (sfd.ShowDialog() == DialogResult.OK) //&#123; //object filename = sfd.FileName; object filename = filePath; wordDoc.SaveAs(ref filename, ref oMissing, ref oMissing, ref oMissing, ref oMissing, ref oMissing, ref oMissing, ref oMissing, ref oMissing, ref oMissing, ref oMissing, ref oMissing, ref oMissing, ref oMissing, ref oMissing, ref oMissing); wordDoc.Close(ref oMissing, ref oMissing, ref oMissing); //关闭word wordApp.Quit(ref oMissing, ref oMissing, ref oMissing); //&#125; &#125; //在书签处插入值 public bool InsertValue(string bookmark, string value) &#123; object bkObj =bookmark; if(wordApp.ActiveDocument.Bookmarks.Exists(bookmark)) &#123; wordApp.ActiveDocument.Bookmarks.get_Item(ref bkObj).Select(); wordApp.Selection.TypeText(value); return true; &#125; return false; &#125; //插入表格,bookmark书签 public Table InsertTable(string bookmark, int rows, int columns,float width) &#123; object miss =System.Reflection.Missing.Value; object oStart =bookmark; Range range =wordDoc.Bookmarks.get_Item(ref oStart).Range;//表格插入位置 Table newTable =wordDoc.Tables.Add(range,rows, columns, ref miss, ref miss); //设置表的格式 newTable.Borders.Enable =1; //允许有边框，默认没有边框(为0时报错，1为实线边框，2、3为虚线边框，以后的数字没试过) newTable.Borders.OutsideLineWidth=WdLineWidth.wdLineWidth050pt;//边框宽度 if(width != 0) &#123; newTable.PreferredWidth=width;//表格宽度 &#125; newTable.AllowPageBreaks =false; return newTable; &#125; // 合并单元格 表id,开始行号,开始列号,结束行号,结束列号 public void MergeCell(int n, int row1, int column1, int row2, int column2) &#123; wordDoc.Content.Tables[n].Cell(row1, column1).Merge(wordDoc.Content.Tables[n].Cell(row2, column2)); &#125; // 合并单元格 表名,开始行号,开始列号,结束行号,结束列号 public void MergeCell(Microsoft.Office.Interop.Word.Table table, int row1, int column1, int row2, int column2) &#123; table.Cell(row1, column1).Merge(table.Cell(row2, column2)); &#125; // 设置表格内容对齐方式 Align水平方向，Vertical垂直方向(左对齐，居中对齐，右对齐分别对应Align和Vertical的值为-1,0,1)Microsoft.Office.Interop.Word.Table table public void SetParagraph_Table(int n, int Align, int Vertical) &#123; switch (Align) &#123; case -1: wordDoc.Content.Tables[n].Range.ParagraphFormat.Alignment = WdParagraphAlignment.wdAlignParagraphLeft; break;//左对齐 case 0: wordDoc.Content.Tables[n].Range.ParagraphFormat.Alignment = WdParagraphAlignment.wdAlignParagraphCenter; break;//水平居中 case 1: wordDoc.Content.Tables[n].Range.ParagraphFormat.Alignment = WdParagraphAlignment.wdAlignParagraphRight; break;//右对齐 &#125; switch (Vertical) &#123; case -1: wordDoc.Content.Tables[n].Range.Cells.VerticalAlignment = WdCellVerticalAlignment.wdCellAlignVerticalTop; break;//顶端对齐 case 0: wordDoc.Content.Tables[n].Range.Cells.VerticalAlignment = WdCellVerticalAlignment.wdCellAlignVerticalCenter; break;//垂直居中 case 1: wordDoc.Content.Tables[n].Range.Cells.VerticalAlignment = WdCellVerticalAlignment.wdCellAlignVerticalBottom; break;//底端对齐 &#125; &#125; // 设置单元格内容对齐方式 public void SetParagraph_Table(int n, int row, int column, int Align, int Vertical) &#123; switch (Align) &#123; case -1: wordDoc.Content.Tables[n].Cell(row, column).Range.ParagraphFormat.Alignment = WdParagraphAlignment.wdAlignParagraphLeft; break;//左对齐 case 0: wordDoc.Content.Tables[n].Cell(row, column).Range.ParagraphFormat.Alignment = WdParagraphAlignment.wdAlignParagraphCenter; break;//水平居中 case 1: wordDoc.Content.Tables[n].Cell(row, column).Range.ParagraphFormat.Alignment = WdParagraphAlignment.wdAlignParagraphRight; break;//右对齐 &#125; switch (Vertical) &#123; case -1: wordDoc.Content.Tables[n].Cell(row, column).Range.Cells.VerticalAlignment = WdCellVerticalAlignment.wdCellAlignVerticalTop; break;//顶端对齐 case 0: wordDoc.Content.Tables[n].Cell(row, column).Range.Cells.VerticalAlignment = WdCellVerticalAlignment.wdCellAlignVerticalCenter; break;//垂直居中 case 1: wordDoc.Content.Tables[n].Cell(row, column).Range.Cells.VerticalAlignment = WdCellVerticalAlignment.wdCellAlignVerticalBottom; break;//底端对齐 &#125; &#125; // 设置表格字体 public void SetFont_Table(Microsoft.Office.Interop.Word.Table table, string fontName, double size) &#123; if (size != 0) &#123; table.Range.Font.Size = Convert.ToSingle(size); &#125; if (fontName != &quot;&quot;) &#123; table.Range.Font.Name = fontName; &#125; &#125; // 设置单元格字体 public void SetFont_Table(int n, int row, int column, string fontName, double size, int bold) &#123; if (size != 0) &#123; wordDoc.Content.Tables[n].Cell(row, column).Range.Font.Size = Convert.ToSingle(size); &#125; if (fontName != &quot;&quot;) &#123; wordDoc.Content.Tables[n].Cell(row, column).Range.Font.Name = fontName; &#125; wordDoc.Content.Tables[n].Cell(row, column).Range.Font.Bold = bold;// 0 表示不是粗体，其他值都是 &#125; // 是否使用边框,n表格的序号,use是或否 // 该处边框参数可以用int代替bool可以让方法更全面 // 具体值方法中介绍 public void UseBorder(int n, bool use) &#123; if (use) &#123; wordDoc.Content.Tables[n].Borders.Enable = 1; //允许有边框，默认没有边框(为0时无边框，1为实线边框，2、3为虚线边框，以后的数字没试过) &#125; else &#123; wordDoc.Content.Tables[n].Borders.Enable = 0; &#125; &#125; // 给表格插入一行,n表格的序号从1开始记 public void AddRow(int n) &#123; object miss = System.Reflection.Missing.Value; wordDoc.Content.Tables[n].Rows.Add(ref miss); &#125; // 给表格添加一行 public void AddRow(Microsoft.Office.Interop.Word.Table table) &#123; object miss = System.Reflection.Missing.Value; table.Rows.Add(ref miss); &#125; // 给表格插入rows行,n为表格的序号 public void AddRow(int n, int rows) &#123; object miss = System.Reflection.Missing.Value; Microsoft.Office.Interop.Word.Table table = wordDoc.Content.Tables[n]; for (int i = 0; i &lt; rows; i++) &#123; table.Rows.Add(ref miss); &#125; &#125; // 删除表格第rows行,n为表格的序号 public void DeleteRow(int n, int row) &#123; Microsoft.Office.Interop.Word.Table table = wordDoc.Content.Tables[n]; table.Rows[row].Delete(); &#125; // 给表格中单元格插入元素，table所在表格，row行号，column列号，value插入的元素 public void InsertCell(Microsoft.Office.Interop.Word.Table table, int row, int column, string value) &#123; table.Cell(row, column).Range.Text = value; &#125; // 给表格中单元格插入元素，n表格的序号从1开始记，row行号，column列号，value插入的元素 public void InsertCell(int n, int row, int column, string value) &#123; wordDoc.Content.Tables[n].Cell(row, column).Range.Text = value; &#125; // 给表格插入一行数据，n为表格的序号，row行号，columns列数，values插入的值 public void InsertCell(int n, int row, int columns, string[] values) &#123; Microsoft.Office.Interop.Word.Table table = wordDoc.Content.Tables[n]; for (int i = 0; i &lt; columns; i++) &#123; table.Cell(row, i + 1).Range.Text = values[i]; &#125; &#125; //杀掉winword.exe进程 public void killWinWordProcess() &#123; System.Diagnostics.Process[] processes = System.Diagnostics.Process.GetProcessesByName(&quot;WINWORD&quot;); foreach (System.Diagnostics.Process process in processes) &#123; bool b = process.MainWindowTitle==&quot;&quot;; if (process.MainWindowTitle ==&quot;&quot;) &#123; process.Kill(); &#125; &#125; &#125; &#125;&#125; Word转pdf123456789101112131415161718192021222324252627282930313233343536373839using System;using System.Collections.Generic;using System.Linq;using System.Text;using Microsoft.Office.Interop.Word;using System.IO;namespace GDZLCHECK&#123; class WordToPdfUtil &#123; public static bool wordToPdf(String sourcePath) &#123; bool result = false; _Application application = new Application(); _Document document = null; try &#123; application.Visible = false; document = application.Documents.Open(sourcePath); string PDFPath = sourcePath.Replace(&quot;.doc&quot;, &quot;.pdf&quot;);//pdf存放位置 if (!File.Exists(@PDFPath))//存在PDF，不需要继续转换 &#123; document.ExportAsFixedFormat(PDFPath, Microsoft.Office.Interop.Word.WdExportFormat.wdExportFormatPDF); &#125; result = true; &#125; catch (Exception e) &#123; Console.WriteLine(e.Message); result = false; &#125; finally &#123; document.Close(); &#125; return result; &#125; &#125;&#125; pdf加水印123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263using iTextSharp.text;using iTextSharp.text.pdf;using System;using System.Collections.Generic;using System.Data;using System.IO;using System.Linq;using System.Text;using System.Threading.Tasks;using System.Windows.Forms; public static void setWatermark(string filePath, string outputfilepath, string waterMarkName, string waterMarkAddr) &#123; PdfReader pdfReader = null; PdfStamper pdfStamper = null; try &#123; pdfReader = new PdfReader(filePath); pdfStamper = new PdfStamper(pdfReader, new FileStream(outputfilepath, FileMode.Create)); //设置权限为只读 pdfStamper.SetEncryption(PdfWriter.STRENGTH128BITS, null, null, PdfWriter.ALLOW_SCREENREADERS | PdfWriter.AllowPrinting); int total = pdfReader.NumberOfPages+1;//获取PDF的总页数 iTextSharp.text.Rectangle psize = pdfReader.GetPageSize(1);//获取第一页 float width = psize.Width;//PDF页面的宽度，用于计算水印倾斜 float height = psize.Height; PdfContentByte waterContent; BaseFont basefont = BaseFont.CreateFont(@&quot;C:\\WINDOWS\\Fonts\\SIMFANG.TTF&quot;, BaseFont.IDENTITY_H, BaseFont.EMBEDDED); PdfGState gs = new PdfGState(); //i从2开始，因为不给封面添加水印 for (int i = 2; i &lt; total; i++) &#123; waterContent = pdfStamper.GetOverContent(i);//在内容上方加水印 //透明度 waterContent.SetGState(gs); //开始写入文本 waterContent.BeginText(); waterContent.SetColorFill(BaseColor.RED); waterContent.SetFontAndSize(basefont, 30); waterContent.SetTextMatrix(0, 0); if (waterMarkAddr == null || waterMarkAddr == &quot;&quot;) &#123; waterContent.ShowTextAligned(Element.ALIGN_CENTER, waterMarkName, width / 2, height / 2, 55); &#125; else &#123; waterContent.ShowTextAligned(Element.ALIGN_CENTER, waterMarkName, width / 2, height / 2 + 100, 55); waterContent.ShowTextAligned(Element.ALIGN_CENTER, waterMarkAddr, width / 2, height / 2 - 100, 55); &#125; waterContent.EndText(); &#125; &#125; catch (Exception e) &#123; Console.WriteLine(e.ToString()); &#125; finally &#123; if (pdfStamper != null) pdfStamper.Close(); if (pdfReader != null) pdfReader.Close(); &#125; &#125; 主函数调用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121if (this.tbManagerName.Text.ToString() == &quot;&quot; || this.tbContact.Text.ToString() == &quot;&quot; || this.tbUnit.Text.ToString() == &quot;&quot;) &#123; MessageBox.Show(&quot;请输入项目负责人姓名,联系电话,承担单位&quot;); return; &#125; //ConstantInfo.outStatic(); FolderBrowserDialog dialog = new FolderBrowserDialog(); dialog.Description = &quot;请选择检查报告输出位置&quot;; string outputFilePath = &quot;&quot;; if (dialog.ShowDialog() == DialogResult.OK) &#123; outputFilePath = dialog.SelectedPath; string managerName = this.tbManagerName.Text.ToString(); string contactNum = this.tbContact.Text.ToString(); string unitName = this.tbUnit.Text.ToString(); //水印1 //PdfUtils.GeneratePDF(resultDt, strPacName, isPassed, managerName, contactNum, unitName, outputFilePath, 1); //水印2 // PdfUtils.GeneratePDF(resultDt, strPac,isPassed,outputFilePath, 2); //图片水印 // string picPath = string.Format(&quot;&#123;0&#125;/Resource/&#123;1&#125;&quot;, AppDomain.CurrentDomain.BaseDirectory,&quot;logo.png&quot;); //PdfUtils.GeneratePDF(resultDt, strPac,isPassed,outputFilePath, 3,picPath); //读取word模板生成数据，转为PDF，然后添加水印，删除临时文件 this.lbShowProcess.Text = &quot;正在准备统计数据...&quot;; this.pbProgress.Visible = true; statisticNum(); this.pbProgress.Position = 30; this.lbShowProcess.Text = &quot;开始生成检查报告...&quot;; savePdf(outputFilePath, managerName, contactNum, unitName); this.lbShowProcess.Text = &quot;检查报告导出完成&quot;; &#125; //保存pdf private void savePdf(string outputFilePath, string managerName, string contactNum, string unitName) &#123; String[] origin = &#123; &quot;O1&quot;, &quot;O2&quot;, &quot;O3&quot;, &quot;O4&quot;, &quot;O5&quot;, &quot;O6&quot; &#125;;//设计点 //创建一个Word应用程序实例 Microsoft.Office.Interop.Word._Application oWord = new Microsoft.Office.Interop.Word.Application(); //设置为不可见 oWord.Visible = false; //模板文件地址，这里假设在X盘根目录 string templatePath = string.Format(&quot;&#123;0&#125;/Config/&#123;1&#125;&quot;, AppDomain.CurrentDomain.BaseDirectory, &quot;template.dot&quot;); object oTemplate = templatePath; //以模板为基础生成文档 Microsoft.Office.Interop.Word._Document oDoc = oWord.Documents.Add(ref oTemplate, ref oMissing, ref oMissing, ref oMissing); CreateWord c = new CreateWord(); c.Application = oWord; c.Document = oDoc; int total = origin.Length this.pbProgress.Properties.Minimum = 0; this.pbProgress.Properties.Maximum =total+10; this.pbProgress.Properties.Step = 1; int i = 0, j = 0; foreach (String s in origin) &#123; Application.DoEvents(); c.InsertValue(s, Convert.ToString(ConstantInfo.StaticResult[j][i])); this.pbProgress.PerformStep(); i++; &#125; c.InsertValue(&quot;单位&quot;, unitName); c.InsertValue(&quot;负责人&quot;, managerName); c.InsertValue(&quot;电话&quot;, contactNum); c.InsertValue(&quot;日期&quot;, DateTime.Now.ToString(&quot;yyyy-MM-dd HH:mm:ss&quot;)); int rowNum = resultDt.Rows.Count; int colNum = resultDt.Columns.Count; if (rowNum &gt; 0) &#123; //插入结果行 c.AddRow(4, rowNum); //插入值 for (int rowIndex = 0; rowIndex &lt; rowNum; rowIndex++) &#123; Application.DoEvents(); for (int colIndex = 0; colIndex &lt; colNum; colIndex++) &#123; c.InsertCell(4, rowIndex+2, colIndex+1, resultDt.Rows[rowIndex][colIndex].ToString()); &#125; this.pbProgress.PerformStep(); &#125; &#125; string fileName = string.Format(&quot;数据_&#123;0&#125;.doc&quot;, DateTime.Now.ToString(&quot;yyyyMMddHHmmss&quot;)); string filePath = string.Format(&quot;&#123;0&#125;/Resource/&#123;1&#125;&quot;, AppDomain.CurrentDomain.BaseDirectory, fileName); c.SaveDocument(filePath);//此时已经生成word Thread.Sleep(5000); WordToPdfUtil.wordToPdf(filePath);//转为pdf string waterMarkName = &quot;检查:&quot; + (isPassed ? &quot;通过&quot; : &quot;未通过&quot;); string waterMarkAddr = strPacName; string outputFileName = string.Format(this.strPacName+&quot;数据入库预检查报告_&#123;0&#125;.pdf&quot;, DateTime.Now.ToString(&quot;yyyyMMddHHmmss&quot;)); outputFilePath = string.Format(&quot;&#123;0&#125;/&#123;1&#125;&quot;, outputFilePath, outputFileName); if (outputFilePath == null || outputFilePath == &quot;&quot;) &#123; outputFilePath = string.Format(&quot;&#123;0&#125;/Resource/&#123;1&#125;&quot;, AppDomain.CurrentDomain.BaseDirectory, outputFileName); &#125; string pdfPath = filePath.Replace(&quot;.doc&quot;, &quot;.pdf&quot;);//pdf存放位置 setWatermark(pdfPath, outputFilePath, waterMarkName, waterMarkAddr);//先生成水印，再删除临时文件 ,加密在设置水印中实现 //先生成水印，再删除临时文件 if (File.Exists(filePath))//判断临时文件是否存在，如果存在则删除 &#123; File.Delete(filePath); GC.Collect();//回收垃圾 &#125; string PDFPath = filePath.Replace(&quot;.doc&quot;, &quot;.pdf&quot;);//pdf存放位置 if (File.Exists(PDFPath))//判断临时文件是否存在，如果存在则删除 &#123; File.Delete(PDFPath); GC.Collect();//回收垃圾 &#125; Application.DoEvents(); this.pbProgress.Position = total + 10; MessageBox.Show(&quot;保存检查结果成功&quot;); this.pbProgress.Visible = false; Console.WriteLine(&quot;done&quot;); &#125;","tags":[{"name":"C#","slug":"C","permalink":"http://11wy11.github.io/tags/C/"}]},{"title":"C#利用itextSharp直接生成pdf","date":"2019-04-10T01:16:23.000Z","path":"2019/04/10/cplusplus-pdf-itextsharp-note/","text":"C#使用开源第三方库itextsharp直接生成pdf,相较于Microsoft Office 的COM组件，不需要依赖office环境，程序兼容性好，更轻量。但也存在一些不足，对于复杂模板的实现较为复杂，介绍一个使用实例 pdf工具类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648using iTextSharp.text;using iTextSharp.text.pdf;using System;using System.Collections.Generic;using System.Data;using System.IO;using System.Linq;using System.Text;using System.Threading.Tasks;using System.Windows.Forms;namespace GDZLCHECK.Utils&#123; class PdfUtils &#123; private static PdfUtils instance; public static PdfUtils GetInstance() &#123; if (instance == null) &#123; instance = new PdfUtils(); &#125; return instance; &#125; private static Document doc; private static BaseFont bf = BaseFont.CreateFont(@&quot;C://Windows/Fonts/simsun.ttc,0&quot;, BaseFont.IDENTITY_H, BaseFont.EMBEDDED); //四种字体 private static Font fontBig = new Font(bf, 20, Font.BOLD); private static Font fontMiddle = new Font(bf, 15, Font.BOLD); private static Font fontSmall = new Font(bf, 13, Font.BOLD); private static Font fontSmall1 = new Font(bf, 13, Font.BOLD); private static Font fontSmallNoBold = new Font(bf, 13); private static float IndentationLeft = 50;//距左边距 //如果要传参数进来，可自定义 public static void GeneratePDF(DataTable tableSource, string pac, bool isPassed,string managerName,string contactNum,string unitName,string outputFilePath = &quot;&quot;, int type = 1, string watermarkPicPath = &quot;&quot;) &#123; doc = new Document(PageSize.A4); doc.AddAuthor(&quot;XXXXXX&quot;); doc.AddCreationDate(); doc.AddHeader(&quot;isPass&quot;, isPassed.ToString()); try &#123; //MemoryStream ms2 = new MemoryStream(); string fileName = string.Format(&quot;数据_&#123;0&#125;.pdf&quot;, DateTime.Now.ToString(&quot;yyyyMMddHHmmss&quot;)); string filePath = string.Format(&quot;&#123;0&#125;/Resource/&#123;1&#125;&quot;, AppDomain.CurrentDomain.BaseDirectory, fileName); FileStream fs = new FileStream(filePath, FileMode.Create);//创建临时文件，到时生成好后删除 PdfWriter writer = PdfWriter.GetInstance(doc, fs); writer.CloseStream = false;//把doc内容写入流中 doc.Open(); //添加封面 //添加质检标志 string picPath = string.Format(&quot;&#123;0&#125;/Resource/&#123;1&#125;&quot;, AppDomain.CurrentDomain.BaseDirectory, &quot;mark.png&quot;); Image img = Image.GetInstance(new Uri(picPath)); float PageHeight = PageSize.A4.Height/7; double percentHeight = Math.Round((PageHeight / img.Height), 2); float PageWidth = PageSize.A4.Width/2; double percentWidth = Math.Round((PageWidth / img.Width), 2); double percent = percentHeight &gt; percentWidth ? percentWidth : percentHeight; img.ScalePercent((float)percent * 100); doc.Add(img); //每次在添加文本内容之前可以先设置字体 HeaderAndFooterEvent.SetFont(BaseColor.BLACK, &quot;宋体&quot;, 36, Font.BOLD); //添加一个空段落来占位，五个参数分别为：内容，对齐方式（1为居中，0为居左，2为居右），段后空行数，段前空行数，行间距 //doc.Add(HeaderAndFooterEvent.AddParagraph(&quot; &quot;, 1, 100, 0, 1.5f)); //这个方法为上一个方法的重载，三个参数分别为：内容，对齐方式，行间距 doc.Add(HeaderAndFooterEvent.AddParagraph(&quot;检 验 报 告&quot;, 1, 2.41f)); HeaderAndFooterEvent.SetFont(BaseColor.BLACK, &quot;宋体&quot;, 28, Font.BOLD); doc.Add(HeaderAndFooterEvent.AddParagraph(&quot;TEST REPORT&quot;, 1, 1.5f)); doc.Add(HeaderAndFooterEvent.AddParagraph(&quot; &quot;, 1, 50, 0, 1.5f)); HeaderAndFooterEvent.SetFont(BaseColor.BLACK, &quot;宋体&quot;, 28, Font.BOLD);//空行 string projectName=&quot;项目名称&quot;; //检测信息 bool isChangeRow = false;//对于项目名称过长需要换行截断 string anotherStr = &quot;&quot;; if (projectName.Length &gt; 19) &#123; isChangeRow = true; anotherStr = projectName.Substring(19, projectName.Length - 19); &#125; if (isChangeRow) &#123; AddPartnerContent(&quot;项目名称 :&quot;, projectName.Substring(0, 19), 38, 0);//添加项目名称 AddPartnerContent(&quot; &quot;, anotherStr, 38, 0);//添加项目名称 &#125; else &#123; AddPartnerContent(&quot;项目名称 :&quot;, projectName, 38, 0);//添加项目名称 &#125; AddPartnerContent(&quot;项目负责人:&quot;, managerName, 38, 0);//添加项目负责人 AddPartnerContent(&quot;联系电话 :&quot;, contactNum, 38, 1);//添加联系电话 AddPartnerContent(&quot;承担单位 :&quot;, unitName, 38, 0);//添加承担单位 AddPartnerContent(&quot;检测日期 :&quot;, DateTime.Now.ToString(&quot;yyyy-MM-dd HH:mm:ss&quot;), 38, 1);//添加项目名称 //检查结果详情 doc.NewPage(); //实现页眉页脚 writer.PageEvent = new HeaderAndFooterEvent(); HeaderAndFooterEvent.PAGE_NUMBER = true;//实现页眉跟页脚 HeaderAndFooterEvent.tpl = writer.DirectContent.CreateTemplate(500, 500); //定义模板 HeaderAndFooterEvent.HeaderLeft = &quot;耕地质量地球化学调查评价&quot;; HeaderAndFooterEvent.HeaderRight = &quot;成果检查&quot;; HeaderAndFooterEvent.FooterLeft = &quot;&quot;; HeaderAndFooterEvent.FooterRight = DateTime.Now.ToString(&quot;yyyy-MM-dd HH:mm:ss&quot;) + &quot;(UTC)&quot;; //核心操作 CreateLine();//生成一条下横线 CreateEmptyRow(1);//生成一行空行 HeaderAndFooterEvent.SetFont(BaseColor.BLACK, &quot;宋体&quot;, 15, Font.BOLD); doc.Add(HeaderAndFooterEvent.AddParagraph(&quot;耕地质量地球化学调查评价成果检查报告&quot;, 1, 1.5f)); //AddHeaderTitleContent(&quot;汇交数据检查报告&quot;);//添加表头 CreateEmptyRow(1);//生成一行空行 //AddPartnerContent(&quot;生产单位&quot;, pac, 30);//添加合作单位 //AddPartnerContent(&quot;检查单位&quot;,&quot;WHU&quot;,25);//添加合作单位 //AddPageNumberContent(1,1);//添加页码 HeaderAndFooterEvent.SetFont(BaseColor.BLACK, &quot;宋体1&quot;, 12); doc.Add(HeaderAndFooterEvent.AddParagraph(&quot;项目名称: XXXXXX&quot;, 0, 1.5f)); doc.Add(HeaderAndFooterEvent.AddParagraph(&quot;项目负责人:&quot;+managerName+&quot; &quot;, 0, 1.5f)); doc.Add(HeaderAndFooterEvent.AddParagraph(&quot;联系电话:&quot;+contactNum+&quot; &quot;, 0, 1.5f)); doc.Add(HeaderAndFooterEvent.AddParagraph(&quot;承担单位:&quot; + unitName + &quot; &quot;, 0, 1.5f)); doc.Add(HeaderAndFooterEvent.AddParagraph(&quot;检测日期: &quot; + DateTime.Now.ToString(&quot;yyyy-MM-dd HH:mm:ss&quot;), 0, 1.5f)); CreateEmptyRow(1);//生成一行空行 #region 生成表格数据 PdfPTable table = new PdfPTable(6);//5列的table //添加表格列头 table.WidthPercentage = 100; table.SetTotalWidth(new float[] &#123; 70, 150,80, 150, 80, 120 &#125;); table.AddCell(GetPdfCell(&quot;序号&quot;, fontSmallNoBold, Element.ALIGN_CENTER)); table.AddCell(GetPdfCell(&quot;检查对象&quot;, fontSmallNoBold, Element.ALIGN_CENTER)); table.AddCell(GetPdfCell(&quot;检查类型&quot;, fontSmallNoBold, Element.ALIGN_CENTER)); table.AddCell(GetPdfCell(&quot;检查内容&quot;, fontSmallNoBold, Element.ALIGN_CENTER)); table.AddCell(GetPdfCell(&quot;检查结果&quot;, fontSmallNoBold, Element.ALIGN_CENTER)); table.AddCell(GetPdfCell(&quot;备注&quot;, fontSmallNoBold, Element.ALIGN_CENTER)); int emptyRow = 20;//如果table的行数小于20行，那么剩余部分显示空白行 if (tableSource.Rows.Count &gt; 0) &#123; emptyRow = emptyRow - tableSource.Rows.Count;//如果为负数，说明不需要生成空白行 for (int i = 0; i &lt; tableSource.Rows.Count; i++) &#123; DataRow row = tableSource.Rows[i]; table.AddCell(GetPdfCell((i + 1).ToString(), fontSmallNoBold, Element.ALIGN_CENTER)); table.AddCell(GetPdfCell(row[&quot;Object&quot;].ToString(), fontSmallNoBold, Element.ALIGN_CENTER)); table.AddCell(GetPdfCell(row[&quot;Type&quot;].ToString(), fontSmallNoBold, Element.ALIGN_CENTER)); table.AddCell(GetPdfCell(row[&quot;Content&quot;].ToString(), fontSmallNoBold, Element.ALIGN_CENTER)); table.AddCell(GetPdfCell(row[&quot;Result&quot;].ToString(), fontSmallNoBold, Element.ALIGN_CENTER)); table.AddCell(GetPdfCell(row[&quot;Info&quot;].ToString(), fontSmallNoBold, Element.ALIGN_CENTER)); &#125; &#125; if (emptyRow &gt; 0)//说明数据源不足20行 &#123; for (int i = 0; i &lt; emptyRow; i++) &#123; table.AddCell(GetPdfCell(((20 - emptyRow) + i + 1).ToString(), fontSmallNoBold, Element.ALIGN_CENTER)); table.AddCell(GetPdfCell(&quot;&quot;, fontSmallNoBold, Element.ALIGN_CENTER)); table.AddCell(GetPdfCell(&quot;&quot;, fontSmallNoBold, Element.ALIGN_CENTER)); table.AddCell(GetPdfCell(&quot;&quot;, fontSmallNoBold, Element.ALIGN_CENTER)); table.AddCell(GetPdfCell(&quot;&quot;, fontSmallNoBold, Element.ALIGN_CENTER)); &#125; &#125; doc.Add(table); #endregion #region 添加水印 string waterMarkName = &quot;检查:&quot;+(isPassed?&quot;通过&quot;:&quot;未通过&quot;); string waterMarkAddr = pac; #endregion doc.Close(); fs.Close(); string outputFileName = string.Format(&quot;检查报告_&#123;0&#125;.pdf&quot;, DateTime.Now.ToString(&quot;yyyyMMddHHmmss&quot;)); outputFilePath = string.Format(&quot;&#123;0&#125;/&#123;1&#125;&quot;, outputFilePath, outputFileName); if (outputFilePath == null || outputFilePath == &quot;&quot;) &#123; outputFilePath = string.Format(&quot;&#123;0&#125;/Resource/&#123;1&#125;&quot;, AppDomain.CurrentDomain.BaseDirectory, outputFileName); &#125; switch (type) &#123; case 1: //目前使用并在其中设置了只读 setWatermark(filePath,outputFilePath,waterMarkName,waterMarkAddr);//先生成水印，再删除临时文件 break; case 2: waterMarkName = string.Format(&quot;汇交检查：&#123;0&#125; 区域：&#123;1&#125; &quot;, &quot;通过&quot;, waterMarkAddr); setWatermark(filePath, outputFilePath, waterMarkName); break; case 3: setPicWatermark(filePath, outputFilePath, watermarkPicPath); break; &#125; //先生成水印，再删除临时文件 if (File.Exists(filePath))//判断临时文件是否存在，如果存在则删除 &#123; File.Delete(filePath); GC.Collect();//回收垃圾 &#125; //设置只读 //pdfreadonly(outputFilePath); MessageBox.Show(&quot;保存检查结果成功&quot;); &#125; catch (DocumentException ex) &#123; throw new Exception(ex.Message); &#125; &#125; #region 生成一条横线 private static void CreateLine() &#123; PdfPTable table = new PdfPTable(1);//一个单元格的 table.WidthPercentage = 100; PdfPCell cell = new PdfPCell(); cell.BorderWidthBottom = 0.5f; table.AddCell(cell); doc.Add(table); &#125; #endregion #region 生成N行空白行 private static void CreateEmptyRow(int emptyRowNum) &#123; for (int i = 0; i &lt; emptyRowNum; i++) &#123; doc.Add(new Paragraph(&quot; &quot;)); &#125; &#125; #endregion #region 生成标题 private static void AddHeaderTitleContent(string content) &#123; Paragraph p = new Paragraph(content, fontMiddle); p.IndentationLeft = IndentationLeft;//距离左边距 doc.Add(p); &#125; #endregion #region 生成带下划线的内容 private static void AddPartnerContent(string stationName, string stationValue, int maxlength,int type) &#123; fontSmall.SetStyle(Font.UNDERLINE);//文字下划线 Paragraph content = new Paragraph(); content.IndentationLeft = 100; Chunk chunkName = new Chunk(stationName, fontSmall1); Chunk chunkText = new Chunk(GetEmptyString(maxlength, stationValue,type), fontSmall); content.Add(0, chunkName); content.Add(1, chunkText); content.SpacingAfter = 2; content.SpacingBefore = 2; content.MultipliedLeading = 1.5f; content.Alignment = 0; doc.Add(content); &#125; //居中显示内容 private static string GetEmptyString(int maxlength, string text,int type) &#123; int padding =0; if (type == 0) &#123; padding = (maxlength - text.Length* 2) ; &#125; else &#123; padding = (maxlength - text.Length); &#125; string empty = string.Empty; for (int i = 0; i &lt; padding; i++) &#123; empty += &quot; &quot;; &#125; return string.Format(&quot;&#123;1&#125;&#123;0&#125;&quot;, empty, text); &#125; #endregion #region 生成页码 private static void AddPageNumberContent(int total,int currentPage) &#123; var content = new Paragraph(&quot;共 &quot;+total+&quot; 页 第&quot;+currentPage+&quot; 页&quot;, fontSmall); content.IndentationRight = IndentationLeft + 20; content.Alignment = 2; //居左 doc.Add(content); &#125; #endregion #region 生成单元格 private static PdfPCell GetPdfCell(string content, Font font, int horizontalAlignment) &#123; PdfPCell cell = new PdfPCell(new Paragraph(content, font)); cell.HorizontalAlignment = horizontalAlignment;//水平位置 cell.VerticalAlignment = Element.ALIGN_CENTER;//垂直居中 cell.MinimumHeight = 20;//单元格的最小高度 return cell; &#125; #endregion #region 生成水印 public static bool CreatePDFByPic(string picPdfPath, string picPath) &#123; //新建一个文档 Document doc = new Document(); try &#123; //建立一个书写器(Writer)与document对象关联 PdfWriter.GetInstance(doc, new FileStream(picPdfPath, FileMode.Create, FileAccess.ReadWrite)); //打开一个文档 doc.Open(); //向文档中添加内容 Image img = Image.GetInstance(picPath); //img.SetAbsolutePosition(); doc.Add(img); return true; &#125; catch (Exception ex) &#123; return false; throw ex; &#125; finally &#123; if (doc != null) &#123; doc.Close(); &#125; &#125; &#125; /// &lt;summary&gt; /// 加图片水印 /// &lt;/summary&gt; /// &lt;param name=&quot;inputfilepath&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;outputfilepath&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;ModelPicName&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;top&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;left&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static bool setPicWatermark(string inputfilepath, string outputfilepath, string ModelPicName) &#123; //throw new NotImplementedException(); PdfReader pdfReader = null; PdfStamper pdfStamper = null; try &#123; pdfReader = new PdfReader(inputfilepath); int numberOfPages = pdfReader.NumberOfPages; iTextSharp.text.Rectangle psize = pdfReader.GetPageSize(1); float width = psize.Width; float height = psize.Height; pdfStamper = new PdfStamper(pdfReader, new FileStream(outputfilepath, FileMode.Create)); PdfContentByte waterMarkContent; iTextSharp.text.Image image = iTextSharp.text.Image.GetInstance(ModelPicName); float left = width / 2 - image.Width; float top = 10; image.GrayFill = 50;//透明度，灰色填充 //image.Rotation//旋转 //image.RotationDegrees//旋转角度 //水印的位置 if (left &lt; 0) &#123; left = width / 2 - image.Width; &#125; //image.SetAbsolutePosition(left, (height - image.Height) - top); image.SetAbsolutePosition(left, (height / 2 - image.Height) - top); //每一页加水印,也可以设置某一页加水印 for (int i = 1; i &lt;= numberOfPages; i++) &#123; //waterMarkContent = pdfStamper.GetUnderContent(i);//内容下层加水印 waterMarkContent = pdfStamper.GetOverContent(i);//内容上层加水印 waterMarkContent.AddImage(image); &#125; //strMsg = &quot;success&quot;; return true; &#125; catch (Exception ex) &#123; throw ex; &#125; finally &#123; if (pdfStamper != null) pdfStamper.Close(); if (pdfReader != null) pdfReader.Close(); &#125; &#125; /// &lt;summary&gt; /// 添加普通偏转角度文字水印 /// &lt;/summary&gt; /// &lt;param name=&quot;inputfilepath&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;outputfilepath&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;waterMarkName&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;permission&quot;&gt;&lt;/param&gt; public static void setWatermark(string inputfilepath, string outputfilepath, string waterMarkName) &#123; PdfReader pdfReader = null; PdfStamper pdfStamper = null; try &#123; pdfReader = new PdfReader(inputfilepath); pdfStamper = new PdfStamper(pdfReader, new FileStream(outputfilepath, FileMode.Create)); int total = pdfReader.NumberOfPages + 1; iTextSharp.text.Rectangle psize = pdfReader.GetPageSize(1); float width = psize.Width; float height = psize.Height; PdfContentByte content; BaseFont font = BaseFont.CreateFont(@&quot;C:\\WINDOWS\\Fonts\\SIMFANG.TTF&quot;, BaseFont.IDENTITY_H, BaseFont.EMBEDDED); PdfGState gs = new PdfGState(); for (int i = 1; i &lt; total; i++) &#123; content = pdfStamper.GetOverContent(i);//在内容上方加水印 //content = pdfStamper.GetUnderContent(i);//在内容下方加水印 //透明度 gs.FillOpacity = 0.3f; content.SetGState(gs); //content.SetGrayFill(0.3f); //开始写入文本 content.BeginText(); content.SetColorFill(BaseColor.LIGHT_GRAY); content.SetFontAndSize(font, 40); content.SetTextMatrix(0, 0); content.ShowTextAligned(Element.ALIGN_CENTER, waterMarkName, width / 2 - 50, height / 2 - 50, 55); //content.SetColorFill(BaseColor.BLACK); //content.SetFontAndSize(font, 8); //content.ShowTextAligned(Element.ALIGN_CENTER, waterMarkName, 0, 0, 0); content.EndText(); &#125; &#125; catch (Exception ex) &#123; throw ex; &#125; finally &#123; if (pdfStamper != null) pdfStamper.Close(); if (pdfReader != null) pdfReader.Close(); &#125; &#125; /// &lt;summary&gt; /// 添加倾斜水印 /// &lt;/summary&gt; /// &lt;param name=&quot;inputfilepath&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;outputfilepath&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;waterMarkName&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;userPassWord&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;ownerPassWord&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;permission&quot;&gt;&lt;/param&gt; public static void setWatermark(string inputfilepath, string outputfilepath, string waterMarkName, string userPassWord, string ownerPassWord, int permission) &#123; PdfReader pdfReader = null; PdfStamper pdfStamper = null; try &#123; pdfReader = new PdfReader(inputfilepath); pdfStamper = new PdfStamper(pdfReader, new FileStream(outputfilepath, FileMode.Create)); // 设置密码 //pdfStamper.SetEncryption(false,userPassWord, ownerPassWord, permission); int total = pdfReader.NumberOfPages + 1; PdfContentByte content; BaseFont font = BaseFont.CreateFont(@&quot;C:\\WINDOWS\\Fonts\\SIMFANG.TTF&quot;, BaseFont.IDENTITY_H, BaseFont.EMBEDDED); PdfGState gs = new PdfGState(); gs.FillOpacity = 0.2f;//透明度 int j = waterMarkName.Length; char c; int rise = 0; for (int i = 1; i &lt; total; i++) &#123; rise = 500; content = pdfStamper.GetOverContent(i);//在内容上方加水印 //content = pdfStamper.GetUnderContent(i);//在内容下方加水印 content.BeginText(); content.SetColorFill(BaseColor.DARK_GRAY); content.SetFontAndSize(font, 50); // 设置水印文字字体倾斜 开始 if (j &gt;= 15) &#123; content.SetTextMatrix(200, 120); for (int k = 0; k &lt; j; k++) &#123; content.SetTextRise(rise); c = waterMarkName[k]; content.ShowText(c + &quot;&quot;); rise -= 20; &#125; &#125; else &#123; content.SetTextMatrix(180, 100); for (int k = 0; k &lt; j; k++) &#123; content.SetTextRise(rise); c = waterMarkName[k]; content.ShowText(c + &quot;&quot;); rise -= 18; &#125; &#125; // 字体设置结束 content.EndText(); // 画一个圆 //content.Ellipse(250, 450, 350, 550); //content.SetLineWidth(1f); //content.Stroke(); &#125; &#125; catch (Exception ex) &#123; throw ex; &#125; finally &#123; if (pdfStamper != null) pdfStamper.Close(); if (pdfReader != null) pdfReader.Close(); &#125; &#125; /// &lt;summary&gt; /// /// &lt;/summary&gt; /// &lt;param name=&quot;filePath&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;outputfilepath&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;waterMarkName&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;waterMarkAddr&quot;&gt;&lt;/param&gt; public static void setWatermark(string filePath, string outputfilepath, string waterMarkName, string waterMarkAddr) &#123; PdfReader pdfReader = null; PdfStamper pdfStamper = null; try &#123; pdfReader = new PdfReader(filePath); pdfStamper = new PdfStamper(pdfReader, new FileStream(outputfilepath, FileMode.Create)); //设置权限为只读 pdfStamper.SetEncryption(PdfWriter.STRENGTH128BITS, null, null, PdfWriter.ALLOW_SCREENREADERS | PdfWriter.AllowPrinting); int total = pdfReader.NumberOfPages+1;//获取PDF的总页数 iTextSharp.text.Rectangle psize = pdfReader.GetPageSize(1);//获取第一页 float width = psize.Width;//PDF页面的宽度，用于计算水印倾斜 float height = psize.Height; PdfContentByte waterContent; BaseFont basefont = BaseFont.CreateFont(@&quot;C:\\WINDOWS\\Fonts\\SIMFANG.TTF&quot;, BaseFont.IDENTITY_H, BaseFont.EMBEDDED); PdfGState gs = new PdfGState(); //i从2开始，因为不给封面添加水印 for (int i = 2; i &lt; total; i++) &#123; waterContent = pdfStamper.GetOverContent(i);//在内容上方加水印 //透明度 waterContent.SetGState(gs); //开始写入文本 waterContent.BeginText(); waterContent.SetColorFill(BaseColor.RED); waterContent.SetFontAndSize(basefont, 30); waterContent.SetTextMatrix(0, 0); if (waterMarkAddr == null || waterMarkAddr == &quot;&quot;) &#123; waterContent.ShowTextAligned(Element.ALIGN_CENTER, waterMarkName, width / 2, height / 2, 55); &#125; else &#123; waterContent.ShowTextAligned(Element.ALIGN_CENTER, waterMarkName, width / 2, height / 2 + 100, 55); waterContent.ShowTextAligned(Element.ALIGN_CENTER, waterMarkAddr, width / 2, height / 2 - 100, 55); &#125; waterContent.EndText(); &#125; &#125; catch (Exception e) &#123; Console.WriteLine(e.ToString()); &#125; finally &#123; if (pdfStamper != null) pdfStamper.Close(); if (pdfReader != null) pdfReader.Close(); &#125; &#125; #endregion #region 只读 public static void pdfreadonly(string pdfname) &#123; string pdfFile = pdfname;// &quot;d:\\\\sample.pdf&quot;; //把文件读入内存可立即释放文件句柄，方便信息覆盖原文件 PdfReader reader = new PdfReader(File.ReadAllBytes(pdfFile)); //获取到本文件的 MetaData 信息 Dictionary&lt;string, string&gt; info = reader.Info; reader.Close(); //覆盖掉原 PDF 文件中 PdfStamper stamper = new PdfStamper(reader, new FileStream(pdfFile, FileMode.Create, FileAccess.Write)); stamper.MoreInfo = info; stamper.SetEncryption(PdfWriter.STRENGTH40BITS, null, null, PdfWriter.AllowScreenReaders); stamper.Close(); &#125; #endregion &#125;&#125; 页眉页脚生成类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305using iTextSharp.text;using iTextSharp.text.pdf;using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;namespace GDZLCHECK.Utils&#123; public class HeaderAndFooterEvent : PdfPageEventHelper, IPdfPageEvent &#123; #region 静态字段 public static PdfTemplate tpl = null; public static bool PAGE_NUMBER = false;//为True时就生成 页眉和页脚 public static iTextSharp.text.Rectangle rect = PageSize.A4; //文档大小 /// &lt;summary&gt; /// 正文字体 /// &lt;/summary&gt; private static Font font; /// &lt;summary&gt; /// 页眉页脚字体 /// &lt;/summary&gt; public static string HeaderFooterFontName = &quot;黑体&quot;; /// &lt;summary&gt; /// 页头页脚字号 /// &lt;/summary&gt; public static int HeaderFooterFontSize = 10; /// &lt;summary&gt; /// 页头页尾字体颜色 /// &lt;/summary&gt; public static BaseColor HeaderFooterFontColor = BaseColor.BLACK; /// &lt;summary&gt; /// 左边页眉 /// &lt;/summary&gt; public static string HeaderLeft &#123; get; set; &#125; /// &lt;summary&gt; /// 右边页眉 /// &lt;/summary&gt; public static string HeaderRight &#123; get; set; &#125; /// &lt;summary&gt; /// 左边页脚 /// &lt;/summary&gt; public static string FooterLeft &#123; get; set; &#125; /// &lt;summary&gt; /// 右边页脚 /// &lt;/summary&gt; public static string FooterRight &#123; get; set; &#125; #endregion #region 设置页面大小 /// &lt;summary&gt; /// 设置页面大小 /// &lt;/summary&gt; /// &lt;param name=&quot;type&quot;&gt;页面大小(如&quot;A4&quot;)&lt;/param&gt; public static void SetPageSize(string type) &#123; switch (type.Trim()) &#123; case &quot;A4&quot;: rect = PageSize.A4; break; case &quot;A8&quot;: rect = PageSize.A8; break; &#125; &#125; #endregion #region 设置字体 /// &lt;summary&gt; /// 设置字体 /// &lt;/summary&gt; /// &lt;param name=&quot;size&quot;&gt;字体大小&lt;/param&gt; public static void SetFont(BaseColor color, string fontName = &quot;华文中宋&quot;, float size = 12, int style = Font.NORMAL) &#123; font = new Font(BaseFontAndSize(fontName), size, style, color); &#125; #endregion #region 生成页眉页脚 /// &lt;summary&gt; /// 关闭一个页面时发生 /// &lt;/summary&gt; public override void OnEndPage(PdfWriter writer, Document document) &#123; if (PAGE_NUMBER) &#123; Font HeaderFooterFont = FontAndSize(HeaderFooterFontName, HeaderFooterFontSize, Font.NORMAL, HeaderFooterFontColor); Phrase header_left = new Phrase(HeaderLeft, HeaderFooterFont); Phrase header_right = new Phrase(HeaderRight, HeaderFooterFont); Phrase footer_left = new Phrase(FooterLeft, HeaderFooterFont); Phrase footer_center = new Phrase(&quot;第&quot; + (writer.PageNumber-1) + &quot;页/共 页&quot;, HeaderFooterFont); Phrase footer_right = new Phrase(FooterRight, HeaderFooterFont); PdfContentByte cb = writer.DirectContent; //模版 显示总共页数 cb.AddTemplate(tpl, document.Right - 290 + document.LeftMargin, document.Bottom - 15);//调节模版显示的位置 //页眉显示的位置 ColumnText.ShowTextAligned(cb, Element.ALIGN_CENTER, header_right, document.Right - 50 + document.LeftMargin, document.Top + 15, 0); ColumnText.ShowTextAligned(cb, Element.ALIGN_CENTER, header_left, document.Right - 500 + document.LeftMargin, document.Top + 15, 0); //页脚显示的位置 ColumnText.ShowTextAligned(cb, Element.ALIGN_CENTER, footer_left, document.Right - 535 + document.LeftMargin, document.Bottom - 15, 0); ColumnText.ShowTextAligned(cb, Element.ALIGN_CENTER, footer_center, document.Right - 300 + document.LeftMargin, document.Bottom - 15, 0); ColumnText.ShowTextAligned(cb, Element.ALIGN_CENTER, footer_right, document.Right - 80 + document.LeftMargin, document.Bottom - 15, 0); &#125; &#125; /// &lt;summary&gt; /// 打开一个新页面时发生 /// &lt;/summary&gt; public override void OnStartPage(PdfWriter writer, Document document) &#123; if (PAGE_NUMBER) &#123; writer.PageCount = writer.PageNumber - 1; &#125; &#125; /// &lt;summary&gt; /// 关闭PDF文档时发生该事件 /// &lt;/summary&gt; public override void OnCloseDocument(PdfWriter writer, Document document) &#123; BaseFont bf = BaseFontAndSize(HeaderFooterFontName); tpl.BeginText(); tpl.SetFontAndSize(bf, HeaderFooterFontSize); tpl.ShowText((writer.PageNumber - 1).ToString());//总页数 tpl.EndText(); tpl.ClosePath(); &#125; #endregion #region 私有方法 private static Font FontAndSize(string font_name, int size, int style, BaseColor baseColor) &#123; BaseFont baseFont; //BaseFont.AddToResourceSearch(&quot;iTextAsian.dll&quot;); //BaseFont.AddToResourceSearch(&quot;iTextAsianCmaps.dll&quot;); Font font = null; string file_name = &quot;&quot;; int fontStyle; switch (font_name) &#123; case &quot;黑体&quot;: file_name = &quot;SIMHEI.TTF&quot;; break; case &quot;华文中宋&quot;: file_name = &quot;STZHONGS.TTF&quot;; break; case &quot;宋体&quot;: file_name = &quot;SIMYOU.TTF&quot;; break; case &quot;宋体1&quot;: file_name = &quot;simsun.ttc&quot;; break; default: file_name = &quot;SIMYOU.TTF&quot;; break; &#125; baseFont = BaseFont.CreateFont(@&quot;c:/windows/fonts/&quot; + file_name, BaseFont.IDENTITY_H, BaseFont.NOT_EMBEDDED); if (style &lt; -1) &#123; fontStyle = Font.NORMAL; &#125; else &#123; fontStyle = style; &#125; font = new Font(baseFont, size, fontStyle, baseColor); return font; &#125; private static BaseFont BaseFontAndSize(string font_name) &#123; BaseFont baseFont; //BaseFont.AddToResourceSearch(&quot;iTextAsian.dll&quot;); //BaseFont.AddToResourceSearch(&quot;iTextAsianCmaps.dll&quot;); string file_name = &quot;&quot;; switch (font_name) &#123; case &quot;黑体&quot;: file_name = &quot;SIMHEI.TTF&quot;; break; case &quot;华文中宋&quot;: file_name = &quot;STZHONGS.TTF&quot;; break; case &quot;宋体&quot;: file_name = &quot;SIMYOU.TTF&quot;; break; default: file_name = &quot;SIMYOU.TTF&quot;; break; &#125; baseFont = BaseFont.CreateFont(@&quot;c:/windows/fonts/&quot; + file_name, BaseFont.IDENTITY_H, BaseFont.NOT_EMBEDDED); return baseFont; &#125; #endregion #region 添加段落 /// &lt;summary&gt; /// 添加段落 /// &lt;/summary&gt; /// &lt;param name=&quot;content&quot;&gt;内容&lt;/param&gt; /// &lt;param name=&quot;Alignment&quot;&gt;对齐方式（1为居中，0为居左，2为居右）&lt;/param&gt; /// &lt;param name=&quot;SpacingAfter&quot;&gt;段后空行数（0为默认值）&lt;/param&gt; /// &lt;param name=&quot;SpacingBefore&quot;&gt;段前空行数（0为默认值）&lt;/param&gt; /// &lt;param name=&quot;MultipliedLeading&quot;&gt;行间距（0为默认值）&lt;/param&gt; public static Paragraph AddParagraph(string content, int Alignment, float SpacingAfter, float SpacingBefore, float MultipliedLeading) &#123; Paragraph pra = new Paragraph(content, font); pra.Alignment = Alignment; pra.SpacingAfter = SpacingAfter; pra.SpacingBefore = SpacingBefore; pra.MultipliedLeading = MultipliedLeading; return pra; &#125; public static Paragraph AddParagraph(string content, int Alignment, float MultipliedLeading) &#123; Paragraph pra = new Paragraph(content, font); pra.Alignment = Alignment; pra.MultipliedLeading = MultipliedLeading; return pra; &#125; public static void AddPhrase(PdfWriter writer, Document document, string content, float marginLift, float marginBottom) &#123; Phrase phrase = new Phrase(content, font); PdfContentByte cb = writer.DirectContent; ColumnText.ShowTextAligned(cb, Element.ALIGN_CENTER, phrase, marginLift + document.LeftMargin, marginBottom, 0); &#125; #endregion #region 添加图片 /// &lt;summary&gt; /// 添加图片 /// &lt;param name=&quot;Alignment&quot;&gt;对齐方式 (0/1/2)&lt;/param&gt; /// &lt;param name=&quot;marginRight&quot;&gt;页边距&lt;/param&gt; /// &lt;param name=&quot;marginBottom&quot;&gt;页边距&lt;/param&gt; /// &lt;/summary&gt; public static iTextSharp.text.Image AddImage(string path, int Alignment, float marginRight, float marginBottom) &#123; Image img = Image.GetInstance(new Uri(path)); img.Alignment = Alignment; //等比缩放，宽与高的缩放系数哪个大就取哪一个（比如高的系数是0.8，宽的是0.7，则取0.7。这样图片就不会超出页面范围） if (img.Width &gt; img.Height) &#123; //这里计算图片的缩放系数，因为图片width&gt;height,所以将图片旋转90度以适应页面，计算缩放系数的时候宽与高对调 float PageHeight = PageSize.A4.Height - marginBottom * 3; double percentHeight = Math.Round((PageHeight / img.Width), 2); float PageWidth = PageSize.A4.Width - marginRight * 2; double percentWidth = Math.Round((PageWidth / img.Height), 2); double percent = percentHeight &gt; percentWidth ? percentWidth : percentHeight; img.ScalePercent((float)percent * 100); img.RotationDegrees = 90f; &#125; else &#123; float PageHeight = PageSize.A4.Height - marginBottom * 3; double percentHeight = Math.Round((PageHeight / img.Height), 2); float PageWidth = PageSize.A4.Width - marginRight * 2; double percentWidth = Math.Round((PageWidth / img.Width), 2); double percent = percentHeight &gt; percentWidth ? percentWidth : percentHeight; img.ScalePercent((float)percent * 100); &#125; return img; &#125; #endregion &#125;&#125; 主函数调用方式1234567891011121314151617181920212223242526272829if (this.tbManagerName.Text.ToString() == &quot;&quot; || this.tbContact.Text.ToString() == &quot;&quot; || this.tbUnit.Text.ToString() == &quot;&quot;) &#123; MessageBox.Show(&quot;请输入项目负责人姓名,联系电话,承担单位&quot;); return; &#125; //ConstantInfo.outStatic(); FolderBrowserDialog dialog = new FolderBrowserDialog(); dialog.Description = &quot;请选择检查报告输出位置&quot;; string outputFilePath = &quot;&quot;; if (dialog.ShowDialog() == DialogResult.OK) &#123; outputFilePath = dialog.SelectedPath; string managerName = this.tbManagerName.Text.ToString(); string contactNum = this.tbContact.Text.ToString(); string unitName = this.tbUnit.Text.ToString(); this.lbShowProcess.Text = &quot;正在准备统计数据...&quot;; this.pbProgress.Visible = true; statisticNum(); this.pbProgress.Position = 30; this.lbShowProcess.Text = &quot;开始生成检查报告...&quot;; //文字水印1 PdfUtils.GeneratePDF(resultDt, strPacName, isPassed, managerName, contactNum, unitName, outputFilePath, 1); //水印2 // PdfUtils.GeneratePDF(resultDt, strPac,isPassed,outputFilePath, 2); //图片水印 // string picPath = string.Format(&quot;&#123;0&#125;/Resource/&#123;1&#125;&quot;, AppDomain.CurrentDomain.BaseDirectory,&quot;logo.png&quot;); //PdfUtils.GeneratePDF(resultDt, strPac,isPassed,outputFilePath, 3,picPath); this.lbShowProcess.Text = &quot;检查报告导出完成&quot;; &#125;","tags":[{"name":"C#","slug":"C","permalink":"http://11wy11.github.io/tags/C/"},{"name":"VS打包","slug":"VS打包","permalink":"http://11wy11.github.io/tags/VS打包/"}]},{"title":"C# Regex正则表达式","date":"2019-03-29T12:30:30.000Z","path":"2019/03/29/cplusplus-regex-note/","text":"正则表达式的本质是使用一系列特殊字符模式，来表示某一类字符串。 Regex 正则表达式正则表达式的本质是使用一系列特殊字符模式，来表示某一类字符串。正则表达式无疑是处理文本最有力的工具，而.NET提供的Regex类实现了验证正则表达式的方法。Regex 类表示不可变（只读）的正则表达式。它还包含各种静态方法，允许在不显式创建其他类的实例的情况下使用其他正则表达式类。 基础 代码 说明 . 匹配除换行符以外的任意字符。 \\w 匹配字母或数字或下划线或汉字。 \\s 匹配任意的空白符。 \\d 匹配数字。 \\b 匹配单词的开始或结束。 [ck] 匹配包含括号内元素的字符 ^ 匹配行的开始。 $ 匹配行的结束。 \\ 对下一个字符转义。比如$是个特殊的字符。要匹配$的话就得用\\$ &#124; 分支条件，如：x&#124; y匹配 x 或 y。 反义元字符 代码 说明 \\W 匹配任意不是字母，数字，下划线，汉字的字符。 \\S 匹配任意不是空白符的字符。等价于 [^ \\f\\n\\r\\t\\v]。 \\D 匹配任意非数字的字符。等价于 [^0-9]。 \\B 匹配不是单词开头或结束的位置。 [^CK] 匹配除了CK以外的任意字符。 特殊元字符 代码 说明 \\f 匹配一个换页符。等价于 \\x0c 和 \\cL。 \\n 匹配一个换行符。等价于 \\x0a 和 \\cJ。 \\r 匹配一个回车符。等价于 \\x0d 和 \\cM。 \\t 匹配一个制表符。等价于 \\x09 和 \\cI。 \\v 匹配一个垂直制表符。等价于 \\x0b 和 \\cK。 限定符 代码 说明 * 匹配前面的子表达式零次或多次。 + 匹配前面的子表达式一次或多次。 ? 匹配前面的子表达式零次或一次。 {n} n 是一个非负整数。匹配确定的 n 次。 {n,} n 是一个非负整数。至少匹配n 次。 {n,m} m 和 n 均为非负整数，其中n &lt;= m。最少匹配 n 次且最多匹配 m 次。 懒惰限定符 代码 说明 *? 重复任意次，但尽可能少重复。 如 “acbacb” 正则 “a.*?b” 只会取到第一个”acb” 原本可以全部取到但加了限定符后，只会匹配尽可能少的字符 ，而”acbacb”最少字符的结果就是”acb” 。 +? 重复1次或更多次，但尽可能少重复。与上面一样，只是至少要重复1次。 ?? 重复0次或1次，但尽可能少重复。 如 “aaacb” 正则 “a.??b” 只会取到最后的三个字符”acb”。 {n,m}? 重复n到m次，但尽可能少重复。 如 “aaaaaaaa” 正则 “a{0,m}” 因为最少是0次所以取到结果为空。 {n,}? 重复n次以上，但尽可能少重复。 如 “aaaaaaa” 正则 “a{1,}” 最少是1次所以取到结果为 “a”。 捕获分组 代码 说明 (exp) 匹配exp,并捕获文本到自动命名的组里。 (?exp) 匹配exp,并捕获文本到名称为name的组里。 (?:exp) 匹配exp,不捕获匹配的文本，也不给此分组分配组号以下为零宽断言。 (?=exp) 匹配exp前面的位置。 如 “How are you doing” 正则”(?.+(?=ing))” 这里取ing前所有的字符，并定义了一个捕获分组名字为 “txt” 而”txt”这个组里的值为”How are you do”; (?&lt;=exp) 匹配exp后面的位置。 如 “How are you doing” 正则”(?(?&lt;=How).+)” 这里取”How”之后所有的字符，并定义了一个捕获分组名字为 “txt” 而”txt”这个组里的值为” are you doing”; (?!exp) 匹配后面跟的不是exp的位置。 如 “123abc” 正则 “\\d{3}(?!\\d)”匹配3位数字后非数字的结果 (?&lt;!exp) 匹配前面不是exp的位置。 如 “abc123 “ 正则 “(?&lt;![0-9])123” 匹配”123”前面是非数字的结果也可写成”(?!&lt;\\d)123” 数字常用表达式1234567891011121314151617181920212223242526272829303132333435363738//数字 Regex reg = new Regex(@&quot;^[0-9]*$&quot;); //n位的数字 Regex reg = new Regex(@&quot;^\\d&#123;n&#125;$&quot;); //至少n位的数字 Regex reg = new Regex(@&quot;^\\d&#123;n,&#125;$&quot;); //m-n位的数字 Regex reg = new Regex(@&quot;^\\d&#123;m,n&#125;$&quot;); //零和非零开头的数字 Regex reg = new Regex(@&quot;^(0|[1-9][0-9]*)$&quot;); //非零开头的最多带两位小数的数字 Regex reg = new Regex(@&quot;^([1-9][0-9]*)+(.[0-9]&#123;1,2&#125;)?$&quot;); //带1-2位小数的正数或负数 Regex reg = new Regex(@&quot;^(\\-)?\\d+(\\.\\d&#123;1,2&#125;)?$&quot;); //正数、负数、和小数 Regex reg = new Regex(@&quot;^(\\-|\\+)?\\d+(\\.\\d+)?$&quot;); //有两位小数的正实数 Regex reg = new Regex(@&quot;^[0-9]+(.[0-9]&#123;2&#125;)?$&quot;); //有1~3位小数的正实数 Regex reg = new Regex(@&quot;^[0-9]+(.[0-9]&#123;1,3&#125;)?$&quot;); //非零的正整数 Regex reg = new Regex(@&quot;^[1-9]\\d*$ 或 ^([1-9][0-9]*)&#123;1,3&#125;$ 或 ^\\+?[1-9][0-9]*$&quot;); //非零的负整数 Regex reg = new Regex(@&quot;^\\-[1-9][]0-9″*$ 或 ^-[1-9]\\d*$&quot;); //非负整数 Regex reg = new Regex(@&quot;^\\d+$ 或 ^[1-9]\\d*|0$&quot;); //非正整数 Regex reg = new Regex(@&quot;^-[1-9]\\d*|0$ 或 ^((-\\d+)|(0+))$&quot;); //非负浮点数 Regex reg = new Regex(@&quot;^\\d+(\\.\\d+)?$ 或 ^[1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*|0?\\.0+|0$&quot;); //非正浮点数 Regex reg = new Regex(@&quot;^((-\\d+(\\.\\d+)?)|(0+(\\.0+)?))$ 或 ^(-([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*))|0?\\.0+|0$&quot;); //正浮点数 Regex reg = new Regex(@&quot;^[1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*$ 或 ^(([0-9]+\\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\\.[0-9]+)|([0-9]*[1-9][0-9]*))$&quot;); //负浮点数 Regex reg = new Regex(@&quot;^-([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*)$ 或 ^(-(([0-9]+\\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\\.[0-9]+)|([0-9]*[1-9][0-9]*)))$&quot;); //浮点数 Regex reg = new Regex(@&quot;^(-?\\d+)(\\.\\d+)?$ 或 ^-?([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*|0?\\.0+|0)$&quot;); 字符123456789101112131415161718192021222324//汉字 Regex reg = new Regex(@&quot;^[\\u4e00-\\u9fa5]&#123;0,&#125;$&quot;); //英文和数字 Regex reg = new Regex(@&quot;^[A-Za-z0-9]+$ 或 ^[A-Za-z0-9]&#123;4,40&#125;$&quot;); //长度为3-20的所有字符 Regex reg = new Regex(@&quot;^.&#123;3,20&#125;$&quot;); //由26个英文字母组成的字符串 Regex reg = new Regex(@&quot;^[A-Za-z]+$&quot;); //由26个大写英文字母组成的字符串 Regex reg = new Regex(@&quot;^[A-Z]+$&quot;); //由26个小写英文字母组成的字符串 Regex reg = new Regex(@&quot;^[a-z]+$&quot;); //由数字和26个英文字母组成的字符串 Regex reg = new Regex(@&quot;^[A-Za-z0-9]+$&quot;); //由数字、26个英文字母或者下划线组成的字符串 Regex reg = new Regex(@&quot;^\\w+$ 或 ^\\w&#123;3,20&#125;$&quot;); //中文、英文、数字包括下划线 Regex reg = new Regex(@&quot;^[\\u4E00-\\u9FA5A-Za-z0-9_]+$&quot;); //中文、英文、数字但不包括下划线等符号 Regex reg = new Regex(@&quot;^[\\u4E00-\\u9FA5A-Za-z0-9]+$ 或 ^[\\u4E00-\\u9FA5A-Za-z0-9]&#123;2,20&#125;$&quot;); //可以输入含有^%&amp;’,;=?$\\”等字符 Regex reg = new Regex(@&quot;[^%&amp;’,;=?$\\x22]+&quot;); //禁止输入含有~的字符 Regex reg = new Regex(@&quot;[^~\\x22]+&quot;); 其他表达式123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566//Email地址 Regex reg = new Regex(@&quot;^\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*$&quot;); //域名 Regex reg = new Regex(@&quot;[a-zA-Z0-9][-a-zA-Z0-9]&#123;0,62&#125;(/.[a-zA-Z0-9][-a-zA-Z0-9]&#123;0,62&#125;)+/.?&quot;); //InternetURL Regex reg = new Regex(@&quot;[a-zA-z]+://[^\\s]* 或 ^http://([\\w-]+\\.)+[\\w-]+(/[\\w-./?%&amp;=]*)?$&quot;); //手机号码 Regex reg = new Regex(@&quot;^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\\d&#123;8&#125;$&quot;); //电话号码(“XXX-XXXXXXX”、”XXXX-XXXXXXXX”、”XXX-XXXXXXX”、”XXX-XXXXXXXX”、”XXXXXXX”和”XXXXXXXX) Regex reg = new Regex(@&quot;^($$\\d&#123;3,4&#125;-)|\\d&#123;3.4&#125;-)?\\d&#123;7,8&#125;$&quot;); //国内电话号码(0511-4405222、021-87888822) Regex reg = new Regex(@&quot;\\d&#123;3&#125;-\\d&#123;8&#125;|\\d&#123;4&#125;-\\d&#123;7&#125;&quot;); //身份证号(15位、18位数字) Regex reg = new Regex(@&quot;^\\d&#123;15&#125;|\\d&#123;18&#125;$&quot;); //短身份证号码(数字、字母x结尾) Regex reg = new Regex(@&quot;^([0-9])&#123;7,18&#125;(x|X)?$ 或 ^\\d&#123;8,18&#125;|[0-9x]&#123;8,18&#125;|[0-9X]&#123;8,18&#125;?$&quot;); //帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线) Regex reg = new Regex(@&quot;^[a-zA-Z][a-zA-Z0-9_]&#123;4,15&#125;$&quot;); //密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线) Regex reg = new Regex(@&quot;^[a-zA-Z]\\w&#123;5,17&#125;$&quot;); //强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间) Regex reg = new Regex(@&quot;^(?=.*\\d)(?=.*[a-z])(?=.*[A-Z]).&#123;8,10&#125;$&quot;); //日期格式 Regex reg = new Regex(@&quot;^\\d&#123;4&#125;-\\d&#123;1,2&#125;-\\d&#123;1,2&#125;&quot;); //一年的12个月(01～09和1～12) Regex reg = new Regex(@&quot;^(0?[1-9]|1[0-2])$&quot;); //一个月的31天(01～09和1～31) Regex reg = new Regex(@&quot;^((0?[1-9])|((1|2)[0-9])|30|31)$&quot;); //钱的输入格式： //有四种钱的表示形式我们可以接受:”10000.00″ 和 “10,000.00”, 和没有 “分” 的 “10000” 和 “10,000” Regex reg = new Regex(@&quot;^[1-9][0-9]*$&quot;); //这表示任意一个不以0开头的数字，但是，这也意味着一个字符”0″不通过，所以我们采用下面的形式 Regex reg = new Regex(@&quot;^(0|[1-9][0-9]*)$&quot;); //一个0或者一个不以0开头的数字.我们还可以允许开头有一个负号 Regex reg = new Regex(@&quot;^(0|-?[1-9][0-9]*)$&quot;); //这表示一个0或者一个可能为负的开头不为0的数字.让用户以0开头好了.把负号的也去掉，因为钱总不能是负的吧.下面我们要加的是说明可能的小数部分 Regex reg = new Regex(@&quot;^[0-9]+(.[0-9]+)?$&quot;); //必须说明的是，小数点后面至少应该有1位数，所以”10.”是不通过的，但是 “10” 和 “10.2” 是通过的 Regex reg = new Regex(@&quot;^[0-9]+(.[0-9]&#123;2&#125;)?$&quot;); //这样我们规定小数点后面必须有两位，如果你认为太苛刻了，可以这样 Regex reg = new Regex(@&quot;^[0-9]+(.[0-9]&#123;1,2&#125;)?$&quot;); //这样就允许用户只写一位小数。下面我们该考虑数字中的逗号了，我们可以这样 Regex reg = new Regex(@&quot;^[0-9]&#123;1,3&#125;(,[0-9]&#123;3&#125;)*(.[0-9]&#123;1,2&#125;)?$&quot;); //1到3个数字，后面跟着任意个 逗号+3个数字，逗号成为可选，而不是必须 Regex reg = new Regex(@&quot;^([0-9]+|[0-9]&#123;1,3&#125;(,[0-9]&#123;3&#125;)*)(.[0-9]&#123;1,2&#125;)?$&quot;); //备注：这就是最终结果了，别忘了”+”可以用”*”替代。如果你觉得空字符串也可以接受的话(奇怪，为什么?)最后，别忘了在用函数时去掉去掉那个反斜杠，一般的错误都在这里 //xml文件 Regex reg = new Regex(@&quot;^([a-zA-Z]+-?)+[a-zA-Z0-9]+\\\\.[x|X][m|M][l|L]$&quot;); //中文字符的正则表达式 Regex reg = new Regex(@&quot;[\\u4e00-\\u9fa5]&quot;); //双字节字符 Regex reg = new Regex(@&quot;[^\\x00-\\xff] (包括汉字在内，可以用来计算字符串的长度(一个双字节字符长度计2，ASCII字符计1))&quot;); //空白行的正则表达式，可用来删除空白行 Regex reg = new Regex(@&quot;\\n\\s*\\r&quot;); //HTML标记的正则表达式 Regex reg = new Regex(@&quot;&lt;(\\S*?)[^&gt;]*&gt;.*?&lt;/\\1&gt;|&lt;.*? /&gt;&quot;);// (网上流传的版本太糟糕，上面这个也仅仅能部分，对于复杂的嵌套标记依旧无能为力) //首尾空白字符的正则表达式 Regex reg = new Regex(@&quot;^\\s*|\\s*$或(^\\s*)|(\\s*$)&quot;);// (可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式) //腾讯QQ号 Regex reg = new Regex(@&quot;[1-9][0-9]&#123;4,&#125;&quot;); //(腾讯QQ号从10000开始) //中国邮政编码 Regex reg = new Regex(@&quot;[1-9]\\d&#123;5&#125;(?!\\d)&quot;);// (中国邮政编码为6位数字) //IP地址 Regex reg = new Regex(@&quot;\\d+\\.\\d+\\.\\d+\\.\\d+&quot;);// (提取IP地址时有用) //IP地址 Regex reg = new Regex(@&quot;((?:(?:25[0-5]|2[0-4]\\\\d|[01]?\\\\d?\\\\d)\\\\.)&#123;3&#125;(?:25[0-5]|2[0-4]\\\\d|[01]?\\\\d?\\\\d))&quot;);","tags":[{"name":"C#","slug":"C","permalink":"http://11wy11.github.io/tags/C/"},{"name":"Regex","slug":"Regex","permalink":"http://11wy11.github.io/tags/Regex/"}]},{"title":"ai组件开发--虚线定义原理及编程实现","date":"2019-03-25T07:41:27.000Z","path":"2019/03/25/ai-dash-line-note/","text":"illustrator中定义虚线形式可以最多设置三个虚线长度和三个间隙长度 虚线定义illustrator中定义虚线形式可以最多设置三个虚线长度和三个间隙长度__需要特别注意如果定义奇数个参数，即没有定义spaceA，spaceB，spaceC时的情况,其中spaceB和spaceC的循环情况原理一致依次标记为dashA,spaceA,dashB,spaceB,dashC,spaceC为更明显的展示，定义：dashA: 3spaceA: 5 dashB: 4spaceB:6 dashC: 2spaceC: 1虚线：—表示一个pt间隙：#表示一个pt结果形式：展示两次循环，每次循环间为区分明显添加了一个空格下面简单介绍定义规则 设置dashA，其他值为空一次循环：此时按照dashA的长度绘制实部，此时，illustrator默认spaceA=dashA，因此间隙也是dashA的长度结果形式:———### ———### 设置dashA，spaceA,其他值为空一次循环：此时按照dashA的长度绘制实部，间隙是spaceA的长度结果形式:———##### ———##### 设置dashA，spaceA,dashB,其他值为空，需注意一次循环：此时按照dashA的长度绘制第一个实部，间隙是spaceA的长度,按照dashB的长度绘制第二个实部，按照dashA绘制间隙，按照spaceA绘制第三个实部，按照dashB绘制间隙结果形式:———#####————####—————#### ———#####————####—————#### 设置dashA，spaceA,dashB,spaceB,其他值为空 一次循环：此时按照dashA的长度绘制第一个实部，间隙是spaceA的长度,按照dashB的长度绘制第二个实部，间隙是spaceB的长度, 结果形式:———#####————###### ———#####————###### 设置dashA，spaceA,dashB,spaceB,dashC,其他值为空 一次循环：此时按照dashA的长度绘制第一个实部，间隙是spaceA的长度,按照dashB的长度绘制第二个实部，间隙是spaceB的长度,按照dashC的长度绘制第三个实部,间隙是spaceC的长度，按照dashA绘制间隙，按照spaceA绘制第四个实部，按照dashB绘制间隙，按照spaceB绘制第五个实部，按照dashC绘制间隙,按照spaceC绘制第六个实部 结果形式:———#####————######——###—————####——————## ———#####————######——###—————####——————## 设置dashA，spaceA,dashB,spaceB,dashC,spaceC 原理同4一致，不再赘述 概括来说，AI本身每次循环使用六个参数定义虚线，如果不足就会重复前面定义的参数 illustrator SDK接口实现","tags":[{"name":"AI","slug":"AI","permalink":"http://11wy11.github.io/tags/AI/"}]},{"title":"AI组件开发（八）--AIArtStyleSuite","date":"2019-03-25T01:46:16.000Z","path":"2019/03/25/ai-eight-style-note/","text":"Art Style套件中的功能用于访问和修改Illustrator文档中图稿的art样式Table of Contents generated with DocToc AIArtStyleSuite 方法 相关类，结构体，指针 AIArtHandle AIArtStyleHandle AIPathStyle AIStrokeStyle AIFillStyle 使用实例 AIArtStyleSuiteArt Style套件中的功能用于访问和修改Illustrator文档中图稿的art样式在AI8中，Illustrator引入了插件组的概念，其中实际打印的art（结果art）与用户编辑的art（编辑art）分开。随着art风格的引入，这一概念在AI9中得到了扩展。现在，文档中的任何art对象（包括组和文本对象）都可以选择附加“样式art”。正是这种“风格art”得到了印刷，而不是原始的“源art”。 应用于art的art风格控制着风格art的生成方式。插件不应该直接修改样式art本身，可以随时重新生成，但应该使用art风格。 导出插件应导出应用于对象的样式化art（如果有），而不是原始源art。 在UI中，应用于Illustratorart对象的art风格称为对象的外观，并通过“外观”调板进行操作。外观也可以通过“图形样式”调板保存并在其他对象上重复使用。 使用SPBasicSuite::AcquireSuite()常量kAIArtStyleSuite和使用获取此套件kAIArtStyleVersion。 方法 AIAPI AIErr（* GetStyledArt）（AIArtHandle art，AIArtHandle * styledArt） 获得art对象的样式。 返回 styleArt [out]用于返回样式化art对象的缓冲区，如果没有应用特殊样式，则返回原始art对象。NULL出错时返回; 例如，如果由于内存限制而无法执行动态效果。 AIAPI AIErr（* GetArtStyle）（AIArtHandle art，AIArtStyleHandle * artStyle） 获得与art对象关联的art风格。 AIAPI AIErr（* GetCurrentArtStyle）（AIArtStyleHandle * artStyle，AIBoolean * mixedState） 获得“外观”调板中当前显示的art样式。 artStyle [out]用于返回art风格参考的缓冲区。 mixedState [out]如果Appearance调色板显示“Mixed”，则返回true的缓冲区。在这种情况下，返回的art风格是一种简单的风格，它试图收集附加到当前文档中当前所选对象的art风格的公共属性。 AIAPI AIErr（* GetArtStyleByName）（AIArtStyleHandle * artStyle，const ai :: UnicodeString＆name，AIBoolean searchAllStyles） 从当前文档中按唯一名称获得art样式。 AIAPI AIErr（* CountNamedArtStyles）（ai :: int32 * count） 获取“图形样式”调板中当前列出的art样式的数量。 AIAPI AIErr（* GetNthNamedArtStyle）（ai :: int32 n，AIArtStyleHandle * artStyle） 按索引获得命名的art样式。 AIAPI AIErr（* SetArtStyle）（AIArtHandle art，AIArtStyleHandle artStyle） 将art样式应用于ar品。 AIAPI AIErr（* SetCurrentArtStyle）（AIArtStyleHandle artStyle） 将art样式应用于画板上当前目标对象。 AIAPI AIErr（* GetArtStyleName）（AIArtStyleHandle artStyle，ai :: UnicodeString＆name，AIBoolean * isAnonymous） 获得art样式的唯一名称。 AIAPI AIErr（* SetArtStyleName）（AIArtStyleHandle artStyle，const ai :: UnicodeString＆name） 设置命名art样式的唯一名称; 也就是说，在“图形样式”调板中显示的那个。 AIAPI AIErr（* GetPaintAttributes）（AIArtStyleHandle artStyle，AIPathStyle * aiPathStyle，AIArtStylePaintData * paintData） 获得art样式的绘画信息。 AIAPI AIErr（* NewStyle）（AIPathStyle * aiPathStyle，AIArtStylePaintData * paintData，AIDictionaryRef blendDict，AIArtStyleHandle * newStyle） 创造一种新的art风格。 AIAPI AIErr（* AddNamedStyle）（AIArtStyleHandle artStyle，const ai :: UnicodeString＆name，AIBoolean uniquify，AIArtStyleHandle * namedStyle） 将匿名样式转换为命名样式，该样式显示在“图形样式”调板中。 AIAPI AIErr（* RemoveNamedStyle）（AIArtStyleHandle namedStyle，AIArtStyleHandle * anonStyle） 将命名样式（在“图形样式”调板中显示）转换为匿名样式， AIAPI AIErr（* CreateAnonymousStyle）（AIArtStyleHandle namedStyle，AIArtStyleHandle * anonStyle） 创建命名art样式的匿名副本（显示在“图形样式”调板中）。 AIAPI AIErr（* RedefineNamedStyle）（AIArtStyleHandle namedStyle，AIArtStyleHandle dstStyle） 重新定义命名的art样式以具有与另一样式相同的特征。 AIAPI AIErr（* MoveNamedStyle）（AIArtStyleHandle namedStyle，ai :: int32 index） 将命名的art样式移动到“图形样式”调板中的位置。 AIAPI AIErr（* GetArtStyleByNameFromDocument）（AIArtStyleHandle * artStyle，const ai :: UnicodeString＆name，AIDocumentHandle document） 通过指定文档中的唯一名称获得命名的art样式。 AIAPI AIErr（* CountNamedArtStylesFromDocument）（ai :: int32 * count，AIDocumentHandle document） 获取指定文档中命名的art样式的数量（当该文档是最新的时，在“图形样式”调板中显示的样式）。 AIAPI AIErr（* GetNthNamedArtStyleFromDocument）（ai :: int32 n，AIArtStyleHandle * artStyle，AIDocumentHandle document） 按索引获得指定文档的命名art样式。 AIAPI AIErr（* 当量）（AIArtStyleHandle artStyle1，AIArtStyleHandle artStyle2，AIBoolean *结果） 测试两种art风格之间的等价性。 AIAPI AIErr（* SortNamedStyles）（void） 按名称按字母顺序对当前文档中的命名art样式进行排序。 AIAPI AIErr（* GetDefaultArtStyle）（AIArtStyleHandle * artStyle） 获得当前文档的默认art样式，该样式始终首先列在“图形样式”调板中。 AIAPI AIErr（* GetDefaultArtStyleName）（ai :: UnicodeString＆name） 获得当前文档的默认art样式的名称，该名称始终首先列在“图形样式”调板中。 AIAPI AIBoolean（* ValidateArtStyle）（AIArtStyleHandle artStyle） 报告当前文档中是否存在artstyle。 AIAPI AIErr（* FlattenStyle）（AIArtHandle art） 扩展art的风格，将art品替换为可返回的GetStyledArt()。 AIAPI AIErr（* GetArtStyleType）（AIArtStyleHandle artStyle，ai :: int16 * type） 获得art风格的类型。 AIAPI AIBoolean（* CanExecute）（AIArtStyleHandle artStyle） 报告art风格是否包含执行所需的所有部分。 AIAPI AIReal（* GetArtStyleScaleFactor）（AIArtHandle art） 返回art对象样式的比例因子。 “缩放笔触和效果”选项允许缩放笔画粗细和附加到art对象的效果。缩放因子与art对象一起存储，并且在应用样式后应用。例如，如果附加到对象的样式具有权重为2 pt的笔划，并且对象的比例因子为2.5，则视觉笔触权重为5 pt。 注意： GetPaintAttributes()获取未缩放的参数值，以及来自的函数AIArtStyleParserSuite。 但是，AIPathStyleSuite调用返回附加到对象的缩放笔画粗细。 参数：art 返回： 比例因子。 AIAPI AIErr（* SetArtStyleScaleFactor）（AIArtHandle art，AIReal scaleFactor） 设置art对象样式的比例因子。 AIAPI AIErr（* ResetArtStyleScaleFactor）（AIArtHandle art） 将新样式应用于按对象的当前比例因子缩放的art对象，并将对象的比例因子重置为1。 AIAPI AIErr（* TransformObjectArtStyle）（AIArtHandle art，AIRealMatrix * matrix，AIReal lineScale，ai :: int32 flags） 改变对象的art风格。 参数： art 需要变换的art对象 matrix 指向转换矩阵的指针。 lineScale 要应用于art对象当前样式中指定的线条绘制样式值的比例因子。 flags 控制转换执行方式的位标志。AITransformArtOptions值的逻辑OR 。如果kTransformObjects标志打开，则假设art对象本身也已经被相同的矩阵变换，并且已经执行了点，后代art等的任何变换。这允许立即调整梯度向量和依赖于对象边界的其他样式属性，而不是延迟到art同步。 AIAPI AIArtStyleHasAttrs（* ExamineStyle）（AIArtStyleHandle artStyle，AIArtStyleHasAttrs checkFor） 检查特定属性的art风格，并返回找到的属性。 AIAPI AIErr（* GetToolArtStyle）（AIArtStyleHandle * artStyle） 根据应用程序首选项获得将用于工具创建的新art的artstyle。 AIAPI AIErr（* GetFlattenedArt）（AIArtHandle art，AIArtHandle * flattenedArt） 扩展ar的风格，将art替换为可返回的art GetStyledArt()。 AIAPI AIBoolean（* HasEffectiveNullStyle）（AIArtHandle art） 报告art对象是否具有等效于null样式的样式。 AIAPI AIErr（* GetPaintMap）（AIArtStyleHandle artStyle，AIPathStyleMap * aiPathStyleMap） 获得art样式的路径样式的地图，如下所示GetPaintAttributes()。 相关类，结构体，指针AIArtHandle123typedef struct ArtObject* AIArtHandleOpaque reference to an art object.Access using AIArtSuite. AIArtStyleHandle1234typedef struct _t_AIArtStyle* AIArtStyleHandleA reference to an art style.See also:AIArtStyleSuite. AIPathStyle描述如何绘制路径的填充和描边。 完整样式完全指定绘画信息。一个部分款式可以指定的绘画信息的子集。例如，它可用于表示选择的常见绘制属性，或修改属性的子集而不影响其他属性。在这种情况下，路径样式与样式映射配对，AIPathStyleMap指定具有有效值的属性子集。注意不要将部分样式传递给需要完整样式的函数; 未指定的字段可以包含无效值。 AIBoolean fillPaint Whether or not to fill the path. AIBoolean strokePaint Whether or not to stroke the path. struct AIFillStyle fill Fill style, if fillPaint is true. struct AIStrokeStyle stroke Stroke style, if strokePaint is true. AIBoolean clip AIBoolean lockClip AIBoolean evenodd When true, use the even-odd rule to determine path insideness. AIReal resolution Path’s resolution. AIStrokeStyle AIColor color Stroke color. AIBoolean overprint Overprint - not meaningful if the color is a pattern. AIReal width Line width in points. struct AIDashStyle dash Stroke dash. enum AILineCap cap Line cap. 12345678910Types of line caps for strokes. Enumerator: kAIButtCap Butt line caps.//平头 kAIRoundCap Round line caps.//圆头 kAIProjectingCap Projecting line caps.//方头 enum AILineJoin join Line join 12345678Types of line joins for strokes.Enumerator:kAIMiterJoin Miter line joins.//斜接连接kAIRoundJoin Round line joins.//圆角连接 AIReal miterLimit Line miter limit. AIFillStyle AIColor color Fill color. AIBoolean overprint When true, print any art beneath this, then print the fill of this object over it. 使用实例123456789101112131415161718192021222324252627282930313233343536373839bool isArtStyle=true;//是否使用图形样式库设置样式if (isArtStyle)&#123; AIArtStyleHandle artStyle=NULL; sAIArtStyle-&gt;GetArtStyleByName(&amp;artStyle, ai::UnicodeString(artStyleName), 1); if (!artStyle)&#123; sAIArt-&gt;DisposeArt(art); return -1; &#125; sAIArtStyle-&gt;SetArtStyle(art, artStyle);&#125;else&#123; AIColor color; AIColor colorFill; float CMYK[4] = &#123;23,211,22,56&#125;; float CMYKFill[4] = &#123;23,223,12,53&#125;; // 描边颜色 color.kind = kFourColor; color.c.f.cyan = CMYK[0]; color.c.f.magenta = CMYK[1]; color.c.f.yellow = CMYK[2]; color.c.f.black = CMYK[3]; //内部填充颜色 colorFill.kind = kFourColor; colorFill.c.f.cyan = CMYKFill[0]; colorFill.c.f.magenta = CMYKFill[1]; colorFill.c.f.yellow = CMYKFill[2]; colorFill.c.f.black = CMYKFill[3]; AIPathStyle PathStyle; PathStyle.fillPaint = true; // 面内颜色填充 设置为true 否则无法在面内填充颜色 PathStyle.strokePaint = true; PathStyle.stroke.width = 0.5; PathStyle.stroke.color = color; PathStyle.fill.color = colorFill; // 内部填充 sAIPathStyle-&gt;SetPathStyle(art, &amp;PathStyle); //设置透明度 sAIBlendStyle-&gt;SetOpacity(art, 0.4);&#125; 相关文章AI组件开发（一）–注记旋转矩阵AI组件开发（二）–AIRealMathSuiteAI组件开发（三）–AIArtboardSuiteAI组件开发（四）–AIDocumentSuiteAI组件开发（五）–AILayerSuiteAI组件开发（六）–AIArtSuiteAI组件开发（七）–AIPathSuite&amp;&amp;AIPathfinderSuiteAI组件开发（八）–AIArtStyleSuite","tags":[]},{"title":"AI组件开发（七）--AIPathSuite&&AIPathfinderSuite","date":"2019-03-25T01:11:13.000Z","path":"2019/03/25/ai-seven-path-note/","text":"AIPathSuite提供的功能允许检查和操作路径,AIPathfinderSuite提供了对路径执行操作的功能，这些功能将各种效果应用于选定的路径图Table of Contents generated with DocToc AIPathSuite 注册声明 方法 AIPathSegment 使用实例 AIPathfinderSuite 注册声明 方法 相关类，结构体，指针 AIPathfinderData AIOptions AIParameters AIMixParameters AITrapParameters AIFilterMessage SPMessageData AIFilterHandle PlatformFilterParameters AIPathSuite此套件提供的功能允许您检查和操作路径，这些路径是art类型的对象kPathArt。 路径的形状由一个或多个路径段定义。路径的每一个段对应于一个锚点，它是在选择路径时显示的手柄。路径上的锚点数或段 数包括每端的两个。段由AIPathSegment结构定义。段索引号从零开始。路径可以有一个锚点。 段的入点和出点定义点p处的曲线的切线。中间点不用于开放路径的初始段和最终段。段可以是角点或平滑点。对于一个角落，进出点可以在任何地方。要形成一条直线，请将每个端点的入点和出点放在它们的p点上。 路径可以是关闭的或打开的。如果路径是打开的，则仅由其段定义。如果它已关闭，Illustrator将在第一个和最后一个锚点之间绘制一个段，该段使用最后一个段的out切线和第一个段的切线。 一些路径也用作指南。在所有其他方面，它们是具有相同内容和属性的路径。绘制属性与通过路径 样式的路径相关联。见AIPathStyleSuite。 使用SPBasicSuite::AcquireSuite()常量kAIPathSuite和使用获取此套件kAIPathVersion。 注册声明123456789101112131415//xxxSuites.h#include &quot;Suites.hpp&quot;#include &quot;AIArtConverter.h&quot;extern &quot;C&quot; AIPathSuite* sAIPath;//xxxSuites.cppextern &quot;C&quot;&#123; AIPathSuite* sAIPath=NULL;&#125;ImportSuite gImportSuites[] = &#123; IMPORT_TEXT_SUITES kAIPathSuite,kAIPathSuiteVersion,&amp;sAIPath, nil, 0, nil &#125;; 方法 AIAPI AIErr（* GetPathSegmentCount）（AIArtHandle path，ai :: int16 * count） 获取路径上的锚点数，包括每端的两个锚点。 AIAPI AIErr（* SetPathSegmentCount）（AIArtHandle path，ai :: int16 count） 从段中删除段或将段附加到路径末尾。 AIAPI AIErr（* GetPathSegments）（AIArtHandle path，ai :: int16 segNumber，ai :: int16 count，AIPathSegment segments []） 从路径中检索一组段。 AIAPI AIErr（* SetPathSegments）（AIArtHandle path，ai :: int16 segNumber，ai :: int16 count，const AIPathSegment segments []） 添加或更新路径中的段。 AIAPI AIErr（* InsertPathSegments）（AIArtHandle path，ai :: int16 segNumber，ai :: int16 count，const AIPathSegment segments []） 将段插入路径。 AIAPI AIErr（* DeletePathSegments）（AIArtHandle path，ai :: int16 segNumber，ai :: int16 count） 从路径中删除段。 AIAPI AIErr（* GetPathClosed）（AIArtHandle path，AIBoolean *closed） 报告路径是否已关闭。 AIAPI AIErr（* SetPathClosed）（AIArtHandle path，AIBoolean closed） 打开或关闭路径。 AIAPI AIErr（* GetPathGuide）（AIArtHandle path，AIBoolean * isGuide） 报告路径是否用作指南。 AIAPI AIErr（* SetPathGuide）（AIArtHandle path，AIBoolean isGuide） 设置是否将路径用作指南。 AIAPI AIErr（* GetPathSegmentSelected）（AIArtHandle path，ai :: int16 segNumber，ai :: int16 *selected） 报告是否选择了路径段的任何部分。 AIAPI AIErr（* SetPathSegmentSelected）（选择AIArtHandle path，ai :: int16 segNumber，ai :: int16 selected） 设置段的选择状态。 AIAPI AIErr（* ReversePathSegments）（AIArtHandle path） 反转路径中段的顺序。 AIAPI AIErr（* GetPathArea）（AIArtHandle path，AIReal *area） 计算路径的面积。 AIAPI AIErr（* GetPathLength）（AIArtHandle path，AIReal *length，AIReal flatness） 计算以点为单位测量的路径周长。 AIAPI AIErr（* GetPathBezier）（AIArtHandle path，ai :: int16 segNumber，AIRealBezier * bezier） 计算路径段的贝塞尔曲线值。 AIAPI AIErr（* PathHasLength）（AIArtHandle path，AIBoolean * hasLength） 报告路径是否有长度。 AIAPI AIErr（* GetPathIsClip）（AIArtHandle path，AIBoolean * isClip） 报告路径是否为剪切路径。 AIAPI AIErr（* GetPathAllSegmentsSelected）（AIArtHandle path，选择AIBoolean *） 报告是否选择了路径的所有段。 AIAPI AIErr（* GetKeySegment）（AIArtHandle * path，ai :: int16 * segmentNumber） 检索关键锚点的路径对象和段号（即，其他锚点对齐的那个）。 AIAPI AIErr（* CancelKeySegment）（void） AIAPI AIBoolean（* IsPath9SliceSplitter）（AIArtHandle path） 报告路径是否为9切片分割器; 也就是说，该指南定义了将艺术板分成9个区域的线。 AIAPI AIErr（* SetKeySegment）（AIArtHandle path，ai :: int16 segmentNumber） 设置艺术对象的关键锚点。 AIAPI AIErr（* MeasureSegments）（AIArtHandle path，ai :: int16 startSeg，ai :: int16 count，AIReal pieceLengths []，AIReal accumulationLengths []） 测量路径段的长度。 AIAPI AIErr（* LengthFractionToBezierPos）（AIArtHandle path，AIReal lengthFraction，ai :: int16＆segIndex，AIReal＆bezierT，const AIReal pieceLengths []，const AIReal accumulationLengths []） 计算作为沿路径的路径长度的给定分数的点的段索引和参数贝塞尔t值。 AIAPI AIErr（* BezierPosToLengthFraction）（AIArtHandle path，ai :: int16 segIndex，AIReal bezierT，AIReal＆lengthFraction，const AIReal pieceLengths []，const AIReal accumulationLengths []） 计算对应于沿路径的位置的总路径长度的分数，该路径表示为段索引，并且将参数贝塞尔t值表示到该段中。 AIAPI AIErr（* BezierPosToAnchoredPos）（AIArtHandle path，ai :: int16 segIndex，AIReal t，AIReal * segLength，AIReal * segLengthFraction） 从参数贝塞尔曲线t值转换为线段长度的一部分。 AIAPI AIErr（* PerpendicularsAtBezierT）（AIArtHandle path，ai :: int16 segIndex，AIReal t，AIReal leftDistance，AIReal rightDistance，AIRealPoint＆pointOnPath，AIRealPoint * leftPoint，AIRealPoint * rightPoint） 计算与表示为段索引和参数贝塞尔t值的位置处的路径垂直（正常）的线段的端点 AIPathSegmentContents Suites Classes Class Index Member IndexAIPathSegment Struct ReferenceDefines a path segment. More… #include &lt;AIPath.h&gt; List of all members. Public AttributesAIRealPoint pAIRealPoint inAIRealPoint outAIBoolean corner 使用实例12345678910111213141516171819202122232425//SetPathSegmentCountlong curCount=10;//定义环面点数AIArtHandle artGroup = NULL;sAIArt-&gt;GetFirstArtOfLayer(PolygonLayer, &amp;artGroup);AIArtHandle art = NULL;sAIArt-&gt;NewArt(kPathArt, kPlaceInsideOnTop, artGroup, &amp;art);sAIPath-&gt;SetPathSegmentCount(art, (short)curCount);AIPathSegment *segment = new AIPathSegment[curCount];AIRealPoint *AIPoint = new AIRealPoint[curCount];...//赋值操作for (int i = 0; i &lt; curCount; i++)&#123; segment[i].p.h = AIPoint[i].h; segment[i].p.v = AIPoint[i].v; segment[i].in = segment[i].out = segment[i].p; segment[i].corner = true;&#125;//SetPathSegmentssAIPath-&gt;SetPathSegments(art, 0, curCount, segment);delete[] segment;delete[] AIPoint;//SetPathClosedsAIPath-&gt;SetPathClosed(art, 1);arts.push_back(art); AIPathfinderSuite该套件提供了对路径（类型的艺术对象kPathArt）执行操作的功能，这些功能将各种效果应用于选定的路径图。这些操作与“路径查找器”调板和“效果”菜单中的操作相对应。附加功能允许操作复合 形状，可以应用效果的插件组。见AIPluginGroupSuite。在复合形状组中，绘制组中的底部对象，然后根据交互模式（AIShapeMode）由其上方的下一个对象进行修改。可以将每个后续对象添加到图形中，从图形中减去，相交或从图形中排除。 使用SPBasicSuite::AcquireSuite()常量kAIPathfinderSuite和使用获取此套件kAIPathfinderVersion。 注册声明123456789101112131415//xxxSuites.h#include &quot;Suites.hpp&quot;#include &quot;AIPathfinder.h&quot;extern &quot;C&quot; AIPathfinderSuite* sAIPathfinder;//xxxSuites.cppextern &quot;C&quot;&#123; AIPathfinderSuite* sAIPathfinder=NULL;&#125;ImportSuite gImportSuites[] = &#123; IMPORT_TEXT_SUITES kAIPathfinderSuite,kAIPathfinderSuiteVersion,&amp;sAIPathfinder, nil, 0, nil &#125;; 方法 AIAPI AIErr（* DoUniteEffect）（AIPathfinderData *data，AIFilterMessage *message） 对选定的艺术应用Unite效果。 AIAPI AIErr（* DoIntersectEffect）（AIPathfinderData * data，AIFilterMessage * message） 将相交效果应用于选定的art。 AIAPI AIErr（* DoExcludeEffect）（AIPathfinderData *data，AIFilterMessage *message） 对所选art应用排除效果。 AIAPI AIErr（* DoBackMinusFrontEffect）（AIPathfinderData * data，AIFilterMessage * message） 对选定的art应用前后减去效果。 AIAPI AIErr（* DoFrontMinusBackEffect）（AIPathfinderData *data，AIFilterMessage *message） 对选定的art应用前后减去效果。 AIAPI AIErr（* DoDivideEffect）（AIPathfinderData *data，AIFilterMessage *message） 对所选art应用分割效果。 AIAPI AIErr（* DoOutlineEffect）（AIPathfinderData * data，AIFilterMessage * message） 将轮廓效果应用于选定的art。 AIAPI AIErr（* DoTrimEffect）（AIPathfinderData *data，AIFilterMessage *message） 对所选art应用修剪效果。 AIAPI AIErr（* DoMergeEffect）（AIPathfinderData *data，AIFilterMessage *message） 对选定的art应用合并效果。 AIAPI AIErr（* DoCropEffect）（AIPathfinderData *data，AIFilterMessage *message） 将裁剪效果应用于选定的art。 AIAPI AIErr（* DoHardEffect）（AIPathfinderData *data，AIFilterMessage *message） 对选定的art应用硬效果。 AIAPI AIErr（* DoSoftEffect）（AIPathfinderData *data，AIFilterMessage *message） 对选定的art应用柔和效果。 AIAPI AIErr（* DoTrapEffect）（AIPathfinderData *data，AIFilterMessage *message） 对选定的art应用陷印效果。 AIAPI AIErr（* GetHardEffectParameters）（AIPathfinderData *data，AIFilterMessage *message） 获得硬效果路径查找器操作的参数。 AIAPI AIErr（* GetSoftEffectParameters）（AIPathfinderData *data，AIFilterMessage *message） 获得Soft效果路径查找器操作的参数。 AIAPI AIErr（* GetTrapEffectParameters）（AIPathfinderData * data，AIFilterMessage * message） 获得陷阱效果路径查找器操作的参数。 AIAPI AIErr（* GetGlobalOptions）（AIPathfinderData *data，AIFilterMessage *message） 获得“路径查找器”和“效果”操作的全局选项。AIAPI AIShapeMode（* GetShapeMode）（AIArtHandle art） 获得art插件组对象的复合形状模式。 AIAPI AIErr（* SetShapeMode）（AIArtHandle art，AIShapeMode mode） 设置art插件组对象的复合形状模式。 AIAPI AIErr（* NewCompoundShape）（ai :: int16 paintOrder，AIArtHandle prep，AIArtHandle * newArt） 在当前文档的art树的绘制顺序中的指定位置创建新的空复合形状。 AIAPI AIErr（* IsCompoundShape）（AIArtHandle art，AIBoolean * isCompoundShape） 报告art品是否为复合形状。 AIAPI AIErr（* FlattenArt）（AIArtHandle * inOutArt） 通过将Unite效果应用于每个组件art对象，将形状扩展为单个路径或复合路径。 相关类，结构体，指针AIPathfinderDataAIOptions options Options that control how pathfinder operations are performed.AIParameters parameters Parameters for mixing and trapping operations.AIArtHandle * fSelectedArt A pointer to an array of selected art objects on which to perform the operation.ai::int32 fSelectedArtCount The number of members of the fSelectedArt array.ai::int32 fAlertInfoID Not used. AIOptions控制路径查找器操作执行方式的选项。double ipmPrecision Pathfinding precision, in microns.ai::int32 removeRedundantPoints Nonzero to remove redundant points.ai::int32 flags Option flags, a logical OR of AIOptionsFlagValues. AIOptionsFlagValues kExtractUnpaintedArtwork设置后，从处理结果中删除未配色的图稿。 kAllowEmptyOutput当设置时，这些功能可以产生空的输出：AIPathfinderSuite::DoBackMinusFrontEffect()，AIPathfinderSuite::DoFrontMinusBackEffect()，AIPathfinderSuite::DoIntersectEffect()，AIPathfinderSuite::DoExcludeEffect()。 kIgnoreEvenOddFillRule设置时，假设所有路径都使用非零填充规则而不是偶数填充规则。 kSuppressProgressDialog设置后，在路径查找器操作期间禁止进度报告。适用于AI 13及更高版本。 kDeselectResultArts设置后，将取消选择结果对象。适用于AI 13及更高版本。 AIParameters混合和捕获参数AIMixParameters mixParameters Parameters for mixing operations.AITrapParameters trapParameters Parameters for trapping operations. AIMixParametersdouble softRate The percentage of visibility in overlapping colors.ai::int32 convertCustomColors Nonzero to convert custom colors when mixing. AITrapParameters这些对应于Pathfinder调色板的Trap对话框中提供的UI值; 有关说明，请参阅用户文档double trapThickness Trap thickness, in points.double heightWidthAspectRatio Height to width aspect ratio.double trapTint Tint.double maximumTint Maximum tint (default is recommended).double tintTolerance Tint tolerance (default is recommended).ai::int32 reverseTrap Nonzero to reverse trap.ai::int32 convertCustomColors Nonzero to convert custom colors. AIFilterMessage过滤器获取参数或Go选择器的消息。SPMessageData d The message data.AIFilterHandle filter The filter object.PlatformFilterParameters parameters The parameter values, in a developer-defined parameter structure. SPMessageDataai::int32 SPCheck kSPValidSPMessageData if this is a valid PICA message.struct SPPlugin * self This plug-in, an SPPluginRef.void * globals An array of application-wide global variables.struct SPBasicSuite * basic A pointer to the basic PICA suite, which you use to obtain all other suites. AIFilterHandletypedef struct _t_AIFilterOpaque * AIFilterHandle Opaque reference to a filter. PlatformFilterParameters使用实例123456789101112131415161718192021//arts已定义好的art对象数组list&lt;AIArtHandle&gt;::iterator artIT = arts.begin(); if (artCount &gt; 1)&#123; AIArtHandle* artArr = (AIArtHandle *)(malloc(sizeof(AIArtHandle)*artCount)); for (int i = 0; i &lt; artCount; i++)&#123; artArr[i] = *artIT; artIT++; &#125; AIFilterMessage message; AIPathfinderData findData; findData.fSelectedArt = artArr; findData.fSelectedArtCount = artCount; AIOptions option; option.ipmPrecision = 100; option.flags = kExtractUnpaintedArtwork; option.removeRedundantPoints = 1; findData.options = option; //应用排除效果 sAIPathfinder-&gt;DoExcludeEffect(&amp;findData, &amp;message); delete[] artArr; &#125; 相关文章AI组件开发（一）–注记旋转矩阵AI组件开发（二）–AIRealMathSuiteAI组件开发（三）–AIArtboardSuiteAI组件开发（四）–AIDocumentSuiteAI组件开发（五）–AILayerSuiteAI组件开发（六）–AIArtSuiteAI组件开发（七）–AIPathSuite&amp;&amp;AIPathfinderSuiteAI组件开发（八）–AIArtStyleSuite","tags":[{"name":"AI","slug":"AI","permalink":"http://11wy11.github.io/tags/AI/"}]},{"title":"AI组件开发（六）--AIArtSuite","date":"2019-03-24T13:43:22.000Z","path":"2019/03/24/ai-six-aiart-note/","text":"Adobe Illustrator 文档中绘制的所有图形均为Art，相关操作函数在AIArtSuite中定义 AIArtSuite此套件允许您访问和修改Illustrator文档中的图稿。 它提供了创建和删除对象，重新排列对象以及获取和设置对象信息的功能。您可以使用这些函数来导航图形对象树，以及获得或修改有关图形对象的一般信息，例如它们的边界或锁定状态。 Art套件是实现大多数插件的基础。Illustrator文档由一个由a引用的图形对象的集合组成AIArtHandle。这是指向文档图稿数据库中图形对象的不透明指针。通过Art suite的访问器功能访问这些字段。 艺术对象可以表示单个实体，诸如路径，文本块或放置的图像，或一组对象，诸如路径的集合。艺术类型标识符（AIArtType）表示艺术品的类型。 使用SPBasicSuite::AcquireSuite()常量kAIArtSuite和使用获取此套件kAIArtVersion。 注册声明123456789101112131415//xxxSuites.h#include &quot;Suites.hpp&quot;#include &quot;AIArtConverter.h&quot;extern &quot;C&quot; AAIArtSuite* sAIArt ;//xxxSuites.cppextern &quot;C&quot;&#123;AIArtSuite* sAIArt = NULL;&#125;ImportSuite gImportSuites[] = &#123; IMPORT_TEXT_SUITES kAIArtSuite, kAIArtSuiteVersion, &amp;sAIArt, nil, 0, nil &#125;; 方法 AIAPI AIErr（* NewArt）（ai :: int16类型，ai :: int16 paintOrder，AIArtHandle prep，AIArtHandle * newArt） 创建一个新的Art对象。 AIAPI AIErr（* DisposeArt）（AIArtHandle Art） 从文档中删除Art对象。 AIAPI AIErr（* ReorderArt）（AIArtHandle thisArt，ai :: int16 paintOrder，AIArtHandle prep） 更改Art对象的绘制顺序，或将路径移入或移出复合路径或组。 AIAPI AIErr（* DuplicateArt）（AIArtHandle thisArt，ai :: int16 paintOrder，AIArtHandle prep，AIArtHandle * newArt） 使用深层复制复制Art对象（组和复合路径的子项也是重复的）。 AIAPI AIErr（* GetFirstArtOfLayer）（AILayerHandle图层，AIArtHandle *Art） 获得图层中的第一个Art对象，该图层包含该图层中的所有Art。 AIAPI AIErr（* GetLayerOfArt）（AIArtHandle art，AILayerHandle *layer） 获得Art对象的父图层（如果有）。 AIAPI AIErr（* GetArtType）（AIArtHandle art，short * type） 获得Art对象的类型。 AIAPI AIErr（* GetArtUserAttr）（AIArtHandle art，ai :: int32 whichAttr，ai :: int32 * attr） 获得Art对象的用户属性; 也就是说，标志显示它是被选中，隐藏还是被锁定。 AIAPI AIErr（* SetArtUserAttr）（AIArtHandle art，ai :: int32 whichAttr，ai :: int32 attr） 设置对象的用户属性; 也就是说，标志显示它是被选中，隐藏还是被锁定。 AIAPI AIErr（* GetArtParent）（AIArtHandle art，AIArtHandle *parent） 获得Art对象的父组。 AIAPI AIErr（* GetArtFirstChild）（AIArtHandle art，AIArtHandle *child） 获得组对象的第一个子对象。 AIAPI AIErr（* GetArtSibling）（AIArtHandle art，AIArtHandle *sibling） 获得同一组中的下一个对象。 AIAPI AIErr（* GetArtPriorSibling）（AIArtHandle art，AIArtHandle *sibling） 获得同一组中的上一个对象。 AIAPI AIErr（* GetArtBounds）（AIArtHandle art，AIRealRect * bounds） 获得Art对象的包围矩形。 AIAPI AIErr（* SetArtBounds）（AIArtHandle art） 更新Art对象的封闭矩形（边界框）的缓存信息。 AIAPI AIErr（* GetArtCenterPointVisible）（AIArtHandle art，AIBoolean *visible） 检查Art品的中心点是否可见。 AIAPI AIErr（* SetArtCenterPointVisible）（AIArtHandle art，AIBoolean visible） 选择对象时，可以使Art品的中心点可见或不可见。 AIAPI AIErr（* GetArtTransformBounds）（AIArtHandle art，AIRealMatrix * transform，ai :: int32 flags，AIRealRect * bounds） 应用变换矩阵后，获得Art对象的几何边界。 AIAPI AIErr（* UpdateArtworkLink）（AIArtHandle art，AIBoolean force，AIBoolean *updated） 检查给定容器的子树中包含的任何链接对象（链接图像或放置对象）是否需要更新，并在需要时更新它们。 AIAPI AIBoolean（* ValidArt）（AIArtHandle art，AIBoolean searchAllLayerLists） 如果Art对象引用有效，则返回true。 AIAPI AIErr（* GetArtOrder）（AIArtHandle art1，AIArtHandle art2，short * order） 获取两个Art品的绘画顺序或遏制关系。 AIAPI AIErr（* SelectNamedArtOfLayer）（AILayerHandle图层，const ai :: UnicodeString＆name，AIBoolean matchWholeWord，AIBoolean caseSensitive） 通过将字符串与Art对象注释的内容进行匹配来选择图层的指定图稿。 AIAPI AIErr（* GetArtRotatedBounds）（AIArtHandle art，AIReal angle，ai :: int32 flags，AIRealRect * bounds） 旋转后获得Art对象的包围矩形。 AIAPI AIBoolean（* ArtHasFill）（AIArtHandle art） 如果Art对象或后代对象绘制应被视为填充的内容，则返回true。 AIAPI AIBoolean（* ArtHasStroke）（AIArtHandle art） 如果Art对象或后代对象绘制应被视为笔划的内容，则返回true。 AIAPI AIBoolean（* ArtsHaveEqualPaths）（AIArtHandle art1，AIArtHandle art2） 如果两个Art对象除了组，路径和复合路径之外只包含其他内容，并且它们具有相同的几何（控制点），则返回true。 AIAPI AIErr（* ArtCopyFillStyleIfEqualPaths）（AIArtHandle dstArt，AIArtHandle srcArt） 未在AI11及更高版本中实施; 回报kNotImplementedErr。 AIAPI AIErr（* ArtCopyStrokeStyleIfEqualPaths）（AIArtHandle dstArt，AIArtHandle srcArt） 未在AI11及更高版本中实施; 回报kNotImplementedErr。 AIAPI AIErr（* GetInsertionPoint）（AIArtHandle * art，short * paintorder，AIBoolean * editable） 获得文档的插入点。 AIAPI AIErr（* SetInsertionPoint）（AIArtHandle art） 设置文档的插入点。 AIAPI AIErr（* GetKeyArt）（AIArtHandle *Art） 获得对象对齐的关键对象。 AIAPI AIErr（* CancelKeyArt）（无效） 清除对象对齐的关键对象。 AIAPI AIErr（* GetDictionary）（AIArtHandle art，struct _AIDictionary ** dictionary） 获得与Art对象关联的字典。 AIAPI AIErr（* SetArtName）（AIArtHandle art，const ai :: UnicodeString＆name） 设置Art对象的名称。 AIAPI AIErr（* GetArtName）（AIArtHandle art，ai :: UnicodeString＆name，ASBoolean * isDefaultName） 获得Art对象的名称。 AIAPI AIErr（* IsArtLayerGroup）（AIArtHandle art，ASBoolean * isLayerGroup） 报告Art对象是否是与图层或子图层对应的组。 AIAPI AIErr（* ReleaseToLayers）（常量AIArtHandle技术中，ASBoolean版本） 将图层，组或插件组的元素释放到单独的图层。 AIAPI AIErr（* ModifyTargetedArtSet）（AIArtHandle * list，ai :: int32 count，ai :: int32 action） 使用指定的操作修改文档中的目标对象集。 AIAPI AIBoolean（* IsArtStyledArt）（AIArtHandle art） 如果art是另一个对象的样式Art的一部分，则返回true。 AIAPI AIBoolean（* IsArtClipping）（AIArtHandle art） 如果art添加到剪辑，则返回true 。 AIAPI AIErr（* TransferAttributes）（AIArtHandle srcart，AIArtHandle dstart，ai :: uint32 which） 将源Art对象的属性传输到目标Art对象。 AIAPI AIErr（* GetArtLastChild）（AIArtHandle art，AIArtHandle *child） 获得容器Art对象的最后一个子项。 AIAPI AIErr（* SetArtTextWrapProperty）（AIArtHandle art，AIReal offset，AIBoolean invert） 设置影响文本环绕文本换行对象的方式的属性; 也就是说，kArtIsTextWrap设置属性的那个。 AIAPI AIErr（* GetArtTextWrapProperty）（AIArtHandle art，AIReal * offset，AIBoolean * invert） 获得影响文本环绕文本换行对象的方式的属性; 也就是说，kArtIsTextWrap设置属性的那个。 AIAPI AIErr（* CreateCopyScope）（枚举AICopyScopeKind类，AICopyScopeHandle *范围） 创建并设置复制范围。 AIAPI AIErr（* DestroyCopyScope）（AICopyScopeHandle范围） 取消并销毁复制范围。 AIAPI AIErr（* InsertionPointBadForArtType）（ai :: int16 paintOrder，AIArtHandle prep，ai :: int16 artType） 检查在给定插入点处创建或插入给定类型的Art对象是否可以。 AIAPI AIErr（* PreinsertionFlightCheck）（AIArtHandle candidateArt，ai :: int16 paintOrder，AIArtHandle prep） 根据插入上下文和候选Art的属性，检查是否可以在指定的插入点处插入Art对象或其副本，而无需实际尝试插入。 AIAPI AIErr（* SetNote）（AIArtHandle art，const ai :: UnicodeString＆inNote） 设置Art对象的音符属性，该属性通常包含用户输入的文本。 AIAPI AIErr（* GetNote）（AIArtHandle art，ai :: UnicodeString＆outNote） 获得Art对象的注释属性文本，该文本通常包含用户输入的文本。 AIAPI AIBoolean（* HasNote）（AIArtHandle art） 检查Art品是否附有说明。 AIAPI无效（* 删除注意）（AIArtHandle art） 删除附加到Art对象的注释（如果有）。 AIAPI AIErr（* GetArtXMPSize）（AIArtHandle art，size_t * size） 获取与Art对象关联的XMP元数据的大小。 AIAPI AIErr（* GetArtXMP）（AIArtHandle art，char * xmp，size_t size） 获得与Art对象的XMP元数据关联的XML数据包。 AIAPI AIErr（* SetArtXMP）（AIArtHandle art，const char * xmp） 设置Art对象的XMP元数据，替换任何现有数据。 AIAPI AIErr（* GetPreciseArtTransformBounds）（AIArtHandle art，AIRealMatrix * transform，ai :: int32 flags，AIDoubleRect * bounds） 应用变换矩阵后，获得Art对象的几何边界。 AIAPI AIErr（* UncheckedDisposeArt）（AIArtHandle art） 从Art树中删除Art对象，对输入的有效性进行最低限度检查，以便最大限度地提高性能。 AIAPI AIErr（* ArtIsGraph）（AIArtHandle art，AIBoolean * artisgraph） 报告Art对象是否为图形对象类型。 AIAPI AIErr（* SetKeyArt）（AIArtHandle art） 将Art设置为对象对齐的KeyArt。关键对象是其他对象对齐的对象。 AIAPI AIErr（* GetDrawingMode）（ai :: int32 * mode） 获得当前文档的绘图模式。 AIAPI AIErr（* SetDrawingMode）（ai :: int32模式） 设置当前文档的绘图模式。 AIAPI AIErr（* GetInsertionPointForDrawingMode）（ai :: int32模式，AIArtHandle * art，short * paintorder，AIBoolean * editable） 根据绘图模式获得当前文档的插入点。 AIAPI AIErr（* GetInsertionPointForCurrentDrawingMode）（AIArtHandle * art，short * paintorder，AIBoolean * editable） 根据当前绘图模式获得当前文档的插入点。 AIAPI AIErr（* GetPathPolarity）（AIArtHandle art，ai :: int32 * polarity） 获得Art对象的路径极性。 AIAPI AIBoolean（* IsPixelPerfect）（AIArtHandle art） 报告Art品是否处于像素完美模式。 AIAPI AIErr（* SetPixelPerfect）（AIArtHandle art，AIBoolean isPixelPerfect） 为Art品打开或关闭像素完美模式。 AIAPI AIBoolean（* ObjectsAreEquivalent）（AIArtHandle art1，AIArtHandle art2） 比较两个Art对象以确定它们在几何，外观属性和字典内容中是否等效。通常，一个对象在当前文档中，另一个在另一个文档中。 AIAPI AIErr（* IsArtALayerInSymbol）（AIArtHandle art，AIBoolean * isLayerInSymbol） 报告Art对象是否充当符号模式中的图层。 AIAPI AIErr（* GetArtTimeStamp）（AIArtHandle art，size_t * timeStamp） 获得Art对象的修改时间戳。 paintOrder 枚举常量12345678910111213141516typedef enum AIPaintOrder &#123; /* Default value */ kPlaceDefault = 0, /** Place above the prepositional object */ kPlaceAbove = 1, /** Place below the prepositional object */ kPlaceBelow, /** Place within and at the top of the prepositional container */ kPlaceInsideOnTop, /** Place within and at the bottom of the prepositional container */ kPlaceInsideOnBottom, /** Place at the top of the paint order, ignoring prepositional object */ kPlaceAboveAll, /** Place at the bottom of the paint order, ignoring prepositional object */ kPlaceBelowAll&#125; AIPaintOrder; AIArtHandle1234typedef struct ArtObject* AIArtHandleOpaque reference to an art object.Access using AIArtSuite. 使用实例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495AIArtHandle artGroup = NULL;sAIArt-&gt;GetFirstArtOfLayer(PolygonLayer, &amp;artGroup);AIArtHandle art = NULL;sAIArt-&gt;NewArt(kPathArt, kPlaceInsideOnTop, artGroup, &amp;art);//setNotesAIArt-&gt;SetNote(&quot;该属性通常包含用户输入的文本。需要记录保存的信息，一般，号分割的字符串，不过插件一般使用Dictionary&quot;);//HasNote,GetNoteif (sAIArt-&gt;HasNote(artGroup))&#123; ai::UnicodeString infoNote; sAIArt-&gt;GetNote(artGroup, infoNote); &#125;//DisposeArtsAIArt-&gt;DisposeArt(artGroup);//设置隐藏图层内容不可见 AILayerHandle FirstLayer; AILayerHandle NextLayer = NULL; sAILayer-&gt;GetLayerFirstChild(m_hideLayer,&amp;FirstLayer); while(FirstLayer) &#123; AIArtHandle ArtGroup; AIArtHandle Art; sAIArt-&gt;GetFirstArtOfLayer(FirstLayer,&amp;ArtGroup); sAIArt-&gt;GetArtFirstChild(ArtGroup,&amp;Art); AILayerHandle LayerTemp; LayerTemp = FirstLayer; sAILayer-&gt;GetNextLayer(FirstLayer,&amp;FirstLayer); if(!Art) sAILayer-&gt;DeleteLayer(LayerTemp); &#125; sAILayer-&gt;SetLayerVisible(m_hideLayer, false); AIRealRect artRect; sAIArt-&gt;GetArtBounds(m_pointArt, &amp;artRect); sAIMathSuite-&gt;AIRealMatrixSetTranslate(&amp;maxtrix, ListIter-&gt;h - (artRect.right + artRect.left) / 2, ListIter-&gt;v - (artRect.top + artRect.bottom) / 2); sAITransformArt-&gt;TransformArt(m_pointArt, &amp;maxtrix, 1, kTransformObjects); sAIArt-&gt;SetArtName(m_pointArt, ai::UnicodeString(&quot;XXXX&quot;)); AIArtHandle textPathPoly = NULL; AIArtHandle textFrame;//已存在变量 sAIArt-&gt;DuplicateArt(textFrame, kPlaceBelow,textFrame, &amp;textPathPoly); AIArtHandle textFrameBackgroud;//已存在变量 sAIArt-&gt;ReorderArt(textFrameBackgroud, kPlaceInsideOnTop, ArtGroup); AIArtHandle outlines=NULL; sAITextFrame-&gt;CreateOutline(textFrame, &amp;outlines); AIArtHandle outlinef=NULL,outlinen=NULL; sAIArt-&gt;GetArtFirstChild(outlines, &amp;outlinef); //描边属性 AIPathStyle pathstyle; pathstyle.fillPaint = false; pathstyle.strokePaint = true; AIStrokeStyle strokestyle; strokestyle.width = this-&gt;borderWidth; strokestyle.cap = kAIRoundCap; strokestyle.join = kAIRoundJoin; strokestyle.color = borderColor; pathstyle.stroke = strokestyle; sAIPathStyle-&gt;SetPathStyle(outlinef, &amp;pathstyle); sAIArt-&gt;GetArtSibling(outlinef, &amp;outlinen); while (outlinen) &#123; sAIPathStyle-&gt;SetPathStyle(outlinen, &amp;pathstyle); sAIArt-&gt;GetArtSibling(outlinen, &amp;outlinen); &#125; sAIArt-&gt;DisposeArt(textFrame); //使用GetArtPriorSibling // get the previous art error = sArt-&gt;GetArtPriorSibling(art, &amp;art); if (error) return error; if (!art)&#123; // art was first in group // see if parent has previous art error = sArt-&gt;GetArtParent(art, &amp;art); if (error) return error; ... //使用GetArtParent ,GetArtSibling ... // see if parent has sibling error = sArt-&gt;GetArtParent(nextart, &amp;nextart); if (error) return error; error = sArt-&gt;GetArtSibling(nextart, &amp;nextart); if (error) return error; if (nextart) &#123; // parent has sibling ... &#125; 相关文章AI组件开发（一）–注记旋转矩阵AI组件开发（二）–AIRealMathSuiteAI组件开发（三）–AIArtboardSuiteAI组件开发（四）–AIDocumentSuiteAI组件开发（五）–AILayerSuiteAI组件开发（六）–AIArtSuiteAI组件开发（七）–AIPathSuite&amp;&amp;AIPathfinderSuiteAI组件开发（八）–AIArtStyleSuite","tags":[{"name":"AI","slug":"AI","permalink":"http://11wy11.github.io/tags/AI/"}]},{"title":"AI组件开发（五）--AILayerSuite","date":"2019-03-24T13:09:15.000Z","path":"2019/03/24/ai-fifth-ailayer-note/","text":"文档中的图稿包含在图层中。AILayerSuite有一堆图层列表。堆栈中最顶层的层是当前正在编辑的层 AILayerSuite每个图层都包含一组对象，可以包含子图层。所有文档都至少以一个图层开头，用户或插件可以向其添加任意数量的新图层。图层是图稿树的容器; 用于AIArtSuite::GetFirstArtOfLayer()获取属于图层的Art对象组。 除了包含图稿之外，图层还有一个名称，一种颜色（用于表示选定的art），以及指示其是可见，可编辑还是已锁定，可打印以及是否将放置的Art显示为灰色的状态标志。图层引用是不透明的; 使用此套件中的函数来获取和设置图层属性。 多个图层属性会影响图层上的图稿是否可编辑。通常，不能选择不可编辑图层上的对象，因此无需检查对当前选择进行操作的插件。但是，在迭代图层或图稿时，请GetLayerEditable()在尝试对图稿进行任何更改之前调用每个图层。 可以将图层指定为模板图层，其中包含用于指导文档图稿构造的模板图稿。例如，模板可能包含正在跟踪的图像。永远不会打印模板图层或将其导出为最终格式的文件格式。 有四个与图层关联的通知程序：kAICurrentLayerNotifierkAILayerDeletionNotifierkAILayerSetNotifierkAILayerOptionsNotifier 使用SPBasicSuite::AcquireSuite()常量kAILayerSuite和使用获取此套件kAILayerVersion。 注册声明1234567891011121314//xxxSuites.h#include &lt;AILayer.h&gt;extern &quot;C&quot; AILayerSuite\\* sAILayer;//xxxSuites.cppextern &quot;C&quot;&#123;AILayerSuite\\* sAILayer = NULL;&#125;ImportSuite gImportSuites[] = &#123; IMPORT_TEXT_SUITES kAILayerSuite, kAILayerSuiteVersion, &amp;sAILayer, nil, 0, nil &#125;; 方法 AIAPI AIErr（* CountLayers）（ai :: int32 * count） 获取当前文档图层列表中的顶级图层数。 AIAPI AIErr（* GetNthLayer）（ai :: int32 n，AILayerHandle *layer） 从当前文档中按索引获得顶级图层。 AIAPI AIErr（* GetCurrentLayer）（AILayerHandle *layer） 获得当前文档中当前图层的引用。 AIAPI AIErr（* SetCurrentLayer）（AILayerHandle layer） 使图层最新。 AIAPI AIErr（* GetFirstLayer）（AILayerHandle * first） 获得当前文档图层列表的最顶层。 AIAPI AIErr（* GetNextLayer）（AILayerHandle prev，AILayerHandle * next） 在堆叠顺序中获得给定图层下方的下一层，位于图层列表堆栈的同一级别。 AIAPI AIErr（* InsertLayer）（AILayerHandle layer，ai :: int16 paintOrder，AILayerHandle * newLayer） 向文档添加新图层，将其插入到相对于现有图层的绘制顺序的图层列表中。 AIAPI AIErr（* DeleteLayer）（AILayerHandle layer） 从当前文档中删除图层及其包含的所有图稿。 AIAPI AIErr（* GetLayerTitle）（AILayerHandle layer，ai :: UnicodeString＆title） 获得图层的名称。 AIAPI AIErr（* SetLayerTitle）（AILayerHandle layer，const ai :: UnicodeString＆newTitle） 设置图层的名称。 AIAPI AIErr（* GetLayerColor）（AILayerHandle layer，AIRGBColor *color） 获得在图层中勾画选定图稿时使用的颜色。 AIAPI AIErr（* SetLayerColor）（AILayerHandle layer，AIRGBColor color） 设置在图层中勾画选定图稿时使用的颜色。 AIAPI AIErr（* GetLayerVisible）（AILayerHandle layer，AIBoolean *visible） 报告图层的可见性状态，这会影响是否绘制图稿。 AIAPI AIErr（* SetLayerVisible）（AILayerHandle layer，AIBoolean visible） 设置图层的可见性状态，这会影响是否绘制图稿。 AIAPI AIErr（* GetLayerPreview）（AILayerHandle layer，AIBoolean *preview） 报告图层是指定预览模式还是轮廓模式。 AIAPI AIErr（* SetLayerPreview）（AILayerHandle layer，AIBoolean preview） 将图层设置为预览模式或轮廓模式。 AIAPI AIErr（* GetLayerEditable）（AILayerHandle layer，AIBoolean *editable） 报告图层是可编辑还是已锁定。 AIAPI AIErr（* SetLayerEditable）（AILayerHandle layer，AIBoolean editable） 设置图层是可编辑还是锁定。 AIAPI AIErr（* GetLayerPrinted）（AILayerHandle layer，AIBoolean *printed） 报告在打印文档时是否将此图层视为可打印。 AIAPI AIErr（* SetLayerPrinted）（AILayerHandle layer，AIBoolean printed） 设置打印文档时是否将此图层视为可打印。 AIAPI AIErr（* GetLayerDimPlacedImages）（AILayerHandle layer，AIBoolean * dimmed） 报告渲染时图层中的图像是否变暗（颜色向白色移动）。 AIAPI AIErr（* SetLayerDimPlacedImages）（AILayerHandle layer，AIBoolean dimmed） 设置渲染时图层中的图像是否变暗（颜色向白色移动）。 AIAPI AIErr（* GetLayerSelected）（AILayerHandle layer，AIBoolean *selected） 报告是否选择了图层。 AIAPI AIErr（* SetLayerSelected）（AILayerHandle layer，AIBoolean selected） 设置是否选择图层。 AIAPI AIErr（* GetLayerByTitle）（AILayerHandle *layer，const ai :: UnicodeString＆title） 按标题获得图层。 AIAPI AIErr（* LayerHasArt）（AILayerHandle layer，AIBoolean * hasArt） 报告图层是否包含子图层以外的对象。 AIAPI AIErr（* LayerHasSelectedArt）（AILayerHandle layer，AIBoolean * hasSel） 报告图层是否包含任何选定的图稿。 AIAPI AIErr（* 取消选择ArtOnLayer）（AILayerHandle layer） 取消选择图层上的所有对象。 AIAPI AIErr（* SelectArtOnLayer）（AILayerHandle layer） 选择可以选择的图层上的所有对象。 AIAPI AIErr（* GetLayerIsTemplate）（AILayerHandle layer，AIBoolean * isTemplate） 报告图层是否为模板图层。 AIAPI AIErr（* SetLayerIsTemplate）（AILayerHandle layer，AIBoolean isTemplate） 设置图层是否为模板图层。 AIAPI AIErr（* GetPrevLayer）（AILayerHandle接下来，AILayerHandle *prev） 在堆叠顺序中获得给定图层上方的图层。 AIAPI AIErr（* GetLayerDimmedPercent）（AILayerHandle layer，ai :: int32 *percent） 当图层设置为灰色时，获得用于绘制图像的调光因子。 AIAPI AIErr（* SetLayerDimmedPercent）（AILayerHandle layer，ai :: int32 percent） 设置图层设置为灰色时用于绘制图像的调光系数。 AIAPI AIErr（* GetLayerFirstChild）（const AILayerHandle layer，AILayerHandle *child） 获得图层的第一个子子图层。 AIAPI AIErr（* GetLayerParent）（const AILayerHandle layer，AILayerHandle * parent） 获得图层的父级。 AIAPI AIErr（* InsertLayerAtArt）（const AIArtHandle art，AIPaintOrder paintOrder，AILayerHandle * newLayer） 在相对于艺术对象的绘制顺序位置处将新图层插入到文档中。 AIAPI AIErr（* ChangeLayerToGroup）（const AILayerHandle layer，const AIArtHandle group） 将此图层的子图层转换为简单组。 AIAPI AIErr（* GetNextPreorderLayer）（AILayerHandle prev，AILayerHandle * next） 在前序遍历中获得下一层，首先查找后代，然后是兄弟姐妹。 AIAPI AIErr（* GetNextNonChildPreorderLayer）（AILayerHandle prev，AILayerHandle * next） 在前序遍历中获得下一层，跳过后代并仅返回兄弟层。 paintOrder 枚举常量12345678910111213141516typedef enum AIPaintOrder &#123; /** Default value */ kPlaceDefault = 0, /** Place above the prepositional object */ kPlaceAbove = 1, /** Place below the prepositional object */ kPlaceBelow, /** Place within and at the top of the prepositional container */ kPlaceInsideOnTop, /** Place within and at the bottom of the prepositional container */ kPlaceInsideOnBottom, /** Place at the top of the paint order, ignoring prepositional object */ kPlaceAboveAll, /** Place at the bottom of the paint order, ignoring prepositional object */ kPlaceBelowAll&#125; AIPaintOrder; AILayerHandle12typedef struct _t_AILayerOpaque* AILayerHandleOpaque reference to a layer. 使用实例12345678910111213141516171819202122232425262728293031323334//使用InsertLayer，SetLayerTitle，GetLayerByTitle，DeleteLayerAILayerHandle m_pointLinePolyLayer;AILayerHandle m_borderMarkLayer;sAILayer-&gt;InsertLayer(m_pointLinePolyLayer, kPlaceInsideOnTop, &amp;m_borderMarkLayer);//在点线面图层上添加色带图层sAILayer-&gt;SetLayerTitle(m_borderMarkLayer, ai::UnicodeString(&quot;色带图层&quot;));//设置新添加图层名称AILayerHandle polyAnnoLayers;sAILayer-&gt;GetLayerByTitle(&amp;polyAnnoLayers, ai::UnicodeString(L&quot;面注记图层&quot;));//找到名为面注记图层的layersAILayer-&gt;DeleteLayer(polyAnnoLayers);//删除面注记图层layer//使用GetLayerFirstChild，GetNextLayerAILayerHandle m_hideLayer;AILayerHandle FirstLayer;AILayerHandle NextLayer = NULL;sAILayer-&gt;GetLayerFirstChild(m_hideLayer,&amp;FirstLayer);//遍历如果存在图稿，则删除该图层 while(FirstLayer) &#123; AIArtHandle ArtGroup; AIArtHandle Art; sAIArt-&gt;GetFirstArtOfLayer(FirstLayer,&amp;ArtGroup); sAIArt-&gt;GetArtFirstChild(ArtGroup,&amp;Art); AILayerHandle LayerTemp; LayerTemp = FirstLayer; sAILayer-&gt;GetNextLayer(FirstLayer,&amp;FirstLayer); if(!Art) sAILayer-&gt;DeleteLayer(LayerTemp); &#125; sAILayer-&gt;SetLayerVisible(m_hideLayer, false); //使用GetNthLayer获得最上面的图层AILayerHandle hideLayer = NULL; sAILayer-&gt;GetNthLayer(0, &amp;hideLayer); AILayerHandle childHideLayer = NULL; 相关文章AI组件开发（一）–注记旋转矩阵AI组件开发（二）–AIRealMathSuiteAI组件开发（三）–AIArtboardSuiteAI组件开发（四）–AIDocumentSuiteAI组件开发（五）–AILayerSuiteAI组件开发（六）–AIArtSuiteAI组件开发（七）–AIPathSuite&amp;&amp;AIPathfinderSuiteAI组件开发（八）–AIArtStyleSuite","tags":[{"name":"AI","slug":"AI","permalink":"http://11wy11.github.io/tags/AI/"}]},{"title":"AI组件开发（四）--AIDocumentSuite","date":"2019-03-24T12:19:52.000Z","path":"2019/03/24/ai-forth-document-note/","text":"获取和设置有关当前文档的信息。 AIDocumentSuite使用这些函数可以获取和设置有关当前文档的信息。某些功能仅在读取文件格式时适用。有些是在文件格式写入期间使用，但可以随时使用。 函数 AIAPI AIErr（* GetDocumentFileSpecification）（ai :: FilePath＆file） 获得当前文档的文件规范。 AIAPI AIErr（* GetDocumentPageOrigin）（AIRealPoint * origin） 获得相对于标尺原点指定的可成像页面左下角的坐标。 AIAPI AIErr（* SetDocumentPageOrigin）（AIRealPoint * origin） 设置可成像页面左下角的坐标。 AIAPI AIErr（* SetDocumentRulerOrigin）（AIRealPoint * origin） 设置当前文档的标尺原点。 AIAPI AIErr（* GetDocumentRulerUnits）（ai :: int16 *units） 获得当前测量单位，显示在标尺中并显示在对话框中。 AIAPI AIErr（* SetDocumentRulerUnits）（ai :: int16 units） 设置当前测量单位，显示在标尺中并显示在对话框中。 AIAPI AIErr（* GetDocumentCropStyle）（AICropMarkStyle * cropStyle） 获得由“创建裁剪标记”命令和过滤器创建的裁剪标记的样式。 AIAPI AIErr（* SetDocumentCropStyle）（AICropMarkStyle cropStyle） 设置“创建裁剪标记”命令和过滤器创建的裁剪标记的样式。 AIAPI AIErr（* GetDocumentSetup）（AIDocumentSetup * setup） 获得有关通过文档“设置”对话框设置的当前文档的信息。 AIAPI AIErr（* SetDocumentSetup）（AIDocumentSetup * setup） 设置文档设置信息，通过文档设置对话框设置。 AIAPI AIErr（* GetDocumentModified）（AIBoolean * modified） 获得文档自上次保存以来是否已被编辑。 AIAPI AIErr（* SetDocumentModified）（AIBoolean修改） 设置当前文档的修改状态。 AIAPI AIErr（* GetDocumentFileFormat）（AIFileFormatHandle * fileFormat） 获得保存当前文档时要使用的文件格式。 AIAPI AIErr（* SetDocumentFileFormat）（AIFileFormatHandle fileFormat） 设置保存当前文档时要使用的文件格式。 AIAPI AIErr（* GetDocumentFileFormatParameters）（AIDocumentFileFormatParameters *参数） 获得与当前文档的关联文件格式关联的用户参数块。 AIAPI AIErr（* SetDocumentFileFormatParameters）（AIDocumentFileFormatParameters参数） 设置与当前文档的关联文件格式关联的用户参数块。 AIAPI AIErr（* GetDocument）（AIDocumentHandle *文件） 获得当前文档的不透明引用，以便与可以对当前文档以外的文档进行操作的函数一起使用。 AIAPI AIErr（* WriteDocument）（const ai :: FilePath＆file，const char * fileFormatName，AIBoolean askForParms） 将当前文档写入文件而不修改文档或更改其修改状态。 AIAPI AIErr（* GetDocumentMiPrintRecord）（AIDocumentMiPrintRecordPtr打印） 获得当前文档的打印记录。 AIAPI AIErr（* GetDocumentRulerOrigin）（AIRealPoint * origin） 获得当前文档的标尺原点。 AIAPI AIErr（* UpdateLinks）（AIBoolean * updatedSomething） 如果需要，更新当前文档中的链接对象。 AIAPI AIErr（* GetDocumentZoomLimit）（AIReal * min，AIReal * max） 获得缩放的限制作为比例因子。 AIAPI AIErr（* GetDocumentMaxArtboardBounds）（AIRealRect * bounds） 获得任何画板的最大有效范围，相对于当前文档的标尺原点表示，而不管文档画板的当前大小。 AIAPI AIErr（* DocumentExists）（AIDocumentHandle文档，AIBoolean *exists） 报告文件是否存在; 也就是说，是一个打开的文档或剪贴板文档。 AIAPI AIErr（* GetDictionary）（struct _AIDictionary **Dictionary） 获得与当前文档关联的录制Dictionary。 AIAPI AIErr（* GetDocumentColorModel）（ai :: int16 * colorModel） 获得文档颜色模型。 AIAPI AIErr（* SetDocumentColorModel）（ai :: int16 colorModel） 在加载时设置文档的预期颜色模型。 AIAPI AIErr（* GetDocumentProfiles）（AIColorProfile * rgbProfile，AIColorProfile * cmykProfile，AIColorProfile * grayProfile） 获得当前文档的颜色校准配置文件。 AIAPI AIErr（* SetDocumentProfiles）（AIColorProfile rgbProfile，AIColorProfile cmykProfile，AIColorProfile grayProfile） 设置当前文档的颜色校准配置文件。 AIAPI AIErr（* Copy）（） 将当前选定的对象复制到剪贴板。 AIAPI AIErr（* Cut）（） 将当前选定的对象剪切到剪贴板。 AIAPI AIErr（* Paste）（） 将剪贴板的内容粘贴到文档中。 AIAPI AIErr（* AIDocumentSuite :: SyncDocument）更新缓存的图稿属性。例如，组的选择状态被缓存，并根据其子项的状态确定。您通常不需要调用此函数。Illustrator会根据需要重新计算缓存的属性。 AIAPI AIErr（* GetNonRecordedDictionary）（struct _AIDictionary **Dictionary） 获得与当前文档关联的未记录Dictionary。 AIAPI int（* GetAIVersion）（） 获得上次保存当前文档的Illustrator文件格式的版本。 AIAPI AIErr（* DocumentHasTransparency）（AIBoolean * hasTransparency，AIBoolean detectOverprint） 报告是否根据当前视图设置渲染当前文档需要任何非不透明的绘制操作。 AIAPI AIErr（* DocumentHasSpotColorArt）（AIBoolean * hasSpotColorArt） 报告是否根据当前视图设置渲染当前文档需要绘制任何专色。 AIAPI AIErr（* GetDocumentAssetMgmtInfo）（AIBoolean * managed，ai :: int32 * pNAlternates，AIBoolean * checkedOut，const char ** URL，AIBoolean * canEdit，char * fileType） 获得资产管理信息。 AIAPI AIErr（* SetDocumentAssetMgmtInfo）（AIBoolean * managed，AIBoolean * checkedOut，const char * URL，AIBoolean * canEdit） 设置资产管理信息。 AIAPI AIErr（* GetDocumentURL）（AIDocumentHandle文档，const char ** URL） 获得与文档关联的URL。 AIAPI AIErr（* GetDocumentXAP）（const char ** xap） 获得当前文档的XMP元数据。 AIAPI AIErr（* SetDocumentXAP）（const char * xap） 设置当前文档的XMP元数据。 AIAPI AIErr（* SuspendTextReflow）（） 暂停当前​​文档中所有文本对象的任何文本重排。 AIAPI AIErr（* ResumeTextReflow）（） 恢复文本重排。 AIAPI AIErr（* GetTextSelection）（TextRangesRef * pTextSelection） 获得当前文档的文本选择对象。 AIAPI AIErr（* HasTextFocus）（AIBoolean * focus） 报告当前文档是否处于文本编辑模式。 AIAPI AIErr（* HasTextCaret）（AIBoolean * caret） 报告当前文档是处于文本编辑模式还是插入符号闪烁（与选择的文本范围相反）。 AIAPI AIErr（* GetTextFocus）（StoryRef * pStory） 获得处于编辑模式的当前故事。 AIAPI AIErr（* SetTextFocus）（StoryRef故事） 将故事设置为处于编辑模式。 AIAPI AIErr（* LoseTextFocus）（） 退出文本编辑模式。 AIAPI AIErr（* GetDocumentTextResources）（DocumentTextResourcesRef * pDocResources） 获得当前文档的文本资源对象。 AIAPI AIErr（* WriteDocumentMacInformationResource）（const ai :: FilePath＆file） AIAPI AIErr（* WriteDocumentWithOptions）（const ai :: FilePath＆file，const char * fileFormatName，ai :: int32 options，AIBoolean askForParms） 将当前文档写入具有指定写入选项的文件，而不修改文档或更改其修改状态。 AIAPI AIErr（* DocumentHasOverprint）（AIBoolean * hasOverprint） 报告是否根据当前视图设置呈现当前文档需要绘制任何叠印对象。 AIAPI AIErr（* DocumentHasManagedLinks）（AIDocumentHandle文档，AIBoolean * hasManagedLinks） 报告文档是否包含任何托管链接。 AIAPI AIErr（* GetDocumentSpotColorMode）（AIDocumentHandle文档，AISpotColorMode *模式） 获得文档的专色模式，该模式控制添加到文档的新专色的外观定义。 AIAPI AIErr（* SetDocumentSpotColorMode）（AIDocumentHandle文档，AISpotColorMode模式，AIBoolean转换，AIBoolean *转换） 设置文档的专色模式，该模式控制添加到文档的新专色的外观定义。 AIAPI AIErr（* 撤消）（） 撤消最近的可撤消事务。 AIAPI AIErr（* 重做）（） 重做最近的可重做事务。 AIAPI AIErr（* DocumentRasterAttributes）（AIBoolean * hasDeviceNRasters，AIBoolean * hasOverprint） 报告当前文档是否包含任何DeviceN或叠印栅格。 AIAPI AIErr（* GetDocumentStartupProfile）（AIDocumentHandle文档，AIDocumentStartupProfile * startupProfile） 获得文档启动配置文件。 AIAPI AIErr（* GetDocumentBleeds）（AIRealRect * bleedOffset） 获得文档的bleedOffset。 AIAPI AIErr（* SetDocumentBleeds）（const AIRealRect＆bleedOffset） 设置文档的bleedOffset。 AIAPI AIErr（* SetDocumentPixelPerfectStatus）（AIBoolean isPixelPerfect） 打开或关闭文档的Pixel Perfect模式。 AIAPI AIBoolean（* GetDocumentPixelPerfectStatus）（） 报告文档当前是否处于Pixel Perfect模式。 使用实例 12345678910111213141516171819//xxxSuites.h#include &lt;AIDocument.h&gt;extern &quot;C&quot; AIDocumentSuite* sAIDocument;//xxxSuites.cppextern &quot;C&quot;&#123;AIDocumentSuite* sAIDocument = NULL;&#125;ImportSuite gImportSuites[] = &#123; IMPORT_TEXT_SUITES kAIDocumentSuite, kAIDocumentSuiteVersion, &amp;sAIDocument, nil, 0, nil &#125;;//XXXPlugin.cpp//绘制操作sAIDocument-&gt;SyncDocument();//更新图稿属性TextRangesRef rangesRef = NULL;sAIDocument-&gt;GetTextSelection(&amp;rangesRef);//获得当前文档的文本选择对象 相关文章AI组件开发（一）–注记旋转矩阵AI组件开发（二）–AIRealMathSuiteAI组件开发（三）–AIArtboardSuiteAI组件开发（四）–AIDocumentSuiteAI组件开发（五）–AILayerSuiteAI组件开发（六）–AIArtSuiteAI组件开发（七）–AIPathSuite&amp;&amp;AIPathfinderSuiteAI组件开发（八）–AIArtStyleSuite","tags":[{"name":"AI","slug":"AI","permalink":"http://11wy11.github.io/tags/AI/"}]},{"title":"AI组件开发（三）--AIArtboardSuite","date":"2019-03-24T08:53:24.000Z","path":"2019/03/24/ai-third-note/","text":"AIArtboardSuite此套件提供的实用程序允许在文档中创建和操作Artboards。相关类ArtboardProperties和ArtboardList AIArtboardSuite此套件提供的实用程序允许您在文档中创建和操作画板Artboards。文档与ArtboardList包含多个Artboard对象的对象相关联，每个ArtboardProperties对象与对象相关联。 建议您使用的包装类，ai::ArtboardProperties和ai::ArtboardList而不是直接调用这些功能。 使用SPBasicSuite::AcquireSuite()常量kAIArtboardSuite和使用获取此套件kAIArtboardSuiteVersion。1234567891011121314//xxxSuites.h#include &quot;AIArtboard.h&quot;extern &quot;C&quot; AIArtboardSuite* sAIArtboard;//xxxSuites.cppextern &quot;C&quot;&#123;AIArtboardSuite* sAIArtboard = NULL;&#125;ImportSuite gImportSuites[] = &#123; IMPORT_TEXT_SUITES kAIArtboardSuite, kAIArtboardSuiteVersion, &amp;sAIArtboard, nil, 0, nil &#125;; 目录 generated with DocToc AddNew CLoneArtboard 3.Delete 4.Dispose 5.GetActive 6.GetArtboardProperties 7.GetCount 8.GetName 9.GetPAR 10.GetPosition 11.GetRulerOrigin 12.GetShowDisplayMark 13.Init 14.Insert 15.IsDefaultName 16.ReleaseArtboardList 17. SetActive 18.SetIsDefaultName 19.SetName 20.SetPAR 21.SetPosition 22.SetRulerOrigin 23.SetShowDisplayMark 24.Update AddNewAIAPI AIErr（* AIArtboardSuite :: AddNew）（ai :: ArtboardList＆artboardList，ai :: ArtboardProperties＆newArtboard，ai :: ArtboardID ＆index）将新画板添加到当前文档并在画板列表中报告其索引位置。 参数： artboardList 画板列表对象。 newArtboard 新画板的属性对象。 index [out]一个缓冲区，用于返回新画板的从0开始的索引位置。 返回： kAIExceededMaxArtboardLimitErr列表大小超过应用程序定义的限制时的错误。 参考ai :: ArtboardList :: AddNew（） CLoneArtboardAIAPI AIErr（* AIArtboardSuite :: CloneArtboard）（ai :: ArtboardProperties &amp;artboard，const ai :: ArtboardProperties &amp;newArtboard）复制画板对象。 参数： artboard artboard属性要克隆。 newArtboard [out]用于返回新画图属性对象。 参考ai :: ArtboardProperties :: ArtboardProperties() 3.DeleteAIAPI AIErr（* AIArtboardSuite ::Delete）（ai :: ArtboardList &amp;artboardList，ai :: ArtboardID &amp;index）从画板列表中删除画板，并使列表中的下一个画板处于活动状态。 无法删除最后一个画板。 参数： artboardList 画板列表对象。 index 要从列表中删除的画板的从0开始的索引位置。 返回： kAICantDeleteLastArtboardErr如果您尝试删除最后一个画板时出现错误。 参考ai::ArtboardList::Delete()。 4.DisposeAIAPI AIErr(* AIArtboardSuite::Dispose)(ai::ArtboardProperties &amp;properties)释放画板属性对象。 参数：properties 画板属性对象。 参考ai :: ArtboardProperties :: ~ArtboardProperties（） 5.GetActiveAIAPI AIErr（* AIArtboardSuite :: GetArtboardList）（ai :: ArtboardList ＆artboardList）获得当前文档的画板列表。 参数： artboardList [out]用于返回画板列表对象的引用。 参考ai :: ArtboardList :: ArtboardList（）。 6.GetArtboardPropertiesAIAPI AIErr（* AIArtboardSuite :: GetArtboardProperties）（ai :: ArtboardList &amp;artboardList，ai :: ArtboardID index，ai :: ArtboardProperties &amp;properties）从画板列表中获得画板的属性。 使用GetCount()和Update()修改画板而不更改文档中哪个画板处于活动状态。 参数： artboardList 画板列表对象。 index 列表中画板的从0开始的索引位置。 properties [out]用于返回画板属性对象。出错时，返回无效对象 使用： 1234ai::ArtboardProperties tempArtboardProperties;ai::ArtboardList tempoartboardList;sAIArtboard-&gt;GetArtboardList(tempoartboardList);sAIArtboard-&gt;GetArtboardProperties(tempoartboardList, 0, tempArtboardProperties); 7.GetCountAIAPI AIErr（* AIArtboardSuite :: GetCount）（const ai :: ArtboardList &amp;artboardList，ai :: ArtboardID &amp;count）获得画板列表中定义的画板数量。 参数： artboardList 画板列表对象。 count [out]用于返回画板数量。 参考ai :: ArtboardList :: GetCount（）。 8.GetNameAIAPI AIErr(* AIArtboardSuite::GetName)(const ai::ArtboardProperties &amp; properties, ai::UnicodeString &amp;name) 9.GetPARAIAPI AIErr(* AIArtboardSuite::GetPAR)(const ai::ArtboardProperties &amp;properties, AIReal &amp;par)获得画板标尺的像素长宽比。 参数： properties 画板属性对象。 par [out]用于返回像素宽高比。 实例： 123456ai::ArtboardProperties tempArtboardProperties;ai::ArtboardList tempoartboardList;sAIArtboard-&gt;GetArtboardList(tempoartboardList);sAIArtboard-&gt;GetArtboardProperties(tempoartboardList, 0, tempArtboardProperties);AIReal artPar;sAIArtboard-&gt;GetPAR(tempArtboardProperties,artPar) 10.GetPositionAIAPI AIErr（* AIArtboardSuite :: GetPosition）（const ai :: ArtboardProperties＆properties，AIRealRect＆bounds）获得画板的位置和边界。 参数： properties 画板属性对象。 bounds [out]一个矩形对象，用于返回画板的位置和边界。 实例： 12345678910ai::ArtboardProperties tempArtboardProperties;ai::ArtboardList tempoartboardList;sAIArtboard-&gt;GetArtboardList(tempoartboardList);sAIArtboard-&gt;GetArtboardProperties(tempoartboardList, 0, tempArtboardProperties);AIRealRect Bound;sAIArtboard-&gt;GetPosition(tempArtboardProperties, Bound); ASReal bottom = Bound.bottom;ASReal top = Bound.top;ASReal right = Bound.right;ASReal left = Bound.left; 11.GetRulerOriginAIAPI AIErr（* AIArtboardSuite :: GetRulerOrigin）（const ai :: ArtboardProperties＆properties，AIRealPoint＆rulerOrigin）获得相对于左下角的画板的标尺原点。 参数： properties 画板属性对象。 rulerOrigin [out]用于返回标尺原点。 12.GetShowDisplayMarkAIAPI AIErr（* AIArtboardSuite :: GetShowDisplayMark）（const ai :: ArtboardProperties＆properties，ai :: ArtboardProperties :: DisplayMarkType type，AIBoolean＆show）报告当前是否显示特定类型的画板注释。 参数： properties 画板属性对象。 type 注释类型。 show 如果显示类型则返回true，如果隐藏则返回false。 13.InitAIAPI AIErr（* AIArtboardSuite :: Init）（ai :: ArtboardProperties＆artboard）使用默认值初始化画板属性对象。 参数：artboard 画板属性对象。 14.InsertAIAPI AIErr（* AIArtboardSuite :: Insert）（ai :: ArtboardList＆artboardList，ai :: ArtboardProperties＆artboard，ai :: ArtboardID＆index）在指定位置插入新画板。 参数： artboardList ArtboardList对象。 artboard 新画板的属性。 index 基于0的新画板的索引位置。 返回： kAIExceededMaxArtboardLimitErr如果超出允许的最大画板数，则会出错。 15.IsDefaultNameAIAPI AIErr（* AIArtboardSuite :: IsDefaultName）（const ai :: ArtboardProperties＆properties，AIBoolean＆isDefault）报告画板的当前名称是否是应用程序生成的。 在这种情况下，用户选择将画板内容导出为JPEG，并将画板保存为单独的文件时，文件只能通过编号来区分，而不是完整生成的名称; 例如，myArt-01.jpg。如果已明确设置画板名称，则会在导出的JPEG文件名中使用该名称。 参数： properties 画板属性对象。 isDefault 如果生成名称则返回true的缓冲区，如果已显式设置，则返回false。 16.ReleaseArtboardListAIAPI AIErr(* AIArtboardSuite::ReleaseArtboardList)(ai::ArtboardList &amp;artboardList)释放画板列表对象。 参数： artboardList 画板列表对象。 17. SetActiveAIAPI AIErr（* AIArtboardSuite :: SetActive）（ai :: ArtboardList＆artboardList，ai :: ArtboardID index）使特定画板处于活动状态，并使其按迭代顺序显示。 参数： artboardList 画板列表对象。 index 列表中画板的从0开始的索引位置。 18.SetIsDefaultNameAIAPI AIErr（* AIArtboardSuite :: SetIsDefaultName）（ai :: ArtboardProperties＆properties，const AIBoolean＆isDefault） 19.SetNameAIAPI AIErr(* AIArtboardSuite::SetName)(ai::ArtboardProperties &amp;properties, const ai::UnicodeString &amp;name) 20.SetPARAIAPI AIErr（* AIArtboardSuite :: SetPAR）（ai :: ArtboardProperties＆properties，AIReal par）修改画板标尺的像素长宽比。 AIArtboardSuite::Update()使用此对象调用进行更改。 参数： properties 画板属性对象。 par 新的像素长宽比。 21.SetPositionAIAPI AIErr（* AIArtboardSuite :: SetPosition）（ai :: ArtboardProperties＆properties，const AIRealRect＆bounds）修改画板的位置和边界。 AIArtboardSuite::Update()使用此对象调用进行更改。 参数： properties 画板属性对象 bounds 新的位置和边界 22.SetRulerOriginAIAPI AIErr（* AIArtboardSuite :: SetRulerOrigin）（ai :: ArtboardProperties＆properties，const AIRealPoint＆rulerOrigin）设置画板的标尺原点，相对于左下角。 参数：properties 画板属性对象rulerOrigin 标尺原点 23.SetShowDisplayMarkAIAPI AIErr（* AIArtboardSuite :: SetShowDisplayMark）（ai :: ArtboardProperties＆properties，ai :: ArtboardProperties :: DisplayMarkType type，AIBoolean show）设置当前是否显示特定类型的画板注释。 24.UpdateAIAPI AIErr（* AIArtboardSuite :: Update）（ai :: ArtboardList＆artboardList，ai :: ArtboardID index，const ai :: ArtboardProperties＆properties）更新画板的属性。 使用GetCount()和GetArtboardProperties()修改画板而不更改文档中哪个画板处于活动状态。 参数： artboardList 画板列表对象。 index 文档列表中画板的从0开始的索引位置。 properties 包含新画板属性的对象。 实例： 12345678910111213AIRealRect DateBound;AIRealPoint CenterPt;double m_scale=2000DateBound.top = (this-&gt;DateBound.top - this-&gt;m_center.v) * 1000 / m_scale * (72 / 25.4) - AIcenter.v;DateBound.bottom = (this-&gt;DateBound.bottom - this-&gt;m_center.v) * 1000 / m_scale * (72 / 25.4) - AIcenter.v;DateBound.left = (this-&gt;DateBound.left - this-&gt;m_center.h) * 1000 / m_scale * (72 / 25.4) - AIcenter.h;DateBound.right = (this-&gt;DateBound.right - this-&gt;m_center.h) * 1000 / m_scale * (72 / 25.4) - AIcenter.h; CenterPt.h = (DateBound.left - DateBound.right) / 2;CenterPt.v = (DateBound.top - DateBound.bottom) / 2; sAIArtboard-&gt;SetPosition(tempArtboardProperties, DateBound);//*******sAIArtboard-&gt;Update(tempoartboardList, 0, tempArtboardProperties);//******* 相关文章AI组件开发（一）–注记旋转矩阵AI组件开发（二）–AIRealMathSuiteAI组件开发（三）–AIArtboardSuiteAI组件开发（四）–AIDocumentSuiteAI组件开发（五）–AILayerSuiteAI组件开发（六）–AIArtSuiteAI组件开发（七）–AIPathSuite&amp;&amp;AIPathfinderSuiteAI组件开发（八）–AIArtStyleSuite","tags":[{"name":"AI","slug":"AI","permalink":"http://11wy11.github.io/tags/AI/"}]},{"title":"GDAL相关类及函数","date":"2019-03-24T06:27:22.000Z","path":"2019/03/24/cpp-gdal-function/","text":"主要介绍GDAL基本类及OGR相关类 GDAL 基本使用函数CPLSetConfigOptionvoid CPLSetConfigOption （ const char pszKey，const char pszValue）为GDAL / OGR使用设置配置选项。 这些选项被定义为（键，值）对。稍后可以使用CPLGetConfigOption（）方法获取与密钥对应的值。 此机制类似于环境变量，但使用CPLSetConfigOption（）设置的选项会覆盖CPLGetConfigOption（）的观点，即环境中定义的值。 如果使用相同的密钥多次调用CPLSetConfigOption（），则将使用上次调用期间提供的值。 也可以使用带有’-config KEY VALUE’的大多数GDAL实用程序的命令行传递选项。例如，ogrinfo -config CPL_DEBUG ON~ / data / test / point.shp 此函数也可用于通过传递NULL作为值来清除设置（注意：传递NULL不会取消设置现有环境变量;它将取消设置先前由CPLSetConfigOption（）设置的值）。 例如：12CPLSetConfigOption(&quot;MDB_DRIVER_TEMPLATE&quot;, &quot;DRIVER=Microsoft Access Driver (*.mdb, *.accdb);DBQ=%s&quot;);CPLSetConfigOption(&quot;PGEO_DRIVER_TEMPLATE&quot;, &quot;DRIVER=Microsoft Access Driver (*.mdb, *.accdb);DBQ=%s&quot;); GDALAllRegister 最初需要注册所需的所有格式驱动程序。这通常通过调用GDALAllRegister（）来完成，该寄存器注册GDAL / OGR中内置的所有格式驱动程序。 原型： 12345678910111213void GDALAllRegister(void) //Register all known configured GDAL drivers.//注册所有已知配置的GDAL驱动程序。 //This function will drive any of the following that are configured into GDAL. See raster list and vector full list //此功能将驱动配置为GDAL的以下任何内容。请参阅栅格列表和矢量完整列表 //This function should generally be called once at the beginning of the application.//通常应在应用程序开始时调用此函数一次。 //使用#include“ ogrsf_frmts.h ” int main（） &#123; GDALAllRegister（）; GDALOpenEx以GDALDataset打开栅格或矢量文件。 此函数将尝试依次调用每个已注册的GDALDriver的Open方法来打开传递的文件或虚拟数据集名称。第一次成功打开将导致返回的数据集。如果所有驱动程序都失败，则返回NULL并发出错误。 几条建议： 如果打开具有GDAL_OF_UPDATE访问权限的数据集对象，则不建议在同一基础文件上打开新数据集。 返回的数据集一次只能由一个线程访问。如果要从不同的线程中使用它，则必须添加所有必需的代码（互斥锁等）以避免并发使用该对象。（某些驱动程序，如GeoTIFF，维护每次读取新块时更新的内部状态变量，从而防止并发使用。） 原型： 123456GDALDatasetH GDALOpenEx （ const char * pszFilename，unsigned int nOpenFlags，const char * const * papszAllowedDrivers，const char * const * papszOpenOptions，const char * const * papszSiblingFiles ） 参数 pszFilename 要访问的文件的名称。在外来驱动程序的情况下，这可能不是指物理文件，而是包含驱动程序有关如何访问数据集的信息。它应该是UTF-8编码。 nOpenFlags GDAL_OF_标志的组合，可以通过逻辑或运算符组合。 驱动程序类型：用于光栅驱动程序的GDAL_OF_RASTER，用于矢量驱动程序的GDAL_OF_VECTOR，用于地理网络模型驱动程序的GDAL_OF_GNM。如果未指定任何值，则隐含所有类型。 访问模式：GDAL_OF_READONLY（独占）或GDAL_OF_UPDATE。 共享模式：GDAL_OF_SHARED。如果设置，它允许与已设置GDAL_OF_SHARED的其他调用者共享数据集的GDALDataset句柄。特别是，GDALOpenEx（）将首先查询其当前打开和共享GDALDataset的列表，如果一个GetDescription（）名称与传递给GDALOpenEx（）的pszFilename完全匹配，则将引用并返回它，如果GDALOpenEx（）是从同一个线程调用。 详细错误：GDAL_OF_VERBOSE_ERROR。如果设置，则尝试打开文件失败将导致报告错误消息。 papszAllowedDrivers NULL考虑所有候选驱动程序，或NULL终止的字符串列表，其中包含必须考虑的驱动程序短名称。 papszOpenOptions NULL或NULL终止的字符串列表，其中打开选项传递给候选驱动程序。所有驱动程序OVERVIEW_LEVEL = level都存在一个选项，用于选择数据集的特定概述级别。级别索引从0开始。级别编号可以以“仅”为后缀，以指定只有此概述级别必须可见，而不是子级别。默认情况下会验证打开选项，如果无法识别选项，则会发出警告。在某些情况下，可能不需要（例如，当不知道哪个驱动程序将打开文件时），因此可以将特殊打开选项VALIDATE_OPEN_OPTIONS设置为NO以避免此类警告。或者，从GDAL 2.1开始，选项名称前面可以加上@字符，表示如果驱动程序没有声明此选项，它可能不会引发警告。 papszSiblingFiles NULL或NULL终止的字符串列表，这些字符串是主文件名的辅助文件名。如果传递NULL，则将完成对文件系统的探测。 返回一个GDALDatasetH句柄或失败时为NULL。对于C ++应用程序，此句柄可以转换为GDALDataset *。 1234567GDALDataset *poDS;poDS = (GDALDataset*) GDALOpenEx( &quot;point.shp&quot;, GDAL_OF_VECTOR, NULL, NULL, NULL );if( poDS == NULL )&#123; printf( &quot;Open failed.\\n&quot; ); exit( 1 );&#125; 使用实例：1234567GDALDataset *poDS;poDS = (GDALDataset*) GDALOpenEx( &quot;point.shp&quot;, GDAL_OF_VECTOR, NULL, NULL, NULL );if( poDS == NULL )&#123; printf( &quot;Open failed.\\n&quot; ); exit( 1 );&#125; GDALDataSet帮助文档https://www.gdal.org/classGDALDataset.html 类图 部分函数介绍 GetLayerByName Fetch a layer by name. The returned layer remains owned by the GDALDataset and should not be deleted by the application. This method is the same as the C function GDALDatasetGetLayerByName() and the deprecated OGR_DS_GetLayerByName(). In GDAL 1.X, this method used to be in the OGRDataSource class. Parameters pszName the layer name of the layer to fetch. Returns the layer, or NULL if Layer is not found or an error occurs. GetLayerCount OGR类或函数OGRLayer帮助文档https://www.gdal.org/classOGRLayer.html 类图 GetLayerDefn GetExtent ResetReading GetNextFeature GetName OGRFeature 包括geometry和attributes GetDefRef GetGeometryRef 返回指向内部要素几何的指针。不应修改此对象 GetFieldAsString 将字段值作为字符串获取 OGRFeature::DestroyFeaturevoid OGRFeature :: DestroyFeature （ OGRFeature * poFeature ） poFeatur要删除的Feature。OGRGeometry所有几何类的抽象基类。 一些空间分析方法要求在GEOS库上构建OGR才能正常工作。描述几何之间空间关系的方法的精确含义在SFCOM或其他简单特征接口规范中描述，例如“OpenGIS®地理信息实现规范 - 简单特征访问 - 第1部分：通用体系结构”：&lt;a href =“ http://www.opengeospatial.org/standards/sfa “&gt; OGC 06-103r4 在GDAL 2.0中，类的层次结构已经扩展为（工作草案）ISO SQL / MM第3部分（ISO / IEC 13249-3）曲线几何：CIRCULARSTRING（OGRCircularString），COMPOUNDCURVE（OGRCompoundCurve），CURVEPOLYGON（OGRCurvePolygon），MULTICURVE（OGRMultiCurve）和MULTISURFACE（OGRMultiSurface）。 OGRPointOGRLineString多顶点线的具体表示。继承OGRSimpleCurve getPointsvoid OGRSimpleCurve::getPoints ( OGRRawPoint * paoPointsOut,double * padfZOut = nullptr ) getPointvoid OGRSimpleCurve::getPoint ( int i,OGRPoint * poPoint )获取行字符串中的一个点。i:要获取的顶点，从0到getNumPoints（） - 1poPoint 用获取的点初始化的点。 getNumPoints获得线上点的个数OGRMultiLineString getNumGeometries获得几何要素格个数OGRPolygon getExteriorRing 获取对外部多边形环的引用 getNumInteriorRings获取指示内部环的数量 getInteriorRing获取指示内部环的引用OGRFeatureDefn 要素类或要素图层的定义。 GetFieldCount 获取字段数 GetFieldDefn 获得字段 参数：字段索引OGRFieldDefn GetNameRef 字段名称 OGREnvelope1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980class CPL_DLL OGREnvelope&#123; public: OGREnvelope() : MinX(std::numeric_limits&lt;double&gt;::infinity()), MaxX(-std::numeric_limits&lt;double&gt;::infinity()), MinY(std::numeric_limits&lt;double&gt;::infinity()), MaxY(-std::numeric_limits&lt;double&gt;::infinity()) &#123; &#125; OGREnvelope(const OGREnvelope&amp; oOther) : MinX(oOther.MinX),MaxX(oOther.MaxX), MinY(oOther.MinY), MaxY(oOther.MaxY) &#123; &#125; double MinX; double MaxX; double MinY; double MaxY;#ifdef HAVE_GCC_DIAGNOSTIC_PUSH#pragma GCC diagnostic push#pragma GCC diagnostic ignored &quot;-Wfloat-equal&quot;#endif int IsInit() const &#123; return MinX != std::numeric_limits&lt;double&gt;::infinity(); &#125;#ifdef HAVE_GCC_DIAGNOSTIC_PUSH#pragma GCC diagnostic pop#endif void Merge( OGREnvelope const&amp; sOther ) &#123; MinX = MIN(MinX,sOther.MinX); MaxX = MAX(MaxX,sOther.MaxX); MinY = MIN(MinY,sOther.MinY); MaxY = MAX(MaxY,sOther.MaxY); &#125; void Merge( double dfX, double dfY ) &#123; MinX = MIN(MinX,dfX); MaxX = MAX(MaxX,dfX); MinY = MIN(MinY,dfY); MaxY = MAX(MaxY,dfY); &#125; void Intersect( OGREnvelope const&amp; sOther ) &#123; if(Intersects(sOther)) &#123; if( IsInit() ) &#123; MinX = MAX(MinX,sOther.MinX); MaxX = MIN(MaxX,sOther.MaxX); MinY = MAX(MinY,sOther.MinY); MaxY = MIN(MaxY,sOther.MaxY); &#125; else &#123; MinX = sOther.MinX; MaxX = sOther.MaxX; MinY = sOther.MinY; MaxY = sOther.MaxY; &#125; &#125; else &#123; *this = OGREnvelope(); &#125; &#125; int Intersects(OGREnvelope const&amp; other) const &#123; return MinX &lt;= other.MaxX &amp;&amp; MaxX &gt;= other.MinX &amp;&amp; MinY &lt;= other.MaxY &amp;&amp; MaxY &gt;= other.MinY; &#125; int Contains(OGREnvelope const&amp; other) const &#123; return MinX &lt;= other.MinX &amp;&amp; MinY &lt;= other.MinY &amp;&amp; MaxX &gt;= other.MaxX &amp;&amp; MaxY &gt;= other.MaxY; &#125;&#125;; OGRwkbGeometryType几何类型代码。在下面这类中实现： OGRMultiLineString, OGRMultiCurve, OGRMultiPoint, OGRTriangulatedSurface, OGRPolyhedralSurface, OGRMultiPolygon, OGRMultiSurface, OGRGeometryCollection, OGRTriangle, OGRPolygon, OGRCurvePolygon, OGRCompoundCurve, OGRCircularString, OGRLineString, and OGRPoint. 常亮值如：wkbPoint，wkbMultiPoint，wkbLineString,wkbMultiLineString，wkbPolygon，wkbCurvePolygon，wkbMultiPolygon 参考资料： 百度百科：https://baike.baidu.com/item/GDAL/4004525?fr=aladdin 官方网站：https://www.gdal.org/","tags":[{"name":"GDAL","slug":"GDAL","permalink":"http://11wy11.github.io/tags/GDAL/"}]},{"title":"krpano快速初级教程（一）之javascript api","date":"2019-03-23T02:37:05.000Z","path":"2019/03/23/krpano-primary-first-note/","text":"","tags":[{"name":"krpano","slug":"krpano","permalink":"http://11wy11.github.io/tags/krpano/"}]},{"title":"VS2013打包C#项目","date":"2019-03-22T13:54:22.000Z","path":"2019/03/22/winform-release/","text":"在VS2013中安装InstallShield打包程序， 背景vs2010打包时，在其他项目类型中找到安装和部署的模板，即可新建安装项目，而在vs2013中需要先在线搜索InstallShield，然后按照网页提示一步步下载，之后添加安装项目，配置打包设置完成打包 在vs2010 选择“新建项目”→“ 其他项目类型”→“ Visual Studio Installer→“安装项目”： 1. 打包前的准备InstallShield安装在我们准备好的项目中右击“解决方案”，在弹出的菜单中选择添加 - 新建项目： 在弹出的新建对话框中依次选择 其他项目 - 安装和部署 - 安装项目，你可以改名字，也可以使用默认的名字setup1 新建一个打包部署项目，点OK，如果是第一次使用的话，会打开一个网页，按照提示的步骤来做， 点击Go to the download web site,进入下载网站，填写完信息，点击“download ”即会收到一封邮件，里面有下载地址和激活码。 之后会下载一个InstallShield2015LimitedEdition.exe的安装包,用管理员权限运行安装完后。重新启动VS2013 重新新建一个这样的项目： 点OK，这时候不再是打开网页，这时打开会提示激活或者是试用，选第一项，下一步 输入收到的邮件里的激活码，激活,待激活完成 卸载功能：找到C:\\Windows\\System32目录下的msiexec.exe文件，右击 选择 “msiexec.exe 的快捷方式”，然后改名为：你想叫名称（卸载、uninstall都可以），移动到你需要打包的程序菜单的文件夹下面。 winform设置项目图标 首先可以在你的窗体属性中找到icon选择你准备好的图标； 右键项目点击属性，找到应用程序中的图标和清单 2. 开始部署2.1 基本配置Application Information 可以设置公司名称，点击右侧General Information 可以设置语言为中文，可以设置应用名称 2.2 Installation Requirements 一般可以默认设置，如果需要,选择安装如.NET Framework 4.5等依赖同时打包，勾选所需依赖 2.3 Installation Architecture 默认即可 2.4 Application Files 添加程序所需文件，这里有两种方式经过测试均可实现 2.4.1方式一 点击到ProgramFilesFolder&gt;Microsoft&gt; &lt;你的工程名&gt;[INSRALLDIR]，点击Add Folders，选择工程bin目录下的Debug或Release文件夹，一般选择Release 2.4.2 方式二 点击到ProgramFilesFolder&gt;Microsoft&gt; &lt;你的工程名&gt;[INSRALLDIR]，点击Add Project Outputs,选择主输出 点击Ok后，选中主输出，右键Resolve Project OutPut 点击OK后，在左边菜单CatcheScreen下新建目录source，然后同上步骤添加源文件，然后选中资源，右键Resolve Project OutPut 在创建一个文件命名“uninstall”，然后同上步骤添加源文件，然后选中资源，右键Resolve Project OutPut 2.5 Application Shortcuts 2.4如果选择方式一，这是默认后有两个Launch xxx.exe,Launch xxx.vshost.exe,可以将第二个删掉，然后重命名第一个 勾选use alternate shortcut icon可以选择自定义的程序图标 然后创建卸载程序的快捷方式 点击Create an unistallation shortcut，选择uninstall 2.4如果选择方式二， 点击左侧的new,弹出对话框后点击最后一项，一直点到最后,点击Open，重命名Built（这里的重命名实际上就是你的程序在桌面上的名称) 选择在桌面上创建快捷方式： 勾选use alternate shortcut icon可以选择自定义的程序图标 然后创建卸载程序的快捷方式 2.6 Application Registry配置是否允许用户修改安装地址等 2.7 在右侧找到第六步Prepare for Release，双击下面的Releases点击选中“SingleImage”–选项卡点击“Setup.exe”–找到 “InstallShield PrerequisitesLocation”，把它设置为“Extract From Setup.exe” 发布生成解决方案后会在安装程序集下面生成一个名为Setup（当时添加安装部署项目的项目名）的文件夹，安装文件就保存在下面的目录中。Install在生成安装文件后会有Setup.exe和.msi两中安装文件，exe文件是安装的引导文件，核心文件是msi文件，里面封存了程序的组件。在里面找到Setup.exe文件及msi文件即可进行安装。 点击Setup.exe，进行安装，如果想卸载，点击Uninstall卸载 更换用installshield打包生成exe文件的图标 打开Visio studio,选择文件方式打开你生成的exe文件 在Icon下右键添加资源》点击导入选择准备好的项目图标等 删除原来的100资源 设置你导入的资源ID为100 保存常见问题 有时打包之后，项目更新之后，重新再生成解决方案来打包,遇到exe文件找不到时【解决方案】 清理，重新生成解决方案 如果还是不行，运行一次，然后点击生成解决方案 重新打包遇到DVD5无法覆盖【解决方案】原因是通过打开了相关文件夹，关闭文件资源管理器即可 设置了应用的ico图标后，生成解决方案提示 error : -3204: Cannot extract icon with index 0 from file…【解决方案】把图标添加进工程。 重新打包遇到错误-1014：错误 29 -1014: Cannot rename directory XXX\\Express\\SingleImage to XXX\\Express\\SingleImage.Bak.Windows Explorer or a DOS prompt may be pointing to a subfolder of the release output folder (Disk1) or to the Interm folder, locking it. Change the current directory. Close any open files in the Disk1 folder. Close Msidb.exe if it is open.【解决方案】将工程文件夹下的当时创建的SetUp应用程序中SetUp（当初新建的工程名）的文件夹删除，保留,isl，isproj文件，点击 生成解决方案即可，在XXX\\Express\\SingleImage\\DiskImages\\DISK1下生成可执行文件 参考：https://blog.csdn.net/qq_38122230/article/details/80470699https://blog.csdn.net/u010872301/article/details/80509405","tags":[{"name":"VS","slug":"VS","permalink":"http://11wy11.github.io/tags/VS/"},{"name":"打包","slug":"打包","permalink":"http://11wy11.github.io/tags/打包/"}]},{"title":"krpano快速入门教程（四）之菜单栏","date":"2019-03-21T15:37:50.000Z","path":"2019/03/21/krpano-forth-note/","text":"主要通过自定义plugin插件实现krpano下拉框 背景有时当有多个场景，用户想要直观的查看和定位指定的菜单栏，因此，最简单的方式是在页面中添加下拉框，能够支持用户选择场景进行跳转 下拉式菜单栏主要通过自定义plugin插件实现下拉框tour.xml代码如下： plugin plugin定义插件，其中使用了krpano中提供的combox插件，align属性可以设置下拉框相对对齐位置，onloaded定义在加载时调用的函数或动作action action fill_with_scenes 主要读取当前所有的场景，依次设置添加到combox的item中，可以看到采用了部分krpano的语法，首先定义了item点击事件itemcall，调用loadscene加载场景，然后将场景名称和场景title作为项的属性添加 action select_box_item 下拉框选中动作，如果该插件加载，则调用选中函数，否则，延时执行选中combox.js下载123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115&lt;krpano version=\"1.19\" title=\"Virtual Tour\" onstart=\"startup();\"&gt;&lt;!-- combobox plugin --&gt; &lt;plugin name=\"box\" keep=\"true\" url=\"%SWFPATH%/plugins/combobox.swf\" width=\"230\" alturl=\"%SWFPATH%/plugins/combobox.js\" native=\"false\" align=\"righttop\" x=\"10\" y=\"10\" onloaded=\"fill_with_scenes();\" /&gt; &lt;!-- an action for automatically fill the combobox with all scenes --&gt; &lt;action name=\"fill_with_scenes\"&gt; for(set(i,0), i LT scene.count, inc(i), txtadd(itemcall, 'loadscene(',get(scene[get(i)].name),',null,MERGE,BLEND(1));'); addIdItem(get(scene[get(i)].name), get(scene[get(i)].title), get(itemcall)); ); &lt;/action&gt; &lt;!-- an action for updating the combobox when the scene was changed --&gt; &lt;action name=\"select_box_item\"&gt; if(plugin[box].loaded, plugin[box].selectIdItem(%1); , delayedcall(0.1, select_box_item(%1)); ); &lt;/action&gt; &lt;action name=\"floorvisible\"&gt; set(layer[map_container_mask].oy,5); set(layer[map_container_mask].height,100%); for(set(i,1);txtadd(floorname, 'floor', '_', get(i)), layer[get(floorname)], inc(i); txtadd(floorname, 'floor', '_', get(i)), set(layer[get(floorname)].visible, false); ); &lt;/action&gt; &lt;!-- set skin settings: bingmaps? gyro? thumbnail controlling? tooltips? --&gt; &lt;skin_settings bingmaps=\"false\" bingmaps_key=\"\" bingmaps_zoombuttons=\"false\" gyro=\"true\" thumbs_width=\"120\" thumbs_height=\"80\" thumbs_padding=\"10\" thumbs_crop=\"0|40|240|160\" thumbs_opened=\"false\" thumbs_text=\"false\" thumbs_dragging=\"true\" thumbs_onhoverscrolling=\"false\" thumbs_scrollbuttons=\"false\" thumbs_scrollindicator=\"false\" tooltips_thumbs=\"false\" tooltips_hotspots=\"false\" tooltips_mapspots=\"false\" controlbar_offset=\"20\" /&gt; &lt;!-- set optional skin logo url --&gt; &lt;layer name=\"skin_logo\" url=\"\" scale=\"0.25\" opened_onclick=\"openurl('...',_blank);\" /&gt; &lt;action name=\"startup\"&gt; if(startscene === null, copy(startscene,scene[0].name)); loadscene(get(startscene), null, MERGE); &lt;/action&gt; &lt;scene name=\"scene_1\" title=\"场景1\" onstart=\"\" thumburl=\"panos/3.tiles/thumb.jpg\" lat=\"\" lng=\"\" heading=\"\"&gt; &lt;view hlookat=\"0\" vlookat=\"0\" fovtype=\"MFOV\" fov=\"120\" maxpixelzoom=\"2.0\" fovmin=\"70\" fovmax=\"140\" limitview=\"auto\" /&gt; &lt;preview url=\"panos/3.tiles/preview.jpg\" /&gt; &lt;image type=\"CUBE\" multires=\"true\" tilesize=\"512\" progressive=\"false\"&gt; &lt;level tiledimagewidth=\"1910\" tiledimageheight=\"1910\"&gt; &lt;cube url=\"panos/3.tiles/%s/l3/%v/l3_%s_%v_%h.jpg\" /&gt; &lt;/level&gt; &lt;level tiledimagewidth=\"955\" tiledimageheight=\"955\"&gt; &lt;cube url=\"panos/3.tiles/%s/l2/%v/l2_%s_%v_%h.jpg\" /&gt; &lt;/level&gt; &lt;level tiledimagewidth=\"512\" tiledimageheight=\"512\"&gt; &lt;cube url=\"panos/3.tiles/%s/l1/%v/l1_%s_%v_%h.jpg\" /&gt; &lt;/level&gt; &lt;mobile&gt; &lt;cube url=\"panos/3.tiles/mobile_%s.jpg\" /&gt; &lt;/mobile&gt; &lt;/image&gt; &lt;!-- place your scene hotspots here --&gt; &lt;/scene&gt; &lt;scene name=\"scene_2\" title=\"场景2\" onstart=\"\" thumburl=\"panos/1.tiles/thumb.jpg\" lat=\"\" lng=\"\" heading=\"\"&gt; &lt;view hlookat=\"0\" vlookat=\"0\" fovtype=\"MFOV\" fov=\"120\" maxpixelzoom=\"2.0\" fovmin=\"70\" fovmax=\"140\" limitview=\"auto\" /&gt; &lt;preview url=\"panos/1.tiles/preview.jpg\" /&gt; &lt;image type=\"CUBE\" multires=\"true\" tilesize=\"512\" progressive=\"false\"&gt; &lt;level tiledimagewidth=\"955\" tiledimageheight=\"955\"&gt; &lt;cube url=\"panos/1.tiles/%s/l2/%v/l2_%s_%v_%h.jpg\" /&gt; &lt;/level&gt; &lt;level tiledimagewidth=\"512\" tiledimageheight=\"512\"&gt; &lt;cube url=\"panos/1.tiles/%s/l1/%v/l1_%s_%v_%h.jpg\" /&gt; &lt;/level&gt; &lt;mobile&gt; &lt;cube url=\"panos/1.tiles/mobile_%s.jpg\" /&gt; &lt;/mobile&gt; &lt;/image&gt; &lt;!-- place your scene hotspots here --&gt; &lt;/scene&gt; &lt;/krpano&gt; 历史文章krpano快速入门教程（一) 使用krpano工具构建即用型panoskrpano快速入门教程（二) vtour全景漫游及vtour文件夹介绍krpano快速入门教程（三）之热点Hotspot","tags":[{"name":"krpano","slug":"krpano","permalink":"http://11wy11.github.io/tags/krpano/"}]},{"title":"AE开发问题总结(一)","date":"2019-03-20T04:55:36.000Z","path":"2019/03/20/arcengine-second/","text":"今天本地运行项目，莫名其妙地报了个 尝试读取或写入受保护的内存，这通常指示其他内存已损坏！提供解决方案 AE 读Shp文件及查属性表等123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263 try&#123; bool flag = true; IWorkspaceFactory pWsFactory = new ShapefileWorkspaceFactoryClass(); IFeatureWorkspace pWorkSpace = pWsFactory.OpenFromFile(path, 0) as IFeatureWorkspace;//path为shp文件所在目录路径 IFeatureClass pFeatureClass = pWorkSpace.OpenFeatureClass(System.IO.Path.GetFileNameWithoutExtension(path));//OpenFeatureClass的参数为不带后缀的shp文件名 //检查属性 IFeatureLayer pFeatureLayer = new FeatureLayerClass(); pFeatureLayer.Name = pFeatureClass.AliasName; pFeatureLayer.FeatureClass = pFeatureClass; //查询 ,search的参数第一个为过滤条件，第二个为是否重复执行 IFeatureCursor pFeatureCursor = pFeatureLayer.Search(null, false); //获取查询到的要素 IFeature pFeature = pFeatureCursor.NextFeature(); string strFeatureClassName = (pFeatureClass as IDataset).Name; int fieldCount = pFeatureClass.Fields.FieldCount; else &#123; for (int i = 0; i &lt; fieldCount; ++i) &#123; //这段当时的需求是判断shp文件中是否有规定要求的字段， string fieldName = ConstantInfo.shpFields[i]; if (pFeatureClass.Fields.FindField(fieldName) == -1) &#123; //自定义函数，按照需要修改 flag = false; &#125; &#125; &#125; IFeature pTempFeature = pFeatureCursor.NextFeature(); int rowid = 0; while (null != pTempFeature) &#123; rowid++; for (int i = 0; i &lt; fieldCount; ++i) &#123; string str = Convert.ToString(pTempFeature.get_Value(i)); //空值检查 if (str == &quot;&quot;) &#123; /自定义函数，按照需要修改 flag = false; &#125; &#125; pTempFeature = pFeatureCursor.NextFeature(); &#125; Marshal.ReleaseComObject(pFeatureCursor); if (!flag) &#123; MainForm.isPassed = false; logger.Error(&quot;Error:&quot; + childNode.InnerText.Replace(&quot;%%&quot;, this.strPac) + &quot;shp文件属性等检查未通过\\n&quot;); &#125;&#125;catch (Exception e)&#123; //自定义函数，按照需要修改&#125;break; 尝试读取或写入受保护的内存，这通常指示其他内存已损坏【解决方法】以管理员的身份运行CMD 执行netsh winsock reset 然后提示你重新启动计算机 重启后错误就没有了 但这样太过复杂，没有从程序自身角度解决这个问题，继续查阅资料，最终找到了有效的方法，释放程序锁 最佳解决方法使用IWorkspaceFactoryLockControl接口的SchemaLockingEnabled和DisableSchemaLocking，分别获得工作空间锁状态，并关闭，具体代码如下：1234567IWorkspaceFactory pWsFactory = new ShapefileWorkspaceFactory();//关闭资源锁定 IWorkspaceFactoryLockControl ipWsFactoryLock = (IWorkspaceFactoryLockControl)pWsFactory;if (ipWsFactoryLock.SchemaLockingEnabled)&#123; ipWsFactoryLock.DisableSchemaLocking(); &#125; 错误原因分析 AE中非托管变量未释放，这些有Icursor，IFeatureCursor，IEnumStyleGalleryItem，IEnumBSTR，IStyleGallery；AGS里面有IServerContext等，释放方法System.Runtime.InteropServices.Marshal.ReleaseComObject(o);或者使用ESRI.ArcGIS.ADF.COMSupport.AOUninitialize.Shutdown() 参考：[1] https://blog.csdn.net/mattran/article/details/47149077 [2] https://blog.csdn.net/u011116642/article/details/17960135","tags":[{"name":"ArcEngine","slug":"ArcEngine","permalink":"http://11wy11.github.io/tags/ArcEngine/"},{"name":"VS","slug":"VS","permalink":"http://11wy11.github.io/tags/VS/"}]},{"title":"krpano学习笔记--干货","date":"2019-03-19T16:46:27.000Z","path":"2019/03/20/krpano-learn-note/","text":"介绍krpano开发中的一些注意事项和重要属性等 1.Krpano xml Onstartonstart事件将在xml加载和解析之后直接调用。 Basedirbasedir设置为所有下面的loadpano（）动作调用定义了基本目录。这可以是相对路径或绝对路径，也可以在这里使用 url占位符。默认值是％FIRSTXML％，这意味着所有下面的loadpano（）动作调用的所有相对xml路径都是相对于第一个加载的xml文件。 关于vars和initvars区别vars在加载xml后加载图像前赋值，而initvars在加载xml前赋值，一般用于构建url。由于get:variable或calc:variable中的变量值需要在加载xml中定义，所以使用vars不能在开始加载时控制krpano的某些设置，但是可以在之后动态的修改其显示状态。 Action: 参数/参数传递/解析当调用一个动作时，可以将参数/参数传递给它。为了访问参数/参数，有两种可能性： 通过占位符替换：（ 旧版本的方法） 可以使用从％0到％99形式的操作代码中的数字占位符来获取给定的参数。 其中％0是操作本身的名称， ％1表示第一个参数， ％2表示第二个参数，依此类推。 这些占位符可以在代码中的任何地方使用。 在实际的操作代码将被解析并执行之前，所有的占位符将被其参数值替换。 当给定的占位符不会有参数时，将使用值’null’。 要在动作中使用％字符，需要使用%% 通过参数到变量映射:( 推荐，新的） 对于具有本地作用域的操作，可以将args属性添加到&lt;action>元素。例如： &lt;action ... args =“var1，var2，var3”&gt; 在那里可以定义给定动作参数/参数的args属性变量名称（用逗号分隔）。 每个动作参数将被映射到本地作用域中的一个新变量，其名称是在args属性中设置的。 这些变量可以像操作代码中的任何其他变量一样正常使用（例如，通过get / calc / copy读取）。 当给定变量没有动作参数时，将使用值’null’。 处理包含引号或逗号字符的值时，使用变量映射非常有用。在这种情况下，正常的占位符替换可能会产生问题 注意 - 建议尽可能使用参数变量映射。没有％N占位符的动作可以在内部进行缓存，这使得进一步调用的执行速度更快。 值得注意的属性 Name属性：每个名字都需要以字母字符开头！这意味着不允许使用数字作为名字！当名称仍然以数字字符开头时，名称将被解释为数组索引。这对于动作内部基于动态索引的访问没有问题，但不能用于定义元素！所有名称将自动转换为小写字母，以便直接区分大小写访问！ URL属性：当一个相对路径被用作url值时，路径将被自动调整为相对于定义了url属性的xml文件。这意味着xml中的相对路径总是相对于xml本身，但是请注意 - 当动态设置/更改url属性时，则不再有与xml的自动关系！要使路径相对于某些特定的预定义路径，可以 在url路径中使用这些占位符中的一些：％FIRSTXML％ - 第一个加载的xml文件的路径。％CURRENTXML％ - 当前加载的主要xml文件的路径（不是包含的）。％SWFPATH％ - krpano查看器文件的路径。％HTMLPATH％ - html文件的路径。％BASEDIR％ - 使用basedir路径。％$ VARIABLE％ - 使用给定’VARIABLE’的值 - 这可以是任何krpano变量，但必须在加载当前xml或场景之前定义它，例如，在嵌入过程中（通过initvars）或在loadpano（），loadscene（）调用之前。 Style属性&lt;style>元素是任何类型属性的集合/存储元素。每个其他具有name属性的xml元素也可以有一个style属性。当xml元素首次被创建时，在&lt;style>元素处定义的所有属性将被复制到元素本身。这将在xml元素本身定义的属性被应用之前完成。这意味着可以在&lt;style>元素中预先定义一些设置，然后使用直接在元素上定义的属性稍后覆盖它们。 Get:|Calc方法当xml属性的值以get：或calc：开头时：在这种情况下，xml属性的值将从其他变量获取或使用表达式计算。在get：或calc：中使用的变量需要在当前xml元素之前（=上方）定义。此外，这里有一个特殊情况 - 在&lt;include>元素上使用它时，那么在那里使用的变量需要在当前xml加载之前定义。这可以在嵌入期间通过使用initvars设置或在xml中进行loadpano（）调用之前在html文件中完成。 Javascript krpano操作 （仅限HTML5）12345&lt;action name =“...” type =“ Javascript ” &gt; &lt;！[CDATA [ ... autorun =“” Javascript代码 ... ]]&gt; &lt;/ action&gt; Action type krpano操作的类型：type =“”（默认） - 正常krpano操作 - 适用于Flash和HTML5type =“Javascript” - JavaScript krpano操作 - 仅限HTML5 Action scope在操作中为新生成的变量定义范围：全局或未设置（默认）新变量将被添加到全局变量作用域中。其他任何行为或代码也可以使用它们。这在再使用变量名称时可能会有问题，特别是当变量类型在用法之间会有所不同时。本地新变量将被添加到仅存在于当前操作调用中的局部变量作用域中。当动作完成或调用其他动作时，局部作用域和其中定义的所有变量将不再可用。动作越复杂，它使用的临时变量越多，使用本地作用域进行此操作越有意义，以避免干扰其他动作的问题。设置LocalOnly有些作为scope = local，但区别在于，默认情况下，所有访问仅引用本地作用域本身。全局范围的访问只能由全局对象来实现。亲使用调用者的范围。当调用当前动作的动作具有局部范围时，则可以在当前动作中使用/访问该动作。私人：NAME为该操作定义一个私有本地范围。范围将由自定义的唯一名称进行参考。该范围在多个操作调用之间保持活动状态，并可以在多个操作中共享。有些作为范围= localonly所有访问只涉及本地范围本身。 笔记全局范围访问 - 搜索变量时，首先搜索本地范围，然后搜索全局范围。为了能够将变量添加到全局范围，即使在使用本地范围或直接访问全局范围内的变量时，也存在全局对象。本地范围访问 - 为了能够确保访问本地范围（例如，当可能已经存在具有相同名称的全局变量时定义本地变量），当前本地范围也可用作 操作代码中的本地对象。例如使用def（local.i，integer，0）; 定义一个名为’i’的局部整型变量。为了稍后访问动作代码，只需使用’i’来解决该变量就足够了。延期代码 - 稍后调用其他代码的操作（例如delayedcall，tween，asyncloop等）将使用与该代码中当前操作相同的范围。调用者范围 - 从插件/图层/热点事件调用的代码对于非localscope动作：当一个动作（或任何代码）将从plugin / layer / hotspot事件中被调用时，plugin / layer / hotspot对象本身也将作为搜索变量的范围。但仅限于访问现有的变量！新生成的变量将始终添加到全局范围中。对于localscope动作：在localscope动作中总是有预定义的局部变量调用者。当动作将从插件/图层/热点事件（或通过使用callwith）被调用时，那么该 调用者变量将引用该元素。否则，调用者变量将为空。 本地作用域操作中的 预定义变量：actionname - 当前操作的名称。args - 参数的值数组。访问者：args [index]。通过以下方式获取数字或参数：args.length。调用者 - 从那里调用插件/图层/热点对象，否则为null。全球 - 参考全球范围。本地 - 对当前本地范围本身的引用。parentscope - 父行为的范围引用，当没有父范围时，这指的是全局范围。","tags":[{"name":"krpano","slug":"krpano","permalink":"http://11wy11.github.io/tags/krpano/"}]},{"title":"VS2013/VS2015/VS2017下使用ArcEngine10.1/10.2（一）","date":"2019-03-19T07:51:40.000Z","path":"2019/03/19/arcengine-first/","text":"ArcObjects SDK for Microsoft .Net Framework 10.1或10.2在安装时，会检测VS2010或VS2012的安装路径，而有时因为其他项目使用限制而且不愿同时安装多个版本的VS,通过修改注册表方式实现安装 背景ArcObjects SDK for Microsoft .Net Framework 10.1或10.2在安装时，会检测VS2010或VS2012的安装路径，而有时因为其他项目使用限制而且不愿同时安装多个版本的VS,通过修改注册表方式实现安装 具体步骤1.修改注册表首先打开注册表，window系统可以通过win+R，输入regedit后，回车打开注册表 找到计算机\\HKEY_LOCAL_MACHINE\\SOFTWARE\\WOW6432Node\\Microsoft\\VisualStudio\\10.0，点击10.0文件夹，此时是没有InstallDir和ShellFolder两个字符串值 找到计算机\\HKEY_LOCAL_MACHINE\\SOFTWARE\\WOW6432Node\\Microsoft\\VisualStudio\\12.0,点击12.0文件夹，查看InstallDir值，并复制 回到10.0目录，右键新建->字符串值，新建InstallDir值，双击编辑值，将刚复制的粘贴 同样的处理，添加ShellFolder 2.安装ArcObjects SDK for Microsoft .Net Framework打开ArcGIS Desktop 或ArcEngine安装程序，找到ArcObjects SDK for Microsoft .Net Framework，点击安装，此时就不会提示要求VS2010或VS2012安装环境了，下面以ArcGIS Desktop 为例： 图1-安装 3. 在工具箱中添加ArcGIS相关组件由于通过修改注册表的方式安装的ArcObjects SDK for Microsoft .Net Framework，因此，可能会导致VS中没有ArcGIS相关工具，需要手动添加 打开VS2013,任意打开一个窗体，打开工具箱，会发现没有ArcGIS选项卡，因此，首先右键新建选项卡，然后右键，点击选择项,在.NET Framework组件下，找到下图所示的ArcGIS组件 图2-添加ArcGIS组件 方案1注意，如果在.NET Framework下找不到相关组件，可以点击浏览,找到ArcObjects SDK for Microsoft .Net Framework的安装目录下的DotNet，一般路径为D:\\Program Files (x86)\\ArcGIS\\DeveloperKit10.2\\DotNet如下图所示，可以按需添加，或者按住Shift全选添加。 图3-浏览组件dll 勾选需要的组件，点击确定后，在新建的选项卡下出现组件 红色框为新添加的.NET组件，上面两个是COM组件，暂时不需要使用，下节介绍.NET组件和COM组件的区别 方案2在Desktop安装目录的bin下找到需要的控件，以.ocx为后缀，选中后拖入工具箱 添加引用在不做任何手动操作时，安装了ArcGIS Desktop之后，可以在COM下的类型库中找到ArcGIS 相关的COM组件，如下图所示 图5-COM类型库中的ArcGIS相关组件 注意点击引用这些组件时，引用呈现下图所示结果： 图6-添加COM组件引用后 但会发现找不到Esri.ArcGIS.Version的库，而这个库必须在主函数入口处使用获得授权许可，之后才能使用ArcEngine中相关的类或接口。 因此，这里在添加引用是选择.NET组件，点击浏览找到ArcObjects SDK for Microsoft .Net Framework的安装目录下的DotNet，一般路径为D:\\Program Files (x86)\\ArcGIS\\DeveloperKit10.2\\DotNet如下图所示，选择Esri.ArcGIS.Version.dll，其他库VS会根据需要自动引用。如上图图3所示.注意点击引用这些组件时，引用呈现下图所示结果： 图7-添加NET组件引用后 Program.cs中授权在Main函数中添加 ESRI.ArcGIS.RuntimeManager.Bind(ESRI.ArcGIS.ProductCode.EngineOrDesktop);,如下图所示 图8-添加授权 直至就可以在一个应用程序中使用ArcEngine的功能了。 当然如果你想使用VS创建ArcGIS模板应用程序，此时你会发现Visual C#下没有ArcGIS选项，这时又需要我们手动添加了 图9-手动安装之前 手动添加ArcGIS项目模板由于我们最开始安装SDK时，采用了修改注册表的方式骗过ArcObject检测，因此，模板默认安装在了但是设置的VS2013安装路径Microsoft Visio Studio 12.0下了 将模板拷贝至vs模板库中找到D:\\Program Files (x86)\\Microsoft Visual Studio 12.0\\Microsoft Visual Studio 10.0，在Common7/IDE下有两个文件夹ItemTemplates/CSharp/ArcGIS,ProjectTemplates/CSharp/ArcGIS,分别拷贝在vs2013模板文件位置，如：D:\\Program Files (x86)\\Microsoft Visual Studio 12.0\\Common7\\IDE\\ItemTemplates\\CSharp和I:\\Program Files (x86)\\Microsoft Visual Studio 12.0\\Common7\\IDE\\ProjectTemplates\\CSharp 右键，以管理员权限运行vs2013,也就是启动vs2013 重新安装一次模板 打开vs2013/2015的命令行工具 2013： 开始–&gt; 所有应用 –&gt; Microsoft Visual Studio 2013 –&gt; Visual Studio Tools,打开后 vs2013开发人员命令提示 2015或更高： 开始–&gt; 所有应用 –&gt; Microsoft Visual Studio 2015 –&gt; vs2015开发人员命令提示（可能会叫Visual Studio 2015 Command Prompt ） 执行如下命令devenv.exe/InstallVSTemplates需要注意的事情是，这个命令执行后，不会马上出现项目或项模板，需要重新打开vs2017，新建时会重新初始化模板。 如果第三步有问题，换成用管理员权限运行。 效果C#下出现ArcGIS相关模板","tags":[{"name":"ArcEngine","slug":"ArcEngine","permalink":"http://11wy11.github.io/tags/ArcEngine/"},{"name":"VS","slug":"VS","permalink":"http://11wy11.github.io/tags/VS/"}]},{"title":"GDAL简介","date":"2019-03-18T07:26:26.000Z","path":"2019/03/18/cpp-gdal/","text":"GDAL(Geospatial Data Abstraction Library)是一个在X/MIT许可协议下的开源栅格空间数据转换库持续更新中Table of Contents generated with DocToc 简介 功能特征 OGR体系结构编辑 GDAL中OGR的使用 读数据 写数据 参考资料： 简介它利用抽象数据模型来表达所支持的各种文件格式。它还有一系列命令行工具来进行数据转换和处理。 OGR是GDAL项目的一个分支，功能与GDAL类似，只不过它提供对矢量数据的支持。 有很多著名的GIS类产品都使用了GDAL/OGR库，包括ESRI的ARCGIS 9.3，Google Earth和跨平台的GRASS GIS系统。利用GDAL/OGR库，可以使基于Linux的地理空间数据管理系统提供对矢量和栅格文件数据的支持。 功能特征GDAL提供对多种栅格数据的支持，包括Arc/Info ASCII Grid(asc)，GeoTiff (tiff)，Erdas Imagine Images(img)，ASCII DEM(dem) 等格式。 GDAL使用抽象数据模型(abstract data model)来解析它所支持的数据格式，抽象数据模型包括数据集(dataset)，坐标系统，仿射地理坐标转换(Affine Geo Transform)， 大地控制点(GCPs)， 元数据(Metadata)，栅格波段(Raster Band)，颜色表(Color Table)，子数据集域(Subdatasets Domain)，图像结构域(Image_Structure Domain)，XML域(XML:Domains)。 GDALMajorObject类：带有元数据的对象。 GDALDdataset类：通常是从一个栅格文件中提取的相关联的栅格波段集合和这些波段的元数据;GDALDdataset也负责所有栅格波段的地理坐标转换(georeferencing transform)和坐标系定义。 GDALDriver类：文件格式驱动类，GDAL会为每一个所支持的文件格式创建一个该类的实体，来管理该文件格式。 GDALDriverManager类：文件格式驱动管理类，用来管理GDALDriver类。 OGR体系结构编辑Geometry类：Geometry (包括OGRGeometry等类)封装了OpenGIS的矢量数据模型，并提供了一些几何操作，WKB(Well Knows Binary)和WKT(Well Known Text)格式之间的相互转换，以及空间参考系统(投影)。 Spatial Reference类：OGRSpatialReference封装了投影和基准面的定义。 Feature类：OGRFeature封装了一个完整feature的定义，一个完整的feature包括一个geometry和geometry的一系列属性。 Feature Definition类：OGRFeatureDefn里面封装了feature的属性，类型、名称及其默认的空间参考系统等。一个OGRFeatureDefn对象通常与一个层(layer)对应。 Layer类：OGRLayer是一个抽象基类，表示数据源类OGRDataSource里面的一层要素(feature)。 Data Source类：OGRDataSource是一个抽象基类，表示含有OGRLayer对象的一个文件或一个数据库。 Drivers类：OGRSFDriver对应于每一个所支持的矢量文件格式。类OGRSFDriver由类OGRSFDriverRegistrar来注册和管理。 GDAL中OGR的使用读数据 在工程的Library files中和Include files中分别添加GDAL的LIB文件目录和头文件目录 最初需要注册所需的所有格式驱动程序。这通常通过调用GDALAllRegister（）来完成，该寄存器注册GDAL / OGR中内置的所有格式驱动程序。 接下来我们需要打开输入OGR数据源。数据源可以是文件，RDBMS，充满文件的目录，甚至是远程Web服务，具体取决于所使用的驱动程序。但是，数据源名称始终是单个字符串。在这种情况下，我们硬编码打开一个特定的shapefile。第二个参数（GDAL_OF_VECTOR）告诉OGROpen（）方法我们想要使用向量驱动程序并且不需要更新访问。失败时返回NULL，我们报告错误。 GDALDataset可以潜在地具有与它相关联的许多层。可以使用GDALDataset :: GetLayerCount（）查询可用的图层数，并使用GDALDataset :: GetLayer（）通过索引获取各个图层。但是，我们只是按名称获取图层。 OGRLayer * poLayer; poLayer = poDS-&gt; GetLayerByName（“point”）; 现在我们要开始从图层中读取要素。在我们开始之前，我们可以为图层指定属性或空间过滤器以限制我们获取的功能集，但是现在我们有兴趣获取所有功能。 我们使用OGRLayer :: GetNextFeature（）遍历图层中的所有要素。当我们用完功能时它会返回NULL。 1234OGRFeature *poFeature;poLayer-&gt;ResetReading();while( (poFeature = poLayer-&gt;GetNextFeature()) != NULL )&#123; 为了转储该功能的所有属性字段，获取OGRFeatureDefn会很有帮助。这是与图层关联的对象，包含所有字段的定义。我们遍历所有字段，并根据其类型获取和报告属性。 123456789101112131415161718192021for( auto&amp;&amp; oField: *poFeature )&#123; switch( oField.GetType() ) &#123; case OFTInteger: printf( &quot;%d,&quot;, oField.GetInteger() ); break; case OFTInteger64: printf( CPL_FRMT_GIB &quot;,&quot;, oField.GetInteger64() ); break; case OFTReal: printf( &quot;%.3f,&quot;, oField.GetDouble() ); break; case OFTString: printf( &quot;%s,&quot;, oField.GetString() ); break; default: printf( &quot;%s,&quot;, oField.GetAsString() ); break; &#125;&#125; 除了上面显式处理的字段类型之外，还有一些字段类型，但可以使用OGRFeature :: GetFieldAsString（）方法获取它们的合理表示。事实上，我们可以通过对所有类型使用OGRFeature :: GetFieldAsString（）来缩短上述内容。 接下来，我们要从要素中提取几何体，并写出点几何体x和y。几何图形作为通用OGRGeometry指针返回。然后我们确定特定的几何类型，如果它是一个点，我们将其转换为点并对其进行操作。如果它是别的东西我们写占位符。 12345678910111213141516 OGRGeometry *poGeometry; poGeometry = poFeature-&gt;GetGeometryRef(); if( poGeometry != NULL &amp;&amp; wkbFlatten(poGeometry-&gt;getGeometryType()) == wkbPoint ) &#123;#if GDAL_VERSION_NUM &gt;= GDAL_COMPUTE_VERSION(2,3,0) OGRPoint *poPoint = poGeometry-&gt;toPoint();#else OGRPoint *poPoint = (OGRPoint *) poGeometry;#endif printf( &quot;%.3f,%3.f\\n&quot;, poPoint-&gt;getX(), poPoint-&gt;getY() ); &#125; else &#123; printf( &quot;no point geometry\\n&quot; ); &#125; 所述wkbFlatten（）宏上述用于将类型转换为一个wkbPoint25D（带z坐标的点）到2D的类型代码（wkbPoint）。对于每个2D几何类型，都有相应的2.5D类型代码。2D和2.5D几何案例由相同的C ++类处理，因此我们的代码将正确处理2D或3D案例。 12345678910111213141516171819202122OGRGeometry *poGeometry; int iGeomField; int nGeomFieldCount; nGeomFieldCount = poFeature-&gt;GetGeomFieldCount(); for(iGeomField = 0; iGeomField &lt; nGeomFieldCount; iGeomField ++ ) &#123; poGeometry = poFeature-&gt;GetGeomFieldRef(iGeomField); if( poGeometry != NULL &amp;&amp; wkbFlatten(poGeometry-&gt;getGeometryType()) == wkbPoint ) &#123; #if GDAL_VERSION_NUM &gt;= GDAL_COMPUTE_VERSION(2,3,0) OGRPoint *poPoint = poGeometry-&gt;toPoint(); #else OGRPoint *poPoint = (OGRPoint *) poGeometry; #endif printf( &quot;%.3f,%3.f\\n&quot;, poPoint-&gt;getX(), poPoint-&gt;getY() ); &#125; else &#123; printf( &quot;no point geometry\\n&quot; ); &#125; &#125; 请注意，OGRFeature :: GetGeometryRef（）和OGRFeature :: GetGeomFieldRef（）返回指向OGRFeature所拥有的内部几何的指针。实际上没有删除返回几何。 对于GDAL &lt;2.3，因为OGRLayer :: GetNextFeature（）方法返回现在由我们拥有的功能的副本。因此，在使用结束时，我们必须释放该功能。我们可以“删除”它，但这可能会导致Windows版本中的问题，其中GDAL DLL与主程序具有不同的“堆”。为了安全起见，我们使用GDAL功能删除该功能。 OGRFeature :: DestroyFeature（poFeature）;} 该OGRLayer通过返回的GDALDataset :: GetLayerByName（）也是由拥有一个内部层参考的GDALDataset所以我们并不需要将其删除。但我们确实需要删除数据源才能关闭输入文件。我们再一次使用自定义删除方法来避免特殊的win32堆问题。 GDALClose（poDS）; } 完整模板 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &quot;ogrsf_frmts.h&quot;int main()&#123; GDALAllRegister(); GDALDataset *poDS = static_cast&lt;GDALDataset*&gt;( GDALOpenEx( &quot;point.shp&quot;, GDAL_OF_VECTOR, NULL, NULL, NULL )); if( poDS == NULL ) &#123; printf( &quot;Open failed.\\n&quot; ); exit( 1 ); &#125; OGRLayer *poLayer = poDS-&gt;GetLayerByName( &quot;point&quot; ); OGRFeatureDefn *poFDefn = poLayer-&gt;GetLayerDefn(); poLayer-&gt;ResetReading(); OGRFeature *poFeature; while( (poFeature = poLayer-&gt;GetNextFeature()) != NULL ) &#123; for( int iField = 0; iField &lt; poFDefn-&gt;GetFieldCount(); iField++ ) &#123; OGRFieldDefn *poFieldDefn = poFDefn-&gt;GetFieldDefn( iField ); switch( poFieldDefn-&gt;GetType() ) &#123; case OFTInteger: printf( &quot;%d,&quot;, poFeature-&gt;GetFieldAsInteger( iField ) ); break; case OFTInteger64: printf( CPL_FRMT_GIB &quot;,&quot;, poFeature-&gt;GetFieldAsInteger64( iField ) ); break; case OFTReal: printf( &quot;%.3f,&quot;, poFeature-&gt;GetFieldAsDouble(iField) ); break; case OFTString: printf( &quot;%s,&quot;, poFeature-&gt;GetFieldAsString(iField) ); break; default: printf( &quot;%s,&quot;, poFeature-&gt;GetFieldAsString(iField) ); break; &#125; &#125; OGRGeometry *poGeometry = poFeature-&gt;GetGeometryRef(); if( poGeometry != NULL &amp;&amp; wkbFlatten(poGeometry-&gt;getGeometryType()) == wkbPoint ) &#123; OGRPoint *poPoint = (OGRPoint *) poGeometry; printf( &quot;%.3f,%3.f\\n&quot;, poPoint-&gt;getX(), poPoint-&gt;getY() ); &#125; else &#123; printf( &quot;no point geometry\\n&quot; ); &#125; OGRFeature::DestroyFeature( poFeature ); &#125; GDALClose( poDS );&#125; 写数据 作为通过OGR写作的一个例子，我们将大致与上述相反。从输入文本中读取逗号分隔值的短程序将通过OGR写入点shapefile。 1. 像往常一样，我们首先注册所有驱动程序，然后获取Shapefile驱动程序，因为我们需要它来创建输出文件。 123456789101112#include &quot;ogrsf_frmts.h&quot;int main()&#123; const char *pszDriverName = &quot;ESRI Shapefile&quot;; GDALDriver *poDriver; GDALAllRegister(); poDriver = GetGDALDriverManager()-&gt;GetDriverByName(pszDriverName ); if( poDriver == NULL ) &#123; printf( &quot;%s driver not available.\\n&quot;, pszDriverName ); exit( 1 ); &#125; 2. 接下来我们创建数据源。ESRI Shapefile驱动程序允许我们创建一个完整的shapefile目录，或一个shapefile作为数据源。在这种情况下，我们将通过在名称中包含扩展名来显式创建单个文件。其他驱动程序表现不同。第二个，第三个，第四个和第五个参数与栅格尺寸相关（如果驱动程序具有栅格功能）。调用的最后一个参数是选项值列表，但在这种情况下我们将只使用默认值。支持的选项的详细信息也是特定于格式的。 1234567GDALDataset *poDS;poDS = poDriver-&gt;Create( &quot;point_out.shp&quot;, 0, 0, 0, GDT_Unknown, NULL );if( poDS == NULL )&#123; printf( &quot;Creation of output file failed.\\n&quot; ); exit( 1 );&#125; 3. 现在我们创建输出层。在这种情况下，由于数据源是单个文件，因此我们只能有一个图层。我们传递wkbPoint来指定该层支持的几何类型。在这种情况下，我们不传递任何坐标系信息或其他特殊图层创建选项。 1234567OGRLayer *poLayer;poLayer = poDS-&gt;CreateLayer( &quot;point_out&quot;, NULL, wkbPoint, NULL );if( poLayer == NULL )&#123; printf( &quot;Layer creation failed.\\n&quot; ); exit( 1 );&#125; 4. 现在该图层已存在，我们需要创建应出现在图层上的任何属性字段。必须在写入任何要素之前将字段添加到图层。要创建字段，我们使用有关字段的信息初始化OGRField对象。在Shapefiles的情况下，字段宽度和精度在创建输出.dbf文件时很重要，所以我们专门设置它，尽管通常默认值是OK。对于此示例，我们将只有一个属性，一个与x，y点关联的名称字符串。 请注意，我们传递给CreateField（）的模板OGRField是在内部复制的。我们保留对象的所有权。 12345678910111213OGRFieldDefn oField（“Name”，OFTString）;oField.SetWidth（32）;if（poLayer-&gt; CreateField（＆oField）！= OGRERR_NONE）&#123; printf（“创建名称字段失败。\\ n”）; 退出（1）;&#125;//通过读数据中的x,y,name，写入double x, y; char szName[33]; while( !feof(stdin) &amp;&amp; fscanf( stdin, &quot;%lf,%lf,%32s&quot;, &amp;x, &amp;y, szName ) == 3 ) &#123; 5. 要将功能写入磁盘，我们必须创建本地OGRFeature，设置属性并附加几何体，然后再尝试将其写入图层。必须从与要写入的层关联的OGRFeatureDefn实例化此功能。 123OGRFeature * poFeature;poFeature = OGRFeature :: CreateFeature（poLayer-&gt; GetLayerDefn（））;poFeature-&gt; SetField（“Name”，szName）; 6. 我们创建一个本地几何对象，并将其副本（间接）分配给该功能。的和OGRFeature :: SetGeometryDirectly（）不同于和OGRFeature :: SetGeometry（）在该直接方法给出了几何形状的特征的所有权。这通常更有效，因为它避免了几何体的额外深层对象副本。 1234OGRPoint pt;pt.setX( x );pt.setY( y );poFeature-&gt;SetGeometry( &amp;pt ); 7. 现在我们在文件中创建一个功能。该OGRLayer :: CreateFeature（）不走我们的特点的所有权，所以我们在用它做清理。 1234567 if( poLayer-&gt;CreateFeature( poFeature ) != OGRERR_NONE ) &#123; printf( &quot;Failed to create feature in shapefile.\\n&quot; ); exit( 1 ); &#125; OGRFeature::DestroyFeature( poFeature );&#125; 8. 最后，我们需要关闭数据源，以确保以有序的方式写出标头，并恢复所有资源。`GDALClose（poDS）;}` 9. 模板 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &quot;ogrsf_frmts.h&quot;int main()&#123; const char *pszDriverName = &quot;ESRI Shapefile&quot;; GDALDriver *poDriver; GDALAllRegister(); poDriver = GetGDALDriverManager()-&gt;GetDriverByName(pszDriverName ); if( poDriver == NULL ) &#123; printf( &quot;%s driver not available.\\n&quot;, pszDriverName ); exit( 1 ); &#125; GDALDataset *poDS; poDS = poDriver-&gt;Create( &quot;point_out.shp&quot;, 0, 0, 0, GDT_Unknown, NULL ); if( poDS == NULL ) &#123; printf( &quot;Creation of output file failed.\\n&quot; ); exit( 1 ); &#125; OGRLayer *poLayer; poLayer = poDS-&gt;CreateLayer( &quot;point_out&quot;, NULL, wkbPoint, NULL ); if( poLayer == NULL ) &#123; printf( &quot;Layer creation failed.\\n&quot; ); exit( 1 ); &#125; OGRFieldDefn oField( &quot;Name&quot;, OFTString ); oField.SetWidth(32); if( poLayer-&gt;CreateField( &amp;oField ) != OGRERR_NONE ) &#123; printf( &quot;Creating Name field failed.\\n&quot; ); exit( 1 ); &#125; double x, y; char szName[33]; while( !feof(stdin) &amp;&amp; fscanf( stdin, &quot;%lf,%lf,%32s&quot;, &amp;x, &amp;y, szName ) == 3 ) &#123; OGRFeature *poFeature; poFeature = OGRFeature::CreateFeature( poLayer-&gt;GetLayerDefn() ); poFeature-&gt;SetField( &quot;Name&quot;, szName ); OGRPoint pt; pt.setX( x ); pt.setY( y ); poFeature-&gt;SetGeometry( &amp;pt ); if( poLayer-&gt;CreateFeature( poFeature ) != OGRERR_NONE ) &#123; printf( &quot;Failed to create feature in shapefile.\\n&quot; ); exit( 1 ); &#125; OGRFeature::DestroyFeature( poFeature ); &#125; GDALClose( poDS );&#125; 参考资料： 百度百科：https://baike.baidu.com/item/GDAL/4004525?fr=aladdin 官方网站：https://www.gdal.org/","tags":[{"name":"GDAL","slug":"GDAL","permalink":"http://11wy11.github.io/tags/GDAL/"}]},{"title":"常用工具","date":"2019-03-18T04:46:05.000Z","path":"2019/03/18/tools/","text":"主要介绍doctoc插件自动生成文章目录 markdown相关doctoc(markdown目录自动生成)GitHub中的markdown文件直接写[TOC]是无法生成目录的，可以使用工具doctocnpm install -g doctoc使用方式 对当前文件夹中所有文件生成目录e.g. 1234567 cd D:\\Develop\\Documents\\Notes\\CSDN笔记\\temp doctoc . ``` + 对文件夹中单个文件生成目录（文件名中间不能有空格） `doctoc /path/to/file [...]` 如： doctoc README.md doctoc CONTRIBUTING.md LICENSE.md doctoc D:\\Develop\\Documents\\Notes\\CSDN笔记\\JAVARxJava.md `","tags":[{"name":"tools","slug":"tools","permalink":"http://11wy11.github.io/tags/tools/"}]},{"title":"AI组件开发（二）--AIRealMathSuite","date":"2019-03-18T02:50:27.000Z","path":"2019/03/18/ai-second-note/","text":"主要介绍AIRealMathSuite中使用到的函数，以及部分应用场景，持续更新中 AIRealRectOverlapAIAPI AIBoolean(* AIRealMathSuite::AIRealRectOverlap)(const AIRealRect *a, const AIRealRect *b)Tests whether two rectangles overlap (have any points in common).测试两个矩形是否重叠（有任何共同点） 参数: aThe first rectangle. bThe second rectangle. 返回值：如果矩形重叠，则为真。 AIRealRectInAIRealRectAIAPI AIBoolean(* AIRealMathSuite::AIRealRectInAIRealRect)(const AIRealRect *a, const AIRealRect *b)Tests whether one rectangle is inside (entirely contained in) another rectangle.测试一个矩形是否在另一个矩形内（完全包含在内）。 Both must be open or both closed.两者都必须是开放的或都是封闭的。 参数: aThe first rectangle. bThe second rectangle. 返回值：True if the set of points contained by a is also contained by b.如果a包含的点集也包含在b内，则为真。 AIRealRectSetAIAPI void(* AIRealMathSuite::AIRealRectSet)(AIRealRect *a, AIReal left, AIReal top, AIReal right, AIReal bottom)Sets the coordinate values in a rectangle. 设置矩形中的坐标值(In the Illustrator art coordinate system, the origin, (0, 0), is at the bottom left corner of a page. X and Y values increase upward and to the right.) 参数: aThe rectangle object. ///AI的矩形对象指针 leftThe left side location.///xmin topThe top side location. ///ymax rightThe right side location.///xmax bottomThe bottom side location.///ymin 注意：Illustrator的坐标系原点位于页面左下角，X和Y值向上和向右增加。 AIRealPointInterpolateAIAPI void（* AIRealMathSuite :: AIRealPointInterpolate）（const AIRealPoint * a，const AIRealPoint * b，AIReal t，AIRealPoint * result）通过在点的相应坐标之间插入新坐标值来计算两点之间的点的位置。原理就是向量结果是 a t + b (1-t) 参数：a 第一点。b 第二点。t（b-a）的百分比，表示为0到1之间的数字。result [out]用于返回结果的缓冲区。 参考资料 Adobe Illustrator SDK，下载地址：https://www.adobe.com/devnet/illustrator/sdk.html 相关文章AI组件开发（一）–注记旋转矩阵AI组件开发（二）–AIRealMathSuiteAI组件开发（三）–AIArtboardSuiteAI组件开发（四）–AIDocumentSuiteAI组件开发（五）–AILayerSuiteAI组件开发（六）–AIArtSuiteAI组件开发（七）–AIPathSuite&amp;&amp;AIPathfinderSuiteAI组件开发（八）–AIArtStyleSuite","tags":[{"name":"AI","slug":"AI","permalink":"http://11wy11.github.io/tags/AI/"}]},{"title":"markdown编写技巧","date":"2019-03-17T13:33:53.000Z","path":"2019/03/17/markdown-first-skill/","text":"markdown编写技巧,转义字符及部分基本语法 常用转义字符 \\\\ 反斜杠 \\` 反引号 \\* 星号 \\_ 下划线 \\{\\} 大括号 \\[\\] 中括号 \\(\\) 小括号 \\# 井号 \\+ 加号 \\- 减号 \\. 英文句号 \\! 感叹号也可以用ASCII码代替 1 2 3 4 基本用法 标题设置（让字体变大，和word的标题意思一样）在Markdown当中设置标题，有两种方式：第一种：通过在文字下方添加“=”和“-”，他们分别表示一级标题和二级标题。第二种：在文字开头加上 “#”，通过“#”数量表示几级标题。（一共只有1~6级标题，1级标题字体最大） 块注释（blockquote）通过在文字开头添加“&gt;”表示块注释。（当&gt;和文字之间添加五个blank时，块注释的文字会有变化。） 斜体将需要设置为斜体的文字两端使用1个“*”或者“_”夹起来 粗体将需要设置为斜体的文字两端使用2个“*”或者“_”夹起来 无序列表在文字开头添加(*, +, and -)实现无序列表。但是要注意在(*, +, and -)和文字之间需要添加空格。（建议：一个文档中只是用一种无序列表的表示方式） 有序列表使用数字后面跟上句号。（还要有空格） 链接（Links）Markdown中有两种方式，实现链接，分别为内联方式和引用方式。内联方式：This is an [example link](http://example.com/).引用方式：I get 10 times more traffic from [Google][1] than from [Yahoo][2] or [MSN][3]. [1]: http://google.com/ “Google”[2]: http://search.yahoo.com/ “Yahoo Search”[3]: http://search.msn.com/ “MSN Search” 图片（Images）图片的处理方式和链接的处理方式，非常的类似。内联方式：![alt text](/path/to/img.jpg “Title”)引用方式：![alt text][id] [id]: /path/to/img.jpg “Title” 代码（HTML中所谓的Code）实现方式有两种：第一种：简单文字出现一个代码框。使用&lt;blockquote&gt;。（不是单引号而是左上角的ESC下面~中的）第二种：大片文字需要实现代码框。使用Tab和四个空格。 脚注（footnote）实现方式如下：hello[^hello] 下划线在空白行下方添加三条“-”横线。（前面讲过在文字下方添加“-”，实现的2级标题）参考官方文档http://daringfireball.net/projects/markdown/basics","tags":[{"name":"markdown","slug":"markdown","permalink":"http://11wy11.github.io/tags/markdown/"}]},{"title":"sqlite数据库查询 C++函数","date":"2019-03-17T13:17:22.000Z","path":"2019/03/17/sqlite-first-note/","text":"sqlite部分函数简介主要有打开数据库连接，执行数据库查询语句，关闭连接等函数 sqlite3_open用法打开数据库链接sqlite3_open用法原型：1234int sqlite3_open( const char *filename, /* Database filename (UTF-8) */ sqlite3 **ppDb /* OUT: SQLite db handle */); 用这个函数开始数据库操作。需要传入两个参数，一是数据库文件名，比如：E:/test.db。文件名不需要一定存在，如果此文件不存在，sqlite会自动建立它。如果它存在，就尝试把它当数据库文件来打开。二是sqlite3**，即前面提到的关键数据结构。函数返回值表示操作是否正确，如果是SQLITE_OK则表示操作正常。相关的返回值sqlite定义了一些宏。具体这些宏的含义可以参考sqlite3.h 文件。里面有详细定义。 sqlite3_close用法关闭数据库链接原型：1int sqlite3_close(sqlite3 *ppDb); ppDb为刚才使用sqlite3_open打开的数据库链接 sqlite3_exec用法执行sql操作原型：1234567int sqlite3_exec( sqlite3* ppDb, /* An open database */ const char *sql, /* SQL to be evaluated */ int (*callback)(void*,int,char**,char**), /* Callback function */ void *, /* 1st argument to callback */ char **errmsg /* Error msg written here */); 这就是执行一条sql 语句的函数。第1个参数不再说了，是前面open函数得到的指针。第2个参数constchar*sql是一条sql 语句，以\\0结尾。第3个参数sqlite3_callback 是回调，当这条语句执行之后，sqlite3会去调用你提供的这个函数。第4个参数void*是你所提供的指针，你可以传递任何一个指针参数到这里，这个参数最终会传到回调函数里面，如果不需要传递指针给回调函数，可以填NULL。回调函数的写法，以及这个参数的使用在之后介绍。第5个参数char** errmsg 是错误信息。注意是指针的指针。sqlite3里面有很多固定的错误信息。执行sqlite3_exec 之后，执行失败时可以查阅这个指针（直接cout&lt;&lt;errmsg得到一串字符串信息，这串信息告诉你错在什么地方。sqlite3_exec函数通过修改你传入的指针的指针，把你提供的指针指向错误提示信息，这样sqlite3_exec函数外面就可以通过这个char*得到具体错误提示。说明：通常，sqlite3_callback 和它后面的void*这两个位置都可以填NULL。填NULL表示你不需要回调。比如你做insert 操作，做delete操作，就没有必要使用回调。而当你做select 时，就要使用回调，因为sqlite3 把数据查出来，得通过回调告诉你查出了什么数据。exec 的回调typedef int(*sqlite3_callback)(void*,int,char**,char**);你的回调函数必须定义成上面这个函数的类型。下面给个简单的例子：123456789//sqlite3的回调函数//sqlite 每查到一条记录，就调用一次这个回调int LoadMyInfo(void* para,intn_column,char** column_value,char** column_name);//para是你在sqlite3_exec 里传入的void*参数通过para参数，你可以传入一些特殊的指针（比如类指针、结构指针），//然后在这里面强制转换成对应的类型（这里面是void*类型，必须强制转换成你的类型才可用）。然后操作这些数据//n_column是这一条记录有多少个字段(即这条记录有多少列)//char** column_value 是个关键值，查出来的数据都保存在这里，它实际上是个1维数组（不要以为是2维数组），//每一个元素都是一个char*值，是一个字段内容（用字符串来表示，以\\0结尾）//char** column_name 跟column_value是对应的，表示这个字段的字段名称 实例：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;iostream&gt;using namespace std;#include &quot;sqlite/sqlite3.h&quot;int callback(void*,int,char**,char**);int main()&#123; sqlite3* db; int nResult = sqlite3_open(&quot;test.db&quot;,&amp;db); if (nResult != SQLITE_OK) &#123; cout&lt;&lt;&quot;打开数据库失败：&quot;&lt;&lt;sqlite3_errmsg(db)&lt;&lt;endl; return 0; &#125; else &#123; cout&lt;&lt;&quot;数据库打开成功&quot;&lt;&lt;endl; &#125; char* errmsg; nResult = sqlite3_exec(db,&quot;create table fuck(id integer primary key autoincrement,name varchar(100))&quot;,NULL,NULL,&amp;errmsg); if (nResult != SQLITE_OK) &#123; sqlite3_close(db); cout&lt;&lt;errmsg; sqlite3_free(errmsg); return 0; &#125; string strSql; strSql+=&quot;begin;\\n&quot;; for (int i=0;i&lt;100;i++) &#123; strSql+=&quot;insert into fuck values(null,&apos;heh&apos;);\\n&quot;; &#125; strSql+=&quot;commit;&quot;; //cout&lt;&lt;strSql&lt;&lt;endl; nResult = sqlite3_exec(db,strSql.c_str(),NULL,NULL,&amp;errmsg); if (nResult != SQLITE_OK) &#123; sqlite3_close(db); cout&lt;&lt;errmsg&lt;&lt;endl; sqlite3_free(errmsg); return 0; &#125; strSql = &quot;select * from fuck&quot;; nResult = sqlite3_exec(db,strSql.c_str(),callback,NULL,&amp;errmsg); if (nResult != SQLITE_OK) &#123; sqlite3_close(db); cout&lt;&lt;errmsg&lt;&lt;endl; sqlite3_free(errmsg); return 0; &#125; sqlite3_close(db); return 0;&#125;int callback(void* ,int nCount,char** pValue,char** pName)&#123; string s; for(int i=0;i&lt;nCount;i++) &#123; s+=pName[i]; s+=&quot;:&quot;; s+=pValue[i]; s+=&quot;\\n&quot;; &#125; cout&lt;&lt;s&lt;&lt;endl; return 0;&#125;","tags":[{"name":"C++","slug":"C","permalink":"http://11wy11.github.io/tags/C/"},{"name":"sqlite","slug":"sqlite","permalink":"http://11wy11.github.io/tags/sqlite/"}]},{"title":"C++部分基础知识","date":"2019-03-17T06:09:53.000Z","path":"2019/03/17/cpp-function/","text":"介绍项目中用到的一些常用函数和关键字的使用Table of Contents generated with DocToc 常用函数 1. strtok 2.strcmp 3. Erase 4. List 5. strcpy 6.转换函数 6.1 Atoi 关键字 extern 变量 函数 编译链接 声明外部变量 C++中extern c的深层探索 常用函数1. strtok 分解字符串为一组字符串。s为要分解的字符，delim为分隔符字符（如果传入字符串，则传入的字符串中每个字符均为分割符）。首次调用时，s指向要分解的字符串，之后再次调用要把s设成NULL。 例如：strtok(“abc,def,ghi”,”,”)，最后可以分割成为abc def ghi.尤其在点分十进制的IP中提取应用较多。strtok的函数原型为char strtok(char s, char *delim)，功能为“Parse S into tokens separated by characters in DELIM.If S is NULL, the saved pointer in SAVE_PTR is used as the next starting point. ” 翻译成汉语就是：作用于字符串s，以包含在delim中的字符为分界符，将s切分成一个个子串；如果，s为空值NULL，则函数保存的指针SAVE_PTR在下一次调用中将作为起始位置。123456789101112131415#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;int main()&#123; char sentence[]=&quot;This is a sentence with 7 tokens&quot;; cout &lt;&lt; &quot;The string to be tokenized is:\\n&quot; &lt;&lt; sentence &lt;&lt; &quot;\\n\\nThe tokens are:\\n\\n&quot;; char *tokenPtr=strtok(sentence,&quot; &quot;); while(tokenPtr!=NULL) &#123; cout&lt;&lt;tokenPtr&lt;&lt;endl; tokenPtr=strtok(NULL,&quot; &quot;); &#125; //cout &lt;&lt; &quot;After strtok,sentence=&quot; &lt;&lt; tokenPtr&lt;&lt;endl; return 0;&#125; 函数第一次调用需设置两个参数。第一次分割的结果，返回串中第一个 ‘,’ 之前的字符串,也就是上面的程序第一次输出abc。第二次调用该函数strtok(NULL,”,”),第一个参数设置为NULL。结果返回分割依据后面的字串，即第二次输出d。strtok是一个线程不安全的函数，因为它使用了静态分配的空间来存储被分割的字符串位置线程安全的函数叫strtok_r,ca运用strtok来判断ip或者mac的时候务必要先用其他的方法判断’.’或’:’的个数，因为用strtok截断的话，比 2.strcmpC/C++函数，比较两个字符串设这两个字符串为str1，str2，若str1=str2，则返回零；若str1&lt;str2，则返回负数；若str1&gt;str2，则返回正数。matlab中函数，strcmp(s1，s2) 判断两个字符串s1和s2是否相同，相同返回true ,不同返回false源码：12345678910111213141516int strcmp(const char *str1,const char *str2)&#123; /*不可用while(*str1++==*str2++)来比较，当不相等时仍会执行一次++， return返回的比较值实际上是下一个字符。应将++放到循环体中进行。*/ while(*str1 == *str2) &#123; assert((str1 != NULL) &amp;&amp; (str2 != NULL)); if(*str1 == '\\0') return 0; str1++; str2++; &#125; return *str1 - *str2;&#125; 3. Erase c.erase(k)从c中删除元素k，返回一个size_type值，指出删除的元素的数量 c.erase(p)从c中删除迭代器p指定的元素，p必须指向c中的一个真实元素，不能等于c.end() c.erase(b,e)从c中删除迭代器对b和e所表示的范围中的元素，返回e4. ListList 反向迭代器begin和end成员begin和end操作产生指向容器内第一个元素和最后一个元素的下一个位置的迭代器，如下所示。这两个迭代器通常用于标记包含容器中所有元素的迭代范围。c.begin() 返回一个迭代器，它指向容器c的第一个元素c.end() 返回一个迭代器，它指向容器c的最后一个元素的下一个位置c.rbegin() 返回一个逆序迭代器，它指向容器c的最后一个元素c.rend() 返回一个逆序迭代器，它指向容器c的第一个元素前面的位置上述每个操作都有两个不同的版本：一个是const成员，另一个是非const成员。这些操作返回什么类型取决于容器是否为const。如果容器不是const，则这些操作返回iterator或reverse_iterator类型。如果容器是const，则其返回类型要加上const_前缀，也就是const_iterator和const_reverse_iterator类型。 5. strcpy描述C 库函数 char strcpy(char dest, const char *src) 把 src 所指向的字符串复制到 dest。 声明下面是 strcpy() 函数的声明。char *strcpy(char *dest, const char *src)参数dest – 指向用于存储复制内容的目标数组。src – 要复制的字符串。返回值该函数返回一个指向最终的目标字符串 dest 的指针。实例下面的实例演示了 strcpy() 函数的用法。12345678910111213141516#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main()&#123; char src[40]; char dest[100]; memset(dest, &apos;\\0&apos;, sizeof(dest)); strcpy(src, &quot;This is runoob.com&quot;); strcpy(dest, src); printf(&quot;最终的目标字符串： %s\\n&quot;, dest); return(0);&#125; 6.转换函数6.1 Atoi字符串转整型 6.2 Atof字符串转浮点型 7. malloc动态内存分配用于申请一块连续的指定大小的内存块区域以void类型返回分配的内存区域地址，当无法知道内存具体位置的时候，想要绑定真正的内存空间，就需要用到动态的分配内存。void \\malloc(size_t size);如果分配成功则返回指向被分配内存的指针(此存储区中的初始值不确定)，否则返回空指针NULL。当内存不再使用时，应使用free()函数将内存块释放。函数返回的指针一定要适当对齐，使其可以用于任何数据对象。例：1234567int *p;p = (int*)malloc(sizeof(int) * 128);//分配128个（可根据实际需要替换该数值）整型存储单元，//并将这128个连续的整型存储单元的首地址存储到指针变量p中double *pd = (double*)malloc(sizeof(double) * 12);//分配12个double型存储单元，//并将首地址存储到指针变量pd中 math库中的函数hypot 计算直角三角形的斜边长 关键字externextern是计算机语言中的一个关键字，可置于变量或者函数前，以表示变量或者函数的定义在别的文件中。提示编译器遇到此变量或函数时，在其它模块中寻找其定义，另外，extern也可用来进行链接指定。 变量在一个源文件里定义了一个数组：char a[6];在另外一个文件里用下列语句进行了声明：extern char *a； 请问，这样可以吗？ 答案与分析： 1)、不可以，程序运行时会告诉你非法访问。原因在于，指向类型T的指针并不等价于类型T的数组。extern char *a声明的是一个指针变量而不是字符数组，因此与实际的定义不同，从而造成运行时非法访问。应该将声明改为extern char a[ ]。 2)、例子分析如下，如果a[] = “abcd”,则外部变量a=0x12345678 (数组的起始地址)，而*a是重新定义了一个指针变量，a指向的地址可能是0x87654321,直接使用*a是错误的. 3)、这提示我们，在使用extern时候要严格对应声明时的格式，在实际编程中，这样的错误屡见不鲜。 4)、extern用在变量声明中常常有这样一个作用：你要在*.c文件中引用另一个文件中的一个全局的变量，那就应该放在*.h中用extern来声明这个全局变量。 extern用于变量的用法： extern int a;//声明一个全局变量a int a; //定义一个全局变量a extern int a =0 ;//定义一个全局变量a 并给初值。一旦给予赋值，一定是定义，定义才会分配存储空间。（注意：经过测试在GCC中，这样定义变量是不能通过编译的，而在VS2013可以） int a =0;//定义一个全局变量a,并给初值， 声明之后你不能直接使用这个变量，需要定义之后才能使用。 第四个等于第三个，都是定义一个可以被外部使用的全局变量，并给初值。 糊涂了吧，他们看上去可真像。但是定义只能出现在一处。也就是说，不管是int a;还是int a=0;都只能出现一次，而那个extern int a可以出现很多次。 当你要引用一个全局变量的时候，你就要声明extern int a;这时候extern不能省略，因为省略了，就变成int a;这是一个定义，不是声明。 函数实际上函数的声明和定义都不需要添加extern关键字，在实际使用的时候也最好不要添加关键字。如果一个函数是不会被其它文件调用的，那么这个函数应该被声明成static的。如：extern int func(void){return 0;}跟int func(void){return 0;} 是等价的另外 extern int func(void); 跟int func(void);是等价的。 编译链接声明外部变量现代编译器一般采用按文件编译的方式，因此在编译时，各个文件中定义的全局变量是互相不透明的。也就是说，在编译时，全局变量的可见域限制在文件内部。 下面举一个简单的例子： 创建一个工程，里面含有A.cpp和B.cpp两个简单的C++源文件：123456//A.cppint i;int main()&#123;&#125;//B.cppint i; 这两个文件极为简单，在A.cpp中我们定义了一个全局变量i，在B中我们也定义了一个全局变量i。 我们对A和B分别编译，都可以正常通过编译，但是进行链接的时候，却出现了错误，错误提示如下：12345Linking...B.obj:error LNK2005:&quot;inti&quot;(?i@@3HA)already defined in A.objDebug/A.exe:fatal error LNK1169:one or more multiply defined symbols foundError executing link.exe.A.exe-2 error(s),0 warning(s) 这就是说，在编译阶段，各个文件中定义的全局变量相互是不透明的，编译A时觉察不到B中也定义了i，同样，编译B时觉察不到A中也定义了i。 但是到了链接阶段，要将各个文件的内容“合为一体”，因此，如果某些文件中定义的全局变量名相同的话，在这个时候就会出现错误，也就是上面提示的重复定义的错误。 因此，各个文件中定义的全局变量名不可相同。 在链接阶段，各个文件的内容（实际是编译产生的obj文件）是被合并到一起的，因而，定义于某文件内的全局变量，在链接完成后，它的可见范围被扩大到了整个程序。 这样一来，按道理说，一个文件中定义的全局变量，可以在整个程序的任何地方被使用，举例说，如果A文件中定义了某全局变量，那么B文件中应可以使用该变量。修改我们的程序，加以验证： 1234567//A.cppint main()&#123; i = 100;//试图使用B中定义的全局变量&#125;//B.cppint i; 编译结果如下:12345Compiling...A.cppC:\\Documents and Settings\\桌面\\try extern\\A.cpp(5):error C2065:&apos;i&apos;:undeclared identifierError executing cl.exe.A.obj-1 error(s),0 warning(s) 编译错误。 其实出现这个错误是意料之中的，因为文件中定义的全局变量的可见性扩展到整个程序是在链接完成之后，而在编译阶段，他们的可见性仍局限于各自的文件。 编译器的目光不够长远，编译器没有能够意识到，某个变量符号虽然不是本文件定义的，但是它可能是在其它的文件中定义的。 虽然编译器不够有远见，但是我们可以给它提示，帮助它来解决上面出现的问题。这就是extern的作用了。 extern的原理很简单，就是告诉编译器：“你现在编译的文件中，有一个标识符虽然没有在本文件中定义，但是它是在别的文件中定义的全局变量，你要放行！” 我们为上面的错误程序加上extern关键字： 12345678//A.cppextern int i;int main()&#123; i=100;//试图使用B中定义的全局变量&#125;//B.cppint i; 顺利通过编译，链接。 C++中extern c的深层探索 简介C++语言的创建初衷是“a better C”，但是这并不意味着C++中类似C语言的全局变量和函数所采用的编译和连接方式与C语言完全相同。作为一种欲与C兼容的语言，C++保留了一部分过程式语言的特点（被世人称为“不彻底地面向对象”），因而它可以定义不属于任何类的全局变量和函数。但是，C++毕竟是一种面向对象的程序设计语言，为了支持函数的重载，C++对全局函数的处理方式与C有明显的不同。 从标准头文件说起某企业曾经给出如下的一道面试题：为什么标准头文件都有类似以下的结构？ 12345678910#ifndef __INCvxWorksh#define __INCvxWorksh#ifdef __cplusplusextern &quot;C&quot; &#123;#endif/*...*/#ifdef __cplusplus&#125;#endif#endif /* __INCvxWorksh */ 分析 显然，头文件中的编译宏“#ifndef INCvxWorksh、#define INCvxWorksh、#endif” 的作用是防止该头文件被重复引用。 那么 123456#ifdef __cplusplusextern &quot;C&quot; &#123;#endif#ifdef __cplusplus&#125;#endif 的作用又是什么呢？我们将在下文一一道 深层揭密extern “C” extern “C” 包含双重含义，从字面上即可得到：首先，被它修饰的目标是“extern”的；其次，被它修饰的目标是“C”的。让我们来详细解读这两重含义。 被extern “C”限定的函数或变量是extern类型的； extern是C/C++语言中表明函数和全局变量作用范围（可见性）的关键字，该关键字告诉编译器，其声明的函数和变量可以在本模块或其它模块中使用，记住，下列语句： extern int a; 仅仅是一个变量的声明，其并不是在定义变量a，并未为a分配内存空间。变量a在所有模块中作为一种全局变量只能被定义一次，否则会出现连接错误。 引用一个定义在其它模块的全局变量或函数（如，全局函数或变量定义在A模块，B欲引用）有两种方法， 一、B模块中include模块A的头文件。 二、模块B中对欲引用的模块A的变量或函数重新声明一遍，并前加extern关键字。 通常，在模块的头文件中对本模块提供给其它模块引用的函数和全局变量以关键字extern声明。 例如，如果模块B欲引用该模块A中定义的全局变量和函数时只需包含模块A的头文件即可。这样，模块B中调用模块A中的函数时，在编译阶段，模块B虽然找不到该函数，但是并不会报错；它会在连接阶段中从模块A编译生成的目标代码中找到此函数。 与extern对应的关键字是static，被它修饰的全局变量和函数只能在本模块中使用。因此，一个函数或变量只可能被本模块使用时，其不可能被extern “C”修饰。 被extern “C”修饰的变量和函数是按照C语言方式编译和连接的； 未加extern “C”声明时的编译方式 首先看看C++中对类似C的函数是怎样编译的。 作为一种面向对象的语言，C++支持函数重载，而过程式语言C则不支持。函数被C++编译后在符号库中的名字与C语言的不同。例如，假设某个函数的原型为： void foo( int x, int y ); 该函数被C编译器编译后在符号库中的名字为_foo，而C++编译器则会产生像_foo_int_int之类的名字（不同的编译器可能生成的名字不同，但是都采用了相同的机制，生成的新名字称为“mangled name”）。 _foo_int_int这样的名字包含了函数名、函数参数数量及类型信息，C++就是靠这种机制来实现函数重载的。例如，在C++中，函数void foo( int x, int y )与void foo( int x, float y )编译生成的符号是不相同的，后者为_foo_int_float。 同样地，C++中的变量除支持局部变量外，还支持类成员变量和全局变量。用户所编写程序的类成员变量可能与全局变量同名，我们以”.”来区分。而本质上，编译器在进行编译时，与函数的处理相似，也为类中的变量取了一个独一无二的名字，这个名字与用户程序中同名的全局变量名字不同。 未加extern “C”声明时的连接方式 假设在C++中，模块A的头文件如下： 123456789// 模块A头文件 moduleA.h#ifndef MODULE_A_H#define MODULE_A_Hint foo( int x, int y );#endif在模块B中引用该函数：// 模块B实现文件 moduleB.cpp#include &quot;moduleA.h&quot;foo(2,3); 实际上，在连接阶段，连接器会从模块A生成的目标文件moduleA.obj中寻找_foo_int_int这样的符号！ 加extern “C”声明后的编译和连接方式 加extern “C”声明后，模块A的头文件变为： 12345// 模块A头文件 moduleA.h#ifndef MODULE_A_H#define MODULE_A_Hextern &quot;C&quot; int foo( int x, int y );#endif 在模块B的实现文件中仍然调用foo( 2,3 )，其结果是： （1）模块A编译生成foo的目标代码时，没有对其名字进行特殊处理，采用了C语言的方式； （2）连接器在为模块B的目标代码寻找foo(2,3)调用时，寻找的是未经修改的符号名_foo。 如果在模块A中函数声明了foo为extern “C”类型，而模块B中包含的是extern int foo( int x, int y ) ，则模块B找不到模块A中的函数；反之亦然。 所以，可以用一句话概括extern “C”这个声明的真实目的（任何语言中的任何语法特性的诞生都不是随意而为的，来源于真实世界的需求驱动。我们在思考问题时，不能只停留在这个语言是怎么做的，还要问一问它为什么要这么做，动机是什么，这样我们可以更深入地理解许多问题）： 实现C++与C及其它语言的混合编程。 明白了C++中extern “C”的设立动机，我们下面来具体分析extern “C”通常的使用技巧。 extern “C”的惯用法 （1）在C++中引用C语言中的函数和变量，在包含C语言头文件（假设为cExample.h）时，需进行下列处理： 1234extern &quot;C&quot;&#123;#include &quot;cExample.h&quot;&#125; 而在C语言的头文件中，对其外部函数只能指定为extern类型，C语言中不支持extern “C”声明，在.c文件中包含了extern “C”时会出现编译语法错误。 笔者编写的C++引用C函数例子工程中包含的三个文件的源代码如下： 123456789101112131415161718192021/*c语言头文件：cExample.h */#ifndef C_EXAMPLE_H#define C_EXAMPLE_Hextern int add(int x,int y);#endif/*c语言实现文件：cExample.c */#include &quot;cExample.h&quot;int add( int x, int y )&#123;return x + y;&#125;//c++实现文件，调用add：cppFile.cppextern &quot;C&quot;&#123;#include &quot;cExample.h&quot;&#125;int main(int argc, char* argv[])&#123;add(2,3);return 0;&#125; 如果C++调用一个C语言编写的.DLL时，当包括.DLL的头文件或声明接口函数时，应加extern “C” { }。 （2）在C++引用C语言中的函数和变量时，C++的头文件需添加extern “C”，但是在C语言中不能直接引用声明了extern “C”的该头文件，应该仅将C文件中将C++中定义的extern “C”函数声明为extern类型。 笔者编写的C引用C++函数例子工程中包含的三个文件的源代码如下： 123456789101112131415161718192021//C++头文件 cppExample.h#ifndef CPP_EXAMPLE_H#define CPP_EXAMPLE_Hextern &quot;C&quot; int add( int x, int y );#endif//C++实现文件 cppExample.cpp#include &quot;cppExample.h&quot;int add( int x, int y )&#123;return x + y;&#125;/* C实现文件 cFile.c/* 这样会编译出错：#include &quot;cppExample.h&quot; */extern int add (int x,int y);int main (int argc,char*argv[])&#123; add(2,3); return 0;&#125; 参考：百度百科https://baike.baidu.com/item/extern/4443005?fr=aladdin 内存操作函数menset 函数原型是：void memset(void s, int ch, size_t n); 函数功能是：将s所指向的某一块内存中的前n个字节的内容全部设置为ch指定的ASCII值， 第一个值为指定的内存地址，块的大小由第三个参数指定，这个函数通常为新申请的内存做初始化工作， 其返回值为指向s的指针，它是对较大的结构体或数组进行清零操作的一种最快方法。 memset函数通常用来对一块已经分配地址的内存进行初始化，并且通常初始化为0或者字符’\\0’（实际上是一样的）。下面是一些常见例子。","tags":[{"name":"C++","slug":"C","permalink":"http://11wy11.github.io/tags/C/"}]},{"title":"krpano快速入门教程（三）之热点Hotspot","date":"2019-03-16T14:54:57.000Z","path":"2019/03/16/krpano-third-note/","text":"使用编辑器热点，添加自定义热点，动态热点等 添加热点及相关内容使用编辑器热点，添加自定义热点，动态热点等 使用tour_editor添加热点及设定起始角度通过Load tour.xml导入要编辑的配置文件点击set as startup view设置初始角度，可以旋转到合适的角度，点击按钮设置全景图默认展示角度。点击Add hotspot按钮，画面中出现一个箭头，将其拖放置你想放置的地方，点击save按钮保存热点编辑。也可以通过编辑按钮设置热点链接场景。点击Save tour.xml按钮保存文件。 编辑 tour.xml添加热点在实际生产中，通常直接编辑xml文件，在相应的场景中添加热点123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687&lt;hotspot name=&quot;...&quot; 定义热点名称 type=&quot;image&quot; 定义热点类型，只能是image url=&quot;...&quot; 热点图像路径，支持SWF, JPG, PNG, GIF alturl=&quot;...&quot; html5状态下显示的图像路径 keep=&quot;false&quot; 是否在下一场景跳转后保持显示 devices=&quot;all&quot; 支持设备类型 visible=&quot;true&quot; 是否可见 enabled=&quot;true&quot; 设置热点是否接收鼠标事件 handcursor=&quot;true&quot; 设置是否鼠标移到上面显示小手 maskchildren=&quot;false&quot; 设置是否将子控件变成蒙板 zorder=&quot;&quot; 插入元素的次序索引，可以是字符也可以是数字，html5输出必须是0-100整数 zorder2=&quot;0.0&quot; 设置为0.0和1.0，分别对应当前热点在扭曲控件之下和之上 capture=&quot;true&quot; 与enabled配合使用，都为true只对热点传递动作，capture=&quot;false&quot;可对子控件传递动作 children=&quot;true&quot; 设置子控件是否接收热点鼠标事件 blendmode=&quot;normal&quot; 设置混合模式，可选：normal, layer, screen, add, subtract, difference, multiply, overlay, lighten, darken, hardlight, invert. style=&quot;&quot; 读入已设置好的style名称 ath=&quot;0.0&quot; atv=&quot;0.0&quot; 设定将场景缩略图为球形热点 edge=&quot;center&quot; 热点的边界对齐点 ox=&quot;0&quot; 边界到对齐点的偏移量 oy=&quot;0&quot; zoom=&quot;false&quot; 设置是否场景缩放时，热点跟随缩放 distorted=&quot;false&quot; rx=&quot;0.0&quot; ry=&quot;0.0&quot; rz=&quot;0.0&quot; 设置热点是否跟随场景进行3D扭曲 details=&quot;8&quot; 热点显示的细节数量，默认为8 inverserotation=&quot;false&quot; 设置是否逆向旋转3D扭曲 flying=&quot;0.0&quot; 设置ath/atv/scale的插值 width=&quot;&quot; height=&quot;&quot; 设置热点宽高 scale=&quot;1.0&quot; 设置热点缩放 rotate=&quot;0.0&quot; 设置热点旋转角度 pixelhittest=&quot;false&quot; 是否启动精确像素测试 smoothing=&quot;true&quot; 设置缩放时，是否平滑化处理 accuracy=&quot;0&quot; 设置像素渲染值（flash下） accuracy2=&quot;1&quot; 设置精度控制（html5下） alpha=&quot;1.0&quot; 设置透明度 autoalpha=&quot;false&quot; 设置是否自动变更透明度 usecontentsize=&quot;false&quot; 是否使用用户指定flash大小，默认false原始大小 scale9grid=&quot;&quot; 定义是否支持矢量缩放，scale9grid=&quot;x-position|y-position|width|height|prescale*&quot; crop=&quot;&quot; 定义元素坐标及宽高 crop=&quot;x-position|y-position|width|height&quot; onovercrop=&quot;&quot; 设置元素鼠标移到上方后的坐标及宽高 ondowncrop=&quot;&quot; 设置元素鼠标按下状态后的坐标及宽高 scalechildren=&quot;false&quot; 子元素是否跟随缩放 mask=&quot;&quot; mask=&quot;name&quot; mask=&quot;layer[name]&quot; mask=&quot;hotspot[name]&quot; effect=&quot;&quot; 热点位图效果3种：glow(color,alpha,range,strength); dropshadow(depth,angle,color,range,strength); blur(radius); onover=&quot;&quot; 鼠标在经过上方时执行动作 onhover=&quot;&quot; 鼠标停在上方时执行动作 onout=&quot;&quot; 鼠标停移出范围时时执行动作 onclick=&quot;&quot; 鼠标停点击时执行动作 ondown=&quot;&quot; 鼠标按下时执行动作 onup=&quot;&quot; 鼠标按键松开时执行动作 onloaded=&quot;&quot; 加载元素完成后执行动作 /&gt; 多边形热点 &lt;hotspot name=&quot;...&quot; keep=&quot;false&quot; visible=&quot;true&quot; enabled=&quot;true&quot; handcursor=&quot;true&quot; zorder=&quot;&quot; capture=&quot;true&quot; blendmode=&quot;normal&quot; style=&quot;&quot; alpha=&quot;1.0&quot; autoalpha=&quot;false&quot; fillcolor=&quot;0xFFFFFF&quot; fillcolorhover=&quot;0xFFFFFF&quot; 填充颜色及鼠标移上后颜色 fillalpha=&quot;0.0&quot; fillalphahover=&quot;0.1&quot; 填充颜色透明度及鼠标移上后颜色透明度 borderwidth=&quot;0.0&quot; borderwidthhover=&quot;4.0&quot; 边界宽度及鼠标移上后边界宽度 bordercolor=&quot;0xFFFFFF&quot; bordercolorhover=&quot;0xFFFFFF&quot; 边界颜色及边界鼠标移上后颜色 borderalpha=&quot;0.0&quot; borderalphahover=&quot;0.8&quot; 边界透明度及鼠标移上后边界透明度 fadeintime=&quot;0.15&quot; fadeincurve=&quot;1.1&quot; 悬停状态变化时间及形式 fadeouttime=&quot;0.3&quot; fadeoutcurve=&quot;0.7&quot; onover=&quot;&quot; onhover=&quot;&quot; onout=&quot;&quot; onclick=&quot;&quot; ondown=&quot;&quot; onup=&quot;&quot; &gt; &lt;point ath=&quot;...&quot; atv=&quot;...&quot; /&gt; 多边形热点坐标 &lt;point ath=&quot;...&quot; atv=&quot;...&quot; /&gt; &lt;point ath=&quot;...&quot; atv=&quot;...&quot; /&gt; ... &lt;/hotspot&gt; 历史文章krpano快速入门教程（一) 使用krpano工具构建即用型panoskrpano快速入门教程（二) vtour全景漫游及vtour文件夹介绍","tags":[{"name":"krpano","slug":"krpano","permalink":"http://11wy11.github.io/tags/krpano/"}]},{"title":"C++之QT的信号和槽的详解","date":"2019-03-16T12:24:56.000Z","path":"2019/03/16/qt-note/","text":"QT的信号和槽的详解，包括简介，信号和槽分析以及一个实例 1 简介 信号和槽是Qt特有的信息传输机制，是Qt设计程序的重要基础，它可以让互不干扰的对象建立一种联系。 在GUI编程中，当我们改变一个部件时，经常想要其他部件被通知。更一般化，我们希望任何一类的对象可以和其它对象进行通讯。例如，如果我们点击一个关闭按钮，我们可能想要窗口的close()函数被调用。 其他工具包通过回调实现了这种通信。回调是一个函数指针，所以如果你希望一个处理函数通知你一些事件，你可以把另一个函数（回调）的指针传递给处理函数。处理函数在适当的时候调用回调。尽管一些成功的框架使用了这个方法，但是回调可能是不直观的，并可能在确保回调参数类型正确性上存在问题。信号槽是 Qt 框架引以为豪的机制之一。所谓信号槽，实际就是观察者模式。当某个事件发生之后，比如，按钮检测到自己被点击了一下，它就会发出一个信号（signal）。这种发出是没有目的的，类似广播。如果有对象对这个信号感兴趣，它就会使用连接（connect）函数，意思是，将想要处理的信号和自己的一个函数（称为槽（slot））绑定来处理这个信号。也就是说，当信号发出时，被连接的槽函数会自动被回调。这就类似观察者模式：当发生了感兴趣的事件，某一个操作就会被自动触发。（这里提一句，Qt 的信号槽使用了额外的处理来实现，并不是 GoF 经典的观察者模式的实现方式。） 信号和槽是Qt特有的信息传输机制，是Qt设计程序的重要基础，它可以让互不干扰的对象建立一种联系。 槽的本质是类的成员函数，其参数可以是任意类型的。和普通C++成员函数几乎没有区别，它可以是虚函数；也可以被重载；可以是公有的、保护的、私有的、也可以被其他C++成员函数调用。唯一区别的是：槽可以与信号连接在一起，每当和槽连接的信号被发射的时候，就会调用这个槽。 Qt的小部件有很多预定义的信号，但是我们总是可以通过继承来加入我们自己的信号。槽就是一个对应于特定信号的被调用的函数。Qt的部件有很多预定义的槽，但同样可以通过子类化加入自己的槽来处理感兴趣的信号。 1.1 对象树(子对象动态分配空间不需要释放) 比如说当应用程序创建了一个具有父窗口部件的对象时，该对象将被加入父窗口部件的孩子列表。当应用程序销毁父窗口部件时，其下的孩子列表中的对象将被一一删除。这让我们在编程时，能够将主要精力放在系统的业务上，提高编程效率，同时也保证了系统的稳健性。 2 信号和槽 在Qt中我们有一种可以替代回调的技术：我们使用信号和槽。当一个特定事件发生的时候，一个信号被发射。Qt的小部件有很多预定义的信号，但是我们总是可以通过继承来加入我们自己的信号。槽就是一个对应于特定信号的被调用的函数。Qt的部件有很多预定义的槽，但同样可以通过子类化加入自己的槽来处理感兴趣的信号。 信号和槽机制是类型安全的：一个信号的签名(参数类型)必须与它的接收槽的签名相匹配。（实际上，一个槽的签名可能比它接收到的信号短，因为它可以忽略额外的参数。）因为签名是兼容的，当使用基于函数指针的语法时，编译器就可以帮助我们检测类型不匹配。基于字符串的信号和槽语法将在运行时检测类型不匹配。信号和插槽是松散耦合的：一个发射信号的类不用知道也不用关心哪个槽要接收这个信号。Qt的信号和槽的机制可以保证如果你把一个信号和一个槽连接起来，槽会在正确的时间使用信号的参数被调用。信号和槽可以使用任何数量、任何类型的参数。它们是完全类型安全的：不会再有回调核心转储(core dump)。 从QObject类或者它的子类（如QWidget类）继承的所有类可以包含信号和槽。当改变它们的状态的时候，信号被发送。从某种意义上说，即它们对其他对象感兴趣。这就是所有的对象通讯时所做的一切。它不知道也不关心是否有其他对象接收到了它发射的信号。这就是真正的信息封装，并且确保对象可以用作一个软件组件使用。 槽可以用来接收信号，但它们也是普通的成员函数。正如一个对象不知道有其他对象收到它的信号一样，一个槽也不知道它是否被任意信号连接。因此，这种方式保证了Qt创建组件的完全独立。 你可以连接多个信号到一个槽，同样一个信号可以被你需要的多个槽连接。甚至可以一个信号连接到另一个信号。（该情况下，只要第一个信 号被发射时，第二个信号立即被发射。） 总体来看，信号和槽构成了一个强有力的组件编程机制。 2.1 信号 当一个对象内部状态发生改变时发射信号，信号就被发射，在某些方面对象的客户端和所有者可能感兴趣。信号是一个public访问函数并可以在任何地方发射，但是我们建议仅在定义了信号的类及他们的子类中发射。 当一个信号被发射，它所连接的槽会被立即执行，类似于一个普通函数的调用。在该情况下，信号/槽机制在任何GUI事件循环中是完全独立的。一旦所有的槽返回了，emit语句随后的代码将会执行。这与queued connections方式有些许不同，queued connections方式下emit关键字随后的代码会立即继续执行，槽在随后执行（相当于异步，参考信号与槽的连接类型）。 如果几个槽被连接到一个信号，当信号被发射时，这些槽就会按它们连接的顺序挨个执行。 信号会由moc自动生成并一定不要在.cpp文件中实现。它们也不能有任何返回类型（也就是 只能使用void）。 2.2 槽 当与槽连接的信号被发射时，该槽被调用。槽是普通的C++函数可以正常调用；它们唯一的特点就是可以被信号连接。 因为槽是普通成员函数，所以被直接调用时遵循一般的C++规则。然而，作为槽，它们能被任何组件调用，通过信号槽连接，无需考虑访问级别。这意味着从一个任意类的实例发出的一个信号可以在一个不相关的类的实例中调用一个私有槽。 同样还可以定义虚拟槽，我们在实践中发现它非常有用。 与回调相比，信号和插槽的速度稍慢，因为它们增加了灵活性，尽管在实际应用程序中的差异是微不足道的。 信号和槽的机制是非常有效的，但是它不像“真正的”回调那样快。信号和槽稍微有些慢，这是因为它们所提供的灵活性造成，尽管在实际应用中这些性能可以被忽略。通常，发射一个和槽相连的信号，大约比直接调接收器非虚函数的调用慢十倍。这是定位连接对象所需的开销，为了安全地遍历所有连接（e.g检查随后的接收器在发射过程中没有被销毁），并以通用的方式安排任意参数。虽然10个非虚函数调用听起来可能很多，但开销比任意new或delete 操作少得多。当执行一个字符串时，vector或list操作在后面的场景中需要new或delete, 但信号和槽在完成函数调用的开销中只占很小的一部分。在一个槽中进行系统调用或者间接地调用超过10个函数，情况也是相同的;。信号/插槽机制的简单和灵活性对于时间的开销是值得，用户甚至不会注意到这点。 注意，与基于qt的应用程序一起编译时，定义变量的其他库调用信号和槽可能会造成编译器警告和错误。要解决这个问题，#undef这些预处理器的冲突符号即可。 2.3 一个Qt Creator的例子 1234567891011#include &lt;QApplication&gt;#include &lt;QPushButton&gt; int main(int argc, char *argv[]) &#123; QApplication app(argc, argv); QPushButton button(&quot;Quit&quot;); QObject::connect(&amp;button, &amp;QPushButton::clicked, &amp;app, &amp;QApplication::quit); button.show(); return app.exec(); &#125; 在 Qt Creator 中创建工程的方法创建好工程，然后将main()函数修改为上面的代码。点击运行，我们会看到一个按钮，上面有“Quit”字样。点击按钮，程序退出。 connect()函数最常用的一般形式： connect(sender, signal, receiver, slot); 参数： sender：发出信号的对象 signal：发送对象发出的信号 receiver：接收信号的对象 slot：接收对象在接收到信号之后所需要调用的函数 信号槽要求信号和槽的参数一致，所谓一致，是参数类型一致。如果不一致，允许的情况是，槽函数的参数可以比信号的少，即便如此，槽函数存在的那些参数的顺序也必须和信号的前面几个一致起来。这是因为，你可以在槽函数中选择忽略信号传来的数据（也就是槽函数的参数比信号的少），但是不能说信号根本没有这个数据，你就要在槽函数中使用（就是槽函数的参数比信号的多，这是不允许的）。 2.4 一个普通C++程序的例子 一个小的C++类声明如下： 12345678910class Counter &#123; public: Counter() &#123; m_value = 0; &#125; int value() const &#123; return m_value; &#125; void setValue(int value); private: int m_value; &#125;; 一个小的基于QObject类如下： 123456789101112131415#include &lt;QObject&gt; class Counter : public QObject &#123; Q_OBJECT public: Counter() &#123; m_value = 0; &#125; int value() const &#123; return m_value; &#125; public slots: void setValue(int value); signals: void valueChanged(int newValue); private: int m_value; &#125;; 这个基于QObject的类有同样的内部状态，并提供公有方法来访问状态。除此之外，这个类可以通过发射一个valueChanged()信号来告诉外部世界关于它的状态改变，并且它有一个槽，其它对象可以发送信号给这个槽。 所有包含信号和/或者槽的类必须在它们的声明中提到Q_OBJECT。它们也必须从QObject继承(直接或间接)。 槽由应用程序的编写者来实现。这里是Counter::setValue()可能的一个槽实现： 1234567void Counter::setValue(int value) &#123; if (value != m_value) &#123; m_value = value; emit valueChanged(value); &#125; &#125; emit这一行从对象中发射valueChanged()信号，以一个新值作为参数。 在下面的小片断中，我们创建了两个Counter对象，并使用QObject::connect()将第一个对象的valueChanget()信号连接到第二个对象的setValue槽。 下面是把两个对象连接在一起的一种方法： 123456Counter a, b; QObject::connect(&amp;a, &amp;Counter::valueChanged, &amp;b, &amp;Counter::setValue); a.setValue(12); // a.value() == 12, b.value() == 12 b.setValue(48); // a.value() == 12, b.value() == 48 调用a.setValue(12)会使a发射一个valueChanged(12) 信号，b将会在它的setValue()槽中接收这个信号，也就是b.setValue(12) 被调用。接下来b会发射同样的valueChanged()信号，但是因为没有槽被连接到b的valueChanged()信号，所以该信号被忽略。 注意只有当value!= m_value的时候setValue()函数才会设置这个值并发射信号。这样就避免了存在环connections的情况下无限循环。（比如b.valueChanged() 和a.setValue()连接在一起）。 默认情况下，对于你做出的每一个连接，一个信号被发射;重复连接下两个信号被发射。你可以调用disconnect()中断所有连接。如果传递了Qt::UniqueConnection类型，连接只有在不重复的情况下才建立。如果已经存在重复连接（同一个对象上确定的信号到确定的槽），则连接将会失败，connect返回fase。 这个例子说明了对象可以协同工作而不需要知道彼此的任何信息。为达到这种效果，对像仅需要相互连接，并用一个简单的QObject::connect()函数调用实现，或者使用uic的自动连接特性。 2.5 带有默认参数的信号和槽 信号和槽的签名可能包含参数，参数可以有默认值。考虑QObject::destroyed()函数。 void destroyed(QObject* = 0); 当一个QObject对象被删除，它发射QObject::destroyed()信号。我们想捕获此信号，无论在我们可能有一个悬空的引用指向删除的QObject对象的情况下，因此我们可以把它清理干净。一个合适的槽签名可能是这样的: void objectDestroyed(QObject* obj = 0); 为连接一个信号到此槽，我们使用QObject::connect。这里有几个方式连接。第一种方式是使用函数指针： connect(sender,&amp;QObject::destroyed,this,&amp;MyObject::objectDestroyed); 连接信号到槽的另一种方法是使用QObject::connect()，SIGNAL和SLOT宏。关于是否在SIGNAL()和SLOT()宏中包含参数的规则，如果参数有默认值，传递给SIGNAL()宏的签名必须不能少于传递给SLOT()宏签名的参数。 下述这些都会生效：12345678connect(sender,SIGNAL(destroyed(QObject*)),this,SLOT(objectDestroyed(Qbject*)));connect(sender,SIGNAL(destroyed(QObject*)),this,SLOT(objectDestroyed()));connect(sender, SIGNAL(destroyed()),this,SLOT(objectDestroyed())); 2.6 信号和槽的进一步使用 对于可能需要信号发送者信息的情况, Qt提供了QObject::sender()函数，它返回一个指向发送信号的对象的指针。 QSignalMapper类为一种情形提供，该情况下多个信号连接到同一个槽，而槽需要以不同的方式处理每个信号。 假设有三个按钮来决定将打开哪个文件: “Tax File”, “Accounts File”, “Report File”. 为了打开正确的文件,使用QSignalMapper:setMapping()来映射所有QPushButton:clicked()到QSignalMapper对象。然后将文件的QPushButton::clicked()信号连接到QSignalMapper::map()槽。 123456789101112131415161718signalMapper = new QSignalMapper(this); signalMapper-&gt;setMapping(taxFileButton, QString(&quot;taxfile.txt&quot;)); signalMapper-&gt;setMapping(accountFileButton, QString(&quot;accountsfile.txt&quot;)); signalMapper-&gt;setMapping(reportFileButton, QString(&quot;reportfile.txt&quot;)); connect(taxFileButton, &amp;QPushButton::clicked, signalMapper, &amp;QSignalMapper::map); connect(accountFileButton, &amp;QPushButton::clicked, signalMapper, &amp;QSignalMapper::map); connect(reportFileButton, &amp;QPushButton::clicked, signalMapper, &amp;QSignalMapper::map); 然后，将mapped()信号连接到readFile()，根据按下的按钮，readFile()打开不同的文件。connect(signalMapper, SIGNAL(mapped(QString)),this, SLOT(readFile(QString))); 2.7 自定义信号槽 发送者和接收者都需要是QObject的子类（当然，槽函数是全局函数、Lambda 表达式等无需接收者的时候除外）； 使用 signals 标记信号函数，信号是一个函数声明，返回 void，不需要实现函数代码； 槽函数是普通的成员函数，作为成员函数，会受到 public、private、protected 的影响； 使用 emit 在恰当的位置发送信号； 使用QObject::connect()函数连接信号和槽。 任何成员函数、static 函数、全局函数和 Lambda 表达式都可以作为槽函数 2.8 信号槽的更多用法 一个信号可以和多个槽相连 如果是这种情况，这些槽会一个接一个的被调用，但是它们的调用顺序是不确定的。 多个信号可以连接到一个槽 只要任意一个信号发出，这个槽就会被调用。 一个信号可以连接到另外的一个信号 当第一个信号发出时，第二个信号被发出。除此之外，这种信号-信号的形式和信号-槽的形式没有什么区别。 槽可以被取消链接 这种情况并不经常出现，因为当一个对象delete之后，Qt自动取消所有连接到这个对象上面的槽。 使用Lambda 表达式 在使用 Qt 5 的时候，能够支持 Qt 5 的编译器都是支持 Lambda 表达式的。 我们的代码可以写成下面这样： 12345QObject::connect(&amp;newspaper, static_cast&lt;void (Newspaper:: *)(const QString &amp;)&gt;(&amp;Newspaper::newPaper),[=](const QString &amp;name) &#123; /* Your code here. */ &#125;); 在连接信号和槽的时候，槽函数可以使用Lambda表达式的方式进行处理。 3 案例mainwidget.h 123456789101112131415161718192021222324252627282930#ifndef MAINWIDGET_H#define MAINWIDGET_H#include &lt;QWidget&gt;#include &lt;QPushButton&gt;#include &quot;subwidget.h&quot; //子窗口头文件class MainWidget : public QWidget&#123; Q_OBJECTpublic: MainWidget(QWidget *parent = 0); ~MainWidget();public slots: void mySlot(); void changeWin(); void dealSub(); void dealSlot(int, QString);private: QPushButton b1; QPushButton *b2; QPushButton b3; SubWidget subWin;&#125;;#endif // MAINWIDGET_H subwidget.h 1234567891011121314151617181920212223242526272829303132#ifndef SUBWIDGET_H#define SUBWIDGET_H#include &lt;QWidget&gt;#include &lt;QPushButton&gt;class SubWidget : public QWidget&#123; Q_OBJECTpublic: explicit SubWidget(QWidget *parent = 0); void sendSlot();signals: /* 信号必须有signals关键字来声明 * 信号没有返回值，但可以有参数 * 信号就是函数的声明，只需声明，无需定义 * 使用：emit mySignal(); * 信号可以重载 */ void mySignal(); void mySignal(int, QString);public slots:private: QPushButton b;&#125;;#endif // SUBWIDGET_H main.cpp 1234567891011#include &quot;mainwidget.h&quot;#include &lt;QApplication&gt;int main(int argc, char *argv[])&#123; QApplication a(argc, argv); MainWidget w;//执行MainWidget的构造函数 w.show(); return a.exec();&#125; mainvidget.cpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120#include &quot;mainwidget.h&quot;#include &lt;QPushButton&gt;#include &lt;QDebug&gt; //打印MainWidget::MainWidget(QWidget *parent) : QWidget(parent)&#123; b1.setParent(this); b1.setText(&quot;close&quot;); b1.move(100, 100); b2 = new QPushButton(this); b2-&gt;setText(&quot;abc&quot;); connect(&amp;b1, &amp;QPushButton::pressed, this, &amp;MainWidget::close); /* &amp;b1: 信号发出者，指针类型 * &amp;QPushButton::pressed：处理的信号， &amp;发送者的类名::信号名字 * this: 信号接收者 * &amp;MainWidget::close： 槽函数，信号处理函数 &amp;接收的类名::槽函数名字 * 发送-处理-接收-处理 */ /* 自定义槽，普通函数的用法 * Qt5：任意的成员函数，普通全局函数，静态函数 * 槽函数需要和信号一致（参数，返回值） * 由于信号都是没有返回值，所以，槽函数一定没有返回值 */ connect(b2, &amp;QPushButton::released, this, &amp;MainWidget::mySlot); connect(b2, &amp;QPushButton::released, &amp;b1, &amp;QPushButton::hide); /* 信号：短信 * 槽函数：接收短信的手机 */ setWindowTitle(&quot;老大&quot;); //this-&gt;setWindowTitle(&quot;老大&quot;);//等价同上 b3.setParent(this); b3.setText(&quot;切换到子窗口&quot;); b3.move(50, 50); //显示子窗口 //subWin.show(); connect(&amp;b3, &amp;QPushButton::released, this, &amp;MainWidget::changeWin); //处理子窗口的信号// void (SubWidget::*funSignal)() = &amp;SubWidget::mySignal;// connect(&amp;subWin, funSignal, this, &amp;MainWidget::dealSub);// void (SubWidget::*testSignal)(int, QString) = &amp;SubWidget::mySignal;// connect(&amp;subWin, testSignal, this, &amp;MainWidget::dealSlot); //Qt4信号连接 //Qt4槽函数必须有slots关键字来修饰 connect(&amp;subWin, SIGNAL(mySignal()), this, SLOT(dealSub()) ); connect(&amp;subWin, SIGNAL(mySignal(int,QString)), this, SLOT(dealSlot(int,QString)) ); //缺点： SIGNAL SLOT 将函数名字 -&gt; 字符串 不进行错误检查 //Lambda表达式, 匿名函数对象 //C++11增加的新特性， 项目文件： CONFIG += C++11 //Qt配合信号一起使用，非常方便 QPushButton *b4 = new QPushButton(this); b4-&gt;setText(&quot;Lambda表达式&quot;); b4-&gt;move(150, 150); int a = 10, b = 100; connect(b4, &amp;QPushButton::clicked, // = :把外部所有局部变量、类中所有成员以值传递方式 // this: 类中所有成员以值传递方式 // &amp; : 把外部所有局部变量， 引用符号 [=](bool isCheck) &#123; qDebug() &lt;&lt; isCheck; &#125; ); resize(400, 300);&#125;void MainWidget::dealSlot(int a, QString str)&#123; // str.toUtf8() -&gt; 字节数组QByteArray // ……data() -&gt; QByteArray -&gt; char * qDebug() &lt;&lt; a &lt;&lt; str.toUtf8().data();&#125;void MainWidget::mySlot()&#123; b2-&gt;setText(&quot;123&quot;);&#125;void MainWidget::changeWin()&#123; //子窗口显示 subWin.show(); //本窗口隐藏 this-&gt;hide();&#125;void MainWidget::dealSub()&#123; //子窗口隐藏 subWin.hide(); //本窗口显示 show();&#125;MainWidget::~MainWidget()&#123;&#125; subwidget.cpp 123456789101112131415161718#include &quot;subwidget.h&quot;SubWidget::SubWidget(QWidget *parent) : QWidget(parent)&#123; this-&gt;setWindowTitle(&quot;小弟&quot;); b.setParent(this); b.setText(&quot;切换到主窗口&quot;); connect(&amp;b, &amp;QPushButton::clicked, this, &amp;SubWidget::sendSlot); resize(400, 300);&#125;void SubWidget::sendSlot()&#123; emit mySignal(); emit mySignal(250, &quot;我是子窗口&quot;);&#125; SingnalAndSlot.pro 12345678910111213141516QT += core guigreaterThan(QT_MAJOR_VERSION, 4): QT += widgetsTARGET = 03_SignalAndSlotTEMPLATE = appSOURCES += main.cpp\\ mainwidget.cpp \\ subwidget.cppHEADERS += mainwidget.h \\ subwidget.hCONFIG += C++11 4 总结 结构图 5 参考博文 C++_之Qt的信号和槽的详解 https://www.cnblogs.com/wanghui1234/p/8964968.html Qt信号和槽机制 https://blog.csdn.net/lsfreeing/article/details/78575246","tags":[{"name":"C++","slug":"C","permalink":"http://11wy11.github.io/tags/C/"},{"name":"QT","slug":"QT","permalink":"http://11wy11.github.io/tags/QT/"}]},{"title":"krpano快速入门教程（二）之vtour简介","date":"2019-03-15T15:19:51.000Z","path":"2019/03/15/krpano-second-note/","text":"主要介绍全景漫游及vtour文件夹介绍 vtour全景漫游及vtour文件夹介绍使用MAKE VTOUR (MULTIRES) droplet工具生成全景漫游 背景在初始学习krpano时，可以借助krpano的工具生成全景漫游文件，之后可以根据需要修改tour.xml,定制skin等；上节简单介绍了krpano使用Make pano的工具创建单场景应用，但大多数应用中场景数量不只一个，彼此之间可以跳转，这就需要借助MAKE VTOUR droplet工具了。而具体选择三种中的哪一种，根据应用场景需要选择，multires支持将全景切片分级，能够达到更好的展示效果，但会使全景文件大小增加，normal生成普通的pano_f.jpg,pano_b.jpg,pano_l.jpg，pano_r.jpg，pano_u.jpg，pano_d.jpg,preview.jpg，分别为全景图的前后左右上下，以及菜单中的预览图。 生成vtour使用MAKE VTOUR (MULTIRES) droplet工具生成的全景漫游场景，场景彼此之间相互连接，能够从一个场景跳转到另一个场景。可以同时选择多张全景图片拖放在该工具上，输入全景图类型，和全景角度，执行切片，等待完成。显示done之后，在全景图文件夹中生成vtour文件夹。 vtour文件夹内容介绍1. tour.html文件--嵌入全景的网页 2. tour.swf文件--krpano的flash viewer 3. tour.js文件--基于swfkrpano.js的一个viewer，即HTML5的viewer及嵌入HTML的js文件的合体 4. tour.xml文件--是krpano xml配置文件，定义全景图配置及皮肤配置 5. panos文件夹--存放处理后的全景图切片 6. plugins文件夹--主要存放使用到的插件 场景Scene它们可用于在当前xml文件中再次定义完整krpano xml文件的内容。它就像一个外部的xml，但只是内联/嵌入到当前的xml中。 在调用具有场景名称的loadscene（） 典型的用法是在一个xml文件中定义几个panos。 使用loadpano（）动作加载新的外部xml文件时，将删除所有当前定义的场景元素。 可以在&lt;scene>元素中存储任何自定义属性 - 查看器本身将忽略它们，但它们可用于自定义操作。1234567891011&lt;scene name=&quot;scene_20171106193359&quot; title=&quot;20171106193359&quot; onstart=&quot;&quot; thumburl=&quot;panos/20171106193359.tiles/thumb.jpg&quot; lat=&quot;51.51500000&quot; lng=&quot;-0.08050000&quot; heading=&quot;0.0&quot;&gt; &lt;view hlookat=&quot;0.0&quot; vlookat=&quot;0.0&quot; fovtype=&quot;MFOV&quot; fov=&quot;120&quot; maxpixelzoom=&quot;2.0&quot; fovmin=&quot;70&quot; fovmax=&quot;140&quot; limitview=&quot;range&quot; vlookatmin=&quot;-56.055&quot; vlookatmax=&quot;56.055&quot; /&gt; &lt;preview url=&quot;panos/20171106193359.tiles/preview.jpg&quot; /&gt; &lt;image prealign=&quot;0|0.0|0&quot;&gt; &lt;cube url=&quot;panos/20171106193359.tiles/pano_%s.jpg&quot; /&gt; &lt;/image&gt; &lt;/scene&gt; 说明： name场景名称，命名规则：每个名字都需要以字母字符开头！这意味着不允许使用数字作为名字！当名称仍然以数字字符开头时，名称将被解释为数组索引。这对于动作内部基于动态索引的访问没有问题，但不能用于定义元素！所有名称将自动转换为小写字母，以便直接区分大小写访问！也是loadscene时设置的参数 title主要显示在缩略图上或者菜单栏名称 onstart此处可以定义将在“开始时”调用全景/场景观看的任何动作/功能。场景启动时调用，可以执行定义好的action thumburl默认视角的展示图路径，使用相对路径，以xml所在位置开始计算相对路径 lat&amp;lon场景所在经纬度，可以用于小地图插件，定位场景 heading仰角度数 视图viewview元素包含有关当前视图的信息。在xml中，它可用于设置启动视图设置。 查找方向将由hlookat / vlookat属性（=水平/垂直lookat）和fov属性中的当前视野定义。要查看部分全景图的限制，可以使用limitview属性。 hlookat&amp;vlookat设置初始视角，分别为水平方向和垂直方向 hlookat:球面坐标的水平方向，以度为单位。典型范围为-180°至+ 180°。该值不会环绕360°，但视图本身会。值0.0指向全景图像的中心。 vlookat:球面坐标的垂直方向，以度为单位。典型范围为-90°至+90°。但视图本身会。值0.0指向全景图像的中心。 fov以度为单位的当前视野 - 从近似0.0到179.0。,默认为90 fovmin&amp;fovmax主要设置视角放大和缩小的最大和最小视角 maxpixelzoom全景图像的最大像素缩放系数。这将根据全景分辨率和当前观察窗口自动限制fov，例如1.0 =限制为100％缩放，不会看到源图像的像素缩放。 预览previewurl:设置预览图路径 全景图image使用&lt;image&gt;元素将定义全景图像。 在此处设置图像/图块的类型，大小和URL路径。 type定义全景图像的类型。 可能的值： CUBE方全景图像 - 六个图像，每个立方体一个图像。 CUBESTRIP在一张图像中作为“图像条”的立方体全景图像。支持的多维数据集格式为6x1,1x6,3x2或2x3。立方体侧对齐本身始终需要：L，F，R，B，U，D（默认为krpano）。 SPHERE球形/ equirectangular全景图像。通过设置自定义hfov， vfov和 voffset设置可以实现部分panos。 CYLINDER一个圆柱形全景图像。通过设置自定义hfov， vfov和 voffset设置可以实现部分panos。 …未设置时：如果未设置类型，则查看器会尝试通过&lt;image>标记内的标记自动检测类型（仅适用于非多图像）。 hfov以度为单位定义全景图像的水平视野（hfov）。这是在全景图像上捕获的可见范围。默认值为360，表示全方位视图。使用较小的值进行部分全景。对于平坦全景（或普通图像），应使用值“1.0”。 multies启用平铺的多分辨率图像。设置为true时，&lt;image>元素需要包含多个&lt;level>元素，其中包含每个多分辨率级别的图像定义。多分辨切片时定义使用 tilesize当全景图为切片时，设置每一级切片大小 level[..].tiledimagewidth level[..].tiledimageheight某一级切片大小 stereo&amp;stereolabels&amp;stereoformat 允许使用立体图像（仅限HTML5和WebGL）。 使用立方体图像时，图像URL应包含％t占位符。此占位符将替换为stereolabels设置中的值。对于左图像，将使用第一个值，对于右图像，将使用第二个值。 对于球形或圆柱形图像或视频，可以使用“帧封装”立体图像。该stereoformat设置定义的打包顺序： stereoformat =“TB” - 上/下 stereoformat =“SBS” - Side-By-Side 示例 - 立体立方体图像： 1234567&lt;image stereo =“true”stereolabels =“1 | 2” &gt; &lt;cube url =“pano_％s_ ％t .jpg”/&gt; &lt;/ image&gt;示例 - 立体全景视频：&lt;image stereo =“true”stereoformat =“TB” &gt; &lt;sphere url =“ plugin：video ”/&gt; &lt;/ image&gt; 注意 - 根据全景图像或视频的像素大小（和侧面），可能需要手动设置hfov，vfov和voffset设置。 fisheye.fov fisheye.align fisheye.crop fisheye.lenscp 鱼眼图像支持（仅限HTML5和WebGL）。 通过鱼眼设置，可以在krpano中使用鱼眼照片和视频。 为了正确地拉直和对齐鱼眼图像，有必要了解一些有关它的参数。获取这些参数的一个好工具是PTGUI。 鱼眼设置： fov = “180.0” 鱼眼图像的视野（以度为单位）。 与crop大小有关。 来源：可以直接从PTGUI fov图像参数中获取。 align = “yaw|pitch|roll” 图像的对齐/旋转/调平（以度为单位）。 来源：可以直接从PTGUI图像参数中获取。（例如，使用垂直线控制点来对齐/调整图像） crop=“left|right|top|bottom” 鱼眼fov裁剪圆的边缘（以像素为单位）。 圆与fov大小有关。 来源：可以直接从PTGUI裁剪设置中获取。 lenscp = “a| b | c | d | e” 的 镜头校正参数。 来源：可以直接从PTGUI镜头设置中获取。 image中URL占位符等根据图像类型和相关设置，图像的URL应包含多个占位符，以允许寻址正确的图像文件。 这些网址占位符可用： 对于立方体的各个面：％s⇒cubelabels的占位符 对于水平图块索引：％h，％x，％u或％c （都相同） 对于垂直图块索引： ％v，％y或％r （都相同） 对于立体图像：％t⇒stereolabels的占位符为当前图像帧：％f ⇒ image.frame （仅限Flash） 每个占位符可以在url中多次使用 - 例如，作为文件名的一部分，也作为foldername的一部分。 平铺索引填充：通过在％字符和tile-index占位符的字符之间插入一个或多个0个字符，可以为数字定义自定义填充。比如:％H ⇒ 1,2,3，…，9,10,11％0H ⇒ 01,02,03，…，09,10,11％00H ⇒ 001,002,003，……，009010011 预览效果 效果图 补充之后的主要工作为：定制skin，定制plugins，定制xml，一些动态操作全景图配置使编辑js文件，能够实现动态配置全景图程序，能够更好的融入到Web应用程序中，作为其中一个子功能模块。后续结合实际案例介绍具体实现方式。历史文章 历史文章krpano快速入门教程（一) 使用krpano工具构建即用型panos","tags":[{"name":"krpano","slug":"krpano","permalink":"http://11wy11.github.io/tags/krpano/"}]},{"title":"krpano快速入门教程（一）之构建panos应用","date":"2019-03-14T07:54:54.000Z","path":"2019/03/14/krpano-first-note/","text":"使用krpano工具构建即用型panos简单使用krpano工具快速生成可执行的pano文件，后续介绍如何自定义编写配置文件切图等 krpano简介Krpano是一款全景漫游制作软件和工具。用krpano所生成的全景，在兼容性、功能性、互动性方面的表现都很不错，而且可以二次开发并拥有自己的编程语言，比如使用专用的krpano xml代码编写全景漫游，可开发出高度定制化的项目。因此，目前主流的全景网站均是在krpano全景的基础上进行开发，并不断进行更新迭代，形成自己独有的全景内容服务。 具体步骤 从krpano下载页面下载适合于自己系统的krpano Tools软件包 将下载的krpano Tools zip文件解压到一个不含中文路径的文件夹下（为了所有稳定使用，推荐） 如果您已拥有krpano许可文件 - 则立即将其复制或移动到krpano Tools文件夹中。如果您没有任何一个，那么只需跳过此步骤即可。之后可以通过注册码注册，具体破解方法请自行百度，注册后能够去掉切片中的krpano水印。 要构建单个全景图 - 打开包含全景图像的文件夹，选择其中一个或全部，拖放到MAKE PANO droplet批处理工具上。等待切片完成，会在全景图像所在文件夹中生成一个以全景图命名的文件夹，里面自动生成一个即用型pano,点击tour_testingsever运行测试服务器，打开index.html查看效果。需要说明的是，这里如果没有注册，运行之后全景图是有krpano水印的。可以运行krpano tools选择 register now 输入序列号完成注册。注册完在按照第4步操作，得到没有水印的全景图注册前 注册后 要构建虚拟游览 - 打开包含全景虚拟游览图像的文件夹，选择所有这些图像拖放到MAKE VTOURdroplet批处理工具上。 其他工具使用类似，主要功能简介如下： MAKE PANO (NORMAL) droplet针对标准全景图（360度），最大值。cubeize默认限制为2200像素（可以在’templates / normal.config’文件中更改），没有皮肤 - 只需pano，HTML5 iPhone / iPad就绪 MAKE PANO（MULTIRES）droplet用于渐进多分辨率的panos，没有尺寸/分辨率限制，快速动态加载，带按钮的默认皮肤，HTML5 iPhone / iPad就绪 MAKE PANO（FLAT）droplet用于平面/ 2D平移/图像，平铺多分辨率，无尺寸/分辨率限制，平坦全景/图像的皮肤/控制，仅限闪光 MAKE PANO（SINGLESWF）droplet只生成一个Flash swf文件，对于标准全景图，完整的pano将立即加载，最大值。cubesize限制为2200像素（可在’templates / singleswf.config’文件中更改），默认皮肤带按钮，仅限Flash MAKE OBJECT droplet用于平铺多分辨率对象影片，一次删除所有对象图像，没有大小/分辨率限制，快速和动态加载，具有按钮和对象旋转控件的对象外观，仅限Flash MAKE VTOUR (NORMAL) droplet / MAKE VTOUR (MULTIRES) droplet 用于自动构建虚拟游览，将所有全景图像放在此工具上，通过自动缩略图生成，准备好HTML5 iPhone / iPad 处理完成后关闭dos / terminal窗口。在源图像的文件夹中会有新文件：典型的.html文件 - 这是嵌入pano的示例网页，.swf文件 - 这是krpano Flash查看器，.js文件 - 这是Javascript Flash到HTML嵌入代码（基于swfkrpano.js）和可选的krpano HTML5 / Javascript iPhone / iPad查看器，一个.xml文件 - 这是krpano xml文件，有pano和皮肤定义，最后有.tiles文件夹 - 有处理过的全景图像。全景图像本身不是观看全景图像所必需的。 6.2。当您使用MAKE VTOUR Droplet时，这些文件将位于’vtour’文件夹中，而pano图像位于其中的’panos’文件夹中。 编辑全景设置打开并在任何文本编辑器中编辑生成的xml文件（带有xml-syntax-highlighting的文本编辑器可能会有帮助）： 在在线文档中查找krpano xml定义：","tags":[{"name":"krpano","slug":"krpano","permalink":"http://11wy11.github.io/tags/krpano/"}]},{"title":"AI组件开发（一）--注记旋转矩阵","date":"2019-03-14T02:56:02.000Z","path":"2019/03/14/ai-first-note/","text":"Adobe Illustrator 组件开发 AIRealMatrixSet介绍及使用方法，参数及原理分析 SDK官方帮助文档AIAPI void( AIRealMathSuite::AIRealMatrixSet)(AIRealMatrix m, AIReal a, AIReal b, AIReal c, AIReal d, AIReal tx, AIReal ty)Sets the scale, rotation, and translation values of a transformation matrix.Parameters:m The matrix object.a New a value.b New b value.c New c value.d New d value.tx New horizontal translation value.ty New vertical translation value. 参数及原理分析ad缩放bc旋转tx,ty位移，基础的2D矩阵 公式 x=ax+cy+tx y=bx+dy+ty 为了把二维图形的变化统一在一个坐标系里，引入了齐次坐标的概念，即把一个图形用一个三维矩阵表示，其中第三列总是(0,0,1)，用来作为坐标系的标准。所以所有的变化都由前两列完成以上参数在矩阵中的表示为： |a b 0| |c d 0| |tx ty 1| 运算原理：原坐标设为（X,Y,1）; |a b 0| [X，Y, 1] |c d 0| = [aX + cY + tx bX + dY + ty 1] ; |tx ty 1| 通过矩阵运算后的坐标[aX + cY + tx bX + dY + ty 1]，我们对比一下可知： 第一种：设a=d=1, b=c=0. 平移 [aX + cY + tx bX + dY + ty 1] = [X + tx Y + ty 1]; 可见，这个时候，坐标是按照向量（tx，ty）进行平移 第二种：设b=c=tx=ty=0. 缩放 [aX + cY + tx bX + dY + ty 1] = [aX dY 1]; 可见，这个时候，坐标X按照a进行缩放，Y按照d进行缩放，a，d就是X，Y的比例系数 第三种：设tx=ty=0，a=cosɵ，b=sinɵ，c=-sinɵ，d=cosɵ。旋转 [aX + cY + tx bX + dY + ty 1] = [Xcosɵ - Ysinɵ Xsinɵ + Ycosɵ 1] ; |cosɵ -sinɵ 0| |sinɵ cosɵ 0| | 0 0 1 | 可见，这个时候，ɵ就是旋转的角度，逆时针为正，顺时针为负 第四种：设tx=ty=0，a=1，b=0，c=-sinɵ，d=cosɵ。倾斜[aX + cY + tx bX + dY + ty 1] = [ - Ysinɵ Ycosɵ 1] ; |1 0 0| |-sinɵ cosɵ 0| | 0 0 1 | 可见，这个时候，ɵ就是倾斜的角度，逆时针为正，顺时针为负 相关文章AI组件开发（一）–注记旋转矩阵AI组件开发（二）–AIRealMathSuiteAI组件开发（三）–AIArtboardSuiteAI组件开发（四）–AIDocumentSuiteAI组件开发（五）–AILayerSuiteAI组件开发（六）–AIArtSuiteAI组件开发（七）–AIPathSuite&amp;&amp;AIPathfinderSuiteAI组件开发（八）–AIArtStyleSuite","tags":[{"name":"AI","slug":"AI","permalink":"http://11wy11.github.io/tags/AI/"}]},{"title":"csdn-markdown编辑器语法","date":"2019-03-13T16:03:21.000Z","path":"2019/03/14/csdn-markdown-grammar/","text":"记录CSDN 的markdown语法，备查@TOC 欢迎使用Markdown编辑器你好！ 这是你第一次使用 Markdown编辑器 所展示的欢迎页。如果你想学习如何使用Markdown编辑器, 可以仔细阅读这篇文章，了解一下Markdown的基本语法知识。 功能快捷键撤销：Ctrl/Command + Z重做：Ctrl/Command + Y加粗：Ctrl/Command + B斜体：Ctrl/Command + I标题：Ctrl/Command + Shift + H无序列表：Ctrl/Command + Shift + U有序列表：Ctrl/Command + Shift + O检查列表：Ctrl/Command + Shift + C插入代码：Ctrl/Command + Shift + K插入链接：Ctrl/Command + Shift + L插入图片：Ctrl/Command + Shift + G 合理的创建标题，有助于目录的生成直接输入1次#，并按下space后，将生成1级标题。输入2次#，并按下space后，将生成2级标题。以此类推，我们支持6级标题。有助于使用TOC语法后生成一个完美的目录。 如何改变文本的样式强调文本 强调文本 加粗文本 加粗文本 ==标记文本== 删除文本 引用文本 H~2~O is是液体。 2^10^ 运算结果是 1024. 插入链接与图片链接: link. 图片: Alt 带尺寸的图片: =30x30 居中的图片: Alt 居中并且带尺寸的图片: =30x30 当然，我们为了让用户更加便捷，我们增加了图片拖拽功能。 如何插入一段漂亮的代码片去博客设置页面，选择一款你喜欢的代码片高亮样式，下面展示同样高亮的 代码片.12// An highlighted blockvar foo = 'bar'; 生成一个适合你的列表 项目 项目 项目 项目1 项目2 项目3 计划任务 完成任务 创建一个表格一个简单的表格是这么创建的：项目 | Value——– | —–电脑 | $1600手机 | $12导管 | $1 设定内容居中、居左、居右使用:---------:居中使用:----------居左使用----------:居右| 第一列 | 第二列 | 第三列 ||:———–:| ————-:|:————-|| 第一列文本居中 | 第二列文本居右 | 第三列文本居左 | SmartyPantsSmartyPants将ASCII标点字符转换为“智能”印刷标点HTML实体。例如：| TYPE |ASCII |HTML|—————-|——————————-|—————————–||Single backticks|&#39;Isn&#39;t this fun?&#39; |’Isn’t this fun?’ ||Quotes |&quot;Isn&#39;t this fun?&quot; |”Isn’t this fun?” ||Dashes |-- is en-dash, --- is em-dash|– is en-dash, — is em-dash| 创建一个自定义列表Markdown: Text-to-HTML conversion tool Authors: John: Luke 如何创建一个注脚一个具有注脚的文本。^2 注释也是必不可少的Markdown将文本转换为 HTML。 *[HTML]: 超文本标记语言 KaTeX数学公式您可以使用渲染LaTeX数学表达式 KaTeX: Gamma公式展示 $\\Gamma(n) = (n-1)!\\quad\\foralln\\in\\mathbb N$ 是通过欧拉积分 $$\\Gamma(z) = \\int_0^\\infty t^{z-1}e^{-t}dt\\,.$$ 你可以找到更多关于的信息 LaTeX 数学表达式here. 新的甘特图功能，丰富你的文章12345678gantt dateFormat YYYY-MM-DD title Adding GANTT diagram functionality to mermaid section 现有任务 已完成 :done, des1, 2014-01-06,2014-01-08 进行中 :active, des2, 2014-01-09, 3d 计划一 : des3, after des2, 5d 计划二 : des4, after des3, 5d 关于 甘特图 语法，参考 这儿, UML 图表可以使用UML图表进行渲染。 Mermaid. 例如下面产生的一个序列图：: 123456789sequenceDiagram张三 -&gt;&gt; 李四: 你好！李四, 最近怎么样?李四--&gt;&gt;王五: 你最近怎么样，王五？李四--x 张三: 我很好，谢谢!李四-x 王五: 我很好，谢谢!Note right of 王五: 李四想了很长时间, 文字太长了&lt;br/&gt;不适合放在一行.李四--&gt;&gt;张三: 打量着王五...张三-&gt;&gt;王五: 很好... 王五, 你怎么样? 这将产生一个流程图。: 12345graph LRA[长方形] -- 链接 --&gt; B((圆))A --&gt; C(圆角长方形)B --&gt; D&#123;菱形&#125;C --&gt; D 关于 Mermaid 语法，参考 这儿, FLowchart流程图我们依旧会支持flowchart的流程图：123456789flowchatst=&gt;start: 开始e=&gt;end: 结束op=&gt;operation: 我的操作cond=&gt;condition: 确认？st-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op 关于 Flowchart流程图 语法，参考 这儿. 导出与导入导出如果你想尝试使用此编辑器, 你可以在此篇文章任意编辑。当你完成了一篇文章的写作, 在上方工具栏找到 文章导出 ，生成一个.md文件或者.html文件进行本地保存。 导入如果你想加载一篇你写过的.md文件或者.html文件，在上方工具栏可以选择导入功能进行对应扩展名的文件导入，继续你的创作。","tags":[{"name":"markdown","slug":"markdown","permalink":"http://11wy11.github.io/tags/markdown/"}]},{"title":"git常用命令","date":"2019-03-13T12:41:15.000Z","path":"2019/03/13/git-command/","text":"记录一些常用的git命令，目前理解还不是很深，有点进一步查阅资料 强制本地覆盖远程分支 1234567 git push origin *** --force ``` 2. 放弃本地分支，远程分支强制覆盖本地 git fetch --all //只是下载代码到本地，不进行合并操作git reset --hard origin/分支名如master //把HEAD指向最新下载的版本3. 删除远程分支和本地分支 git branch -a//查看分支git push origin –delete // 删除远程分支git branch -d //删除本地分支 1234. git diff 检查文件更改内容5. 撤销未提交的修改git checkout git checkout app/src/main/../MainActivity 16、git reset git log #找到需要退回的commit版本号，可以只复制前几位git reset &lt;刚查找到的版本号&gt;`7、git log","tags":[{"name":"git","slug":"git","permalink":"http://11wy11.github.io/tags/git/"}]},{"title":"使用hexo+github创建个人博客并备份源码","date":"2019-03-09T13:52:06.000Z","path":"2019/03/09/create-blog-process/","text":"最基础的hexo+github搭建个人博客的教程 一、准备 安装node.js 安装git-windows 安装hexo-cli 1$npm install hexo-cli -g 在GitHub上创建&lt;username&gt;.github.io的仓库 e.g. 11wy11.github.io 配置SSH key打开本机的控制台，以windows系统为例，可以执行win+R 输入cmd打开，执行 1ssh-keygen -t rsa -C &apos;D:/id.txt&apos; 然后连续按3次回车，最终会在用户目录下生成一个文件，找到目录.ssh/id_rsa.pub文件，用记事本打开全选复制。在你的github上点击头像&gt;设置进入设置页面，选择SSH and GPG keys, 点击New SSH key按钮，名称随意填写，将刚复制的内容粘贴到key,添加 二、搭建流程 本地创建&lt;username&gt;.github.io 在本地&lt;username&gt;.github.io文件夹下初始化hexo项目并安装依赖 123hexo init //初始化工程npm install //安装依赖hexo server //启动本地调试器在localhost:4000预览 修改默认主题，可以在github上clone其他的主题，如yilia,icarus,indigo等 以indigo为例，在本地&lt;username&gt;.github.io文件夹下执行以下命令安装主题 1git clone git@github.com:yscoder/hexo-theme-indigo.git themes/indigo 修改工程中的_config.yml配置文件，将themes: landscope改为themes: indigo 依赖安装分别安装Less,Feed,Json-content依赖，执行如下命令 123$ npm install hexo-renderer-less --save$ npm install hexo-generator-feed --save$ npm install hexo-generator-json-content --save 执行hexo s命令启动服务器在localhost:4000查看效果 新建文章，使用hexo new “my-first blog”，会在source/_posts下创建my-first-blog.md的页面文件进行编写 发布博客首先修改工程中的_config.yml配置文件，在最后三行添加以下代码，将username换成自己的git用户名 1234deploy: type: git repo: git@github.com:&lt;username&gt;/&lt;username&gt;.github.io.git branch: master 其次安装hexo-deployer-git 执行 npm install hexo-deployer-git --save 在工程文件夹内右键git bash进入命令行 输入hexo g，编译为静态文件，生成public文件夹，使用 hexo d 部署，此时可以访问https://&lt;username&gt;.github.io查看你的博客 备份源码 在工程文件夹内右键git bash进入命令行 输入 touch .gitignore ，生成“.gitignore”文件。 在”.gitignore” 文件里输入你要忽略的文件夹及其文件就可以了。（注意格式） 我的 .gitignore： 12345678node_modules/.deploy_gitpublic/.DS_Store Thumbs.dbdb.json *.log.deploy*/ 执行以下命令 123456789101112#git初始化git init#创建hexo分支，用来存放源码git checkout -b hexo#git 文件添加git add .#git 提交git commit -m &quot;init&quot;#添加远程仓库git remote add origin git@github.com:&lt;username&gt;/&lt;username&gt;.github.io.git#push到hexo分支git push origin hexo 执行hexo g -d生成网站并部署到GitHub上 这样一来，在GitHub上的git@github.com:&lt;username&gt;/&lt;username&gt;.github.io.git仓库就有两个分支，一个hexo分支用来存放网站的原始文件，一个master分支用来存放生成的静态网页。 其他设备更新博客步骤： 1、先安装hexo $ npm install -g hexo-cli 2、存在github上的git clone下来 git clone -b hexo git@github.com:&lt;username&gt;/&lt;username&gt;.github.io.git 3、项目文件夹下 $ npm install $ npm install hexo-deployer-git 4、重新配置github和coding的公钥 5、编写博客push 到远程分支 补充 有时会出现下载的主题无法上传，首先删除themes/主题文件夹下的.git,使用git rm --cached themes/indigo命令清空后重新上传` 如果最开始.gitignore文件没有配置正确，可以使用git rm -r --cached .命令清楚缓存文件，重新add,commit,push上传 当使用node 14以上版本，使用hexo d命令部署时，会提示AGType错误，需要将node的版本退回到12，可以使用nvm管理多个版本的node,具体步骤如下： 下载nvm(https://github.com/coreybutler/nvm-windows/releases) setup.zip,安装，注意不要将nvm安装到默认的c/program files下，换一个盘，不然安装node之后会提示node命令找不到 在控制台，使用nvm install node@12.4.0命令安装node，可以使用nvm ls 查看当前安装的node版本，使用命令nvm use 12.4.0使用指定版本，使用命令node -v 或 npm -v检查安装是否成功","tags":[{"name":"hexo","slug":"hexo","permalink":"http://11wy11.github.io/tags/hexo/"},{"name":"git","slug":"git","permalink":"http://11wy11.github.io/tags/git/"}]},{"title":"Vue全局添加组件","date":"2019-03-09T02:39:22.000Z","path":"2019/03/09/Vue-global-component/","text":"Vue全局添加组件，方便重复使用的功能一次性定义 一. 背景在项目中有时需要反复用到如区域选择器等组件，每次使用时都需要在对应的vue中添加import,并在component中注册，为了避免多次书写引用代码，可以自定义全局组件，只需要在main.js中一次性注册在vue项目中，可以自定义组件像vue-resource一样使用Vue.use（）方法来使用。 二. 具体实现方法1、首先建一个自定义组件的文件夹，比如叫loading，在该文件夹下新建一个index.js，一个自定义组件loading.vue,在这个loading.vue里面就是这个组件的具体的内容， 2、在index.js中，规定使用这个组件的名字，以及使用方法，如： import loadingComponent from &apos;./loading.vue&apos; const loading={ install:function(Vue){ Vue.component(&apos;Loading&apos;,loadingComponent) } //&apos;Loading&apos;这就是后面可以使用的组件的名字，install是默认的一个方法 }; export default loading; 3、只要在main.js中规定了install方法，就可以像一些公共的插件一样使用Vue.use()来使用： import loading from &apos;./loading&apos; Vue.use(loading）","tags":[{"name":"Vue","slug":"Vue","permalink":"http://11wy11.github.io/tags/Vue/"}]},{"title":"Oracle配置SDE支持空间查询","date":"2019-03-09T01:56:40.000Z","path":"2019/03/09/oracle-st-geometry/","text":"Oracle配置SDE支持空间查询,配置oracle外部链接库 配置oracle外部链接库 将ArcGIS Desktop安装目录下DatabaseSupport文件夹下的st_shapelib.dll拷贝到装有oracle的服务器上，可以放置在任意地方，这里推荐放在Oracle安装目录下的bin文件夹下。 例如：st_shapelib.dll所在文件夹路径： C:\\ProgramFiles(x86)\\ArcGIS\\Desktop10.2\\DatabaseSupport\\Oracle\\Windows64\\st_shapelib.dll 拷贝放置位置：E:\\app\\503\\product\\11.2.0\\dbhome_1\\BIN\\ st_shapelib.dll 修改oracle安装目录下的network/admin文件夹下的listener.ora,将步骤1中的st_shapelib.dll路径添加到ENVS”EXTPROC_DLLS=ONLY:E:\\app\\503\\product\\11.2.0\\dbhome_1\\bin\\oraclr11.dll;后面 例如：linstener文件，添加红色字部分 1234567891011121314151617181920212223# listener.ora Network Configuration File: D:\\app\\Administrator\\product\\11.2.0\\dbhome_1\\NETWORK\\ADMIN\\listener.ora# Generated by Oracle configuration tools.SID_LIST_LISTENER = (SID_LIST = (SID_DESC = (SID_NAME = CLRExtProc) (ORACLE_HOME = E:\\app\\503\\product\\11.2.0\\dbhome_1) (PROGRAM = extproc) (ENVS= &quot;EXTPROC_DLLS=ONLY:E:\\app\\503\\product\\11.2.0\\dbhome_1\\bin\\oraclr11.dll;E:\\app\\503\\product\\11.2.0\\dbhome_1\\bin\\st_shapelib.dll&quot;) # interesting ) ) LISTENER = (DESCRIPTION_LIST = (DESCRIPTION = (ADDRESS = (PROTOCOL = TCP)(HOST = 503-PC)(PORT = 1521)) (ADDRESS = (PROTOCOL = IPC)(KEY = EXTPROC1521)) ) (DESCRIPTION = (ADDRESS = (PROTOCOL = TCP)(HOST = 192.168.1.164)(PORT = 1521)) ) ) ADR_BASE_LISTENER = E:\\app\\503 修改oracle安装home目录下的hs/admin文件夹下的extproc.ora，具体路径示例：E:\\app\\503\\product\\11.2.0\\dbhome_1\\hs\\admin\\extproc.ora，将最后一行的SET EXTPROC_DLLS= 设为ANY 通过任何一个数据库管理软件，这里以sql-plus为例，使用sde用户登录首先执行：select * from user_libraries 查看是否有ST_SHAPELIB并检查路径是否与步骤1中的一致，通常默认为c盘第一次安装Arcgis时的相关路径。结果如下： 如果路径与步骤1中st_shapelib的路径不一致，执行以下两条命令： Create or replace library st_SHAPELIB as &lt;步骤1中的st_shapelib路径&gt; Alter package sde.st_geometry_shapelib_pkg compile reuse settings 重启监听器OracleOraDB11g_home1TNSListener，有时也需要重启服务OracleServiceORCL。","tags":[{"name":"ArcGIS","slug":"ArcGIS","permalink":"http://11wy11.github.io/tags/ArcGIS/"},{"name":"Oracle","slug":"Oracle","permalink":"http://11wy11.github.io/tags/Oracle/"}]}]