[{"title":"C# 使用NLog显示和输出日志","date":"2019-04-10T03:15:48.000Z","path":"2019/04/10/cplusplus-log-note/","text":"1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859 public static Logger logger;private void initLogger() &#123; // Step 1. Create configuration object LoggingConfiguration logConfig = new LoggingConfiguration(); // Step 2. Create targets and add them to the configuration RichTextBoxTarget rtbTarget = new RichTextBoxTarget(); logConfig.AddTarget(&quot;richTextBox&quot;, rtbTarget); rtbTarget.FormName = &quot;MainForm&quot;; // your winform class name rtbTarget.ControlName = &quot;richTextBox1&quot;; // your RichTextBox control/variable name //rtbTarget.UseDefaultRowColoringRules = false; rtbTarget.RowColoringRules.Add( new RichTextBoxRowColoringRule( &quot;level == LogLevel.Error&quot;, //condition &quot;DarkRed&quot;, // font color &quot;Control&quot;, //backgroud color FontStyle.Bold ) ); rtbTarget.RowColoringRules.Add( new RichTextBoxRowColoringRule( &quot;level == LogLevel.Warn&quot;, //condition &quot;Navy&quot;, // font color &quot;Control&quot;, //backgroud color FontStyle.Bold ) ); FileTarget fileTarget = new FileTarget(); logConfig.AddTarget(&quot;logFile&quot;, fileTarget); // Step 3. Set target properties //string commonLayout = &quot;$&#123;date:format=MM-dd HH\\\\:mm\\\\:ss&#125; $&#123;logger&#125; $&#123;message&#125;&quot;; string commonLayout = &quot;$&#123;date:format=HH\\\\:mm&#125; $&#123;logger&#125; $&#123;message&#125;&quot;; rtbTarget.Layout = commonLayout; //string curDatetimeStr = DateTime.Now.ToString(); DateTime curDateTime = DateTime.Now; string curDatetimeStr = String.Format(&quot;&#123;0:yyyy-MM-dd_HHmmss&#125;&quot;, curDateTime); //&quot;2013-06-11_142102&quot; fileTarget.FileName = &quot;$&#123;basedir&#125;/logfile/&quot; + curDatetimeStr + &quot;_log.txt&quot;; //&#123;&apos;$&#123;basedir&#125;/2013-06-11_142102_log.txt&apos;&#125; fileTarget.Layout = commonLayout; // Step 4. Define rules LoggingRule ruleRichTextBox = new LoggingRule(&quot;*&quot;, LogLevel.Debug, rtbTarget); logConfig.LoggingRules.Add(ruleRichTextBox); LoggingRule ruleFile = new LoggingRule(&quot;*&quot;, LogLevel.Debug, fileTarget); logConfig.LoggingRules.Add(ruleFile); // Step 5. Activate the configuration LogManager.Configuration = logConfig; // Example usage logger = LogManager.GetLogger(&quot;&quot;); &#125;//使用 logger.Info(&quot;Info:开始进行文件夹目录结构检查&quot;); logger.Error(&quot;XXXXXXX&quot;);","tags":[{"name":"C#","slug":"C","permalink":"http://11wy11.github.io/tags/C/"}]},{"title":"C#读取txt和xml文件等","date":"2019-04-10T03:05:59.000Z","path":"2019/04/10/cplusplus-txt-xml-read-note/","text":"读取txt和xml等，生成Dictionary等 TXT文件读取pac文件格式：11000,XX省11100,XX市11101,XXXX区11102,XXXX1区 12345678910111213public static Dictionary&lt;string, string&gt; countyPacMap = new Dictionary&lt;string, string&gt;();//存储区域PAC码对应信息 FileStream file = new FileStream(&quot;Config/PAC.txt&quot;, FileMode.OpenOrCreate); StreamReader reader = new StreamReader(file, UnicodeEncoding.GetEncoding(&quot;UTF-8&quot;)); string strLine = string.Empty; while ((strLine = reader.ReadLine()) != null) &#123; strLine = strLine.Trim().ToString(); string[] nameAndCode = strLine.Split(&apos;,&apos;); string name = nameAndCode[1]; string pac = nameAndCode[0]; countyPacMap.Add(name, pac); &#125; file.Close(); XML读取XML格式：1234567&lt;Directory Name=&quot;XX&quot; &gt; &lt;Directory Name=&quot;1-采样数据&quot; &gt; &lt;File DestinationDirectory=&quot;1-采样数据&quot; isCheckAttribute=&quot;true&quot; type=&quot;1&quot; sheetNum=&quot;1&quot; &gt;XXX.txt&lt;/File&gt; &lt;File DestinationDirectory=&quot;1-采样数据&quot;&gt;2-登记表.pdf&lt;/File&gt; &lt;File DestinationDirectory=&quot;1-采样数据&quot;&gt;3-送样单.pdf&lt;/File&gt; &lt;/Directory&gt;&lt;/Directory&gt; 读取XML123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475 public static List&lt;FieldModel&gt; getFieldsFromXml(String xmlName, int index) &#123; string m_strConfig = &quot;Tables/&quot;; List&lt;FieldModel&gt; result = new List&lt;FieldModel&gt;(); XmlDocument doc = new XmlDocument(); doc.Load(m_strConfig + xmlName + &quot;.xml&quot;); XmlNode root = doc.SelectSingleNode(&quot;Table&quot;); XmlNode sheet = root.ChildNodes[index]; // 得到根节点的所有子节点 XmlNodeList xnl = sheet.ChildNodes; foreach (XmlNode xn in xnl) &#123; FieldModel fieldModel = new FieldModel(); // 将节点转换为元素，便于得到节点的属性值 XmlElement xe = (XmlElement)xn; fieldModel.FieldName = xe.GetAttribute(&quot;Name&quot;).ToString(); fieldModel.FieldType = xe.GetAttribute(&quot;Type&quot;).ToString(); fieldModel.RuleType = xe.GetAttribute(&quot;RuleType&quot;).ToString(); fieldModel.RuleParms = xe.GetAttribute(&quot;RuleParms&quot;).ToString(); result.Add(fieldModel); &#125; return result; &#125; public static string[] getFieldCNames(ArrayList array) &#123; int nums = array.Count; string[] names = new string[nums]; for (int i = 0; i &lt; nums; i++) &#123; FieldModel fieldModel = (FieldModel)array[i]; names[i] = fieldModel.FieldName; &#125; return names; &#125;//FieldModel类class FieldModel &#123; public FieldModel() &#123; &#125; private string fieldName; public string FieldName &#123; get &#123; return fieldName; &#125; set &#123; fieldName = value; &#125; &#125; private string ruleType; public string RuleType &#123; get &#123; return ruleType; &#125; set &#123; ruleType = value; &#125; &#125; private string fieldType; public string FieldType &#123; get &#123; return fieldType; &#125; set &#123; fieldType = value; &#125; &#125; private string ruleParms; public string RuleParms &#123; get &#123; return ruleParms; &#125; set &#123; ruleParms = value; &#125; &#125; &#125;","tags":[{"name":"C#","slug":"C","permalink":"http://11wy11.github.io/tags/C/"}]},{"title":"C#读取，生成Excel","date":"2019-04-10T02:58:28.000Z","path":"2019/04/10/cplusplus-excel-note/","text":"ExcelUtils123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215using GDZLCHECK.Forms;using NPOI.HSSF.UserModel;using NPOI.SS.UserModel;using NPOI.SS.Util;using NPOI.XSSF.UserModel;using System;using System.Collections.Generic;using System.Data;using System.IO;using System.Linq;using System.Text;using System.Threading.Tasks;using System.Windows.Forms;namespace GDZLCHECK.Utils&#123; class ExcelUtils &#123; public static IWorkbook GetWorkbook(string filePath) &#123; IWorkbook workbook; string fileType = System.IO.Path.GetExtension(filePath); if (string.IsNullOrEmpty(fileType)) return null; try &#123; using (FileStream file = new FileStream(filePath, FileMode.Open, FileAccess.Read)) &#123; if (fileType == &quot;.xls&quot;) &#123; workbook = new HSSFWorkbook(file) as IWorkbook; &#125; else if (fileType == &quot;.xlsx&quot;) &#123; workbook = new XSSFWorkbook(file); &#125; else &#123; return null; &#125; file.Close(); return workbook; &#125; &#125; catch (Exception ex) &#123; MessageBox.Show(&quot;打开excel失败，文件可能正被打开&quot;); Console.WriteLine( ex.Message.ToString()); // MainForm.logger.Error(&quot;Error: 打开&quot;+filePath+&quot; excel失败，文件可能正被打开&quot;); return null; &#125; &#125; /// &lt;summary&gt; /// 判断指定行列所在的单元格是否为合并单元格， /// &lt;/summary&gt; /// &lt;param name=&quot;sheet&quot;&gt;Excel工作表&lt;/param&gt; /// &lt;param name=&quot;rowIndex&quot;&gt;行索引，从0开始&lt;/param&gt; /// &lt;param name=&quot;columnIndex&quot;&gt;列索引，从0开始&lt;/param&gt; /// &lt;returns&gt;返回是否为合并单元格的布尔(Boolean)值&lt;/returns&gt; public static bool IsMergeCell(ISheet sheet, int rowIndex, int columnIndex) &#123; for (int i = 0; i &lt; sheet.NumMergedRegions; i++) &#123; CellRangeAddress range = sheet.GetMergedRegion(i); sheet.IsMergedRegion(range); //这种算法只有当指定行列索引刚好是合并单元格的第一个跨度行第一个跨度列时才能取得合并单元格的跨度 //if (range.FirstRow == rowIndex &amp;&amp; range.FirstColumn == columnIndex) //&#123; // dimension.DataCell = sheet.GetRow(range.FirstRow).GetCell(range.FirstColumn); // dimension.RowSpan = range.LastRow - range.FirstRow + 1; // dimension.ColumnSpan = range.LastColumn - range.FirstColumn + 1; // dimension.FirstRowIndex = range.FirstRow; // dimension.LastRowIndex = range.LastRow; // dimension.FirstColumnIndex = range.FirstColumn; // dimension.LastColumnIndex = range.LastColumn; // break; //&#125; if ((rowIndex &gt;= range.FirstRow &amp;&amp; range.LastRow &gt;= rowIndex) &amp;&amp; (columnIndex &gt;= range.FirstColumn &amp;&amp; range.LastColumn &gt;= columnIndex)) &#123; break; &#125; &#125; bool result; if (rowIndex &gt;= 0 &amp;&amp; sheet.LastRowNum &gt; rowIndex) &#123; IRow row = sheet.GetRow(rowIndex); if (columnIndex &gt;= 0 &amp;&amp; row.LastCellNum &gt; columnIndex) &#123; ICell cell = row.GetCell(columnIndex); result = cell.IsMergedCell; &#125; else &#123; result = false; &#125; &#125; else &#123; result = false; &#125; return result; &#125; public static object GetCellValue(ICell cell) &#123; object value = &quot;&quot;; try &#123; if (cell.CellType != CellType.Blank) &#123; switch (cell.CellType) &#123; case CellType.Numeric: // Date comes here if (DateUtil.IsCellDateFormatted(cell)) &#123; value = cell.DateCellValue; &#125; else &#123; // Numeric type value = cell.NumericCellValue; &#125; break; case CellType.Boolean: // Boolean type value = cell.BooleanCellValue; break; case CellType.Formula: value = cell.CellFormula; break; default: // String type value = cell.StringCellValue; break; &#125; &#125; &#125; catch (Exception) &#123; value = &quot;&quot;; &#125; return value; &#125; //判断是否为空 public static bool isEmptyRow(ICell cell) &#123; if (cell == null) return true; else &#123; if (cell.CellType == CellType.Blank || string.IsNullOrEmpty(cell.ToString().Trim())) return true; else return false; &#125; &#125; public static DataTable ExportToDataTable(ISheet sheet) &#123; DataTable dt = new DataTable(); //默认，第一行是字段 IRow headRow = sheet.GetRow(0); //设置datatable字段 for (int i = headRow.FirstCellNum, len = headRow.LastCellNum; i &lt; len; i++) &#123; dt.Columns.Add(headRow.Cells[i].StringCellValue); &#125; //遍历数据行 for (int i = (sheet.FirstRowNum + 1), len = sheet.LastRowNum + 1; i &lt; len; i++) &#123; IRow tempRow = sheet.GetRow(i); DataRow dataRow = dt.NewRow(); //遍历一行的每一个单元格 for (int r = 0, j = tempRow.FirstCellNum, len2 = tempRow.LastCellNum; j &lt; len2; j++, r++) &#123; ICell cell = tempRow.GetCell(j); if (cell != null) &#123; switch (cell.CellType) &#123; case CellType.String: dataRow[r] = cell.StringCellValue; break; case CellType.Numeric: dataRow[r] = cell.NumericCellValue; break; case CellType.Boolean: dataRow[r] = cell.BooleanCellValue; break; default: dataRow[r] = &quot;&quot;; break; &#125; &#125; &#125; dt.Rows.Add(dataRow); &#125; return dt; &#125; &#125;&#125;","tags":[{"name":"C#","slug":"C","permalink":"http://11wy11.github.io/tags/C/"}]},{"title":"C#winform程序全局异常处理","date":"2019-04-10T02:39:18.000Z","path":"2019/04/10/cplusplus-exception-note/","text":"全局处理未处理异常 program.cs入口1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162using GDZLCHECK.Forms;using NLog;using System;using System.Collections.Generic;using System.Linq;using System.Threading.Tasks;using System.Windows.Forms;namespace GDZLCHECK&#123; static class Program &#123; /// &lt;summary&gt; /// 应用程序的主入口点。 /// &lt;/summary&gt; [STAThread] static void Main() &#123; try &#123; Application.EnableVisualStyles(); Application.SetCompatibleTextRenderingDefault(false); //处理未捕获的异常 Application.SetUnhandledExceptionMode(UnhandledExceptionMode.CatchException); //处理UI线程异常 Application.ThreadException += new System.Threading.ThreadExceptionEventHandler(Application_ThreadException); //处理非UI线程异常 AppDomain.CurrentDomain.UnhandledException += new UnhandledExceptionEventHandler(CurrentDomain_UnhandledException); ESRI.ArcGIS.RuntimeManager.Bind(ESRI.ArcGIS.ProductCode.EngineOrDesktop); Application.EnableVisualStyles(); Application.SetCompatibleTextRenderingDefault(false); Application.Run(new MainForm()); glExitApp = true; &#125; catch (Exception e) &#123; MessageBox.Show(&quot;请确保安装有ArcGIS和Office,且ArcGIS License已启动&quot;); Application.Exit(); &#125; &#125; static bool glExitApp = false; static void CurrentDomain_UnhandledException(object sender, UnhandledExceptionEventArgs e) &#123; MessageBox.Show(&quot;抱歉，您的操作没有能够完成，请再试一次或者联系软件提供商&quot;); Logger logger = LogManager.GetCurrentClassLogger(); logger.Error(&quot;CurrentDomain_UnhandledException&quot;); logger.Error(&quot;IsTerminating:&quot; + e.IsTerminating.ToString()); logger.Error(e.ExceptionObject.ToString()); &#125; static void Application_ThreadException(object sender, System.Threading.ThreadExceptionEventArgs e) &#123; MessageBox.Show(&quot;抱歉，您的操作没有能够完成，请再试一次或者联系软件提供商&quot;); Logger logger = LogManager.GetCurrentClassLogger(); logger.Error(&quot;Application_ThreadException:&quot;+e.Exception.Message); logger.Error(e.Exception); //throw new NotImplementedException(); &#125; &#125;&#125;","tags":[{"name":"C#","slug":"C","permalink":"http://11wy11.github.io/tags/C/"}]},{"title":"C#读取word模板填充数据生成带水印的pdf","date":"2019-04-10T01:32:08.000Z","path":"2019/04/10/cplusplus-wordtemplete-note/","text":"使用Microsoft Office 的COM组件,方便快捷，较好的复用和使用模板快速生成较复杂的文档不足在于对于环境依赖较高 Word相关处理类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251using System;using System.Collections.Generic;using System.ComponentModel;using System.Data;using System.Drawing;using System.Linq;using System.Text;using Microsoft.Office.Interop.Word;using System.Windows.Forms;using System.Threading;namespace GDZLCHECK.Utils&#123; class CreateWord &#123; private _Application wordApp= null; private _Document wordDoc= null; public _Application Application &#123; get &#123; return wordApp; &#125; set &#123; wordApp = value; &#125; &#125; public _Document Document &#123; get &#123; return wordDoc; &#125; set &#123; wordDoc = value; &#125; &#125; //保存新文件 public void SaveDocument(string filePath) &#123; // killWinWordProcess(); object oMissing = System.Reflection.Missing.Value; //SaveFileDialog sfd = new SaveFileDialog(); //sfd.Filter = &quot;Word Document(*.doc)|*.doc|PDF(*.pdf)|*.pdf&quot;; //sfd.DefaultExt = &quot;Word Document(*.doc)|*.doc&quot;; //if (sfd.ShowDialog() == DialogResult.OK) //&#123; //object filename = sfd.FileName; object filename = filePath; wordDoc.SaveAs(ref filename, ref oMissing, ref oMissing, ref oMissing, ref oMissing, ref oMissing, ref oMissing, ref oMissing, ref oMissing, ref oMissing, ref oMissing, ref oMissing, ref oMissing, ref oMissing, ref oMissing, ref oMissing); wordDoc.Close(ref oMissing, ref oMissing, ref oMissing); //关闭word wordApp.Quit(ref oMissing, ref oMissing, ref oMissing); //&#125; &#125; //在书签处插入值 public bool InsertValue(string bookmark, string value) &#123; object bkObj =bookmark; if(wordApp.ActiveDocument.Bookmarks.Exists(bookmark)) &#123; wordApp.ActiveDocument.Bookmarks.get_Item(ref bkObj).Select(); wordApp.Selection.TypeText(value); return true; &#125; return false; &#125; //插入表格,bookmark书签 public Table InsertTable(string bookmark, int rows, int columns,float width) &#123; object miss =System.Reflection.Missing.Value; object oStart =bookmark; Range range =wordDoc.Bookmarks.get_Item(ref oStart).Range;//表格插入位置 Table newTable =wordDoc.Tables.Add(range,rows, columns, ref miss, ref miss); //设置表的格式 newTable.Borders.Enable =1; //允许有边框，默认没有边框(为0时报错，1为实线边框，2、3为虚线边框，以后的数字没试过) newTable.Borders.OutsideLineWidth=WdLineWidth.wdLineWidth050pt;//边框宽度 if(width != 0) &#123; newTable.PreferredWidth=width;//表格宽度 &#125; newTable.AllowPageBreaks =false; return newTable; &#125; // 合并单元格 表id,开始行号,开始列号,结束行号,结束列号 public void MergeCell(int n, int row1, int column1, int row2, int column2) &#123; wordDoc.Content.Tables[n].Cell(row1, column1).Merge(wordDoc.Content.Tables[n].Cell(row2, column2)); &#125; // 合并单元格 表名,开始行号,开始列号,结束行号,结束列号 public void MergeCell(Microsoft.Office.Interop.Word.Table table, int row1, int column1, int row2, int column2) &#123; table.Cell(row1, column1).Merge(table.Cell(row2, column2)); &#125; // 设置表格内容对齐方式 Align水平方向，Vertical垂直方向(左对齐，居中对齐，右对齐分别对应Align和Vertical的值为-1,0,1)Microsoft.Office.Interop.Word.Table table public void SetParagraph_Table(int n, int Align, int Vertical) &#123; switch (Align) &#123; case -1: wordDoc.Content.Tables[n].Range.ParagraphFormat.Alignment = WdParagraphAlignment.wdAlignParagraphLeft; break;//左对齐 case 0: wordDoc.Content.Tables[n].Range.ParagraphFormat.Alignment = WdParagraphAlignment.wdAlignParagraphCenter; break;//水平居中 case 1: wordDoc.Content.Tables[n].Range.ParagraphFormat.Alignment = WdParagraphAlignment.wdAlignParagraphRight; break;//右对齐 &#125; switch (Vertical) &#123; case -1: wordDoc.Content.Tables[n].Range.Cells.VerticalAlignment = WdCellVerticalAlignment.wdCellAlignVerticalTop; break;//顶端对齐 case 0: wordDoc.Content.Tables[n].Range.Cells.VerticalAlignment = WdCellVerticalAlignment.wdCellAlignVerticalCenter; break;//垂直居中 case 1: wordDoc.Content.Tables[n].Range.Cells.VerticalAlignment = WdCellVerticalAlignment.wdCellAlignVerticalBottom; break;//底端对齐 &#125; &#125; // 设置单元格内容对齐方式 public void SetParagraph_Table(int n, int row, int column, int Align, int Vertical) &#123; switch (Align) &#123; case -1: wordDoc.Content.Tables[n].Cell(row, column).Range.ParagraphFormat.Alignment = WdParagraphAlignment.wdAlignParagraphLeft; break;//左对齐 case 0: wordDoc.Content.Tables[n].Cell(row, column).Range.ParagraphFormat.Alignment = WdParagraphAlignment.wdAlignParagraphCenter; break;//水平居中 case 1: wordDoc.Content.Tables[n].Cell(row, column).Range.ParagraphFormat.Alignment = WdParagraphAlignment.wdAlignParagraphRight; break;//右对齐 &#125; switch (Vertical) &#123; case -1: wordDoc.Content.Tables[n].Cell(row, column).Range.Cells.VerticalAlignment = WdCellVerticalAlignment.wdCellAlignVerticalTop; break;//顶端对齐 case 0: wordDoc.Content.Tables[n].Cell(row, column).Range.Cells.VerticalAlignment = WdCellVerticalAlignment.wdCellAlignVerticalCenter; break;//垂直居中 case 1: wordDoc.Content.Tables[n].Cell(row, column).Range.Cells.VerticalAlignment = WdCellVerticalAlignment.wdCellAlignVerticalBottom; break;//底端对齐 &#125; &#125; // 设置表格字体 public void SetFont_Table(Microsoft.Office.Interop.Word.Table table, string fontName, double size) &#123; if (size != 0) &#123; table.Range.Font.Size = Convert.ToSingle(size); &#125; if (fontName != &quot;&quot;) &#123; table.Range.Font.Name = fontName; &#125; &#125; // 设置单元格字体 public void SetFont_Table(int n, int row, int column, string fontName, double size, int bold) &#123; if (size != 0) &#123; wordDoc.Content.Tables[n].Cell(row, column).Range.Font.Size = Convert.ToSingle(size); &#125; if (fontName != &quot;&quot;) &#123; wordDoc.Content.Tables[n].Cell(row, column).Range.Font.Name = fontName; &#125; wordDoc.Content.Tables[n].Cell(row, column).Range.Font.Bold = bold;// 0 表示不是粗体，其他值都是 &#125; // 是否使用边框,n表格的序号,use是或否 // 该处边框参数可以用int代替bool可以让方法更全面 // 具体值方法中介绍 public void UseBorder(int n, bool use) &#123; if (use) &#123; wordDoc.Content.Tables[n].Borders.Enable = 1; //允许有边框，默认没有边框(为0时无边框，1为实线边框，2、3为虚线边框，以后的数字没试过) &#125; else &#123; wordDoc.Content.Tables[n].Borders.Enable = 0; &#125; &#125; // 给表格插入一行,n表格的序号从1开始记 public void AddRow(int n) &#123; object miss = System.Reflection.Missing.Value; wordDoc.Content.Tables[n].Rows.Add(ref miss); &#125; // 给表格添加一行 public void AddRow(Microsoft.Office.Interop.Word.Table table) &#123; object miss = System.Reflection.Missing.Value; table.Rows.Add(ref miss); &#125; // 给表格插入rows行,n为表格的序号 public void AddRow(int n, int rows) &#123; object miss = System.Reflection.Missing.Value; Microsoft.Office.Interop.Word.Table table = wordDoc.Content.Tables[n]; for (int i = 0; i &lt; rows; i++) &#123; table.Rows.Add(ref miss); &#125; &#125; // 删除表格第rows行,n为表格的序号 public void DeleteRow(int n, int row) &#123; Microsoft.Office.Interop.Word.Table table = wordDoc.Content.Tables[n]; table.Rows[row].Delete(); &#125; // 给表格中单元格插入元素，table所在表格，row行号，column列号，value插入的元素 public void InsertCell(Microsoft.Office.Interop.Word.Table table, int row, int column, string value) &#123; table.Cell(row, column).Range.Text = value; &#125; // 给表格中单元格插入元素，n表格的序号从1开始记，row行号，column列号，value插入的元素 public void InsertCell(int n, int row, int column, string value) &#123; wordDoc.Content.Tables[n].Cell(row, column).Range.Text = value; &#125; // 给表格插入一行数据，n为表格的序号，row行号，columns列数，values插入的值 public void InsertCell(int n, int row, int columns, string[] values) &#123; Microsoft.Office.Interop.Word.Table table = wordDoc.Content.Tables[n]; for (int i = 0; i &lt; columns; i++) &#123; table.Cell(row, i + 1).Range.Text = values[i]; &#125; &#125; //杀掉winword.exe进程 public void killWinWordProcess() &#123; System.Diagnostics.Process[] processes = System.Diagnostics.Process.GetProcessesByName(&quot;WINWORD&quot;); foreach (System.Diagnostics.Process process in processes) &#123; bool b = process.MainWindowTitle==&quot;&quot;; if (process.MainWindowTitle ==&quot;&quot;) &#123; process.Kill(); &#125; &#125; &#125; &#125;&#125; Word转pdf123456789101112131415161718192021222324252627282930313233343536373839using System;using System.Collections.Generic;using System.Linq;using System.Text;using Microsoft.Office.Interop.Word;using System.IO;namespace GDZLCHECK&#123; class WordToPdfUtil &#123; public static bool wordToPdf(String sourcePath) &#123; bool result = false; _Application application = new Application(); _Document document = null; try &#123; application.Visible = false; document = application.Documents.Open(sourcePath); string PDFPath = sourcePath.Replace(&quot;.doc&quot;, &quot;.pdf&quot;);//pdf存放位置 if (!File.Exists(@PDFPath))//存在PDF，不需要继续转换 &#123; document.ExportAsFixedFormat(PDFPath, Microsoft.Office.Interop.Word.WdExportFormat.wdExportFormatPDF); &#125; result = true; &#125; catch (Exception e) &#123; Console.WriteLine(e.Message); result = false; &#125; finally &#123; document.Close(); &#125; return result; &#125; &#125;&#125; pdf加水印123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263using iTextSharp.text;using iTextSharp.text.pdf;using System;using System.Collections.Generic;using System.Data;using System.IO;using System.Linq;using System.Text;using System.Threading.Tasks;using System.Windows.Forms; public static void setWatermark(string filePath, string outputfilepath, string waterMarkName, string waterMarkAddr) &#123; PdfReader pdfReader = null; PdfStamper pdfStamper = null; try &#123; pdfReader = new PdfReader(filePath); pdfStamper = new PdfStamper(pdfReader, new FileStream(outputfilepath, FileMode.Create)); //设置权限为只读 pdfStamper.SetEncryption(PdfWriter.STRENGTH128BITS, null, null, PdfWriter.ALLOW_SCREENREADERS | PdfWriter.AllowPrinting); int total = pdfReader.NumberOfPages+1;//获取PDF的总页数 iTextSharp.text.Rectangle psize = pdfReader.GetPageSize(1);//获取第一页 float width = psize.Width;//PDF页面的宽度，用于计算水印倾斜 float height = psize.Height; PdfContentByte waterContent; BaseFont basefont = BaseFont.CreateFont(@&quot;C:\\WINDOWS\\Fonts\\SIMFANG.TTF&quot;, BaseFont.IDENTITY_H, BaseFont.EMBEDDED); PdfGState gs = new PdfGState(); //i从2开始，因为不给封面添加水印 for (int i = 2; i &lt; total; i++) &#123; waterContent = pdfStamper.GetOverContent(i);//在内容上方加水印 //透明度 waterContent.SetGState(gs); //开始写入文本 waterContent.BeginText(); waterContent.SetColorFill(BaseColor.RED); waterContent.SetFontAndSize(basefont, 30); waterContent.SetTextMatrix(0, 0); if (waterMarkAddr == null || waterMarkAddr == &quot;&quot;) &#123; waterContent.ShowTextAligned(Element.ALIGN_CENTER, waterMarkName, width / 2, height / 2, 55); &#125; else &#123; waterContent.ShowTextAligned(Element.ALIGN_CENTER, waterMarkName, width / 2, height / 2 + 100, 55); waterContent.ShowTextAligned(Element.ALIGN_CENTER, waterMarkAddr, width / 2, height / 2 - 100, 55); &#125; waterContent.EndText(); &#125; &#125; catch (Exception e) &#123; Console.WriteLine(e.ToString()); &#125; finally &#123; if (pdfStamper != null) pdfStamper.Close(); if (pdfReader != null) pdfReader.Close(); &#125; &#125; 主函数调用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121if (this.tbManagerName.Text.ToString() == &quot;&quot; || this.tbContact.Text.ToString() == &quot;&quot; || this.tbUnit.Text.ToString() == &quot;&quot;) &#123; MessageBox.Show(&quot;请输入项目负责人姓名,联系电话,承担单位&quot;); return; &#125; //ConstantInfo.outStatic(); FolderBrowserDialog dialog = new FolderBrowserDialog(); dialog.Description = &quot;请选择检查报告输出位置&quot;; string outputFilePath = &quot;&quot;; if (dialog.ShowDialog() == DialogResult.OK) &#123; outputFilePath = dialog.SelectedPath; string managerName = this.tbManagerName.Text.ToString(); string contactNum = this.tbContact.Text.ToString(); string unitName = this.tbUnit.Text.ToString(); //水印1 //PdfUtils.GeneratePDF(resultDt, strPacName, isPassed, managerName, contactNum, unitName, outputFilePath, 1); //水印2 // PdfUtils.GeneratePDF(resultDt, strPac,isPassed,outputFilePath, 2); //图片水印 // string picPath = string.Format(&quot;&#123;0&#125;/Resource/&#123;1&#125;&quot;, AppDomain.CurrentDomain.BaseDirectory,&quot;logo.png&quot;); //PdfUtils.GeneratePDF(resultDt, strPac,isPassed,outputFilePath, 3,picPath); //读取word模板生成数据，转为PDF，然后添加水印，删除临时文件 this.lbShowProcess.Text = &quot;正在准备统计数据...&quot;; this.pbProgress.Visible = true; statisticNum(); this.pbProgress.Position = 30; this.lbShowProcess.Text = &quot;开始生成检查报告...&quot;; savePdf(outputFilePath, managerName, contactNum, unitName); this.lbShowProcess.Text = &quot;检查报告导出完成&quot;; &#125; //保存pdf private void savePdf(string outputFilePath, string managerName, string contactNum, string unitName) &#123; String[] origin = &#123; &quot;O1&quot;, &quot;O2&quot;, &quot;O3&quot;, &quot;O4&quot;, &quot;O5&quot;, &quot;O6&quot; &#125;;//设计点 //创建一个Word应用程序实例 Microsoft.Office.Interop.Word._Application oWord = new Microsoft.Office.Interop.Word.Application(); //设置为不可见 oWord.Visible = false; //模板文件地址，这里假设在X盘根目录 string templatePath = string.Format(&quot;&#123;0&#125;/Config/&#123;1&#125;&quot;, AppDomain.CurrentDomain.BaseDirectory, &quot;template.dot&quot;); object oTemplate = templatePath; //以模板为基础生成文档 Microsoft.Office.Interop.Word._Document oDoc = oWord.Documents.Add(ref oTemplate, ref oMissing, ref oMissing, ref oMissing); CreateWord c = new CreateWord(); c.Application = oWord; c.Document = oDoc; int total = origin.Length this.pbProgress.Properties.Minimum = 0; this.pbProgress.Properties.Maximum =total+10; this.pbProgress.Properties.Step = 1; int i = 0, j = 0; foreach (String s in origin) &#123; Application.DoEvents(); c.InsertValue(s, Convert.ToString(ConstantInfo.StaticResult[j][i])); this.pbProgress.PerformStep(); i++; &#125; c.InsertValue(&quot;单位&quot;, unitName); c.InsertValue(&quot;负责人&quot;, managerName); c.InsertValue(&quot;电话&quot;, contactNum); c.InsertValue(&quot;日期&quot;, DateTime.Now.ToString(&quot;yyyy-MM-dd HH:mm:ss&quot;)); int rowNum = resultDt.Rows.Count; int colNum = resultDt.Columns.Count; if (rowNum &gt; 0) &#123; //插入结果行 c.AddRow(4, rowNum); //插入值 for (int rowIndex = 0; rowIndex &lt; rowNum; rowIndex++) &#123; Application.DoEvents(); for (int colIndex = 0; colIndex &lt; colNum; colIndex++) &#123; c.InsertCell(4, rowIndex+2, colIndex+1, resultDt.Rows[rowIndex][colIndex].ToString()); &#125; this.pbProgress.PerformStep(); &#125; &#125; string fileName = string.Format(&quot;数据_&#123;0&#125;.doc&quot;, DateTime.Now.ToString(&quot;yyyyMMddHHmmss&quot;)); string filePath = string.Format(&quot;&#123;0&#125;/Resource/&#123;1&#125;&quot;, AppDomain.CurrentDomain.BaseDirectory, fileName); c.SaveDocument(filePath);//此时已经生成word Thread.Sleep(5000); WordToPdfUtil.wordToPdf(filePath);//转为pdf string waterMarkName = &quot;检查:&quot; + (isPassed ? &quot;通过&quot; : &quot;未通过&quot;); string waterMarkAddr = strPacName; string outputFileName = string.Format(this.strPacName+&quot;数据入库预检查报告_&#123;0&#125;.pdf&quot;, DateTime.Now.ToString(&quot;yyyyMMddHHmmss&quot;)); outputFilePath = string.Format(&quot;&#123;0&#125;/&#123;1&#125;&quot;, outputFilePath, outputFileName); if (outputFilePath == null || outputFilePath == &quot;&quot;) &#123; outputFilePath = string.Format(&quot;&#123;0&#125;/Resource/&#123;1&#125;&quot;, AppDomain.CurrentDomain.BaseDirectory, outputFileName); &#125; string pdfPath = filePath.Replace(&quot;.doc&quot;, &quot;.pdf&quot;);//pdf存放位置 setWatermark(pdfPath, outputFilePath, waterMarkName, waterMarkAddr);//先生成水印，再删除临时文件 ,加密在设置水印中实现 //先生成水印，再删除临时文件 if (File.Exists(filePath))//判断临时文件是否存在，如果存在则删除 &#123; File.Delete(filePath); GC.Collect();//回收垃圾 &#125; string PDFPath = filePath.Replace(&quot;.doc&quot;, &quot;.pdf&quot;);//pdf存放位置 if (File.Exists(PDFPath))//判断临时文件是否存在，如果存在则删除 &#123; File.Delete(PDFPath); GC.Collect();//回收垃圾 &#125; Application.DoEvents(); this.pbProgress.Position = total + 10; MessageBox.Show(&quot;保存检查结果成功&quot;); this.pbProgress.Visible = false; Console.WriteLine(&quot;done&quot;); &#125;","tags":[{"name":"C#","slug":"C","permalink":"http://11wy11.github.io/tags/C/"}]},{"title":"C#利用itextSharp直接生成pdf","date":"2019-04-10T01:16:23.000Z","path":"2019/04/10/cplusplus-pdf-itextsharp-note/","text":"C#使用开源第三方库itextsharp直接生成pdf,相较于Microsoft Office 的COM组件，不需要依赖office环境，程序兼容性好，更轻量。但也存在一些不足，对于复杂模板的实现较为复杂，介绍一个使用实例 pdf工具类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648using iTextSharp.text;using iTextSharp.text.pdf;using System;using System.Collections.Generic;using System.Data;using System.IO;using System.Linq;using System.Text;using System.Threading.Tasks;using System.Windows.Forms;namespace GDZLCHECK.Utils&#123; class PdfUtils &#123; private static PdfUtils instance; public static PdfUtils GetInstance() &#123; if (instance == null) &#123; instance = new PdfUtils(); &#125; return instance; &#125; private static Document doc; private static BaseFont bf = BaseFont.CreateFont(@&quot;C://Windows/Fonts/simsun.ttc,0&quot;, BaseFont.IDENTITY_H, BaseFont.EMBEDDED); //四种字体 private static Font fontBig = new Font(bf, 20, Font.BOLD); private static Font fontMiddle = new Font(bf, 15, Font.BOLD); private static Font fontSmall = new Font(bf, 13, Font.BOLD); private static Font fontSmall1 = new Font(bf, 13, Font.BOLD); private static Font fontSmallNoBold = new Font(bf, 13); private static float IndentationLeft = 50;//距左边距 //如果要传参数进来，可自定义 public static void GeneratePDF(DataTable tableSource, string pac, bool isPassed,string managerName,string contactNum,string unitName,string outputFilePath = &quot;&quot;, int type = 1, string watermarkPicPath = &quot;&quot;) &#123; doc = new Document(PageSize.A4); doc.AddAuthor(&quot;XXXXXX&quot;); doc.AddCreationDate(); doc.AddHeader(&quot;isPass&quot;, isPassed.ToString()); try &#123; //MemoryStream ms2 = new MemoryStream(); string fileName = string.Format(&quot;数据_&#123;0&#125;.pdf&quot;, DateTime.Now.ToString(&quot;yyyyMMddHHmmss&quot;)); string filePath = string.Format(&quot;&#123;0&#125;/Resource/&#123;1&#125;&quot;, AppDomain.CurrentDomain.BaseDirectory, fileName); FileStream fs = new FileStream(filePath, FileMode.Create);//创建临时文件，到时生成好后删除 PdfWriter writer = PdfWriter.GetInstance(doc, fs); writer.CloseStream = false;//把doc内容写入流中 doc.Open(); //添加封面 //添加质检标志 string picPath = string.Format(&quot;&#123;0&#125;/Resource/&#123;1&#125;&quot;, AppDomain.CurrentDomain.BaseDirectory, &quot;mark.png&quot;); Image img = Image.GetInstance(new Uri(picPath)); float PageHeight = PageSize.A4.Height/7; double percentHeight = Math.Round((PageHeight / img.Height), 2); float PageWidth = PageSize.A4.Width/2; double percentWidth = Math.Round((PageWidth / img.Width), 2); double percent = percentHeight &gt; percentWidth ? percentWidth : percentHeight; img.ScalePercent((float)percent * 100); doc.Add(img); //每次在添加文本内容之前可以先设置字体 HeaderAndFooterEvent.SetFont(BaseColor.BLACK, &quot;宋体&quot;, 36, Font.BOLD); //添加一个空段落来占位，五个参数分别为：内容，对齐方式（1为居中，0为居左，2为居右），段后空行数，段前空行数，行间距 //doc.Add(HeaderAndFooterEvent.AddParagraph(&quot; &quot;, 1, 100, 0, 1.5f)); //这个方法为上一个方法的重载，三个参数分别为：内容，对齐方式，行间距 doc.Add(HeaderAndFooterEvent.AddParagraph(&quot;检 验 报 告&quot;, 1, 2.41f)); HeaderAndFooterEvent.SetFont(BaseColor.BLACK, &quot;宋体&quot;, 28, Font.BOLD); doc.Add(HeaderAndFooterEvent.AddParagraph(&quot;TEST REPORT&quot;, 1, 1.5f)); doc.Add(HeaderAndFooterEvent.AddParagraph(&quot; &quot;, 1, 50, 0, 1.5f)); HeaderAndFooterEvent.SetFont(BaseColor.BLACK, &quot;宋体&quot;, 28, Font.BOLD);//空行 string projectName=&quot;项目名称&quot;; //检测信息 bool isChangeRow = false;//对于项目名称过长需要换行截断 string anotherStr = &quot;&quot;; if (projectName.Length &gt; 19) &#123; isChangeRow = true; anotherStr = projectName.Substring(19, projectName.Length - 19); &#125; if (isChangeRow) &#123; AddPartnerContent(&quot;项目名称 :&quot;, projectName.Substring(0, 19), 38, 0);//添加项目名称 AddPartnerContent(&quot; &quot;, anotherStr, 38, 0);//添加项目名称 &#125; else &#123; AddPartnerContent(&quot;项目名称 :&quot;, projectName, 38, 0);//添加项目名称 &#125; AddPartnerContent(&quot;项目负责人:&quot;, managerName, 38, 0);//添加项目负责人 AddPartnerContent(&quot;联系电话 :&quot;, contactNum, 38, 1);//添加联系电话 AddPartnerContent(&quot;承担单位 :&quot;, unitName, 38, 0);//添加承担单位 AddPartnerContent(&quot;检测日期 :&quot;, DateTime.Now.ToString(&quot;yyyy-MM-dd HH:mm:ss&quot;), 38, 1);//添加项目名称 //检查结果详情 doc.NewPage(); //实现页眉页脚 writer.PageEvent = new HeaderAndFooterEvent(); HeaderAndFooterEvent.PAGE_NUMBER = true;//实现页眉跟页脚 HeaderAndFooterEvent.tpl = writer.DirectContent.CreateTemplate(500, 500); //定义模板 HeaderAndFooterEvent.HeaderLeft = &quot;耕地质量地球化学调查评价&quot;; HeaderAndFooterEvent.HeaderRight = &quot;成果检查&quot;; HeaderAndFooterEvent.FooterLeft = &quot;&quot;; HeaderAndFooterEvent.FooterRight = DateTime.Now.ToString(&quot;yyyy-MM-dd HH:mm:ss&quot;) + &quot;(UTC)&quot;; //核心操作 CreateLine();//生成一条下横线 CreateEmptyRow(1);//生成一行空行 HeaderAndFooterEvent.SetFont(BaseColor.BLACK, &quot;宋体&quot;, 15, Font.BOLD); doc.Add(HeaderAndFooterEvent.AddParagraph(&quot;耕地质量地球化学调查评价成果检查报告&quot;, 1, 1.5f)); //AddHeaderTitleContent(&quot;汇交数据检查报告&quot;);//添加表头 CreateEmptyRow(1);//生成一行空行 //AddPartnerContent(&quot;生产单位&quot;, pac, 30);//添加合作单位 //AddPartnerContent(&quot;检查单位&quot;,&quot;WHU&quot;,25);//添加合作单位 //AddPageNumberContent(1,1);//添加页码 HeaderAndFooterEvent.SetFont(BaseColor.BLACK, &quot;宋体1&quot;, 12); doc.Add(HeaderAndFooterEvent.AddParagraph(&quot;项目名称: XXXXXX&quot;, 0, 1.5f)); doc.Add(HeaderAndFooterEvent.AddParagraph(&quot;项目负责人:&quot;+managerName+&quot; &quot;, 0, 1.5f)); doc.Add(HeaderAndFooterEvent.AddParagraph(&quot;联系电话:&quot;+contactNum+&quot; &quot;, 0, 1.5f)); doc.Add(HeaderAndFooterEvent.AddParagraph(&quot;承担单位:&quot; + unitName + &quot; &quot;, 0, 1.5f)); doc.Add(HeaderAndFooterEvent.AddParagraph(&quot;检测日期: &quot; + DateTime.Now.ToString(&quot;yyyy-MM-dd HH:mm:ss&quot;), 0, 1.5f)); CreateEmptyRow(1);//生成一行空行 #region 生成表格数据 PdfPTable table = new PdfPTable(6);//5列的table //添加表格列头 table.WidthPercentage = 100; table.SetTotalWidth(new float[] &#123; 70, 150,80, 150, 80, 120 &#125;); table.AddCell(GetPdfCell(&quot;序号&quot;, fontSmallNoBold, Element.ALIGN_CENTER)); table.AddCell(GetPdfCell(&quot;检查对象&quot;, fontSmallNoBold, Element.ALIGN_CENTER)); table.AddCell(GetPdfCell(&quot;检查类型&quot;, fontSmallNoBold, Element.ALIGN_CENTER)); table.AddCell(GetPdfCell(&quot;检查内容&quot;, fontSmallNoBold, Element.ALIGN_CENTER)); table.AddCell(GetPdfCell(&quot;检查结果&quot;, fontSmallNoBold, Element.ALIGN_CENTER)); table.AddCell(GetPdfCell(&quot;备注&quot;, fontSmallNoBold, Element.ALIGN_CENTER)); int emptyRow = 20;//如果table的行数小于20行，那么剩余部分显示空白行 if (tableSource.Rows.Count &gt; 0) &#123; emptyRow = emptyRow - tableSource.Rows.Count;//如果为负数，说明不需要生成空白行 for (int i = 0; i &lt; tableSource.Rows.Count; i++) &#123; DataRow row = tableSource.Rows[i]; table.AddCell(GetPdfCell((i + 1).ToString(), fontSmallNoBold, Element.ALIGN_CENTER)); table.AddCell(GetPdfCell(row[&quot;Object&quot;].ToString(), fontSmallNoBold, Element.ALIGN_CENTER)); table.AddCell(GetPdfCell(row[&quot;Type&quot;].ToString(), fontSmallNoBold, Element.ALIGN_CENTER)); table.AddCell(GetPdfCell(row[&quot;Content&quot;].ToString(), fontSmallNoBold, Element.ALIGN_CENTER)); table.AddCell(GetPdfCell(row[&quot;Result&quot;].ToString(), fontSmallNoBold, Element.ALIGN_CENTER)); table.AddCell(GetPdfCell(row[&quot;Info&quot;].ToString(), fontSmallNoBold, Element.ALIGN_CENTER)); &#125; &#125; if (emptyRow &gt; 0)//说明数据源不足20行 &#123; for (int i = 0; i &lt; emptyRow; i++) &#123; table.AddCell(GetPdfCell(((20 - emptyRow) + i + 1).ToString(), fontSmallNoBold, Element.ALIGN_CENTER)); table.AddCell(GetPdfCell(&quot;&quot;, fontSmallNoBold, Element.ALIGN_CENTER)); table.AddCell(GetPdfCell(&quot;&quot;, fontSmallNoBold, Element.ALIGN_CENTER)); table.AddCell(GetPdfCell(&quot;&quot;, fontSmallNoBold, Element.ALIGN_CENTER)); table.AddCell(GetPdfCell(&quot;&quot;, fontSmallNoBold, Element.ALIGN_CENTER)); &#125; &#125; doc.Add(table); #endregion #region 添加水印 string waterMarkName = &quot;检查:&quot;+(isPassed?&quot;通过&quot;:&quot;未通过&quot;); string waterMarkAddr = pac; #endregion doc.Close(); fs.Close(); string outputFileName = string.Format(&quot;检查报告_&#123;0&#125;.pdf&quot;, DateTime.Now.ToString(&quot;yyyyMMddHHmmss&quot;)); outputFilePath = string.Format(&quot;&#123;0&#125;/&#123;1&#125;&quot;, outputFilePath, outputFileName); if (outputFilePath == null || outputFilePath == &quot;&quot;) &#123; outputFilePath = string.Format(&quot;&#123;0&#125;/Resource/&#123;1&#125;&quot;, AppDomain.CurrentDomain.BaseDirectory, outputFileName); &#125; switch (type) &#123; case 1: //目前使用并在其中设置了只读 setWatermark(filePath,outputFilePath,waterMarkName,waterMarkAddr);//先生成水印，再删除临时文件 break; case 2: waterMarkName = string.Format(&quot;汇交检查：&#123;0&#125; 区域：&#123;1&#125; &quot;, &quot;通过&quot;, waterMarkAddr); setWatermark(filePath, outputFilePath, waterMarkName); break; case 3: setPicWatermark(filePath, outputFilePath, watermarkPicPath); break; &#125; //先生成水印，再删除临时文件 if (File.Exists(filePath))//判断临时文件是否存在，如果存在则删除 &#123; File.Delete(filePath); GC.Collect();//回收垃圾 &#125; //设置只读 //pdfreadonly(outputFilePath); MessageBox.Show(&quot;保存检查结果成功&quot;); &#125; catch (DocumentException ex) &#123; throw new Exception(ex.Message); &#125; &#125; #region 生成一条横线 private static void CreateLine() &#123; PdfPTable table = new PdfPTable(1);//一个单元格的 table.WidthPercentage = 100; PdfPCell cell = new PdfPCell(); cell.BorderWidthBottom = 0.5f; table.AddCell(cell); doc.Add(table); &#125; #endregion #region 生成N行空白行 private static void CreateEmptyRow(int emptyRowNum) &#123; for (int i = 0; i &lt; emptyRowNum; i++) &#123; doc.Add(new Paragraph(&quot; &quot;)); &#125; &#125; #endregion #region 生成标题 private static void AddHeaderTitleContent(string content) &#123; Paragraph p = new Paragraph(content, fontMiddle); p.IndentationLeft = IndentationLeft;//距离左边距 doc.Add(p); &#125; #endregion #region 生成带下划线的内容 private static void AddPartnerContent(string stationName, string stationValue, int maxlength,int type) &#123; fontSmall.SetStyle(Font.UNDERLINE);//文字下划线 Paragraph content = new Paragraph(); content.IndentationLeft = 100; Chunk chunkName = new Chunk(stationName, fontSmall1); Chunk chunkText = new Chunk(GetEmptyString(maxlength, stationValue,type), fontSmall); content.Add(0, chunkName); content.Add(1, chunkText); content.SpacingAfter = 2; content.SpacingBefore = 2; content.MultipliedLeading = 1.5f; content.Alignment = 0; doc.Add(content); &#125; //居中显示内容 private static string GetEmptyString(int maxlength, string text,int type) &#123; int padding =0; if (type == 0) &#123; padding = (maxlength - text.Length* 2) ; &#125; else &#123; padding = (maxlength - text.Length); &#125; string empty = string.Empty; for (int i = 0; i &lt; padding; i++) &#123; empty += &quot; &quot;; &#125; return string.Format(&quot;&#123;1&#125;&#123;0&#125;&quot;, empty, text); &#125; #endregion #region 生成页码 private static void AddPageNumberContent(int total,int currentPage) &#123; var content = new Paragraph(&quot;共 &quot;+total+&quot; 页 第&quot;+currentPage+&quot; 页&quot;, fontSmall); content.IndentationRight = IndentationLeft + 20; content.Alignment = 2; //居左 doc.Add(content); &#125; #endregion #region 生成单元格 private static PdfPCell GetPdfCell(string content, Font font, int horizontalAlignment) &#123; PdfPCell cell = new PdfPCell(new Paragraph(content, font)); cell.HorizontalAlignment = horizontalAlignment;//水平位置 cell.VerticalAlignment = Element.ALIGN_CENTER;//垂直居中 cell.MinimumHeight = 20;//单元格的最小高度 return cell; &#125; #endregion #region 生成水印 public static bool CreatePDFByPic(string picPdfPath, string picPath) &#123; //新建一个文档 Document doc = new Document(); try &#123; //建立一个书写器(Writer)与document对象关联 PdfWriter.GetInstance(doc, new FileStream(picPdfPath, FileMode.Create, FileAccess.ReadWrite)); //打开一个文档 doc.Open(); //向文档中添加内容 Image img = Image.GetInstance(picPath); //img.SetAbsolutePosition(); doc.Add(img); return true; &#125; catch (Exception ex) &#123; return false; throw ex; &#125; finally &#123; if (doc != null) &#123; doc.Close(); &#125; &#125; &#125; /// &lt;summary&gt; /// 加图片水印 /// &lt;/summary&gt; /// &lt;param name=&quot;inputfilepath&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;outputfilepath&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;ModelPicName&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;top&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;left&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static bool setPicWatermark(string inputfilepath, string outputfilepath, string ModelPicName) &#123; //throw new NotImplementedException(); PdfReader pdfReader = null; PdfStamper pdfStamper = null; try &#123; pdfReader = new PdfReader(inputfilepath); int numberOfPages = pdfReader.NumberOfPages; iTextSharp.text.Rectangle psize = pdfReader.GetPageSize(1); float width = psize.Width; float height = psize.Height; pdfStamper = new PdfStamper(pdfReader, new FileStream(outputfilepath, FileMode.Create)); PdfContentByte waterMarkContent; iTextSharp.text.Image image = iTextSharp.text.Image.GetInstance(ModelPicName); float left = width / 2 - image.Width; float top = 10; image.GrayFill = 50;//透明度，灰色填充 //image.Rotation//旋转 //image.RotationDegrees//旋转角度 //水印的位置 if (left &lt; 0) &#123; left = width / 2 - image.Width; &#125; //image.SetAbsolutePosition(left, (height - image.Height) - top); image.SetAbsolutePosition(left, (height / 2 - image.Height) - top); //每一页加水印,也可以设置某一页加水印 for (int i = 1; i &lt;= numberOfPages; i++) &#123; //waterMarkContent = pdfStamper.GetUnderContent(i);//内容下层加水印 waterMarkContent = pdfStamper.GetOverContent(i);//内容上层加水印 waterMarkContent.AddImage(image); &#125; //strMsg = &quot;success&quot;; return true; &#125; catch (Exception ex) &#123; throw ex; &#125; finally &#123; if (pdfStamper != null) pdfStamper.Close(); if (pdfReader != null) pdfReader.Close(); &#125; &#125; /// &lt;summary&gt; /// 添加普通偏转角度文字水印 /// &lt;/summary&gt; /// &lt;param name=&quot;inputfilepath&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;outputfilepath&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;waterMarkName&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;permission&quot;&gt;&lt;/param&gt; public static void setWatermark(string inputfilepath, string outputfilepath, string waterMarkName) &#123; PdfReader pdfReader = null; PdfStamper pdfStamper = null; try &#123; pdfReader = new PdfReader(inputfilepath); pdfStamper = new PdfStamper(pdfReader, new FileStream(outputfilepath, FileMode.Create)); int total = pdfReader.NumberOfPages + 1; iTextSharp.text.Rectangle psize = pdfReader.GetPageSize(1); float width = psize.Width; float height = psize.Height; PdfContentByte content; BaseFont font = BaseFont.CreateFont(@&quot;C:\\WINDOWS\\Fonts\\SIMFANG.TTF&quot;, BaseFont.IDENTITY_H, BaseFont.EMBEDDED); PdfGState gs = new PdfGState(); for (int i = 1; i &lt; total; i++) &#123; content = pdfStamper.GetOverContent(i);//在内容上方加水印 //content = pdfStamper.GetUnderContent(i);//在内容下方加水印 //透明度 gs.FillOpacity = 0.3f; content.SetGState(gs); //content.SetGrayFill(0.3f); //开始写入文本 content.BeginText(); content.SetColorFill(BaseColor.LIGHT_GRAY); content.SetFontAndSize(font, 40); content.SetTextMatrix(0, 0); content.ShowTextAligned(Element.ALIGN_CENTER, waterMarkName, width / 2 - 50, height / 2 - 50, 55); //content.SetColorFill(BaseColor.BLACK); //content.SetFontAndSize(font, 8); //content.ShowTextAligned(Element.ALIGN_CENTER, waterMarkName, 0, 0, 0); content.EndText(); &#125; &#125; catch (Exception ex) &#123; throw ex; &#125; finally &#123; if (pdfStamper != null) pdfStamper.Close(); if (pdfReader != null) pdfReader.Close(); &#125; &#125; /// &lt;summary&gt; /// 添加倾斜水印 /// &lt;/summary&gt; /// &lt;param name=&quot;inputfilepath&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;outputfilepath&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;waterMarkName&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;userPassWord&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;ownerPassWord&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;permission&quot;&gt;&lt;/param&gt; public static void setWatermark(string inputfilepath, string outputfilepath, string waterMarkName, string userPassWord, string ownerPassWord, int permission) &#123; PdfReader pdfReader = null; PdfStamper pdfStamper = null; try &#123; pdfReader = new PdfReader(inputfilepath); pdfStamper = new PdfStamper(pdfReader, new FileStream(outputfilepath, FileMode.Create)); // 设置密码 //pdfStamper.SetEncryption(false,userPassWord, ownerPassWord, permission); int total = pdfReader.NumberOfPages + 1; PdfContentByte content; BaseFont font = BaseFont.CreateFont(@&quot;C:\\WINDOWS\\Fonts\\SIMFANG.TTF&quot;, BaseFont.IDENTITY_H, BaseFont.EMBEDDED); PdfGState gs = new PdfGState(); gs.FillOpacity = 0.2f;//透明度 int j = waterMarkName.Length; char c; int rise = 0; for (int i = 1; i &lt; total; i++) &#123; rise = 500; content = pdfStamper.GetOverContent(i);//在内容上方加水印 //content = pdfStamper.GetUnderContent(i);//在内容下方加水印 content.BeginText(); content.SetColorFill(BaseColor.DARK_GRAY); content.SetFontAndSize(font, 50); // 设置水印文字字体倾斜 开始 if (j &gt;= 15) &#123; content.SetTextMatrix(200, 120); for (int k = 0; k &lt; j; k++) &#123; content.SetTextRise(rise); c = waterMarkName[k]; content.ShowText(c + &quot;&quot;); rise -= 20; &#125; &#125; else &#123; content.SetTextMatrix(180, 100); for (int k = 0; k &lt; j; k++) &#123; content.SetTextRise(rise); c = waterMarkName[k]; content.ShowText(c + &quot;&quot;); rise -= 18; &#125; &#125; // 字体设置结束 content.EndText(); // 画一个圆 //content.Ellipse(250, 450, 350, 550); //content.SetLineWidth(1f); //content.Stroke(); &#125; &#125; catch (Exception ex) &#123; throw ex; &#125; finally &#123; if (pdfStamper != null) pdfStamper.Close(); if (pdfReader != null) pdfReader.Close(); &#125; &#125; /// &lt;summary&gt; /// /// &lt;/summary&gt; /// &lt;param name=&quot;filePath&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;outputfilepath&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;waterMarkName&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;waterMarkAddr&quot;&gt;&lt;/param&gt; public static void setWatermark(string filePath, string outputfilepath, string waterMarkName, string waterMarkAddr) &#123; PdfReader pdfReader = null; PdfStamper pdfStamper = null; try &#123; pdfReader = new PdfReader(filePath); pdfStamper = new PdfStamper(pdfReader, new FileStream(outputfilepath, FileMode.Create)); //设置权限为只读 pdfStamper.SetEncryption(PdfWriter.STRENGTH128BITS, null, null, PdfWriter.ALLOW_SCREENREADERS | PdfWriter.AllowPrinting); int total = pdfReader.NumberOfPages+1;//获取PDF的总页数 iTextSharp.text.Rectangle psize = pdfReader.GetPageSize(1);//获取第一页 float width = psize.Width;//PDF页面的宽度，用于计算水印倾斜 float height = psize.Height; PdfContentByte waterContent; BaseFont basefont = BaseFont.CreateFont(@&quot;C:\\WINDOWS\\Fonts\\SIMFANG.TTF&quot;, BaseFont.IDENTITY_H, BaseFont.EMBEDDED); PdfGState gs = new PdfGState(); //i从2开始，因为不给封面添加水印 for (int i = 2; i &lt; total; i++) &#123; waterContent = pdfStamper.GetOverContent(i);//在内容上方加水印 //透明度 waterContent.SetGState(gs); //开始写入文本 waterContent.BeginText(); waterContent.SetColorFill(BaseColor.RED); waterContent.SetFontAndSize(basefont, 30); waterContent.SetTextMatrix(0, 0); if (waterMarkAddr == null || waterMarkAddr == &quot;&quot;) &#123; waterContent.ShowTextAligned(Element.ALIGN_CENTER, waterMarkName, width / 2, height / 2, 55); &#125; else &#123; waterContent.ShowTextAligned(Element.ALIGN_CENTER, waterMarkName, width / 2, height / 2 + 100, 55); waterContent.ShowTextAligned(Element.ALIGN_CENTER, waterMarkAddr, width / 2, height / 2 - 100, 55); &#125; waterContent.EndText(); &#125; &#125; catch (Exception e) &#123; Console.WriteLine(e.ToString()); &#125; finally &#123; if (pdfStamper != null) pdfStamper.Close(); if (pdfReader != null) pdfReader.Close(); &#125; &#125; #endregion #region 只读 public static void pdfreadonly(string pdfname) &#123; string pdfFile = pdfname;// &quot;d:\\\\sample.pdf&quot;; //把文件读入内存可立即释放文件句柄，方便信息覆盖原文件 PdfReader reader = new PdfReader(File.ReadAllBytes(pdfFile)); //获取到本文件的 MetaData 信息 Dictionary&lt;string, string&gt; info = reader.Info; reader.Close(); //覆盖掉原 PDF 文件中 PdfStamper stamper = new PdfStamper(reader, new FileStream(pdfFile, FileMode.Create, FileAccess.Write)); stamper.MoreInfo = info; stamper.SetEncryption(PdfWriter.STRENGTH40BITS, null, null, PdfWriter.AllowScreenReaders); stamper.Close(); &#125; #endregion &#125;&#125; 页眉页脚生成类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305using iTextSharp.text;using iTextSharp.text.pdf;using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;namespace GDZLCHECK.Utils&#123; public class HeaderAndFooterEvent : PdfPageEventHelper, IPdfPageEvent &#123; #region 静态字段 public static PdfTemplate tpl = null; public static bool PAGE_NUMBER = false;//为True时就生成 页眉和页脚 public static iTextSharp.text.Rectangle rect = PageSize.A4; //文档大小 /// &lt;summary&gt; /// 正文字体 /// &lt;/summary&gt; private static Font font; /// &lt;summary&gt; /// 页眉页脚字体 /// &lt;/summary&gt; public static string HeaderFooterFontName = &quot;黑体&quot;; /// &lt;summary&gt; /// 页头页脚字号 /// &lt;/summary&gt; public static int HeaderFooterFontSize = 10; /// &lt;summary&gt; /// 页头页尾字体颜色 /// &lt;/summary&gt; public static BaseColor HeaderFooterFontColor = BaseColor.BLACK; /// &lt;summary&gt; /// 左边页眉 /// &lt;/summary&gt; public static string HeaderLeft &#123; get; set; &#125; /// &lt;summary&gt; /// 右边页眉 /// &lt;/summary&gt; public static string HeaderRight &#123; get; set; &#125; /// &lt;summary&gt; /// 左边页脚 /// &lt;/summary&gt; public static string FooterLeft &#123; get; set; &#125; /// &lt;summary&gt; /// 右边页脚 /// &lt;/summary&gt; public static string FooterRight &#123; get; set; &#125; #endregion #region 设置页面大小 /// &lt;summary&gt; /// 设置页面大小 /// &lt;/summary&gt; /// &lt;param name=&quot;type&quot;&gt;页面大小(如&quot;A4&quot;)&lt;/param&gt; public static void SetPageSize(string type) &#123; switch (type.Trim()) &#123; case &quot;A4&quot;: rect = PageSize.A4; break; case &quot;A8&quot;: rect = PageSize.A8; break; &#125; &#125; #endregion #region 设置字体 /// &lt;summary&gt; /// 设置字体 /// &lt;/summary&gt; /// &lt;param name=&quot;size&quot;&gt;字体大小&lt;/param&gt; public static void SetFont(BaseColor color, string fontName = &quot;华文中宋&quot;, float size = 12, int style = Font.NORMAL) &#123; font = new Font(BaseFontAndSize(fontName), size, style, color); &#125; #endregion #region 生成页眉页脚 /// &lt;summary&gt; /// 关闭一个页面时发生 /// &lt;/summary&gt; public override void OnEndPage(PdfWriter writer, Document document) &#123; if (PAGE_NUMBER) &#123; Font HeaderFooterFont = FontAndSize(HeaderFooterFontName, HeaderFooterFontSize, Font.NORMAL, HeaderFooterFontColor); Phrase header_left = new Phrase(HeaderLeft, HeaderFooterFont); Phrase header_right = new Phrase(HeaderRight, HeaderFooterFont); Phrase footer_left = new Phrase(FooterLeft, HeaderFooterFont); Phrase footer_center = new Phrase(&quot;第&quot; + (writer.PageNumber-1) + &quot;页/共 页&quot;, HeaderFooterFont); Phrase footer_right = new Phrase(FooterRight, HeaderFooterFont); PdfContentByte cb = writer.DirectContent; //模版 显示总共页数 cb.AddTemplate(tpl, document.Right - 290 + document.LeftMargin, document.Bottom - 15);//调节模版显示的位置 //页眉显示的位置 ColumnText.ShowTextAligned(cb, Element.ALIGN_CENTER, header_right, document.Right - 50 + document.LeftMargin, document.Top + 15, 0); ColumnText.ShowTextAligned(cb, Element.ALIGN_CENTER, header_left, document.Right - 500 + document.LeftMargin, document.Top + 15, 0); //页脚显示的位置 ColumnText.ShowTextAligned(cb, Element.ALIGN_CENTER, footer_left, document.Right - 535 + document.LeftMargin, document.Bottom - 15, 0); ColumnText.ShowTextAligned(cb, Element.ALIGN_CENTER, footer_center, document.Right - 300 + document.LeftMargin, document.Bottom - 15, 0); ColumnText.ShowTextAligned(cb, Element.ALIGN_CENTER, footer_right, document.Right - 80 + document.LeftMargin, document.Bottom - 15, 0); &#125; &#125; /// &lt;summary&gt; /// 打开一个新页面时发生 /// &lt;/summary&gt; public override void OnStartPage(PdfWriter writer, Document document) &#123; if (PAGE_NUMBER) &#123; writer.PageCount = writer.PageNumber - 1; &#125; &#125; /// &lt;summary&gt; /// 关闭PDF文档时发生该事件 /// &lt;/summary&gt; public override void OnCloseDocument(PdfWriter writer, Document document) &#123; BaseFont bf = BaseFontAndSize(HeaderFooterFontName); tpl.BeginText(); tpl.SetFontAndSize(bf, HeaderFooterFontSize); tpl.ShowText((writer.PageNumber - 1).ToString());//总页数 tpl.EndText(); tpl.ClosePath(); &#125; #endregion #region 私有方法 private static Font FontAndSize(string font_name, int size, int style, BaseColor baseColor) &#123; BaseFont baseFont; //BaseFont.AddToResourceSearch(&quot;iTextAsian.dll&quot;); //BaseFont.AddToResourceSearch(&quot;iTextAsianCmaps.dll&quot;); Font font = null; string file_name = &quot;&quot;; int fontStyle; switch (font_name) &#123; case &quot;黑体&quot;: file_name = &quot;SIMHEI.TTF&quot;; break; case &quot;华文中宋&quot;: file_name = &quot;STZHONGS.TTF&quot;; break; case &quot;宋体&quot;: file_name = &quot;SIMYOU.TTF&quot;; break; case &quot;宋体1&quot;: file_name = &quot;simsun.ttc&quot;; break; default: file_name = &quot;SIMYOU.TTF&quot;; break; &#125; baseFont = BaseFont.CreateFont(@&quot;c:/windows/fonts/&quot; + file_name, BaseFont.IDENTITY_H, BaseFont.NOT_EMBEDDED); if (style &lt; -1) &#123; fontStyle = Font.NORMAL; &#125; else &#123; fontStyle = style; &#125; font = new Font(baseFont, size, fontStyle, baseColor); return font; &#125; private static BaseFont BaseFontAndSize(string font_name) &#123; BaseFont baseFont; //BaseFont.AddToResourceSearch(&quot;iTextAsian.dll&quot;); //BaseFont.AddToResourceSearch(&quot;iTextAsianCmaps.dll&quot;); string file_name = &quot;&quot;; switch (font_name) &#123; case &quot;黑体&quot;: file_name = &quot;SIMHEI.TTF&quot;; break; case &quot;华文中宋&quot;: file_name = &quot;STZHONGS.TTF&quot;; break; case &quot;宋体&quot;: file_name = &quot;SIMYOU.TTF&quot;; break; default: file_name = &quot;SIMYOU.TTF&quot;; break; &#125; baseFont = BaseFont.CreateFont(@&quot;c:/windows/fonts/&quot; + file_name, BaseFont.IDENTITY_H, BaseFont.NOT_EMBEDDED); return baseFont; &#125; #endregion #region 添加段落 /// &lt;summary&gt; /// 添加段落 /// &lt;/summary&gt; /// &lt;param name=&quot;content&quot;&gt;内容&lt;/param&gt; /// &lt;param name=&quot;Alignment&quot;&gt;对齐方式（1为居中，0为居左，2为居右）&lt;/param&gt; /// &lt;param name=&quot;SpacingAfter&quot;&gt;段后空行数（0为默认值）&lt;/param&gt; /// &lt;param name=&quot;SpacingBefore&quot;&gt;段前空行数（0为默认值）&lt;/param&gt; /// &lt;param name=&quot;MultipliedLeading&quot;&gt;行间距（0为默认值）&lt;/param&gt; public static Paragraph AddParagraph(string content, int Alignment, float SpacingAfter, float SpacingBefore, float MultipliedLeading) &#123; Paragraph pra = new Paragraph(content, font); pra.Alignment = Alignment; pra.SpacingAfter = SpacingAfter; pra.SpacingBefore = SpacingBefore; pra.MultipliedLeading = MultipliedLeading; return pra; &#125; public static Paragraph AddParagraph(string content, int Alignment, float MultipliedLeading) &#123; Paragraph pra = new Paragraph(content, font); pra.Alignment = Alignment; pra.MultipliedLeading = MultipliedLeading; return pra; &#125; public static void AddPhrase(PdfWriter writer, Document document, string content, float marginLift, float marginBottom) &#123; Phrase phrase = new Phrase(content, font); PdfContentByte cb = writer.DirectContent; ColumnText.ShowTextAligned(cb, Element.ALIGN_CENTER, phrase, marginLift + document.LeftMargin, marginBottom, 0); &#125; #endregion #region 添加图片 /// &lt;summary&gt; /// 添加图片 /// &lt;param name=&quot;Alignment&quot;&gt;对齐方式 (0/1/2)&lt;/param&gt; /// &lt;param name=&quot;marginRight&quot;&gt;页边距&lt;/param&gt; /// &lt;param name=&quot;marginBottom&quot;&gt;页边距&lt;/param&gt; /// &lt;/summary&gt; public static iTextSharp.text.Image AddImage(string path, int Alignment, float marginRight, float marginBottom) &#123; Image img = Image.GetInstance(new Uri(path)); img.Alignment = Alignment; //等比缩放，宽与高的缩放系数哪个大就取哪一个（比如高的系数是0.8，宽的是0.7，则取0.7。这样图片就不会超出页面范围） if (img.Width &gt; img.Height) &#123; //这里计算图片的缩放系数，因为图片width&gt;height,所以将图片旋转90度以适应页面，计算缩放系数的时候宽与高对调 float PageHeight = PageSize.A4.Height - marginBottom * 3; double percentHeight = Math.Round((PageHeight / img.Width), 2); float PageWidth = PageSize.A4.Width - marginRight * 2; double percentWidth = Math.Round((PageWidth / img.Height), 2); double percent = percentHeight &gt; percentWidth ? percentWidth : percentHeight; img.ScalePercent((float)percent * 100); img.RotationDegrees = 90f; &#125; else &#123; float PageHeight = PageSize.A4.Height - marginBottom * 3; double percentHeight = Math.Round((PageHeight / img.Height), 2); float PageWidth = PageSize.A4.Width - marginRight * 2; double percentWidth = Math.Round((PageWidth / img.Width), 2); double percent = percentHeight &gt; percentWidth ? percentWidth : percentHeight; img.ScalePercent((float)percent * 100); &#125; return img; &#125; #endregion &#125;&#125; 主函数调用方式1234567891011121314151617181920212223242526272829if (this.tbManagerName.Text.ToString() == &quot;&quot; || this.tbContact.Text.ToString() == &quot;&quot; || this.tbUnit.Text.ToString() == &quot;&quot;) &#123; MessageBox.Show(&quot;请输入项目负责人姓名,联系电话,承担单位&quot;); return; &#125; //ConstantInfo.outStatic(); FolderBrowserDialog dialog = new FolderBrowserDialog(); dialog.Description = &quot;请选择检查报告输出位置&quot;; string outputFilePath = &quot;&quot;; if (dialog.ShowDialog() == DialogResult.OK) &#123; outputFilePath = dialog.SelectedPath; string managerName = this.tbManagerName.Text.ToString(); string contactNum = this.tbContact.Text.ToString(); string unitName = this.tbUnit.Text.ToString(); this.lbShowProcess.Text = &quot;正在准备统计数据...&quot;; this.pbProgress.Visible = true; statisticNum(); this.pbProgress.Position = 30; this.lbShowProcess.Text = &quot;开始生成检查报告...&quot;; //文字水印1 PdfUtils.GeneratePDF(resultDt, strPacName, isPassed, managerName, contactNum, unitName, outputFilePath, 1); //水印2 // PdfUtils.GeneratePDF(resultDt, strPac,isPassed,outputFilePath, 2); //图片水印 // string picPath = string.Format(&quot;&#123;0&#125;/Resource/&#123;1&#125;&quot;, AppDomain.CurrentDomain.BaseDirectory,&quot;logo.png&quot;); //PdfUtils.GeneratePDF(resultDt, strPac,isPassed,outputFilePath, 3,picPath); this.lbShowProcess.Text = &quot;检查报告导出完成&quot;; &#125;","tags":[{"name":"C#","slug":"C","permalink":"http://11wy11.github.io/tags/C/"},{"name":"VS打包","slug":"VS打包","permalink":"http://11wy11.github.io/tags/VS打包/"}]},{"title":"C# Regex正则表达式","date":"2019-03-29T12:30:30.000Z","path":"2019/03/29/cplusplus-regex-note/","text":"正则表达式的本质是使用一系列特殊字符模式，来表示某一类字符串。 Regex 正则表达式正则表达式的本质是使用一系列特殊字符模式，来表示某一类字符串。正则表达式无疑是处理文本最有力的工具，而.NET提供的Regex类实现了验证正则表达式的方法。Regex 类表示不可变（只读）的正则表达式。它还包含各种静态方法，允许在不显式创建其他类的实例的情况下使用其他正则表达式类。 基础 代码 说明 . 匹配除换行符以外的任意字符。 \\w 匹配字母或数字或下划线或汉字。 \\s 匹配任意的空白符。 \\d 匹配数字。 \\b 匹配单词的开始或结束。 [ck] 匹配包含括号内元素的字符 ^ 匹配行的开始。 $ 匹配行的结束。 \\ 对下一个字符转义。比如$是个特殊的字符。要匹配$的话就得用\\$ &#124; 分支条件，如：x&#124; y匹配 x 或 y。 反义元字符 代码 说明 \\W 匹配任意不是字母，数字，下划线，汉字的字符。 \\S 匹配任意不是空白符的字符。等价于 [^ \\f\\n\\r\\t\\v]。 \\D 匹配任意非数字的字符。等价于 [^0-9]。 \\B 匹配不是单词开头或结束的位置。 [^CK] 匹配除了CK以外的任意字符。 特殊元字符 代码 说明 \\f 匹配一个换页符。等价于 \\x0c 和 \\cL。 \\n 匹配一个换行符。等价于 \\x0a 和 \\cJ。 \\r 匹配一个回车符。等价于 \\x0d 和 \\cM。 \\t 匹配一个制表符。等价于 \\x09 和 \\cI。 \\v 匹配一个垂直制表符。等价于 \\x0b 和 \\cK。 限定符 代码 说明 * 匹配前面的子表达式零次或多次。 + 匹配前面的子表达式一次或多次。 ? 匹配前面的子表达式零次或一次。 {n} n 是一个非负整数。匹配确定的 n 次。 {n,} n 是一个非负整数。至少匹配n 次。 {n,m} m 和 n 均为非负整数，其中n &lt;= m。最少匹配 n 次且最多匹配 m 次。 懒惰限定符 代码 说明 *? 重复任意次，但尽可能少重复。 如 “acbacb” 正则 “a.*?b” 只会取到第一个”acb” 原本可以全部取到但加了限定符后，只会匹配尽可能少的字符 ，而”acbacb”最少字符的结果就是”acb” 。 +? 重复1次或更多次，但尽可能少重复。与上面一样，只是至少要重复1次。 ?? 重复0次或1次，但尽可能少重复。 如 “aaacb” 正则 “a.??b” 只会取到最后的三个字符”acb”。 {n,m}? 重复n到m次，但尽可能少重复。 如 “aaaaaaaa” 正则 “a{0,m}” 因为最少是0次所以取到结果为空。 {n,}? 重复n次以上，但尽可能少重复。 如 “aaaaaaa” 正则 “a{1,}” 最少是1次所以取到结果为 “a”。 捕获分组 代码 说明 (exp) 匹配exp,并捕获文本到自动命名的组里。 (?exp) 匹配exp,并捕获文本到名称为name的组里。 (?:exp) 匹配exp,不捕获匹配的文本，也不给此分组分配组号以下为零宽断言。 (?=exp) 匹配exp前面的位置。 如 “How are you doing” 正则”(?.+(?=ing))” 这里取ing前所有的字符，并定义了一个捕获分组名字为 “txt” 而”txt”这个组里的值为”How are you do”; (?&lt;=exp) 匹配exp后面的位置。 如 “How are you doing” 正则”(?(?&lt;=How).+)” 这里取”How”之后所有的字符，并定义了一个捕获分组名字为 “txt” 而”txt”这个组里的值为” are you doing”; (?!exp) 匹配后面跟的不是exp的位置。 如 “123abc” 正则 “\\d{3}(?!\\d)”匹配3位数字后非数字的结果 (?&lt;!exp) 匹配前面不是exp的位置。 如 “abc123 “ 正则 “(?&lt;![0-9])123” 匹配”123”前面是非数字的结果也可写成”(?!&lt;\\d)123” 数字常用表达式1234567891011121314151617181920212223242526272829303132333435363738//数字 Regex reg = new Regex(@&quot;^[0-9]*$&quot;); //n位的数字 Regex reg = new Regex(@&quot;^\\d&#123;n&#125;$&quot;); //至少n位的数字 Regex reg = new Regex(@&quot;^\\d&#123;n,&#125;$&quot;); //m-n位的数字 Regex reg = new Regex(@&quot;^\\d&#123;m,n&#125;$&quot;); //零和非零开头的数字 Regex reg = new Regex(@&quot;^(0|[1-9][0-9]*)$&quot;); //非零开头的最多带两位小数的数字 Regex reg = new Regex(@&quot;^([1-9][0-9]*)+(.[0-9]&#123;1,2&#125;)?$&quot;); //带1-2位小数的正数或负数 Regex reg = new Regex(@&quot;^(\\-)?\\d+(\\.\\d&#123;1,2&#125;)?$&quot;); //正数、负数、和小数 Regex reg = new Regex(@&quot;^(\\-|\\+)?\\d+(\\.\\d+)?$&quot;); //有两位小数的正实数 Regex reg = new Regex(@&quot;^[0-9]+(.[0-9]&#123;2&#125;)?$&quot;); //有1~3位小数的正实数 Regex reg = new Regex(@&quot;^[0-9]+(.[0-9]&#123;1,3&#125;)?$&quot;); //非零的正整数 Regex reg = new Regex(@&quot;^[1-9]\\d*$ 或 ^([1-9][0-9]*)&#123;1,3&#125;$ 或 ^\\+?[1-9][0-9]*$&quot;); //非零的负整数 Regex reg = new Regex(@&quot;^\\-[1-9][]0-9″*$ 或 ^-[1-9]\\d*$&quot;); //非负整数 Regex reg = new Regex(@&quot;^\\d+$ 或 ^[1-9]\\d*|0$&quot;); //非正整数 Regex reg = new Regex(@&quot;^-[1-9]\\d*|0$ 或 ^((-\\d+)|(0+))$&quot;); //非负浮点数 Regex reg = new Regex(@&quot;^\\d+(\\.\\d+)?$ 或 ^[1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*|0?\\.0+|0$&quot;); //非正浮点数 Regex reg = new Regex(@&quot;^((-\\d+(\\.\\d+)?)|(0+(\\.0+)?))$ 或 ^(-([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*))|0?\\.0+|0$&quot;); //正浮点数 Regex reg = new Regex(@&quot;^[1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*$ 或 ^(([0-9]+\\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\\.[0-9]+)|([0-9]*[1-9][0-9]*))$&quot;); //负浮点数 Regex reg = new Regex(@&quot;^-([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*)$ 或 ^(-(([0-9]+\\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\\.[0-9]+)|([0-9]*[1-9][0-9]*)))$&quot;); //浮点数 Regex reg = new Regex(@&quot;^(-?\\d+)(\\.\\d+)?$ 或 ^-?([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*|0?\\.0+|0)$&quot;); 字符123456789101112131415161718192021222324//汉字 Regex reg = new Regex(@&quot;^[\\u4e00-\\u9fa5]&#123;0,&#125;$&quot;); //英文和数字 Regex reg = new Regex(@&quot;^[A-Za-z0-9]+$ 或 ^[A-Za-z0-9]&#123;4,40&#125;$&quot;); //长度为3-20的所有字符 Regex reg = new Regex(@&quot;^.&#123;3,20&#125;$&quot;); //由26个英文字母组成的字符串 Regex reg = new Regex(@&quot;^[A-Za-z]+$&quot;); //由26个大写英文字母组成的字符串 Regex reg = new Regex(@&quot;^[A-Z]+$&quot;); //由26个小写英文字母组成的字符串 Regex reg = new Regex(@&quot;^[a-z]+$&quot;); //由数字和26个英文字母组成的字符串 Regex reg = new Regex(@&quot;^[A-Za-z0-9]+$&quot;); //由数字、26个英文字母或者下划线组成的字符串 Regex reg = new Regex(@&quot;^\\w+$ 或 ^\\w&#123;3,20&#125;$&quot;); //中文、英文、数字包括下划线 Regex reg = new Regex(@&quot;^[\\u4E00-\\u9FA5A-Za-z0-9_]+$&quot;); //中文、英文、数字但不包括下划线等符号 Regex reg = new Regex(@&quot;^[\\u4E00-\\u9FA5A-Za-z0-9]+$ 或 ^[\\u4E00-\\u9FA5A-Za-z0-9]&#123;2,20&#125;$&quot;); //可以输入含有^%&amp;’,;=?$\\”等字符 Regex reg = new Regex(@&quot;[^%&amp;’,;=?$\\x22]+&quot;); //禁止输入含有~的字符 Regex reg = new Regex(@&quot;[^~\\x22]+&quot;); 其他表达式123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566//Email地址 Regex reg = new Regex(@&quot;^\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*$&quot;); //域名 Regex reg = new Regex(@&quot;[a-zA-Z0-9][-a-zA-Z0-9]&#123;0,62&#125;(/.[a-zA-Z0-9][-a-zA-Z0-9]&#123;0,62&#125;)+/.?&quot;); //InternetURL Regex reg = new Regex(@&quot;[a-zA-z]+://[^\\s]* 或 ^http://([\\w-]+\\.)+[\\w-]+(/[\\w-./?%&amp;=]*)?$&quot;); //手机号码 Regex reg = new Regex(@&quot;^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\\d&#123;8&#125;$&quot;); //电话号码(“XXX-XXXXXXX”、”XXXX-XXXXXXXX”、”XXX-XXXXXXX”、”XXX-XXXXXXXX”、”XXXXXXX”和”XXXXXXXX) Regex reg = new Regex(@&quot;^($$\\d&#123;3,4&#125;-)|\\d&#123;3.4&#125;-)?\\d&#123;7,8&#125;$&quot;); //国内电话号码(0511-4405222、021-87888822) Regex reg = new Regex(@&quot;\\d&#123;3&#125;-\\d&#123;8&#125;|\\d&#123;4&#125;-\\d&#123;7&#125;&quot;); //身份证号(15位、18位数字) Regex reg = new Regex(@&quot;^\\d&#123;15&#125;|\\d&#123;18&#125;$&quot;); //短身份证号码(数字、字母x结尾) Regex reg = new Regex(@&quot;^([0-9])&#123;7,18&#125;(x|X)?$ 或 ^\\d&#123;8,18&#125;|[0-9x]&#123;8,18&#125;|[0-9X]&#123;8,18&#125;?$&quot;); //帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线) Regex reg = new Regex(@&quot;^[a-zA-Z][a-zA-Z0-9_]&#123;4,15&#125;$&quot;); //密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线) Regex reg = new Regex(@&quot;^[a-zA-Z]\\w&#123;5,17&#125;$&quot;); //强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间) Regex reg = new Regex(@&quot;^(?=.*\\d)(?=.*[a-z])(?=.*[A-Z]).&#123;8,10&#125;$&quot;); //日期格式 Regex reg = new Regex(@&quot;^\\d&#123;4&#125;-\\d&#123;1,2&#125;-\\d&#123;1,2&#125;&quot;); //一年的12个月(01～09和1～12) Regex reg = new Regex(@&quot;^(0?[1-9]|1[0-2])$&quot;); //一个月的31天(01～09和1～31) Regex reg = new Regex(@&quot;^((0?[1-9])|((1|2)[0-9])|30|31)$&quot;); //钱的输入格式： //有四种钱的表示形式我们可以接受:”10000.00″ 和 “10,000.00”, 和没有 “分” 的 “10000” 和 “10,000” Regex reg = new Regex(@&quot;^[1-9][0-9]*$&quot;); //这表示任意一个不以0开头的数字，但是，这也意味着一个字符”0″不通过，所以我们采用下面的形式 Regex reg = new Regex(@&quot;^(0|[1-9][0-9]*)$&quot;); //一个0或者一个不以0开头的数字.我们还可以允许开头有一个负号 Regex reg = new Regex(@&quot;^(0|-?[1-9][0-9]*)$&quot;); //这表示一个0或者一个可能为负的开头不为0的数字.让用户以0开头好了.把负号的也去掉，因为钱总不能是负的吧.下面我们要加的是说明可能的小数部分 Regex reg = new Regex(@&quot;^[0-9]+(.[0-9]+)?$&quot;); //必须说明的是，小数点后面至少应该有1位数，所以”10.”是不通过的，但是 “10” 和 “10.2” 是通过的 Regex reg = new Regex(@&quot;^[0-9]+(.[0-9]&#123;2&#125;)?$&quot;); //这样我们规定小数点后面必须有两位，如果你认为太苛刻了，可以这样 Regex reg = new Regex(@&quot;^[0-9]+(.[0-9]&#123;1,2&#125;)?$&quot;); //这样就允许用户只写一位小数。下面我们该考虑数字中的逗号了，我们可以这样 Regex reg = new Regex(@&quot;^[0-9]&#123;1,3&#125;(,[0-9]&#123;3&#125;)*(.[0-9]&#123;1,2&#125;)?$&quot;); //1到3个数字，后面跟着任意个 逗号+3个数字，逗号成为可选，而不是必须 Regex reg = new Regex(@&quot;^([0-9]+|[0-9]&#123;1,3&#125;(,[0-9]&#123;3&#125;)*)(.[0-9]&#123;1,2&#125;)?$&quot;); //备注：这就是最终结果了，别忘了”+”可以用”*”替代。如果你觉得空字符串也可以接受的话(奇怪，为什么?)最后，别忘了在用函数时去掉去掉那个反斜杠，一般的错误都在这里 //xml文件 Regex reg = new Regex(@&quot;^([a-zA-Z]+-?)+[a-zA-Z0-9]+\\\\.[x|X][m|M][l|L]$&quot;); //中文字符的正则表达式 Regex reg = new Regex(@&quot;[\\u4e00-\\u9fa5]&quot;); //双字节字符 Regex reg = new Regex(@&quot;[^\\x00-\\xff] (包括汉字在内，可以用来计算字符串的长度(一个双字节字符长度计2，ASCII字符计1))&quot;); //空白行的正则表达式，可用来删除空白行 Regex reg = new Regex(@&quot;\\n\\s*\\r&quot;); //HTML标记的正则表达式 Regex reg = new Regex(@&quot;&lt;(\\S*?)[^&gt;]*&gt;.*?&lt;/\\1&gt;|&lt;.*? /&gt;&quot;);// (网上流传的版本太糟糕，上面这个也仅仅能部分，对于复杂的嵌套标记依旧无能为力) //首尾空白字符的正则表达式 Regex reg = new Regex(@&quot;^\\s*|\\s*$或(^\\s*)|(\\s*$)&quot;);// (可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式) //腾讯QQ号 Regex reg = new Regex(@&quot;[1-9][0-9]&#123;4,&#125;&quot;); //(腾讯QQ号从10000开始) //中国邮政编码 Regex reg = new Regex(@&quot;[1-9]\\d&#123;5&#125;(?!\\d)&quot;);// (中国邮政编码为6位数字) //IP地址 Regex reg = new Regex(@&quot;\\d+\\.\\d+\\.\\d+\\.\\d+&quot;);// (提取IP地址时有用) //IP地址 Regex reg = new Regex(@&quot;((?:(?:25[0-5]|2[0-4]\\\\d|[01]?\\\\d?\\\\d)\\\\.)&#123;3&#125;(?:25[0-5]|2[0-4]\\\\d|[01]?\\\\d?\\\\d))&quot;);","tags":[{"name":"C#","slug":"C","permalink":"http://11wy11.github.io/tags/C/"},{"name":"Regex","slug":"Regex","permalink":"http://11wy11.github.io/tags/Regex/"}]},{"title":"ai组件开发--虚线定义原理及编程实现","date":"2019-03-25T07:41:27.000Z","path":"2019/03/25/ai-dash-line-note/","text":"illustrator中定义虚线形式可以最多设置三个虚线长度和三个间隙长度 虚线定义illustrator中定义虚线形式可以最多设置三个虚线长度和三个间隙长度__需要特别注意如果定义奇数个参数，即没有定义spaceA，spaceB，spaceC时的情况,其中spaceB和spaceC的循环情况原理一致依次标记为dashA,spaceA,dashB,spaceB,dashC,spaceC为更明显的展示，定义：dashA: 3spaceA: 5 dashB: 4spaceB:6 dashC: 2spaceC: 1虚线：—表示一个pt间隙：#表示一个pt结果形式：展示两次循环，每次循环间为区分明显添加了一个空格下面简单介绍定义规则 设置dashA，其他值为空一次循环：此时按照dashA的长度绘制实部，此时，illustrator默认spaceA=dashA，因此间隙也是dashA的长度结果形式:———### ———### 设置dashA，spaceA,其他值为空一次循环：此时按照dashA的长度绘制实部，间隙是spaceA的长度结果形式:———##### ———##### 设置dashA，spaceA,dashB,其他值为空，需注意一次循环：此时按照dashA的长度绘制第一个实部，间隙是spaceA的长度,按照dashB的长度绘制第二个实部，按照dashA绘制间隙，按照spaceA绘制第三个实部，按照dashB绘制间隙结果形式:———#####————####—————#### ———#####————####—————#### 设置dashA，spaceA,dashB,spaceB,其他值为空 一次循环：此时按照dashA的长度绘制第一个实部，间隙是spaceA的长度,按照dashB的长度绘制第二个实部，间隙是spaceB的长度, 结果形式:———#####————###### ———#####————###### 设置dashA，spaceA,dashB,spaceB,dashC,其他值为空 一次循环：此时按照dashA的长度绘制第一个实部，间隙是spaceA的长度,按照dashB的长度绘制第二个实部，间隙是spaceB的长度,按照dashC的长度绘制第三个实部,间隙是spaceC的长度，按照dashA绘制间隙，按照spaceA绘制第四个实部，按照dashB绘制间隙，按照spaceB绘制第五个实部，按照dashC绘制间隙,按照spaceC绘制第六个实部 结果形式:———#####————######——###—————####——————## ———#####————######——###—————####——————## 设置dashA，spaceA,dashB,spaceB,dashC,spaceC 原理同4一致，不再赘述 概括来说，AI本身每次循环使用六个参数定义虚线，如果不足就会重复前面定义的参数 illustrator SDK接口实现","tags":[{"name":"AI","slug":"AI","permalink":"http://11wy11.github.io/tags/AI/"}]},{"title":"AI组件开发（八）--AIArtStyleSuite","date":"2019-03-25T01:46:16.000Z","path":"2019/03/25/ai-eight-style-note/","text":"Art Style套件中的功能用于访问和修改Illustrator文档中图稿的art样式Table of Contents generated with DocToc AIArtStyleSuite 方法 相关类，结构体，指针 AIArtHandle AIArtStyleHandle AIPathStyle AIStrokeStyle AIFillStyle 使用实例 AIArtStyleSuiteArt Style套件中的功能用于访问和修改Illustrator文档中图稿的art样式在AI8中，Illustrator引入了插件组的概念，其中实际打印的art（结果art）与用户编辑的art（编辑art）分开。随着art风格的引入，这一概念在AI9中得到了扩展。现在，文档中的任何art对象（包括组和文本对象）都可以选择附加“样式art”。正是这种“风格art”得到了印刷，而不是原始的“源art”。 应用于art的art风格控制着风格art的生成方式。插件不应该直接修改样式art本身，可以随时重新生成，但应该使用art风格。 导出插件应导出应用于对象的样式化art（如果有），而不是原始源art。 在UI中，应用于Illustratorart对象的art风格称为对象的外观，并通过“外观”调板进行操作。外观也可以通过“图形样式”调板保存并在其他对象上重复使用。 使用SPBasicSuite::AcquireSuite()常量kAIArtStyleSuite和使用获取此套件kAIArtStyleVersion。 方法 AIAPI AIErr（* GetStyledArt）（AIArtHandle art，AIArtHandle * styledArt） 获得art对象的样式。 返回 styleArt [out]用于返回样式化art对象的缓冲区，如果没有应用特殊样式，则返回原始art对象。NULL出错时返回; 例如，如果由于内存限制而无法执行动态效果。 AIAPI AIErr（* GetArtStyle）（AIArtHandle art，AIArtStyleHandle * artStyle） 获得与art对象关联的art风格。 AIAPI AIErr（* GetCurrentArtStyle）（AIArtStyleHandle * artStyle，AIBoolean * mixedState） 获得“外观”调板中当前显示的art样式。 artStyle [out]用于返回art风格参考的缓冲区。 mixedState [out]如果Appearance调色板显示“Mixed”，则返回true的缓冲区。在这种情况下，返回的art风格是一种简单的风格，它试图收集附加到当前文档中当前所选对象的art风格的公共属性。 AIAPI AIErr（* GetArtStyleByName）（AIArtStyleHandle * artStyle，const ai :: UnicodeString＆name，AIBoolean searchAllStyles） 从当前文档中按唯一名称获得art样式。 AIAPI AIErr（* CountNamedArtStyles）（ai :: int32 * count） 获取“图形样式”调板中当前列出的art样式的数量。 AIAPI AIErr（* GetNthNamedArtStyle）（ai :: int32 n，AIArtStyleHandle * artStyle） 按索引获得命名的art样式。 AIAPI AIErr（* SetArtStyle）（AIArtHandle art，AIArtStyleHandle artStyle） 将art样式应用于ar品。 AIAPI AIErr（* SetCurrentArtStyle）（AIArtStyleHandle artStyle） 将art样式应用于画板上当前目标对象。 AIAPI AIErr（* GetArtStyleName）（AIArtStyleHandle artStyle，ai :: UnicodeString＆name，AIBoolean * isAnonymous） 获得art样式的唯一名称。 AIAPI AIErr（* SetArtStyleName）（AIArtStyleHandle artStyle，const ai :: UnicodeString＆name） 设置命名art样式的唯一名称; 也就是说，在“图形样式”调板中显示的那个。 AIAPI AIErr（* GetPaintAttributes）（AIArtStyleHandle artStyle，AIPathStyle * aiPathStyle，AIArtStylePaintData * paintData） 获得art样式的绘画信息。 AIAPI AIErr（* NewStyle）（AIPathStyle * aiPathStyle，AIArtStylePaintData * paintData，AIDictionaryRef blendDict，AIArtStyleHandle * newStyle） 创造一种新的art风格。 AIAPI AIErr（* AddNamedStyle）（AIArtStyleHandle artStyle，const ai :: UnicodeString＆name，AIBoolean uniquify，AIArtStyleHandle * namedStyle） 将匿名样式转换为命名样式，该样式显示在“图形样式”调板中。 AIAPI AIErr（* RemoveNamedStyle）（AIArtStyleHandle namedStyle，AIArtStyleHandle * anonStyle） 将命名样式（在“图形样式”调板中显示）转换为匿名样式， AIAPI AIErr（* CreateAnonymousStyle）（AIArtStyleHandle namedStyle，AIArtStyleHandle * anonStyle） 创建命名art样式的匿名副本（显示在“图形样式”调板中）。 AIAPI AIErr（* RedefineNamedStyle）（AIArtStyleHandle namedStyle，AIArtStyleHandle dstStyle） 重新定义命名的art样式以具有与另一样式相同的特征。 AIAPI AIErr（* MoveNamedStyle）（AIArtStyleHandle namedStyle，ai :: int32 index） 将命名的art样式移动到“图形样式”调板中的位置。 AIAPI AIErr（* GetArtStyleByNameFromDocument）（AIArtStyleHandle * artStyle，const ai :: UnicodeString＆name，AIDocumentHandle document） 通过指定文档中的唯一名称获得命名的art样式。 AIAPI AIErr（* CountNamedArtStylesFromDocument）（ai :: int32 * count，AIDocumentHandle document） 获取指定文档中命名的art样式的数量（当该文档是最新的时，在“图形样式”调板中显示的样式）。 AIAPI AIErr（* GetNthNamedArtStyleFromDocument）（ai :: int32 n，AIArtStyleHandle * artStyle，AIDocumentHandle document） 按索引获得指定文档的命名art样式。 AIAPI AIErr（* 当量）（AIArtStyleHandle artStyle1，AIArtStyleHandle artStyle2，AIBoolean *结果） 测试两种art风格之间的等价性。 AIAPI AIErr（* SortNamedStyles）（void） 按名称按字母顺序对当前文档中的命名art样式进行排序。 AIAPI AIErr（* GetDefaultArtStyle）（AIArtStyleHandle * artStyle） 获得当前文档的默认art样式，该样式始终首先列在“图形样式”调板中。 AIAPI AIErr（* GetDefaultArtStyleName）（ai :: UnicodeString＆name） 获得当前文档的默认art样式的名称，该名称始终首先列在“图形样式”调板中。 AIAPI AIBoolean（* ValidateArtStyle）（AIArtStyleHandle artStyle） 报告当前文档中是否存在artstyle。 AIAPI AIErr（* FlattenStyle）（AIArtHandle art） 扩展art的风格，将art品替换为可返回的GetStyledArt()。 AIAPI AIErr（* GetArtStyleType）（AIArtStyleHandle artStyle，ai :: int16 * type） 获得art风格的类型。 AIAPI AIBoolean（* CanExecute）（AIArtStyleHandle artStyle） 报告art风格是否包含执行所需的所有部分。 AIAPI AIReal（* GetArtStyleScaleFactor）（AIArtHandle art） 返回art对象样式的比例因子。 “缩放笔触和效果”选项允许缩放笔画粗细和附加到art对象的效果。缩放因子与art对象一起存储，并且在应用样式后应用。例如，如果附加到对象的样式具有权重为2 pt的笔划，并且对象的比例因子为2.5，则视觉笔触权重为5 pt。 注意： GetPaintAttributes()获取未缩放的参数值，以及来自的函数AIArtStyleParserSuite。 但是，AIPathStyleSuite调用返回附加到对象的缩放笔画粗细。 参数：art 返回： 比例因子。 AIAPI AIErr（* SetArtStyleScaleFactor）（AIArtHandle art，AIReal scaleFactor） 设置art对象样式的比例因子。 AIAPI AIErr（* ResetArtStyleScaleFactor）（AIArtHandle art） 将新样式应用于按对象的当前比例因子缩放的art对象，并将对象的比例因子重置为1。 AIAPI AIErr（* TransformObjectArtStyle）（AIArtHandle art，AIRealMatrix * matrix，AIReal lineScale，ai :: int32 flags） 改变对象的art风格。 参数： art 需要变换的art对象 matrix 指向转换矩阵的指针。 lineScale 要应用于art对象当前样式中指定的线条绘制样式值的比例因子。 flags 控制转换执行方式的位标志。AITransformArtOptions值的逻辑OR 。如果kTransformObjects标志打开，则假设art对象本身也已经被相同的矩阵变换，并且已经执行了点，后代art等的任何变换。这允许立即调整梯度向量和依赖于对象边界的其他样式属性，而不是延迟到art同步。 AIAPI AIArtStyleHasAttrs（* ExamineStyle）（AIArtStyleHandle artStyle，AIArtStyleHasAttrs checkFor） 检查特定属性的art风格，并返回找到的属性。 AIAPI AIErr（* GetToolArtStyle）（AIArtStyleHandle * artStyle） 根据应用程序首选项获得将用于工具创建的新art的artstyle。 AIAPI AIErr（* GetFlattenedArt）（AIArtHandle art，AIArtHandle * flattenedArt） 扩展ar的风格，将art替换为可返回的art GetStyledArt()。 AIAPI AIBoolean（* HasEffectiveNullStyle）（AIArtHandle art） 报告art对象是否具有等效于null样式的样式。 AIAPI AIErr（* GetPaintMap）（AIArtStyleHandle artStyle，AIPathStyleMap * aiPathStyleMap） 获得art样式的路径样式的地图，如下所示GetPaintAttributes()。 相关类，结构体，指针AIArtHandle123typedef struct ArtObject* AIArtHandleOpaque reference to an art object.Access using AIArtSuite. AIArtStyleHandle1234typedef struct _t_AIArtStyle* AIArtStyleHandleA reference to an art style.See also:AIArtStyleSuite. AIPathStyle描述如何绘制路径的填充和描边。 完整样式完全指定绘画信息。一个部分款式可以指定的绘画信息的子集。例如，它可用于表示选择的常见绘制属性，或修改属性的子集而不影响其他属性。在这种情况下，路径样式与样式映射配对，AIPathStyleMap指定具有有效值的属性子集。注意不要将部分样式传递给需要完整样式的函数; 未指定的字段可以包含无效值。 AIBoolean fillPaint Whether or not to fill the path. AIBoolean strokePaint Whether or not to stroke the path. struct AIFillStyle fill Fill style, if fillPaint is true. struct AIStrokeStyle stroke Stroke style, if strokePaint is true. AIBoolean clip AIBoolean lockClip AIBoolean evenodd When true, use the even-odd rule to determine path insideness. AIReal resolution Path’s resolution. AIStrokeStyle AIColor color Stroke color. AIBoolean overprint Overprint - not meaningful if the color is a pattern. AIReal width Line width in points. struct AIDashStyle dash Stroke dash. enum AILineCap cap Line cap. 12345678910Types of line caps for strokes. Enumerator: kAIButtCap Butt line caps.//平头 kAIRoundCap Round line caps.//圆头 kAIProjectingCap Projecting line caps.//方头 enum AILineJoin join Line join 12345678Types of line joins for strokes.Enumerator:kAIMiterJoin Miter line joins.//斜接连接kAIRoundJoin Round line joins.//圆角连接 AIReal miterLimit Line miter limit. AIFillStyle AIColor color Fill color. AIBoolean overprint When true, print any art beneath this, then print the fill of this object over it. 使用实例123456789101112131415161718192021222324252627282930313233343536373839bool isArtStyle=true;//是否使用图形样式库设置样式if (isArtStyle)&#123; AIArtStyleHandle artStyle=NULL; sAIArtStyle-&gt;GetArtStyleByName(&amp;artStyle, ai::UnicodeString(artStyleName), 1); if (!artStyle)&#123; sAIArt-&gt;DisposeArt(art); return -1; &#125; sAIArtStyle-&gt;SetArtStyle(art, artStyle);&#125;else&#123; AIColor color; AIColor colorFill; float CMYK[4] = &#123;23,211,22,56&#125;; float CMYKFill[4] = &#123;23,223,12,53&#125;; // 描边颜色 color.kind = kFourColor; color.c.f.cyan = CMYK[0]; color.c.f.magenta = CMYK[1]; color.c.f.yellow = CMYK[2]; color.c.f.black = CMYK[3]; //内部填充颜色 colorFill.kind = kFourColor; colorFill.c.f.cyan = CMYKFill[0]; colorFill.c.f.magenta = CMYKFill[1]; colorFill.c.f.yellow = CMYKFill[2]; colorFill.c.f.black = CMYKFill[3]; AIPathStyle PathStyle; PathStyle.fillPaint = true; // 面内颜色填充 设置为true 否则无法在面内填充颜色 PathStyle.strokePaint = true; PathStyle.stroke.width = 0.5; PathStyle.stroke.color = color; PathStyle.fill.color = colorFill; // 内部填充 sAIPathStyle-&gt;SetPathStyle(art, &amp;PathStyle); //设置透明度 sAIBlendStyle-&gt;SetOpacity(art, 0.4);&#125; 相关文章AI组件开发（一）–注记旋转矩阵AI组件开发（二）–AIRealMathSuiteAI组件开发（三）–AIArtboardSuiteAI组件开发（四）–AIDocumentSuiteAI组件开发（五）–AILayerSuiteAI组件开发（六）–AIArtSuiteAI组件开发（七）–AIPathSuite&amp;&amp;AIPathfinderSuiteAI组件开发（八）–AIArtStyleSuite","tags":[]},{"title":"AI组件开发（七）--AIPathSuite&&AIPathfinderSuite","date":"2019-03-25T01:11:13.000Z","path":"2019/03/25/ai-seven-path-note/","text":"AIPathSuite提供的功能允许检查和操作路径,AIPathfinderSuite提供了对路径执行操作的功能，这些功能将各种效果应用于选定的路径图Table of Contents generated with DocToc AIPathSuite 注册声明 方法 AIPathSegment 使用实例 AIPathfinderSuite 注册声明 方法 相关类，结构体，指针 AIPathfinderData AIOptions AIParameters AIMixParameters AITrapParameters AIFilterMessage SPMessageData AIFilterHandle PlatformFilterParameters AIPathSuite此套件提供的功能允许您检查和操作路径，这些路径是art类型的对象kPathArt。 路径的形状由一个或多个路径段定义。路径的每一个段对应于一个锚点，它是在选择路径时显示的手柄。路径上的锚点数或段 数包括每端的两个。段由AIPathSegment结构定义。段索引号从零开始。路径可以有一个锚点。 段的入点和出点定义点p处的曲线的切线。中间点不用于开放路径的初始段和最终段。段可以是角点或平滑点。对于一个角落，进出点可以在任何地方。要形成一条直线，请将每个端点的入点和出点放在它们的p点上。 路径可以是关闭的或打开的。如果路径是打开的，则仅由其段定义。如果它已关闭，Illustrator将在第一个和最后一个锚点之间绘制一个段，该段使用最后一个段的out切线和第一个段的切线。 一些路径也用作指南。在所有其他方面，它们是具有相同内容和属性的路径。绘制属性与通过路径 样式的路径相关联。见AIPathStyleSuite。 使用SPBasicSuite::AcquireSuite()常量kAIPathSuite和使用获取此套件kAIPathVersion。 注册声明123456789101112131415//xxxSuites.h#include &quot;Suites.hpp&quot;#include &quot;AIArtConverter.h&quot;extern &quot;C&quot; AIPathSuite* sAIPath;//xxxSuites.cppextern &quot;C&quot;&#123; AIPathSuite* sAIPath=NULL;&#125;ImportSuite gImportSuites[] = &#123; IMPORT_TEXT_SUITES kAIPathSuite,kAIPathSuiteVersion,&amp;sAIPath, nil, 0, nil &#125;; 方法 AIAPI AIErr（* GetPathSegmentCount）（AIArtHandle path，ai :: int16 * count） 获取路径上的锚点数，包括每端的两个锚点。 AIAPI AIErr（* SetPathSegmentCount）（AIArtHandle path，ai :: int16 count） 从段中删除段或将段附加到路径末尾。 AIAPI AIErr（* GetPathSegments）（AIArtHandle path，ai :: int16 segNumber，ai :: int16 count，AIPathSegment segments []） 从路径中检索一组段。 AIAPI AIErr（* SetPathSegments）（AIArtHandle path，ai :: int16 segNumber，ai :: int16 count，const AIPathSegment segments []） 添加或更新路径中的段。 AIAPI AIErr（* InsertPathSegments）（AIArtHandle path，ai :: int16 segNumber，ai :: int16 count，const AIPathSegment segments []） 将段插入路径。 AIAPI AIErr（* DeletePathSegments）（AIArtHandle path，ai :: int16 segNumber，ai :: int16 count） 从路径中删除段。 AIAPI AIErr（* GetPathClosed）（AIArtHandle path，AIBoolean *closed） 报告路径是否已关闭。 AIAPI AIErr（* SetPathClosed）（AIArtHandle path，AIBoolean closed） 打开或关闭路径。 AIAPI AIErr（* GetPathGuide）（AIArtHandle path，AIBoolean * isGuide） 报告路径是否用作指南。 AIAPI AIErr（* SetPathGuide）（AIArtHandle path，AIBoolean isGuide） 设置是否将路径用作指南。 AIAPI AIErr（* GetPathSegmentSelected）（AIArtHandle path，ai :: int16 segNumber，ai :: int16 *selected） 报告是否选择了路径段的任何部分。 AIAPI AIErr（* SetPathSegmentSelected）（选择AIArtHandle path，ai :: int16 segNumber，ai :: int16 selected） 设置段的选择状态。 AIAPI AIErr（* ReversePathSegments）（AIArtHandle path） 反转路径中段的顺序。 AIAPI AIErr（* GetPathArea）（AIArtHandle path，AIReal *area） 计算路径的面积。 AIAPI AIErr（* GetPathLength）（AIArtHandle path，AIReal *length，AIReal flatness） 计算以点为单位测量的路径周长。 AIAPI AIErr（* GetPathBezier）（AIArtHandle path，ai :: int16 segNumber，AIRealBezier * bezier） 计算路径段的贝塞尔曲线值。 AIAPI AIErr（* PathHasLength）（AIArtHandle path，AIBoolean * hasLength） 报告路径是否有长度。 AIAPI AIErr（* GetPathIsClip）（AIArtHandle path，AIBoolean * isClip） 报告路径是否为剪切路径。 AIAPI AIErr（* GetPathAllSegmentsSelected）（AIArtHandle path，选择AIBoolean *） 报告是否选择了路径的所有段。 AIAPI AIErr（* GetKeySegment）（AIArtHandle * path，ai :: int16 * segmentNumber） 检索关键锚点的路径对象和段号（即，其他锚点对齐的那个）。 AIAPI AIErr（* CancelKeySegment）（void） AIAPI AIBoolean（* IsPath9SliceSplitter）（AIArtHandle path） 报告路径是否为9切片分割器; 也就是说，该指南定义了将艺术板分成9个区域的线。 AIAPI AIErr（* SetKeySegment）（AIArtHandle path，ai :: int16 segmentNumber） 设置艺术对象的关键锚点。 AIAPI AIErr（* MeasureSegments）（AIArtHandle path，ai :: int16 startSeg，ai :: int16 count，AIReal pieceLengths []，AIReal accumulationLengths []） 测量路径段的长度。 AIAPI AIErr（* LengthFractionToBezierPos）（AIArtHandle path，AIReal lengthFraction，ai :: int16＆segIndex，AIReal＆bezierT，const AIReal pieceLengths []，const AIReal accumulationLengths []） 计算作为沿路径的路径长度的给定分数的点的段索引和参数贝塞尔t值。 AIAPI AIErr（* BezierPosToLengthFraction）（AIArtHandle path，ai :: int16 segIndex，AIReal bezierT，AIReal＆lengthFraction，const AIReal pieceLengths []，const AIReal accumulationLengths []） 计算对应于沿路径的位置的总路径长度的分数，该路径表示为段索引，并且将参数贝塞尔t值表示到该段中。 AIAPI AIErr（* BezierPosToAnchoredPos）（AIArtHandle path，ai :: int16 segIndex，AIReal t，AIReal * segLength，AIReal * segLengthFraction） 从参数贝塞尔曲线t值转换为线段长度的一部分。 AIAPI AIErr（* PerpendicularsAtBezierT）（AIArtHandle path，ai :: int16 segIndex，AIReal t，AIReal leftDistance，AIReal rightDistance，AIRealPoint＆pointOnPath，AIRealPoint * leftPoint，AIRealPoint * rightPoint） 计算与表示为段索引和参数贝塞尔t值的位置处的路径垂直（正常）的线段的端点 AIPathSegmentContents Suites Classes Class Index Member IndexAIPathSegment Struct ReferenceDefines a path segment. More… #include &lt;AIPath.h&gt; List of all members. Public AttributesAIRealPoint pAIRealPoint inAIRealPoint outAIBoolean corner 使用实例12345678910111213141516171819202122232425//SetPathSegmentCountlong curCount=10;//定义环面点数AIArtHandle artGroup = NULL;sAIArt-&gt;GetFirstArtOfLayer(PolygonLayer, &amp;artGroup);AIArtHandle art = NULL;sAIArt-&gt;NewArt(kPathArt, kPlaceInsideOnTop, artGroup, &amp;art);sAIPath-&gt;SetPathSegmentCount(art, (short)curCount);AIPathSegment *segment = new AIPathSegment[curCount];AIRealPoint *AIPoint = new AIRealPoint[curCount];...//赋值操作for (int i = 0; i &lt; curCount; i++)&#123; segment[i].p.h = AIPoint[i].h; segment[i].p.v = AIPoint[i].v; segment[i].in = segment[i].out = segment[i].p; segment[i].corner = true;&#125;//SetPathSegmentssAIPath-&gt;SetPathSegments(art, 0, curCount, segment);delete[] segment;delete[] AIPoint;//SetPathClosedsAIPath-&gt;SetPathClosed(art, 1);arts.push_back(art); AIPathfinderSuite该套件提供了对路径（类型的艺术对象kPathArt）执行操作的功能，这些功能将各种效果应用于选定的路径图。这些操作与“路径查找器”调板和“效果”菜单中的操作相对应。附加功能允许操作复合 形状，可以应用效果的插件组。见AIPluginGroupSuite。在复合形状组中，绘制组中的底部对象，然后根据交互模式（AIShapeMode）由其上方的下一个对象进行修改。可以将每个后续对象添加到图形中，从图形中减去，相交或从图形中排除。 使用SPBasicSuite::AcquireSuite()常量kAIPathfinderSuite和使用获取此套件kAIPathfinderVersion。 注册声明123456789101112131415//xxxSuites.h#include &quot;Suites.hpp&quot;#include &quot;AIPathfinder.h&quot;extern &quot;C&quot; AIPathfinderSuite* sAIPathfinder;//xxxSuites.cppextern &quot;C&quot;&#123; AIPathfinderSuite* sAIPathfinder=NULL;&#125;ImportSuite gImportSuites[] = &#123; IMPORT_TEXT_SUITES kAIPathfinderSuite,kAIPathfinderSuiteVersion,&amp;sAIPathfinder, nil, 0, nil &#125;; 方法 AIAPI AIErr（* DoUniteEffect）（AIPathfinderData *data，AIFilterMessage *message） 对选定的艺术应用Unite效果。 AIAPI AIErr（* DoIntersectEffect）（AIPathfinderData * data，AIFilterMessage * message） 将相交效果应用于选定的art。 AIAPI AIErr（* DoExcludeEffect）（AIPathfinderData *data，AIFilterMessage *message） 对所选art应用排除效果。 AIAPI AIErr（* DoBackMinusFrontEffect）（AIPathfinderData * data，AIFilterMessage * message） 对选定的art应用前后减去效果。 AIAPI AIErr（* DoFrontMinusBackEffect）（AIPathfinderData *data，AIFilterMessage *message） 对选定的art应用前后减去效果。 AIAPI AIErr（* DoDivideEffect）（AIPathfinderData *data，AIFilterMessage *message） 对所选art应用分割效果。 AIAPI AIErr（* DoOutlineEffect）（AIPathfinderData * data，AIFilterMessage * message） 将轮廓效果应用于选定的art。 AIAPI AIErr（* DoTrimEffect）（AIPathfinderData *data，AIFilterMessage *message） 对所选art应用修剪效果。 AIAPI AIErr（* DoMergeEffect）（AIPathfinderData *data，AIFilterMessage *message） 对选定的art应用合并效果。 AIAPI AIErr（* DoCropEffect）（AIPathfinderData *data，AIFilterMessage *message） 将裁剪效果应用于选定的art。 AIAPI AIErr（* DoHardEffect）（AIPathfinderData *data，AIFilterMessage *message） 对选定的art应用硬效果。 AIAPI AIErr（* DoSoftEffect）（AIPathfinderData *data，AIFilterMessage *message） 对选定的art应用柔和效果。 AIAPI AIErr（* DoTrapEffect）（AIPathfinderData *data，AIFilterMessage *message） 对选定的art应用陷印效果。 AIAPI AIErr（* GetHardEffectParameters）（AIPathfinderData *data，AIFilterMessage *message） 获得硬效果路径查找器操作的参数。 AIAPI AIErr（* GetSoftEffectParameters）（AIPathfinderData *data，AIFilterMessage *message） 获得Soft效果路径查找器操作的参数。 AIAPI AIErr（* GetTrapEffectParameters）（AIPathfinderData * data，AIFilterMessage * message） 获得陷阱效果路径查找器操作的参数。 AIAPI AIErr（* GetGlobalOptions）（AIPathfinderData *data，AIFilterMessage *message） 获得“路径查找器”和“效果”操作的全局选项。AIAPI AIShapeMode（* GetShapeMode）（AIArtHandle art） 获得art插件组对象的复合形状模式。 AIAPI AIErr（* SetShapeMode）（AIArtHandle art，AIShapeMode mode） 设置art插件组对象的复合形状模式。 AIAPI AIErr（* NewCompoundShape）（ai :: int16 paintOrder，AIArtHandle prep，AIArtHandle * newArt） 在当前文档的art树的绘制顺序中的指定位置创建新的空复合形状。 AIAPI AIErr（* IsCompoundShape）（AIArtHandle art，AIBoolean * isCompoundShape） 报告art品是否为复合形状。 AIAPI AIErr（* FlattenArt）（AIArtHandle * inOutArt） 通过将Unite效果应用于每个组件art对象，将形状扩展为单个路径或复合路径。 相关类，结构体，指针AIPathfinderDataAIOptions options Options that control how pathfinder operations are performed.AIParameters parameters Parameters for mixing and trapping operations.AIArtHandle * fSelectedArt A pointer to an array of selected art objects on which to perform the operation.ai::int32 fSelectedArtCount The number of members of the fSelectedArt array.ai::int32 fAlertInfoID Not used. AIOptions控制路径查找器操作执行方式的选项。double ipmPrecision Pathfinding precision, in microns.ai::int32 removeRedundantPoints Nonzero to remove redundant points.ai::int32 flags Option flags, a logical OR of AIOptionsFlagValues. AIOptionsFlagValues kExtractUnpaintedArtwork设置后，从处理结果中删除未配色的图稿。 kAllowEmptyOutput当设置时，这些功能可以产生空的输出：AIPathfinderSuite::DoBackMinusFrontEffect()，AIPathfinderSuite::DoFrontMinusBackEffect()，AIPathfinderSuite::DoIntersectEffect()，AIPathfinderSuite::DoExcludeEffect()。 kIgnoreEvenOddFillRule设置时，假设所有路径都使用非零填充规则而不是偶数填充规则。 kSuppressProgressDialog设置后，在路径查找器操作期间禁止进度报告。适用于AI 13及更高版本。 kDeselectResultArts设置后，将取消选择结果对象。适用于AI 13及更高版本。 AIParameters混合和捕获参数AIMixParameters mixParameters Parameters for mixing operations.AITrapParameters trapParameters Parameters for trapping operations. AIMixParametersdouble softRate The percentage of visibility in overlapping colors.ai::int32 convertCustomColors Nonzero to convert custom colors when mixing. AITrapParameters这些对应于Pathfinder调色板的Trap对话框中提供的UI值; 有关说明，请参阅用户文档double trapThickness Trap thickness, in points.double heightWidthAspectRatio Height to width aspect ratio.double trapTint Tint.double maximumTint Maximum tint (default is recommended).double tintTolerance Tint tolerance (default is recommended).ai::int32 reverseTrap Nonzero to reverse trap.ai::int32 convertCustomColors Nonzero to convert custom colors. AIFilterMessage过滤器获取参数或Go选择器的消息。SPMessageData d The message data.AIFilterHandle filter The filter object.PlatformFilterParameters parameters The parameter values, in a developer-defined parameter structure. SPMessageDataai::int32 SPCheck kSPValidSPMessageData if this is a valid PICA message.struct SPPlugin * self This plug-in, an SPPluginRef.void * globals An array of application-wide global variables.struct SPBasicSuite * basic A pointer to the basic PICA suite, which you use to obtain all other suites. AIFilterHandletypedef struct _t_AIFilterOpaque * AIFilterHandle Opaque reference to a filter. PlatformFilterParameters使用实例123456789101112131415161718192021//arts已定义好的art对象数组list&lt;AIArtHandle&gt;::iterator artIT = arts.begin(); if (artCount &gt; 1)&#123; AIArtHandle* artArr = (AIArtHandle *)(malloc(sizeof(AIArtHandle)*artCount)); for (int i = 0; i &lt; artCount; i++)&#123; artArr[i] = *artIT; artIT++; &#125; AIFilterMessage message; AIPathfinderData findData; findData.fSelectedArt = artArr; findData.fSelectedArtCount = artCount; AIOptions option; option.ipmPrecision = 100; option.flags = kExtractUnpaintedArtwork; option.removeRedundantPoints = 1; findData.options = option; //应用排除效果 sAIPathfinder-&gt;DoExcludeEffect(&amp;findData, &amp;message); delete[] artArr; &#125; 相关文章AI组件开发（一）–注记旋转矩阵AI组件开发（二）–AIRealMathSuiteAI组件开发（三）–AIArtboardSuiteAI组件开发（四）–AIDocumentSuiteAI组件开发（五）–AILayerSuiteAI组件开发（六）–AIArtSuiteAI组件开发（七）–AIPathSuite&amp;&amp;AIPathfinderSuiteAI组件开发（八）–AIArtStyleSuite","tags":[{"name":"AI","slug":"AI","permalink":"http://11wy11.github.io/tags/AI/"}]},{"title":"AI组件开发（六）--AIArtSuite","date":"2019-03-24T13:43:22.000Z","path":"2019/03/24/ai-six-aiart-note/","text":"Adobe Illustrator 文档中绘制的所有图形均为Art，相关操作函数在AIArtSuite中定义 AIArtSuite此套件允许您访问和修改Illustrator文档中的图稿。 它提供了创建和删除对象，重新排列对象以及获取和设置对象信息的功能。您可以使用这些函数来导航图形对象树，以及获得或修改有关图形对象的一般信息，例如它们的边界或锁定状态。 Art套件是实现大多数插件的基础。Illustrator文档由一个由a引用的图形对象的集合组成AIArtHandle。这是指向文档图稿数据库中图形对象的不透明指针。通过Art suite的访问器功能访问这些字段。 艺术对象可以表示单个实体，诸如路径，文本块或放置的图像，或一组对象，诸如路径的集合。艺术类型标识符（AIArtType）表示艺术品的类型。 使用SPBasicSuite::AcquireSuite()常量kAIArtSuite和使用获取此套件kAIArtVersion。 注册声明123456789101112131415//xxxSuites.h#include &quot;Suites.hpp&quot;#include &quot;AIArtConverter.h&quot;extern &quot;C&quot; AAIArtSuite* sAIArt ;//xxxSuites.cppextern &quot;C&quot;&#123;AIArtSuite* sAIArt = NULL;&#125;ImportSuite gImportSuites[] = &#123; IMPORT_TEXT_SUITES kAIArtSuite, kAIArtSuiteVersion, &amp;sAIArt, nil, 0, nil &#125;; 方法 AIAPI AIErr（* NewArt）（ai :: int16类型，ai :: int16 paintOrder，AIArtHandle prep，AIArtHandle * newArt） 创建一个新的Art对象。 AIAPI AIErr（* DisposeArt）（AIArtHandle Art） 从文档中删除Art对象。 AIAPI AIErr（* ReorderArt）（AIArtHandle thisArt，ai :: int16 paintOrder，AIArtHandle prep） 更改Art对象的绘制顺序，或将路径移入或移出复合路径或组。 AIAPI AIErr（* DuplicateArt）（AIArtHandle thisArt，ai :: int16 paintOrder，AIArtHandle prep，AIArtHandle * newArt） 使用深层复制复制Art对象（组和复合路径的子项也是重复的）。 AIAPI AIErr（* GetFirstArtOfLayer）（AILayerHandle图层，AIArtHandle *Art） 获得图层中的第一个Art对象，该图层包含该图层中的所有Art。 AIAPI AIErr（* GetLayerOfArt）（AIArtHandle art，AILayerHandle *layer） 获得Art对象的父图层（如果有）。 AIAPI AIErr（* GetArtType）（AIArtHandle art，short * type） 获得Art对象的类型。 AIAPI AIErr（* GetArtUserAttr）（AIArtHandle art，ai :: int32 whichAttr，ai :: int32 * attr） 获得Art对象的用户属性; 也就是说，标志显示它是被选中，隐藏还是被锁定。 AIAPI AIErr（* SetArtUserAttr）（AIArtHandle art，ai :: int32 whichAttr，ai :: int32 attr） 设置对象的用户属性; 也就是说，标志显示它是被选中，隐藏还是被锁定。 AIAPI AIErr（* GetArtParent）（AIArtHandle art，AIArtHandle *parent） 获得Art对象的父组。 AIAPI AIErr（* GetArtFirstChild）（AIArtHandle art，AIArtHandle *child） 获得组对象的第一个子对象。 AIAPI AIErr（* GetArtSibling）（AIArtHandle art，AIArtHandle *sibling） 获得同一组中的下一个对象。 AIAPI AIErr（* GetArtPriorSibling）（AIArtHandle art，AIArtHandle *sibling） 获得同一组中的上一个对象。 AIAPI AIErr（* GetArtBounds）（AIArtHandle art，AIRealRect * bounds） 获得Art对象的包围矩形。 AIAPI AIErr（* SetArtBounds）（AIArtHandle art） 更新Art对象的封闭矩形（边界框）的缓存信息。 AIAPI AIErr（* GetArtCenterPointVisible）（AIArtHandle art，AIBoolean *visible） 检查Art品的中心点是否可见。 AIAPI AIErr（* SetArtCenterPointVisible）（AIArtHandle art，AIBoolean visible） 选择对象时，可以使Art品的中心点可见或不可见。 AIAPI AIErr（* GetArtTransformBounds）（AIArtHandle art，AIRealMatrix * transform，ai :: int32 flags，AIRealRect * bounds） 应用变换矩阵后，获得Art对象的几何边界。 AIAPI AIErr（* UpdateArtworkLink）（AIArtHandle art，AIBoolean force，AIBoolean *updated） 检查给定容器的子树中包含的任何链接对象（链接图像或放置对象）是否需要更新，并在需要时更新它们。 AIAPI AIBoolean（* ValidArt）（AIArtHandle art，AIBoolean searchAllLayerLists） 如果Art对象引用有效，则返回true。 AIAPI AIErr（* GetArtOrder）（AIArtHandle art1，AIArtHandle art2，short * order） 获取两个Art品的绘画顺序或遏制关系。 AIAPI AIErr（* SelectNamedArtOfLayer）（AILayerHandle图层，const ai :: UnicodeString＆name，AIBoolean matchWholeWord，AIBoolean caseSensitive） 通过将字符串与Art对象注释的内容进行匹配来选择图层的指定图稿。 AIAPI AIErr（* GetArtRotatedBounds）（AIArtHandle art，AIReal angle，ai :: int32 flags，AIRealRect * bounds） 旋转后获得Art对象的包围矩形。 AIAPI AIBoolean（* ArtHasFill）（AIArtHandle art） 如果Art对象或后代对象绘制应被视为填充的内容，则返回true。 AIAPI AIBoolean（* ArtHasStroke）（AIArtHandle art） 如果Art对象或后代对象绘制应被视为笔划的内容，则返回true。 AIAPI AIBoolean（* ArtsHaveEqualPaths）（AIArtHandle art1，AIArtHandle art2） 如果两个Art对象除了组，路径和复合路径之外只包含其他内容，并且它们具有相同的几何（控制点），则返回true。 AIAPI AIErr（* ArtCopyFillStyleIfEqualPaths）（AIArtHandle dstArt，AIArtHandle srcArt） 未在AI11及更高版本中实施; 回报kNotImplementedErr。 AIAPI AIErr（* ArtCopyStrokeStyleIfEqualPaths）（AIArtHandle dstArt，AIArtHandle srcArt） 未在AI11及更高版本中实施; 回报kNotImplementedErr。 AIAPI AIErr（* GetInsertionPoint）（AIArtHandle * art，short * paintorder，AIBoolean * editable） 获得文档的插入点。 AIAPI AIErr（* SetInsertionPoint）（AIArtHandle art） 设置文档的插入点。 AIAPI AIErr（* GetKeyArt）（AIArtHandle *Art） 获得对象对齐的关键对象。 AIAPI AIErr（* CancelKeyArt）（无效） 清除对象对齐的关键对象。 AIAPI AIErr（* GetDictionary）（AIArtHandle art，struct _AIDictionary ** dictionary） 获得与Art对象关联的字典。 AIAPI AIErr（* SetArtName）（AIArtHandle art，const ai :: UnicodeString＆name） 设置Art对象的名称。 AIAPI AIErr（* GetArtName）（AIArtHandle art，ai :: UnicodeString＆name，ASBoolean * isDefaultName） 获得Art对象的名称。 AIAPI AIErr（* IsArtLayerGroup）（AIArtHandle art，ASBoolean * isLayerGroup） 报告Art对象是否是与图层或子图层对应的组。 AIAPI AIErr（* ReleaseToLayers）（常量AIArtHandle技术中，ASBoolean版本） 将图层，组或插件组的元素释放到单独的图层。 AIAPI AIErr（* ModifyTargetedArtSet）（AIArtHandle * list，ai :: int32 count，ai :: int32 action） 使用指定的操作修改文档中的目标对象集。 AIAPI AIBoolean（* IsArtStyledArt）（AIArtHandle art） 如果art是另一个对象的样式Art的一部分，则返回true。 AIAPI AIBoolean（* IsArtClipping）（AIArtHandle art） 如果art添加到剪辑，则返回true 。 AIAPI AIErr（* TransferAttributes）（AIArtHandle srcart，AIArtHandle dstart，ai :: uint32 which） 将源Art对象的属性传输到目标Art对象。 AIAPI AIErr（* GetArtLastChild）（AIArtHandle art，AIArtHandle *child） 获得容器Art对象的最后一个子项。 AIAPI AIErr（* SetArtTextWrapProperty）（AIArtHandle art，AIReal offset，AIBoolean invert） 设置影响文本环绕文本换行对象的方式的属性; 也就是说，kArtIsTextWrap设置属性的那个。 AIAPI AIErr（* GetArtTextWrapProperty）（AIArtHandle art，AIReal * offset，AIBoolean * invert） 获得影响文本环绕文本换行对象的方式的属性; 也就是说，kArtIsTextWrap设置属性的那个。 AIAPI AIErr（* CreateCopyScope）（枚举AICopyScopeKind类，AICopyScopeHandle *范围） 创建并设置复制范围。 AIAPI AIErr（* DestroyCopyScope）（AICopyScopeHandle范围） 取消并销毁复制范围。 AIAPI AIErr（* InsertionPointBadForArtType）（ai :: int16 paintOrder，AIArtHandle prep，ai :: int16 artType） 检查在给定插入点处创建或插入给定类型的Art对象是否可以。 AIAPI AIErr（* PreinsertionFlightCheck）（AIArtHandle candidateArt，ai :: int16 paintOrder，AIArtHandle prep） 根据插入上下文和候选Art的属性，检查是否可以在指定的插入点处插入Art对象或其副本，而无需实际尝试插入。 AIAPI AIErr（* SetNote）（AIArtHandle art，const ai :: UnicodeString＆inNote） 设置Art对象的音符属性，该属性通常包含用户输入的文本。 AIAPI AIErr（* GetNote）（AIArtHandle art，ai :: UnicodeString＆outNote） 获得Art对象的注释属性文本，该文本通常包含用户输入的文本。 AIAPI AIBoolean（* HasNote）（AIArtHandle art） 检查Art品是否附有说明。 AIAPI无效（* 删除注意）（AIArtHandle art） 删除附加到Art对象的注释（如果有）。 AIAPI AIErr（* GetArtXMPSize）（AIArtHandle art，size_t * size） 获取与Art对象关联的XMP元数据的大小。 AIAPI AIErr（* GetArtXMP）（AIArtHandle art，char * xmp，size_t size） 获得与Art对象的XMP元数据关联的XML数据包。 AIAPI AIErr（* SetArtXMP）（AIArtHandle art，const char * xmp） 设置Art对象的XMP元数据，替换任何现有数据。 AIAPI AIErr（* GetPreciseArtTransformBounds）（AIArtHandle art，AIRealMatrix * transform，ai :: int32 flags，AIDoubleRect * bounds） 应用变换矩阵后，获得Art对象的几何边界。 AIAPI AIErr（* UncheckedDisposeArt）（AIArtHandle art） 从Art树中删除Art对象，对输入的有效性进行最低限度检查，以便最大限度地提高性能。 AIAPI AIErr（* ArtIsGraph）（AIArtHandle art，AIBoolean * artisgraph） 报告Art对象是否为图形对象类型。 AIAPI AIErr（* SetKeyArt）（AIArtHandle art） 将Art设置为对象对齐的KeyArt。关键对象是其他对象对齐的对象。 AIAPI AIErr（* GetDrawingMode）（ai :: int32 * mode） 获得当前文档的绘图模式。 AIAPI AIErr（* SetDrawingMode）（ai :: int32模式） 设置当前文档的绘图模式。 AIAPI AIErr（* GetInsertionPointForDrawingMode）（ai :: int32模式，AIArtHandle * art，short * paintorder，AIBoolean * editable） 根据绘图模式获得当前文档的插入点。 AIAPI AIErr（* GetInsertionPointForCurrentDrawingMode）（AIArtHandle * art，short * paintorder，AIBoolean * editable） 根据当前绘图模式获得当前文档的插入点。 AIAPI AIErr（* GetPathPolarity）（AIArtHandle art，ai :: int32 * polarity） 获得Art对象的路径极性。 AIAPI AIBoolean（* IsPixelPerfect）（AIArtHandle art） 报告Art品是否处于像素完美模式。 AIAPI AIErr（* SetPixelPerfect）（AIArtHandle art，AIBoolean isPixelPerfect） 为Art品打开或关闭像素完美模式。 AIAPI AIBoolean（* ObjectsAreEquivalent）（AIArtHandle art1，AIArtHandle art2） 比较两个Art对象以确定它们在几何，外观属性和字典内容中是否等效。通常，一个对象在当前文档中，另一个在另一个文档中。 AIAPI AIErr（* IsArtALayerInSymbol）（AIArtHandle art，AIBoolean * isLayerInSymbol） 报告Art对象是否充当符号模式中的图层。 AIAPI AIErr（* GetArtTimeStamp）（AIArtHandle art，size_t * timeStamp） 获得Art对象的修改时间戳。 paintOrder 枚举常量12345678910111213141516typedef enum AIPaintOrder &#123; /* Default value */ kPlaceDefault = 0, /** Place above the prepositional object */ kPlaceAbove = 1, /** Place below the prepositional object */ kPlaceBelow, /** Place within and at the top of the prepositional container */ kPlaceInsideOnTop, /** Place within and at the bottom of the prepositional container */ kPlaceInsideOnBottom, /** Place at the top of the paint order, ignoring prepositional object */ kPlaceAboveAll, /** Place at the bottom of the paint order, ignoring prepositional object */ kPlaceBelowAll&#125; AIPaintOrder; AIArtHandle1234typedef struct ArtObject* AIArtHandleOpaque reference to an art object.Access using AIArtSuite. 使用实例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495AIArtHandle artGroup = NULL;sAIArt-&gt;GetFirstArtOfLayer(PolygonLayer, &amp;artGroup);AIArtHandle art = NULL;sAIArt-&gt;NewArt(kPathArt, kPlaceInsideOnTop, artGroup, &amp;art);//setNotesAIArt-&gt;SetNote(&quot;该属性通常包含用户输入的文本。需要记录保存的信息，一般，号分割的字符串，不过插件一般使用Dictionary&quot;);//HasNote,GetNoteif (sAIArt-&gt;HasNote(artGroup))&#123; ai::UnicodeString infoNote; sAIArt-&gt;GetNote(artGroup, infoNote); &#125;//DisposeArtsAIArt-&gt;DisposeArt(artGroup);//设置隐藏图层内容不可见 AILayerHandle FirstLayer; AILayerHandle NextLayer = NULL; sAILayer-&gt;GetLayerFirstChild(m_hideLayer,&amp;FirstLayer); while(FirstLayer) &#123; AIArtHandle ArtGroup; AIArtHandle Art; sAIArt-&gt;GetFirstArtOfLayer(FirstLayer,&amp;ArtGroup); sAIArt-&gt;GetArtFirstChild(ArtGroup,&amp;Art); AILayerHandle LayerTemp; LayerTemp = FirstLayer; sAILayer-&gt;GetNextLayer(FirstLayer,&amp;FirstLayer); if(!Art) sAILayer-&gt;DeleteLayer(LayerTemp); &#125; sAILayer-&gt;SetLayerVisible(m_hideLayer, false); AIRealRect artRect; sAIArt-&gt;GetArtBounds(m_pointArt, &amp;artRect); sAIMathSuite-&gt;AIRealMatrixSetTranslate(&amp;maxtrix, ListIter-&gt;h - (artRect.right + artRect.left) / 2, ListIter-&gt;v - (artRect.top + artRect.bottom) / 2); sAITransformArt-&gt;TransformArt(m_pointArt, &amp;maxtrix, 1, kTransformObjects); sAIArt-&gt;SetArtName(m_pointArt, ai::UnicodeString(&quot;XXXX&quot;)); AIArtHandle textPathPoly = NULL; AIArtHandle textFrame;//已存在变量 sAIArt-&gt;DuplicateArt(textFrame, kPlaceBelow,textFrame, &amp;textPathPoly); AIArtHandle textFrameBackgroud;//已存在变量 sAIArt-&gt;ReorderArt(textFrameBackgroud, kPlaceInsideOnTop, ArtGroup); AIArtHandle outlines=NULL; sAITextFrame-&gt;CreateOutline(textFrame, &amp;outlines); AIArtHandle outlinef=NULL,outlinen=NULL; sAIArt-&gt;GetArtFirstChild(outlines, &amp;outlinef); //描边属性 AIPathStyle pathstyle; pathstyle.fillPaint = false; pathstyle.strokePaint = true; AIStrokeStyle strokestyle; strokestyle.width = this-&gt;borderWidth; strokestyle.cap = kAIRoundCap; strokestyle.join = kAIRoundJoin; strokestyle.color = borderColor; pathstyle.stroke = strokestyle; sAIPathStyle-&gt;SetPathStyle(outlinef, &amp;pathstyle); sAIArt-&gt;GetArtSibling(outlinef, &amp;outlinen); while (outlinen) &#123; sAIPathStyle-&gt;SetPathStyle(outlinen, &amp;pathstyle); sAIArt-&gt;GetArtSibling(outlinen, &amp;outlinen); &#125; sAIArt-&gt;DisposeArt(textFrame); //使用GetArtPriorSibling // get the previous art error = sArt-&gt;GetArtPriorSibling(art, &amp;art); if (error) return error; if (!art)&#123; // art was first in group // see if parent has previous art error = sArt-&gt;GetArtParent(art, &amp;art); if (error) return error; ... //使用GetArtParent ,GetArtSibling ... // see if parent has sibling error = sArt-&gt;GetArtParent(nextart, &amp;nextart); if (error) return error; error = sArt-&gt;GetArtSibling(nextart, &amp;nextart); if (error) return error; if (nextart) &#123; // parent has sibling ... &#125; 相关文章AI组件开发（一）–注记旋转矩阵AI组件开发（二）–AIRealMathSuiteAI组件开发（三）–AIArtboardSuiteAI组件开发（四）–AIDocumentSuiteAI组件开发（五）–AILayerSuiteAI组件开发（六）–AIArtSuiteAI组件开发（七）–AIPathSuite&amp;&amp;AIPathfinderSuiteAI组件开发（八）–AIArtStyleSuite","tags":[{"name":"AI","slug":"AI","permalink":"http://11wy11.github.io/tags/AI/"}]},{"title":"AI组件开发（五）--AILayerSuite","date":"2019-03-24T13:09:15.000Z","path":"2019/03/24/ai-fifth-ailayer-note/","text":"文档中的图稿包含在图层中。AILayerSuite有一堆图层列表。堆栈中最顶层的层是当前正在编辑的层 AILayerSuite每个图层都包含一组对象，可以包含子图层。所有文档都至少以一个图层开头，用户或插件可以向其添加任意数量的新图层。图层是图稿树的容器; 用于AIArtSuite::GetFirstArtOfLayer()获取属于图层的Art对象组。 除了包含图稿之外，图层还有一个名称，一种颜色（用于表示选定的art），以及指示其是可见，可编辑还是已锁定，可打印以及是否将放置的Art显示为灰色的状态标志。图层引用是不透明的; 使用此套件中的函数来获取和设置图层属性。 多个图层属性会影响图层上的图稿是否可编辑。通常，不能选择不可编辑图层上的对象，因此无需检查对当前选择进行操作的插件。但是，在迭代图层或图稿时，请GetLayerEditable()在尝试对图稿进行任何更改之前调用每个图层。 可以将图层指定为模板图层，其中包含用于指导文档图稿构造的模板图稿。例如，模板可能包含正在跟踪的图像。永远不会打印模板图层或将其导出为最终格式的文件格式。 有四个与图层关联的通知程序：kAICurrentLayerNotifierkAILayerDeletionNotifierkAILayerSetNotifierkAILayerOptionsNotifier 使用SPBasicSuite::AcquireSuite()常量kAILayerSuite和使用获取此套件kAILayerVersion。 注册声明1234567891011121314//xxxSuites.h#include &lt;AILayer.h&gt;extern &quot;C&quot; AILayerSuite\\* sAILayer;//xxxSuites.cppextern &quot;C&quot;&#123;AILayerSuite\\* sAILayer = NULL;&#125;ImportSuite gImportSuites[] = &#123; IMPORT_TEXT_SUITES kAILayerSuite, kAILayerSuiteVersion, &amp;sAILayer, nil, 0, nil &#125;; 方法 AIAPI AIErr（* CountLayers）（ai :: int32 * count） 获取当前文档图层列表中的顶级图层数。 AIAPI AIErr（* GetNthLayer）（ai :: int32 n，AILayerHandle *layer） 从当前文档中按索引获得顶级图层。 AIAPI AIErr（* GetCurrentLayer）（AILayerHandle *layer） 获得当前文档中当前图层的引用。 AIAPI AIErr（* SetCurrentLayer）（AILayerHandle layer） 使图层最新。 AIAPI AIErr（* GetFirstLayer）（AILayerHandle * first） 获得当前文档图层列表的最顶层。 AIAPI AIErr（* GetNextLayer）（AILayerHandle prev，AILayerHandle * next） 在堆叠顺序中获得给定图层下方的下一层，位于图层列表堆栈的同一级别。 AIAPI AIErr（* InsertLayer）（AILayerHandle layer，ai :: int16 paintOrder，AILayerHandle * newLayer） 向文档添加新图层，将其插入到相对于现有图层的绘制顺序的图层列表中。 AIAPI AIErr（* DeleteLayer）（AILayerHandle layer） 从当前文档中删除图层及其包含的所有图稿。 AIAPI AIErr（* GetLayerTitle）（AILayerHandle layer，ai :: UnicodeString＆title） 获得图层的名称。 AIAPI AIErr（* SetLayerTitle）（AILayerHandle layer，const ai :: UnicodeString＆newTitle） 设置图层的名称。 AIAPI AIErr（* GetLayerColor）（AILayerHandle layer，AIRGBColor *color） 获得在图层中勾画选定图稿时使用的颜色。 AIAPI AIErr（* SetLayerColor）（AILayerHandle layer，AIRGBColor color） 设置在图层中勾画选定图稿时使用的颜色。 AIAPI AIErr（* GetLayerVisible）（AILayerHandle layer，AIBoolean *visible） 报告图层的可见性状态，这会影响是否绘制图稿。 AIAPI AIErr（* SetLayerVisible）（AILayerHandle layer，AIBoolean visible） 设置图层的可见性状态，这会影响是否绘制图稿。 AIAPI AIErr（* GetLayerPreview）（AILayerHandle layer，AIBoolean *preview） 报告图层是指定预览模式还是轮廓模式。 AIAPI AIErr（* SetLayerPreview）（AILayerHandle layer，AIBoolean preview） 将图层设置为预览模式或轮廓模式。 AIAPI AIErr（* GetLayerEditable）（AILayerHandle layer，AIBoolean *editable） 报告图层是可编辑还是已锁定。 AIAPI AIErr（* SetLayerEditable）（AILayerHandle layer，AIBoolean editable） 设置图层是可编辑还是锁定。 AIAPI AIErr（* GetLayerPrinted）（AILayerHandle layer，AIBoolean *printed） 报告在打印文档时是否将此图层视为可打印。 AIAPI AIErr（* SetLayerPrinted）（AILayerHandle layer，AIBoolean printed） 设置打印文档时是否将此图层视为可打印。 AIAPI AIErr（* GetLayerDimPlacedImages）（AILayerHandle layer，AIBoolean * dimmed） 报告渲染时图层中的图像是否变暗（颜色向白色移动）。 AIAPI AIErr（* SetLayerDimPlacedImages）（AILayerHandle layer，AIBoolean dimmed） 设置渲染时图层中的图像是否变暗（颜色向白色移动）。 AIAPI AIErr（* GetLayerSelected）（AILayerHandle layer，AIBoolean *selected） 报告是否选择了图层。 AIAPI AIErr（* SetLayerSelected）（AILayerHandle layer，AIBoolean selected） 设置是否选择图层。 AIAPI AIErr（* GetLayerByTitle）（AILayerHandle *layer，const ai :: UnicodeString＆title） 按标题获得图层。 AIAPI AIErr（* LayerHasArt）（AILayerHandle layer，AIBoolean * hasArt） 报告图层是否包含子图层以外的对象。 AIAPI AIErr（* LayerHasSelectedArt）（AILayerHandle layer，AIBoolean * hasSel） 报告图层是否包含任何选定的图稿。 AIAPI AIErr（* 取消选择ArtOnLayer）（AILayerHandle layer） 取消选择图层上的所有对象。 AIAPI AIErr（* SelectArtOnLayer）（AILayerHandle layer） 选择可以选择的图层上的所有对象。 AIAPI AIErr（* GetLayerIsTemplate）（AILayerHandle layer，AIBoolean * isTemplate） 报告图层是否为模板图层。 AIAPI AIErr（* SetLayerIsTemplate）（AILayerHandle layer，AIBoolean isTemplate） 设置图层是否为模板图层。 AIAPI AIErr（* GetPrevLayer）（AILayerHandle接下来，AILayerHandle *prev） 在堆叠顺序中获得给定图层上方的图层。 AIAPI AIErr（* GetLayerDimmedPercent）（AILayerHandle layer，ai :: int32 *percent） 当图层设置为灰色时，获得用于绘制图像的调光因子。 AIAPI AIErr（* SetLayerDimmedPercent）（AILayerHandle layer，ai :: int32 percent） 设置图层设置为灰色时用于绘制图像的调光系数。 AIAPI AIErr（* GetLayerFirstChild）（const AILayerHandle layer，AILayerHandle *child） 获得图层的第一个子子图层。 AIAPI AIErr（* GetLayerParent）（const AILayerHandle layer，AILayerHandle * parent） 获得图层的父级。 AIAPI AIErr（* InsertLayerAtArt）（const AIArtHandle art，AIPaintOrder paintOrder，AILayerHandle * newLayer） 在相对于艺术对象的绘制顺序位置处将新图层插入到文档中。 AIAPI AIErr（* ChangeLayerToGroup）（const AILayerHandle layer，const AIArtHandle group） 将此图层的子图层转换为简单组。 AIAPI AIErr（* GetNextPreorderLayer）（AILayerHandle prev，AILayerHandle * next） 在前序遍历中获得下一层，首先查找后代，然后是兄弟姐妹。 AIAPI AIErr（* GetNextNonChildPreorderLayer）（AILayerHandle prev，AILayerHandle * next） 在前序遍历中获得下一层，跳过后代并仅返回兄弟层。 paintOrder 枚举常量12345678910111213141516typedef enum AIPaintOrder &#123; /** Default value */ kPlaceDefault = 0, /** Place above the prepositional object */ kPlaceAbove = 1, /** Place below the prepositional object */ kPlaceBelow, /** Place within and at the top of the prepositional container */ kPlaceInsideOnTop, /** Place within and at the bottom of the prepositional container */ kPlaceInsideOnBottom, /** Place at the top of the paint order, ignoring prepositional object */ kPlaceAboveAll, /** Place at the bottom of the paint order, ignoring prepositional object */ kPlaceBelowAll&#125; AIPaintOrder; AILayerHandle12typedef struct _t_AILayerOpaque* AILayerHandleOpaque reference to a layer. 使用实例12345678910111213141516171819202122232425262728293031323334//使用InsertLayer，SetLayerTitle，GetLayerByTitle，DeleteLayerAILayerHandle m_pointLinePolyLayer;AILayerHandle m_borderMarkLayer;sAILayer-&gt;InsertLayer(m_pointLinePolyLayer, kPlaceInsideOnTop, &amp;m_borderMarkLayer);//在点线面图层上添加色带图层sAILayer-&gt;SetLayerTitle(m_borderMarkLayer, ai::UnicodeString(&quot;色带图层&quot;));//设置新添加图层名称AILayerHandle polyAnnoLayers;sAILayer-&gt;GetLayerByTitle(&amp;polyAnnoLayers, ai::UnicodeString(L&quot;面注记图层&quot;));//找到名为面注记图层的layersAILayer-&gt;DeleteLayer(polyAnnoLayers);//删除面注记图层layer//使用GetLayerFirstChild，GetNextLayerAILayerHandle m_hideLayer;AILayerHandle FirstLayer;AILayerHandle NextLayer = NULL;sAILayer-&gt;GetLayerFirstChild(m_hideLayer,&amp;FirstLayer);//遍历如果存在图稿，则删除该图层 while(FirstLayer) &#123; AIArtHandle ArtGroup; AIArtHandle Art; sAIArt-&gt;GetFirstArtOfLayer(FirstLayer,&amp;ArtGroup); sAIArt-&gt;GetArtFirstChild(ArtGroup,&amp;Art); AILayerHandle LayerTemp; LayerTemp = FirstLayer; sAILayer-&gt;GetNextLayer(FirstLayer,&amp;FirstLayer); if(!Art) sAILayer-&gt;DeleteLayer(LayerTemp); &#125; sAILayer-&gt;SetLayerVisible(m_hideLayer, false); //使用GetNthLayer获得最上面的图层AILayerHandle hideLayer = NULL; sAILayer-&gt;GetNthLayer(0, &amp;hideLayer); AILayerHandle childHideLayer = NULL; 相关文章AI组件开发（一）–注记旋转矩阵AI组件开发（二）–AIRealMathSuiteAI组件开发（三）–AIArtboardSuiteAI组件开发（四）–AIDocumentSuiteAI组件开发（五）–AILayerSuiteAI组件开发（六）–AIArtSuiteAI组件开发（七）–AIPathSuite&amp;&amp;AIPathfinderSuiteAI组件开发（八）–AIArtStyleSuite","tags":[{"name":"AI","slug":"AI","permalink":"http://11wy11.github.io/tags/AI/"}]},{"title":"AI组件开发（四）--AIDocumentSuite","date":"2019-03-24T12:19:52.000Z","path":"2019/03/24/ai-forth-document-note/","text":"获取和设置有关当前文档的信息。 AIDocumentSuite使用这些函数可以获取和设置有关当前文档的信息。某些功能仅在读取文件格式时适用。有些是在文件格式写入期间使用，但可以随时使用。 函数 AIAPI AIErr（* GetDocumentFileSpecification）（ai :: FilePath＆file） 获得当前文档的文件规范。 AIAPI AIErr（* GetDocumentPageOrigin）（AIRealPoint * origin） 获得相对于标尺原点指定的可成像页面左下角的坐标。 AIAPI AIErr（* SetDocumentPageOrigin）（AIRealPoint * origin） 设置可成像页面左下角的坐标。 AIAPI AIErr（* SetDocumentRulerOrigin）（AIRealPoint * origin） 设置当前文档的标尺原点。 AIAPI AIErr（* GetDocumentRulerUnits）（ai :: int16 *units） 获得当前测量单位，显示在标尺中并显示在对话框中。 AIAPI AIErr（* SetDocumentRulerUnits）（ai :: int16 units） 设置当前测量单位，显示在标尺中并显示在对话框中。 AIAPI AIErr（* GetDocumentCropStyle）（AICropMarkStyle * cropStyle） 获得由“创建裁剪标记”命令和过滤器创建的裁剪标记的样式。 AIAPI AIErr（* SetDocumentCropStyle）（AICropMarkStyle cropStyle） 设置“创建裁剪标记”命令和过滤器创建的裁剪标记的样式。 AIAPI AIErr（* GetDocumentSetup）（AIDocumentSetup * setup） 获得有关通过文档“设置”对话框设置的当前文档的信息。 AIAPI AIErr（* SetDocumentSetup）（AIDocumentSetup * setup） 设置文档设置信息，通过文档设置对话框设置。 AIAPI AIErr（* GetDocumentModified）（AIBoolean * modified） 获得文档自上次保存以来是否已被编辑。 AIAPI AIErr（* SetDocumentModified）（AIBoolean修改） 设置当前文档的修改状态。 AIAPI AIErr（* GetDocumentFileFormat）（AIFileFormatHandle * fileFormat） 获得保存当前文档时要使用的文件格式。 AIAPI AIErr（* SetDocumentFileFormat）（AIFileFormatHandle fileFormat） 设置保存当前文档时要使用的文件格式。 AIAPI AIErr（* GetDocumentFileFormatParameters）（AIDocumentFileFormatParameters *参数） 获得与当前文档的关联文件格式关联的用户参数块。 AIAPI AIErr（* SetDocumentFileFormatParameters）（AIDocumentFileFormatParameters参数） 设置与当前文档的关联文件格式关联的用户参数块。 AIAPI AIErr（* GetDocument）（AIDocumentHandle *文件） 获得当前文档的不透明引用，以便与可以对当前文档以外的文档进行操作的函数一起使用。 AIAPI AIErr（* WriteDocument）（const ai :: FilePath＆file，const char * fileFormatName，AIBoolean askForParms） 将当前文档写入文件而不修改文档或更改其修改状态。 AIAPI AIErr（* GetDocumentMiPrintRecord）（AIDocumentMiPrintRecordPtr打印） 获得当前文档的打印记录。 AIAPI AIErr（* GetDocumentRulerOrigin）（AIRealPoint * origin） 获得当前文档的标尺原点。 AIAPI AIErr（* UpdateLinks）（AIBoolean * updatedSomething） 如果需要，更新当前文档中的链接对象。 AIAPI AIErr（* GetDocumentZoomLimit）（AIReal * min，AIReal * max） 获得缩放的限制作为比例因子。 AIAPI AIErr（* GetDocumentMaxArtboardBounds）（AIRealRect * bounds） 获得任何画板的最大有效范围，相对于当前文档的标尺原点表示，而不管文档画板的当前大小。 AIAPI AIErr（* DocumentExists）（AIDocumentHandle文档，AIBoolean *exists） 报告文件是否存在; 也就是说，是一个打开的文档或剪贴板文档。 AIAPI AIErr（* GetDictionary）（struct _AIDictionary **Dictionary） 获得与当前文档关联的录制Dictionary。 AIAPI AIErr（* GetDocumentColorModel）（ai :: int16 * colorModel） 获得文档颜色模型。 AIAPI AIErr（* SetDocumentColorModel）（ai :: int16 colorModel） 在加载时设置文档的预期颜色模型。 AIAPI AIErr（* GetDocumentProfiles）（AIColorProfile * rgbProfile，AIColorProfile * cmykProfile，AIColorProfile * grayProfile） 获得当前文档的颜色校准配置文件。 AIAPI AIErr（* SetDocumentProfiles）（AIColorProfile rgbProfile，AIColorProfile cmykProfile，AIColorProfile grayProfile） 设置当前文档的颜色校准配置文件。 AIAPI AIErr（* Copy）（） 将当前选定的对象复制到剪贴板。 AIAPI AIErr（* Cut）（） 将当前选定的对象剪切到剪贴板。 AIAPI AIErr（* Paste）（） 将剪贴板的内容粘贴到文档中。 AIAPI AIErr（* AIDocumentSuite :: SyncDocument）更新缓存的图稿属性。例如，组的选择状态被缓存，并根据其子项的状态确定。您通常不需要调用此函数。Illustrator会根据需要重新计算缓存的属性。 AIAPI AIErr（* GetNonRecordedDictionary）（struct _AIDictionary **Dictionary） 获得与当前文档关联的未记录Dictionary。 AIAPI int（* GetAIVersion）（） 获得上次保存当前文档的Illustrator文件格式的版本。 AIAPI AIErr（* DocumentHasTransparency）（AIBoolean * hasTransparency，AIBoolean detectOverprint） 报告是否根据当前视图设置渲染当前文档需要任何非不透明的绘制操作。 AIAPI AIErr（* DocumentHasSpotColorArt）（AIBoolean * hasSpotColorArt） 报告是否根据当前视图设置渲染当前文档需要绘制任何专色。 AIAPI AIErr（* GetDocumentAssetMgmtInfo）（AIBoolean * managed，ai :: int32 * pNAlternates，AIBoolean * checkedOut，const char ** URL，AIBoolean * canEdit，char * fileType） 获得资产管理信息。 AIAPI AIErr（* SetDocumentAssetMgmtInfo）（AIBoolean * managed，AIBoolean * checkedOut，const char * URL，AIBoolean * canEdit） 设置资产管理信息。 AIAPI AIErr（* GetDocumentURL）（AIDocumentHandle文档，const char ** URL） 获得与文档关联的URL。 AIAPI AIErr（* GetDocumentXAP）（const char ** xap） 获得当前文档的XMP元数据。 AIAPI AIErr（* SetDocumentXAP）（const char * xap） 设置当前文档的XMP元数据。 AIAPI AIErr（* SuspendTextReflow）（） 暂停当前​​文档中所有文本对象的任何文本重排。 AIAPI AIErr（* ResumeTextReflow）（） 恢复文本重排。 AIAPI AIErr（* GetTextSelection）（TextRangesRef * pTextSelection） 获得当前文档的文本选择对象。 AIAPI AIErr（* HasTextFocus）（AIBoolean * focus） 报告当前文档是否处于文本编辑模式。 AIAPI AIErr（* HasTextCaret）（AIBoolean * caret） 报告当前文档是处于文本编辑模式还是插入符号闪烁（与选择的文本范围相反）。 AIAPI AIErr（* GetTextFocus）（StoryRef * pStory） 获得处于编辑模式的当前故事。 AIAPI AIErr（* SetTextFocus）（StoryRef故事） 将故事设置为处于编辑模式。 AIAPI AIErr（* LoseTextFocus）（） 退出文本编辑模式。 AIAPI AIErr（* GetDocumentTextResources）（DocumentTextResourcesRef * pDocResources） 获得当前文档的文本资源对象。 AIAPI AIErr（* WriteDocumentMacInformationResource）（const ai :: FilePath＆file） AIAPI AIErr（* WriteDocumentWithOptions）（const ai :: FilePath＆file，const char * fileFormatName，ai :: int32 options，AIBoolean askForParms） 将当前文档写入具有指定写入选项的文件，而不修改文档或更改其修改状态。 AIAPI AIErr（* DocumentHasOverprint）（AIBoolean * hasOverprint） 报告是否根据当前视图设置呈现当前文档需要绘制任何叠印对象。 AIAPI AIErr（* DocumentHasManagedLinks）（AIDocumentHandle文档，AIBoolean * hasManagedLinks） 报告文档是否包含任何托管链接。 AIAPI AIErr（* GetDocumentSpotColorMode）（AIDocumentHandle文档，AISpotColorMode *模式） 获得文档的专色模式，该模式控制添加到文档的新专色的外观定义。 AIAPI AIErr（* SetDocumentSpotColorMode）（AIDocumentHandle文档，AISpotColorMode模式，AIBoolean转换，AIBoolean *转换） 设置文档的专色模式，该模式控制添加到文档的新专色的外观定义。 AIAPI AIErr（* 撤消）（） 撤消最近的可撤消事务。 AIAPI AIErr（* 重做）（） 重做最近的可重做事务。 AIAPI AIErr（* DocumentRasterAttributes）（AIBoolean * hasDeviceNRasters，AIBoolean * hasOverprint） 报告当前文档是否包含任何DeviceN或叠印栅格。 AIAPI AIErr（* GetDocumentStartupProfile）（AIDocumentHandle文档，AIDocumentStartupProfile * startupProfile） 获得文档启动配置文件。 AIAPI AIErr（* GetDocumentBleeds）（AIRealRect * bleedOffset） 获得文档的bleedOffset。 AIAPI AIErr（* SetDocumentBleeds）（const AIRealRect＆bleedOffset） 设置文档的bleedOffset。 AIAPI AIErr（* SetDocumentPixelPerfectStatus）（AIBoolean isPixelPerfect） 打开或关闭文档的Pixel Perfect模式。 AIAPI AIBoolean（* GetDocumentPixelPerfectStatus）（） 报告文档当前是否处于Pixel Perfect模式。 使用实例 12345678910111213141516171819//xxxSuites.h#include &lt;AIDocument.h&gt;extern &quot;C&quot; AIDocumentSuite* sAIDocument;//xxxSuites.cppextern &quot;C&quot;&#123;AIDocumentSuite* sAIDocument = NULL;&#125;ImportSuite gImportSuites[] = &#123; IMPORT_TEXT_SUITES kAIDocumentSuite, kAIDocumentSuiteVersion, &amp;sAIDocument, nil, 0, nil &#125;;//XXXPlugin.cpp//绘制操作sAIDocument-&gt;SyncDocument();//更新图稿属性TextRangesRef rangesRef = NULL;sAIDocument-&gt;GetTextSelection(&amp;rangesRef);//获得当前文档的文本选择对象 相关文章AI组件开发（一）–注记旋转矩阵AI组件开发（二）–AIRealMathSuiteAI组件开发（三）–AIArtboardSuiteAI组件开发（四）–AIDocumentSuiteAI组件开发（五）–AILayerSuiteAI组件开发（六）–AIArtSuiteAI组件开发（七）–AIPathSuite&amp;&amp;AIPathfinderSuiteAI组件开发（八）–AIArtStyleSuite","tags":[{"name":"AI","slug":"AI","permalink":"http://11wy11.github.io/tags/AI/"}]},{"title":"AI组件开发（三）--AIArtboardSuite","date":"2019-03-24T08:53:24.000Z","path":"2019/03/24/ai-third-note/","text":"AIArtboardSuite此套件提供的实用程序允许在文档中创建和操作Artboards。相关类ArtboardProperties和ArtboardList AIArtboardSuite此套件提供的实用程序允许您在文档中创建和操作画板Artboards。文档与ArtboardList包含多个Artboard对象的对象相关联，每个ArtboardProperties对象与对象相关联。 建议您使用的包装类，ai::ArtboardProperties和ai::ArtboardList而不是直接调用这些功能。 使用SPBasicSuite::AcquireSuite()常量kAIArtboardSuite和使用获取此套件kAIArtboardSuiteVersion。1234567891011121314//xxxSuites.h#include &quot;AIArtboard.h&quot;extern &quot;C&quot; AIArtboardSuite* sAIArtboard;//xxxSuites.cppextern &quot;C&quot;&#123;AIArtboardSuite* sAIArtboard = NULL;&#125;ImportSuite gImportSuites[] = &#123; IMPORT_TEXT_SUITES kAIArtboardSuite, kAIArtboardSuiteVersion, &amp;sAIArtboard, nil, 0, nil &#125;; 目录 generated with DocToc AddNew CLoneArtboard 3.Delete 4.Dispose 5.GetActive 6.GetArtboardProperties 7.GetCount 8.GetName 9.GetPAR 10.GetPosition 11.GetRulerOrigin 12.GetShowDisplayMark 13.Init 14.Insert 15.IsDefaultName 16.ReleaseArtboardList 17. SetActive 18.SetIsDefaultName 19.SetName 20.SetPAR 21.SetPosition 22.SetRulerOrigin 23.SetShowDisplayMark 24.Update AddNewAIAPI AIErr（* AIArtboardSuite :: AddNew）（ai :: ArtboardList＆artboardList，ai :: ArtboardProperties＆newArtboard，ai :: ArtboardID ＆index）将新画板添加到当前文档并在画板列表中报告其索引位置。 参数： artboardList 画板列表对象。 newArtboard 新画板的属性对象。 index [out]一个缓冲区，用于返回新画板的从0开始的索引位置。 返回： kAIExceededMaxArtboardLimitErr列表大小超过应用程序定义的限制时的错误。 参考ai :: ArtboardList :: AddNew（） CLoneArtboardAIAPI AIErr（* AIArtboardSuite :: CloneArtboard）（ai :: ArtboardProperties &amp;artboard，const ai :: ArtboardProperties &amp;newArtboard）复制画板对象。 参数： artboard artboard属性要克隆。 newArtboard [out]用于返回新画图属性对象。 参考ai :: ArtboardProperties :: ArtboardProperties() 3.DeleteAIAPI AIErr（* AIArtboardSuite ::Delete）（ai :: ArtboardList &amp;artboardList，ai :: ArtboardID &amp;index）从画板列表中删除画板，并使列表中的下一个画板处于活动状态。 无法删除最后一个画板。 参数： artboardList 画板列表对象。 index 要从列表中删除的画板的从0开始的索引位置。 返回： kAICantDeleteLastArtboardErr如果您尝试删除最后一个画板时出现错误。 参考ai::ArtboardList::Delete()。 4.DisposeAIAPI AIErr(* AIArtboardSuite::Dispose)(ai::ArtboardProperties &amp;properties)释放画板属性对象。 参数：properties 画板属性对象。 参考ai :: ArtboardProperties :: ~ArtboardProperties（） 5.GetActiveAIAPI AIErr（* AIArtboardSuite :: GetArtboardList）（ai :: ArtboardList ＆artboardList）获得当前文档的画板列表。 参数： artboardList [out]用于返回画板列表对象的引用。 参考ai :: ArtboardList :: ArtboardList（）。 6.GetArtboardPropertiesAIAPI AIErr（* AIArtboardSuite :: GetArtboardProperties）（ai :: ArtboardList &amp;artboardList，ai :: ArtboardID index，ai :: ArtboardProperties &amp;properties）从画板列表中获得画板的属性。 使用GetCount()和Update()修改画板而不更改文档中哪个画板处于活动状态。 参数： artboardList 画板列表对象。 index 列表中画板的从0开始的索引位置。 properties [out]用于返回画板属性对象。出错时，返回无效对象 使用： 1234ai::ArtboardProperties tempArtboardProperties;ai::ArtboardList tempoartboardList;sAIArtboard-&gt;GetArtboardList(tempoartboardList);sAIArtboard-&gt;GetArtboardProperties(tempoartboardList, 0, tempArtboardProperties); 7.GetCountAIAPI AIErr（* AIArtboardSuite :: GetCount）（const ai :: ArtboardList &amp;artboardList，ai :: ArtboardID &amp;count）获得画板列表中定义的画板数量。 参数： artboardList 画板列表对象。 count [out]用于返回画板数量。 参考ai :: ArtboardList :: GetCount（）。 8.GetNameAIAPI AIErr(* AIArtboardSuite::GetName)(const ai::ArtboardProperties &amp; properties, ai::UnicodeString &amp;name) 9.GetPARAIAPI AIErr(* AIArtboardSuite::GetPAR)(const ai::ArtboardProperties &amp;properties, AIReal &amp;par)获得画板标尺的像素长宽比。 参数： properties 画板属性对象。 par [out]用于返回像素宽高比。 实例： 123456ai::ArtboardProperties tempArtboardProperties;ai::ArtboardList tempoartboardList;sAIArtboard-&gt;GetArtboardList(tempoartboardList);sAIArtboard-&gt;GetArtboardProperties(tempoartboardList, 0, tempArtboardProperties);AIReal artPar;sAIArtboard-&gt;GetPAR(tempArtboardProperties,artPar) 10.GetPositionAIAPI AIErr（* AIArtboardSuite :: GetPosition）（const ai :: ArtboardProperties＆properties，AIRealRect＆bounds）获得画板的位置和边界。 参数： properties 画板属性对象。 bounds [out]一个矩形对象，用于返回画板的位置和边界。 实例： 12345678910ai::ArtboardProperties tempArtboardProperties;ai::ArtboardList tempoartboardList;sAIArtboard-&gt;GetArtboardList(tempoartboardList);sAIArtboard-&gt;GetArtboardProperties(tempoartboardList, 0, tempArtboardProperties);AIRealRect Bound;sAIArtboard-&gt;GetPosition(tempArtboardProperties, Bound); ASReal bottom = Bound.bottom;ASReal top = Bound.top;ASReal right = Bound.right;ASReal left = Bound.left; 11.GetRulerOriginAIAPI AIErr（* AIArtboardSuite :: GetRulerOrigin）（const ai :: ArtboardProperties＆properties，AIRealPoint＆rulerOrigin）获得相对于左下角的画板的标尺原点。 参数： properties 画板属性对象。 rulerOrigin [out]用于返回标尺原点。 12.GetShowDisplayMarkAIAPI AIErr（* AIArtboardSuite :: GetShowDisplayMark）（const ai :: ArtboardProperties＆properties，ai :: ArtboardProperties :: DisplayMarkType type，AIBoolean＆show）报告当前是否显示特定类型的画板注释。 参数： properties 画板属性对象。 type 注释类型。 show 如果显示类型则返回true，如果隐藏则返回false。 13.InitAIAPI AIErr（* AIArtboardSuite :: Init）（ai :: ArtboardProperties＆artboard）使用默认值初始化画板属性对象。 参数：artboard 画板属性对象。 14.InsertAIAPI AIErr（* AIArtboardSuite :: Insert）（ai :: ArtboardList＆artboardList，ai :: ArtboardProperties＆artboard，ai :: ArtboardID＆index）在指定位置插入新画板。 参数： artboardList ArtboardList对象。 artboard 新画板的属性。 index 基于0的新画板的索引位置。 返回： kAIExceededMaxArtboardLimitErr如果超出允许的最大画板数，则会出错。 15.IsDefaultNameAIAPI AIErr（* AIArtboardSuite :: IsDefaultName）（const ai :: ArtboardProperties＆properties，AIBoolean＆isDefault）报告画板的当前名称是否是应用程序生成的。 在这种情况下，用户选择将画板内容导出为JPEG，并将画板保存为单独的文件时，文件只能通过编号来区分，而不是完整生成的名称; 例如，myArt-01.jpg。如果已明确设置画板名称，则会在导出的JPEG文件名中使用该名称。 参数： properties 画板属性对象。 isDefault 如果生成名称则返回true的缓冲区，如果已显式设置，则返回false。 16.ReleaseArtboardListAIAPI AIErr(* AIArtboardSuite::ReleaseArtboardList)(ai::ArtboardList &amp;artboardList)释放画板列表对象。 参数： artboardList 画板列表对象。 17. SetActiveAIAPI AIErr（* AIArtboardSuite :: SetActive）（ai :: ArtboardList＆artboardList，ai :: ArtboardID index）使特定画板处于活动状态，并使其按迭代顺序显示。 参数： artboardList 画板列表对象。 index 列表中画板的从0开始的索引位置。 18.SetIsDefaultNameAIAPI AIErr（* AIArtboardSuite :: SetIsDefaultName）（ai :: ArtboardProperties＆properties，const AIBoolean＆isDefault） 19.SetNameAIAPI AIErr(* AIArtboardSuite::SetName)(ai::ArtboardProperties &amp;properties, const ai::UnicodeString &amp;name) 20.SetPARAIAPI AIErr（* AIArtboardSuite :: SetPAR）（ai :: ArtboardProperties＆properties，AIReal par）修改画板标尺的像素长宽比。 AIArtboardSuite::Update()使用此对象调用进行更改。 参数： properties 画板属性对象。 par 新的像素长宽比。 21.SetPositionAIAPI AIErr（* AIArtboardSuite :: SetPosition）（ai :: ArtboardProperties＆properties，const AIRealRect＆bounds）修改画板的位置和边界。 AIArtboardSuite::Update()使用此对象调用进行更改。 参数： properties 画板属性对象 bounds 新的位置和边界 22.SetRulerOriginAIAPI AIErr（* AIArtboardSuite :: SetRulerOrigin）（ai :: ArtboardProperties＆properties，const AIRealPoint＆rulerOrigin）设置画板的标尺原点，相对于左下角。 参数：properties 画板属性对象rulerOrigin 标尺原点 23.SetShowDisplayMarkAIAPI AIErr（* AIArtboardSuite :: SetShowDisplayMark）（ai :: ArtboardProperties＆properties，ai :: ArtboardProperties :: DisplayMarkType type，AIBoolean show）设置当前是否显示特定类型的画板注释。 24.UpdateAIAPI AIErr（* AIArtboardSuite :: Update）（ai :: ArtboardList＆artboardList，ai :: ArtboardID index，const ai :: ArtboardProperties＆properties）更新画板的属性。 使用GetCount()和GetArtboardProperties()修改画板而不更改文档中哪个画板处于活动状态。 参数： artboardList 画板列表对象。 index 文档列表中画板的从0开始的索引位置。 properties 包含新画板属性的对象。 实例： 12345678910111213AIRealRect DateBound;AIRealPoint CenterPt;double m_scale=2000DateBound.top = (this-&gt;DateBound.top - this-&gt;m_center.v) * 1000 / m_scale * (72 / 25.4) - AIcenter.v;DateBound.bottom = (this-&gt;DateBound.bottom - this-&gt;m_center.v) * 1000 / m_scale * (72 / 25.4) - AIcenter.v;DateBound.left = (this-&gt;DateBound.left - this-&gt;m_center.h) * 1000 / m_scale * (72 / 25.4) - AIcenter.h;DateBound.right = (this-&gt;DateBound.right - this-&gt;m_center.h) * 1000 / m_scale * (72 / 25.4) - AIcenter.h; CenterPt.h = (DateBound.left - DateBound.right) / 2;CenterPt.v = (DateBound.top - DateBound.bottom) / 2; sAIArtboard-&gt;SetPosition(tempArtboardProperties, DateBound);//*******sAIArtboard-&gt;Update(tempoartboardList, 0, tempArtboardProperties);//******* 相关文章AI组件开发（一）–注记旋转矩阵AI组件开发（二）–AIRealMathSuiteAI组件开发（三）–AIArtboardSuiteAI组件开发（四）–AIDocumentSuiteAI组件开发（五）–AILayerSuiteAI组件开发（六）–AIArtSuiteAI组件开发（七）–AIPathSuite&amp;&amp;AIPathfinderSuiteAI组件开发（八）–AIArtStyleSuite","tags":[{"name":"AI","slug":"AI","permalink":"http://11wy11.github.io/tags/AI/"}]},{"title":"GDAL相关类及函数","date":"2019-03-24T06:27:22.000Z","path":"2019/03/24/cpp-gdal-function/","text":"主要介绍GDAL基本类及OGR相关类 GDAL 基本使用函数CPLSetConfigOptionvoid CPLSetConfigOption （ const char pszKey，const char pszValue）为GDAL / OGR使用设置配置选项。 这些选项被定义为（键，值）对。稍后可以使用CPLGetConfigOption（）方法获取与密钥对应的值。 此机制类似于环境变量，但使用CPLSetConfigOption（）设置的选项会覆盖CPLGetConfigOption（）的观点，即环境中定义的值。 如果使用相同的密钥多次调用CPLSetConfigOption（），则将使用上次调用期间提供的值。 也可以使用带有’-config KEY VALUE’的大多数GDAL实用程序的命令行传递选项。例如，ogrinfo -config CPL_DEBUG ON~ / data / test / point.shp 此函数也可用于通过传递NULL作为值来清除设置（注意：传递NULL不会取消设置现有环境变量;它将取消设置先前由CPLSetConfigOption（）设置的值）。 例如：12CPLSetConfigOption(&quot;MDB_DRIVER_TEMPLATE&quot;, &quot;DRIVER=Microsoft Access Driver (*.mdb, *.accdb);DBQ=%s&quot;);CPLSetConfigOption(&quot;PGEO_DRIVER_TEMPLATE&quot;, &quot;DRIVER=Microsoft Access Driver (*.mdb, *.accdb);DBQ=%s&quot;); GDALAllRegister 最初需要注册所需的所有格式驱动程序。这通常通过调用GDALAllRegister（）来完成，该寄存器注册GDAL / OGR中内置的所有格式驱动程序。 原型： 12345678910111213void GDALAllRegister(void) //Register all known configured GDAL drivers.//注册所有已知配置的GDAL驱动程序。 //This function will drive any of the following that are configured into GDAL. See raster list and vector full list //此功能将驱动配置为GDAL的以下任何内容。请参阅栅格列表和矢量完整列表 //This function should generally be called once at the beginning of the application.//通常应在应用程序开始时调用此函数一次。 //使用#include“ ogrsf_frmts.h ” int main（） &#123; GDALAllRegister（）; GDALOpenEx以GDALDataset打开栅格或矢量文件。 此函数将尝试依次调用每个已注册的GDALDriver的Open方法来打开传递的文件或虚拟数据集名称。第一次成功打开将导致返回的数据集。如果所有驱动程序都失败，则返回NULL并发出错误。 几条建议： 如果打开具有GDAL_OF_UPDATE访问权限的数据集对象，则不建议在同一基础文件上打开新数据集。 返回的数据集一次只能由一个线程访问。如果要从不同的线程中使用它，则必须添加所有必需的代码（互斥锁等）以避免并发使用该对象。（某些驱动程序，如GeoTIFF，维护每次读取新块时更新的内部状态变量，从而防止并发使用。） 原型： 123456GDALDatasetH GDALOpenEx （ const char * pszFilename，unsigned int nOpenFlags，const char * const * papszAllowedDrivers，const char * const * papszOpenOptions，const char * const * papszSiblingFiles ） 参数 pszFilename 要访问的文件的名称。在外来驱动程序的情况下，这可能不是指物理文件，而是包含驱动程序有关如何访问数据集的信息。它应该是UTF-8编码。 nOpenFlags GDAL_OF_标志的组合，可以通过逻辑或运算符组合。 驱动程序类型：用于光栅驱动程序的GDAL_OF_RASTER，用于矢量驱动程序的GDAL_OF_VECTOR，用于地理网络模型驱动程序的GDAL_OF_GNM。如果未指定任何值，则隐含所有类型。 访问模式：GDAL_OF_READONLY（独占）或GDAL_OF_UPDATE。 共享模式：GDAL_OF_SHARED。如果设置，它允许与已设置GDAL_OF_SHARED的其他调用者共享数据集的GDALDataset句柄。特别是，GDALOpenEx（）将首先查询其当前打开和共享GDALDataset的列表，如果一个GetDescription（）名称与传递给GDALOpenEx（）的pszFilename完全匹配，则将引用并返回它，如果GDALOpenEx（）是从同一个线程调用。 详细错误：GDAL_OF_VERBOSE_ERROR。如果设置，则尝试打开文件失败将导致报告错误消息。 papszAllowedDrivers NULL考虑所有候选驱动程序，或NULL终止的字符串列表，其中包含必须考虑的驱动程序短名称。 papszOpenOptions NULL或NULL终止的字符串列表，其中打开选项传递给候选驱动程序。所有驱动程序OVERVIEW_LEVEL = level都存在一个选项，用于选择数据集的特定概述级别。级别索引从0开始。级别编号可以以“仅”为后缀，以指定只有此概述级别必须可见，而不是子级别。默认情况下会验证打开选项，如果无法识别选项，则会发出警告。在某些情况下，可能不需要（例如，当不知道哪个驱动程序将打开文件时），因此可以将特殊打开选项VALIDATE_OPEN_OPTIONS设置为NO以避免此类警告。或者，从GDAL 2.1开始，选项名称前面可以加上@字符，表示如果驱动程序没有声明此选项，它可能不会引发警告。 papszSiblingFiles NULL或NULL终止的字符串列表，这些字符串是主文件名的辅助文件名。如果传递NULL，则将完成对文件系统的探测。 返回一个GDALDatasetH句柄或失败时为NULL。对于C ++应用程序，此句柄可以转换为GDALDataset *。 1234567GDALDataset *poDS;poDS = (GDALDataset*) GDALOpenEx( &quot;point.shp&quot;, GDAL_OF_VECTOR, NULL, NULL, NULL );if( poDS == NULL )&#123; printf( &quot;Open failed.\\n&quot; ); exit( 1 );&#125; 使用实例：1234567GDALDataset *poDS;poDS = (GDALDataset*) GDALOpenEx( &quot;point.shp&quot;, GDAL_OF_VECTOR, NULL, NULL, NULL );if( poDS == NULL )&#123; printf( &quot;Open failed.\\n&quot; ); exit( 1 );&#125; GDALDataSet帮助文档https://www.gdal.org/classGDALDataset.html 类图 部分函数介绍 GetLayerByName Fetch a layer by name. The returned layer remains owned by the GDALDataset and should not be deleted by the application. This method is the same as the C function GDALDatasetGetLayerByName() and the deprecated OGR_DS_GetLayerByName(). In GDAL 1.X, this method used to be in the OGRDataSource class. Parameters pszName the layer name of the layer to fetch. Returns the layer, or NULL if Layer is not found or an error occurs. GetLayerCount OGR类或函数OGRLayer帮助文档https://www.gdal.org/classOGRLayer.html 类图 GetLayerDefn GetExtent ResetReading GetNextFeature GetName OGRFeature 包括geometry和attributes GetDefRef GetGeometryRef 返回指向内部要素几何的指针。不应修改此对象 GetFieldAsString 将字段值作为字符串获取 OGRFeature::DestroyFeaturevoid OGRFeature :: DestroyFeature （ OGRFeature * poFeature ） poFeatur要删除的Feature。OGRGeometry所有几何类的抽象基类。 一些空间分析方法要求在GEOS库上构建OGR才能正常工作。描述几何之间空间关系的方法的精确含义在SFCOM或其他简单特征接口规范中描述，例如“OpenGIS®地理信息实现规范 - 简单特征访问 - 第1部分：通用体系结构”：&lt;a href =“ http://www.opengeospatial.org/standards/sfa “&gt; OGC 06-103r4 在GDAL 2.0中，类的层次结构已经扩展为（工作草案）ISO SQL / MM第3部分（ISO / IEC 13249-3）曲线几何：CIRCULARSTRING（OGRCircularString），COMPOUNDCURVE（OGRCompoundCurve），CURVEPOLYGON（OGRCurvePolygon），MULTICURVE（OGRMultiCurve）和MULTISURFACE（OGRMultiSurface）。 OGRPointOGRLineString多顶点线的具体表示。继承OGRSimpleCurve getPointsvoid OGRSimpleCurve::getPoints ( OGRRawPoint * paoPointsOut,double * padfZOut = nullptr ) getPointvoid OGRSimpleCurve::getPoint ( int i,OGRPoint * poPoint )获取行字符串中的一个点。i:要获取的顶点，从0到getNumPoints（） - 1poPoint 用获取的点初始化的点。 getNumPoints获得线上点的个数OGRMultiLineString getNumGeometries获得几何要素格个数OGRPolygon getExteriorRing 获取对外部多边形环的引用 getNumInteriorRings获取指示内部环的数量 getInteriorRing获取指示内部环的引用OGRFeatureDefn 要素类或要素图层的定义。 GetFieldCount 获取字段数 GetFieldDefn 获得字段 参数：字段索引OGRFieldDefn GetNameRef 字段名称 OGREnvelope1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980class CPL_DLL OGREnvelope&#123; public: OGREnvelope() : MinX(std::numeric_limits&lt;double&gt;::infinity()), MaxX(-std::numeric_limits&lt;double&gt;::infinity()), MinY(std::numeric_limits&lt;double&gt;::infinity()), MaxY(-std::numeric_limits&lt;double&gt;::infinity()) &#123; &#125; OGREnvelope(const OGREnvelope&amp; oOther) : MinX(oOther.MinX),MaxX(oOther.MaxX), MinY(oOther.MinY), MaxY(oOther.MaxY) &#123; &#125; double MinX; double MaxX; double MinY; double MaxY;#ifdef HAVE_GCC_DIAGNOSTIC_PUSH#pragma GCC diagnostic push#pragma GCC diagnostic ignored &quot;-Wfloat-equal&quot;#endif int IsInit() const &#123; return MinX != std::numeric_limits&lt;double&gt;::infinity(); &#125;#ifdef HAVE_GCC_DIAGNOSTIC_PUSH#pragma GCC diagnostic pop#endif void Merge( OGREnvelope const&amp; sOther ) &#123; MinX = MIN(MinX,sOther.MinX); MaxX = MAX(MaxX,sOther.MaxX); MinY = MIN(MinY,sOther.MinY); MaxY = MAX(MaxY,sOther.MaxY); &#125; void Merge( double dfX, double dfY ) &#123; MinX = MIN(MinX,dfX); MaxX = MAX(MaxX,dfX); MinY = MIN(MinY,dfY); MaxY = MAX(MaxY,dfY); &#125; void Intersect( OGREnvelope const&amp; sOther ) &#123; if(Intersects(sOther)) &#123; if( IsInit() ) &#123; MinX = MAX(MinX,sOther.MinX); MaxX = MIN(MaxX,sOther.MaxX); MinY = MAX(MinY,sOther.MinY); MaxY = MIN(MaxY,sOther.MaxY); &#125; else &#123; MinX = sOther.MinX; MaxX = sOther.MaxX; MinY = sOther.MinY; MaxY = sOther.MaxY; &#125; &#125; else &#123; *this = OGREnvelope(); &#125; &#125; int Intersects(OGREnvelope const&amp; other) const &#123; return MinX &lt;= other.MaxX &amp;&amp; MaxX &gt;= other.MinX &amp;&amp; MinY &lt;= other.MaxY &amp;&amp; MaxY &gt;= other.MinY; &#125; int Contains(OGREnvelope const&amp; other) const &#123; return MinX &lt;= other.MinX &amp;&amp; MinY &lt;= other.MinY &amp;&amp; MaxX &gt;= other.MaxX &amp;&amp; MaxY &gt;= other.MaxY; &#125;&#125;; OGRwkbGeometryType几何类型代码。在下面这类中实现： OGRMultiLineString, OGRMultiCurve, OGRMultiPoint, OGRTriangulatedSurface, OGRPolyhedralSurface, OGRMultiPolygon, OGRMultiSurface, OGRGeometryCollection, OGRTriangle, OGRPolygon, OGRCurvePolygon, OGRCompoundCurve, OGRCircularString, OGRLineString, and OGRPoint. 常亮值如：wkbPoint，wkbMultiPoint，wkbLineString,wkbMultiLineString，wkbPolygon，wkbCurvePolygon，wkbMultiPolygon 参考资料： 百度百科：https://baike.baidu.com/item/GDAL/4004525?fr=aladdin 官方网站：https://www.gdal.org/","tags":[{"name":"GDAL","slug":"GDAL","permalink":"http://11wy11.github.io/tags/GDAL/"}]},{"title":"krpano快速初级教程（一）之javascript api","date":"2019-03-23T02:37:05.000Z","path":"2019/03/23/krpano-primary-first-note/","text":"","tags":[{"name":"krpano","slug":"krpano","permalink":"http://11wy11.github.io/tags/krpano/"}]},{"title":"VS2013打包C#项目","date":"2019-03-22T13:54:22.000Z","path":"2019/03/22/winform-release/","text":"在VS2013中安装InstallShield打包程序， 背景vs2010打包时，在其他项目类型中找到安装和部署的模板，即可新建安装项目，而在vs2013中需要先在线搜索InstallShield，然后按照网页提示一步步下载，之后添加安装项目，配置打包设置完成打包 在vs2010 选择“新建项目”→“ 其他项目类型”→“ Visual Studio Installer→“安装项目”： 1. 打包前的准备InstallShield安装在我们准备好的项目中右击“解决方案”，在弹出的菜单中选择添加 - 新建项目： 在弹出的新建对话框中依次选择 其他项目 - 安装和部署 - 安装项目，你可以改名字，也可以使用默认的名字setup1 新建一个打包部署项目，点OK，如果是第一次使用的话，会打开一个网页，按照提示的步骤来做， 点击Go to the download web site,进入下载网站，填写完信息，点击“download ”即会收到一封邮件，里面有下载地址和激活码。 之后会下载一个InstallShield2015LimitedEdition.exe的安装包,用管理员权限运行安装完后。重新启动VS2013 重新新建一个这样的项目： 点OK，这时候不再是打开网页，这时打开会提示激活或者是试用，选第一项，下一步 输入收到的邮件里的激活码，激活,待激活完成 卸载功能：找到C:\\Windows\\System32目录下的msiexec.exe文件，右击 选择 “msiexec.exe 的快捷方式”，然后改名为：你想叫名称（卸载、uninstall都可以），移动到你需要打包的程序菜单的文件夹下面。 winform设置项目图标 首先可以在你的窗体属性中找到icon选择你准备好的图标； 右键项目点击属性，找到应用程序中的图标和清单 2. 开始部署2.1 基本配置Application Information 可以设置公司名称，点击右侧General Information 可以设置语言为中文，可以设置应用名称 2.2 Installation Requirements 一般可以默认设置，如果需要,选择安装如.NET Framework 4.5等依赖同时打包，勾选所需依赖 2.3 Installation Architecture 默认即可 2.4 Application Files 添加程序所需文件，这里有两种方式经过测试均可实现 2.4.1方式一 点击到ProgramFilesFolder&gt;Microsoft&gt; &lt;你的工程名&gt;[INSRALLDIR]，点击Add Folders，选择工程bin目录下的Debug或Release文件夹，一般选择Release 2.4.2 方式二 点击到ProgramFilesFolder&gt;Microsoft&gt; &lt;你的工程名&gt;[INSRALLDIR]，点击Add Project Outputs,选择主输出 点击Ok后，选中主输出，右键Resolve Project OutPut 点击OK后，在左边菜单CatcheScreen下新建目录source，然后同上步骤添加源文件，然后选中资源，右键Resolve Project OutPut 在创建一个文件命名“uninstall”，然后同上步骤添加源文件，然后选中资源，右键Resolve Project OutPut 2.5 Application Shortcuts 2.4如果选择方式一，这是默认后有两个Launch xxx.exe,Launch xxx.vshost.exe,可以将第二个删掉，然后重命名第一个 勾选use alternate shortcut icon可以选择自定义的程序图标 然后创建卸载程序的快捷方式 点击Create an unistallation shortcut，选择uninstall 2.4如果选择方式二， 点击左侧的new,弹出对话框后点击最后一项，一直点到最后,点击Open，重命名Built（这里的重命名实际上就是你的程序在桌面上的名称) 选择在桌面上创建快捷方式： 勾选use alternate shortcut icon可以选择自定义的程序图标 然后创建卸载程序的快捷方式 2.6 Application Registry配置是否允许用户修改安装地址等 2.7 在右侧找到第六步Prepare for Release，双击下面的Releases点击选中“SingleImage”–选项卡点击“Setup.exe”–找到 “InstallShield PrerequisitesLocation”，把它设置为“Extract From Setup.exe” 发布生成解决方案后会在安装程序集下面生成一个名为Setup（当时添加安装部署项目的项目名）的文件夹，安装文件就保存在下面的目录中。Install在生成安装文件后会有Setup.exe和.msi两中安装文件，exe文件是安装的引导文件，核心文件是msi文件，里面封存了程序的组件。在里面找到Setup.exe文件及msi文件即可进行安装。 点击Setup.exe，进行安装，如果想卸载，点击Uninstall卸载 更换用installshield打包生成exe文件的图标 打开Visio studio,选择文件方式打开你生成的exe文件 在Icon下右键添加资源》点击导入选择准备好的项目图标等 删除原来的100资源 设置你导入的资源ID为100 保存常见问题 有时打包之后，项目更新之后，重新再生成解决方案来打包,遇到exe文件找不到时【解决方案】 清理，重新生成解决方案 如果还是不行，运行一次，然后点击生成解决方案 重新打包遇到DVD5无法覆盖【解决方案】原因是通过打开了相关文件夹，关闭文件资源管理器即可 设置了应用的ico图标后，生成解决方案提示 error : -3204: Cannot extract icon with index 0 from file…【解决方案】把图标添加进工程。 重新打包遇到错误-1014：错误 29 -1014: Cannot rename directory XXX\\Express\\SingleImage to XXX\\Express\\SingleImage.Bak.Windows Explorer or a DOS prompt may be pointing to a subfolder of the release output folder (Disk1) or to the Interm folder, locking it. Change the current directory. Close any open files in the Disk1 folder. Close Msidb.exe if it is open.【解决方案】将工程文件夹下的当时创建的SetUp应用程序中SetUp（当初新建的工程名）的文件夹删除，保留,isl，isproj文件，点击 生成解决方案即可，在XXX\\Express\\SingleImage\\DiskImages\\DISK1下生成可执行文件 参考：https://blog.csdn.net/qq_38122230/article/details/80470699https://blog.csdn.net/u010872301/article/details/80509405","tags":[{"name":"VS","slug":"VS","permalink":"http://11wy11.github.io/tags/VS/"},{"name":"打包","slug":"打包","permalink":"http://11wy11.github.io/tags/打包/"}]},{"title":"krpano快速入门教程（四）之菜单栏","date":"2019-03-21T15:37:50.000Z","path":"2019/03/21/krpano-forth-note/","text":"主要通过自定义plugin插件实现krpano下拉框 背景有时当有多个场景，用户想要直观的查看和定位指定的菜单栏，因此，最简单的方式是在页面中添加下拉框，能够支持用户选择场景进行跳转 下拉式菜单栏主要通过自定义plugin插件实现下拉框tour.xml代码如下： plugin plugin定义插件，其中使用了krpano中提供的combox插件，align属性可以设置下拉框相对对齐位置，onloaded定义在加载时调用的函数或动作action action fill_with_scenes 主要读取当前所有的场景，依次设置添加到combox的item中，可以看到采用了部分krpano的语法，首先定义了item点击事件itemcall，调用loadscene加载场景，然后将场景名称和场景title作为项的属性添加 action select_box_item 下拉框选中动作，如果该插件加载，则调用选中函数，否则，延时执行选中combox.js下载123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115&lt;krpano version=\"1.19\" title=\"Virtual Tour\" onstart=\"startup();\"&gt;&lt;!-- combobox plugin --&gt; &lt;plugin name=\"box\" keep=\"true\" url=\"%SWFPATH%/plugins/combobox.swf\" width=\"230\" alturl=\"%SWFPATH%/plugins/combobox.js\" native=\"false\" align=\"righttop\" x=\"10\" y=\"10\" onloaded=\"fill_with_scenes();\" /&gt; &lt;!-- an action for automatically fill the combobox with all scenes --&gt; &lt;action name=\"fill_with_scenes\"&gt; for(set(i,0), i LT scene.count, inc(i), txtadd(itemcall, 'loadscene(',get(scene[get(i)].name),',null,MERGE,BLEND(1));'); addIdItem(get(scene[get(i)].name), get(scene[get(i)].title), get(itemcall)); ); &lt;/action&gt; &lt;!-- an action for updating the combobox when the scene was changed --&gt; &lt;action name=\"select_box_item\"&gt; if(plugin[box].loaded, plugin[box].selectIdItem(%1); , delayedcall(0.1, select_box_item(%1)); ); &lt;/action&gt; &lt;action name=\"floorvisible\"&gt; set(layer[map_container_mask].oy,5); set(layer[map_container_mask].height,100%); for(set(i,1);txtadd(floorname, 'floor', '_', get(i)), layer[get(floorname)], inc(i); txtadd(floorname, 'floor', '_', get(i)), set(layer[get(floorname)].visible, false); ); &lt;/action&gt; &lt;!-- set skin settings: bingmaps? gyro? thumbnail controlling? tooltips? --&gt; &lt;skin_settings bingmaps=\"false\" bingmaps_key=\"\" bingmaps_zoombuttons=\"false\" gyro=\"true\" thumbs_width=\"120\" thumbs_height=\"80\" thumbs_padding=\"10\" thumbs_crop=\"0|40|240|160\" thumbs_opened=\"false\" thumbs_text=\"false\" thumbs_dragging=\"true\" thumbs_onhoverscrolling=\"false\" thumbs_scrollbuttons=\"false\" thumbs_scrollindicator=\"false\" tooltips_thumbs=\"false\" tooltips_hotspots=\"false\" tooltips_mapspots=\"false\" controlbar_offset=\"20\" /&gt; &lt;!-- set optional skin logo url --&gt; &lt;layer name=\"skin_logo\" url=\"\" scale=\"0.25\" opened_onclick=\"openurl('...',_blank);\" /&gt; &lt;action name=\"startup\"&gt; if(startscene === null, copy(startscene,scene[0].name)); loadscene(get(startscene), null, MERGE); &lt;/action&gt; &lt;scene name=\"scene_1\" title=\"场景1\" onstart=\"\" thumburl=\"panos/3.tiles/thumb.jpg\" lat=\"\" lng=\"\" heading=\"\"&gt; &lt;view hlookat=\"0\" vlookat=\"0\" fovtype=\"MFOV\" fov=\"120\" maxpixelzoom=\"2.0\" fovmin=\"70\" fovmax=\"140\" limitview=\"auto\" /&gt; &lt;preview url=\"panos/3.tiles/preview.jpg\" /&gt; &lt;image type=\"CUBE\" multires=\"true\" tilesize=\"512\" progressive=\"false\"&gt; &lt;level tiledimagewidth=\"1910\" tiledimageheight=\"1910\"&gt; &lt;cube url=\"panos/3.tiles/%s/l3/%v/l3_%s_%v_%h.jpg\" /&gt; &lt;/level&gt; &lt;level tiledimagewidth=\"955\" tiledimageheight=\"955\"&gt; &lt;cube url=\"panos/3.tiles/%s/l2/%v/l2_%s_%v_%h.jpg\" /&gt; &lt;/level&gt; &lt;level tiledimagewidth=\"512\" tiledimageheight=\"512\"&gt; &lt;cube url=\"panos/3.tiles/%s/l1/%v/l1_%s_%v_%h.jpg\" /&gt; &lt;/level&gt; &lt;mobile&gt; &lt;cube url=\"panos/3.tiles/mobile_%s.jpg\" /&gt; &lt;/mobile&gt; &lt;/image&gt; &lt;!-- place your scene hotspots here --&gt; &lt;/scene&gt; &lt;scene name=\"scene_2\" title=\"场景2\" onstart=\"\" thumburl=\"panos/1.tiles/thumb.jpg\" lat=\"\" lng=\"\" heading=\"\"&gt; &lt;view hlookat=\"0\" vlookat=\"0\" fovtype=\"MFOV\" fov=\"120\" maxpixelzoom=\"2.0\" fovmin=\"70\" fovmax=\"140\" limitview=\"auto\" /&gt; &lt;preview url=\"panos/1.tiles/preview.jpg\" /&gt; &lt;image type=\"CUBE\" multires=\"true\" tilesize=\"512\" progressive=\"false\"&gt; &lt;level tiledimagewidth=\"955\" tiledimageheight=\"955\"&gt; &lt;cube url=\"panos/1.tiles/%s/l2/%v/l2_%s_%v_%h.jpg\" /&gt; &lt;/level&gt; &lt;level tiledimagewidth=\"512\" tiledimageheight=\"512\"&gt; &lt;cube url=\"panos/1.tiles/%s/l1/%v/l1_%s_%v_%h.jpg\" /&gt; &lt;/level&gt; &lt;mobile&gt; &lt;cube url=\"panos/1.tiles/mobile_%s.jpg\" /&gt; &lt;/mobile&gt; &lt;/image&gt; &lt;!-- place your scene hotspots here --&gt; &lt;/scene&gt; &lt;/krpano&gt; 历史文章krpano快速入门教程（一) 使用krpano工具构建即用型panoskrpano快速入门教程（二) vtour全景漫游及vtour文件夹介绍krpano快速入门教程（三）之热点Hotspot","tags":[{"name":"krpano","slug":"krpano","permalink":"http://11wy11.github.io/tags/krpano/"}]},{"title":"AE开发问题总结(一)","date":"2019-03-20T04:55:36.000Z","path":"2019/03/20/arcengine-second/","text":"今天本地运行项目，莫名其妙地报了个 尝试读取或写入受保护的内存，这通常指示其他内存已损坏！提供解决方案 AE 读Shp文件及查属性表等123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263 try&#123; bool flag = true; IWorkspaceFactory pWsFactory = new ShapefileWorkspaceFactoryClass(); IFeatureWorkspace pWorkSpace = pWsFactory.OpenFromFile(path, 0) as IFeatureWorkspace;//path为shp文件所在目录路径 IFeatureClass pFeatureClass = pWorkSpace.OpenFeatureClass(System.IO.Path.GetFileNameWithoutExtension(path));//OpenFeatureClass的参数为不带后缀的shp文件名 //检查属性 IFeatureLayer pFeatureLayer = new FeatureLayerClass(); pFeatureLayer.Name = pFeatureClass.AliasName; pFeatureLayer.FeatureClass = pFeatureClass; //查询 ,search的参数第一个为过滤条件，第二个为是否重复执行 IFeatureCursor pFeatureCursor = pFeatureLayer.Search(null, false); //获取查询到的要素 IFeature pFeature = pFeatureCursor.NextFeature(); string strFeatureClassName = (pFeatureClass as IDataset).Name; int fieldCount = pFeatureClass.Fields.FieldCount; else &#123; for (int i = 0; i &lt; fieldCount; ++i) &#123; //这段当时的需求是判断shp文件中是否有规定要求的字段， string fieldName = ConstantInfo.shpFields[i]; if (pFeatureClass.Fields.FindField(fieldName) == -1) &#123; //自定义函数，按照需要修改 flag = false; &#125; &#125; &#125; IFeature pTempFeature = pFeatureCursor.NextFeature(); int rowid = 0; while (null != pTempFeature) &#123; rowid++; for (int i = 0; i &lt; fieldCount; ++i) &#123; string str = Convert.ToString(pTempFeature.get_Value(i)); //空值检查 if (str == &quot;&quot;) &#123; /自定义函数，按照需要修改 flag = false; &#125; &#125; pTempFeature = pFeatureCursor.NextFeature(); &#125; Marshal.ReleaseComObject(pFeatureCursor); if (!flag) &#123; MainForm.isPassed = false; logger.Error(&quot;Error:&quot; + childNode.InnerText.Replace(&quot;%%&quot;, this.strPac) + &quot;shp文件属性等检查未通过\\n&quot;); &#125;&#125;catch (Exception e)&#123; //自定义函数，按照需要修改&#125;break; 尝试读取或写入受保护的内存，这通常指示其他内存已损坏【解决方法】以管理员的身份运行CMD 执行netsh winsock reset 然后提示你重新启动计算机 重启后错误就没有了 但这样太过复杂，没有从程序自身角度解决这个问题，继续查阅资料，最终找到了有效的方法，释放程序锁 最佳解决方法使用IWorkspaceFactoryLockControl接口的SchemaLockingEnabled和DisableSchemaLocking，分别获得工作空间锁状态，并关闭，具体代码如下：1234567IWorkspaceFactory pWsFactory = new ShapefileWorkspaceFactory();//关闭资源锁定 IWorkspaceFactoryLockControl ipWsFactoryLock = (IWorkspaceFactoryLockControl)pWsFactory;if (ipWsFactoryLock.SchemaLockingEnabled)&#123; ipWsFactoryLock.DisableSchemaLocking(); &#125; 错误原因分析 AE中非托管变量未释放，这些有Icursor，IFeatureCursor，IEnumStyleGalleryItem，IEnumBSTR，IStyleGallery；AGS里面有IServerContext等，释放方法System.Runtime.InteropServices.Marshal.ReleaseComObject(o);或者使用ESRI.ArcGIS.ADF.COMSupport.AOUninitialize.Shutdown() 参考：[1] https://blog.csdn.net/mattran/article/details/47149077 [2] https://blog.csdn.net/u011116642/article/details/17960135","tags":[{"name":"ArcEngine","slug":"ArcEngine","permalink":"http://11wy11.github.io/tags/ArcEngine/"},{"name":"VS","slug":"VS","permalink":"http://11wy11.github.io/tags/VS/"}]},{"title":"krpano学习笔记--干货","date":"2019-03-19T16:46:27.000Z","path":"2019/03/20/krpano-learn-note/","text":"介绍krpano开发中的一些注意事项和重要属性等 1.Krpano xml Onstartonstart事件将在xml加载和解析之后直接调用。 Basedirbasedir设置为所有下面的loadpano（）动作调用定义了基本目录。这可以是相对路径或绝对路径，也可以在这里使用 url占位符。默认值是％FIRSTXML％，这意味着所有下面的loadpano（）动作调用的所有相对xml路径都是相对于第一个加载的xml文件。 关于vars和initvars区别vars在加载xml后加载图像前赋值，而initvars在加载xml前赋值，一般用于构建url。由于get:variable或calc:variable中的变量值需要在加载xml中定义，所以使用vars不能在开始加载时控制krpano的某些设置，但是可以在之后动态的修改其显示状态。 Action: 参数/参数传递/解析当调用一个动作时，可以将参数/参数传递给它。为了访问参数/参数，有两种可能性： 通过占位符替换：（ 旧版本的方法） 可以使用从％0到％99形式的操作代码中的数字占位符来获取给定的参数。 其中％0是操作本身的名称， ％1表示第一个参数， ％2表示第二个参数，依此类推。 这些占位符可以在代码中的任何地方使用。 在实际的操作代码将被解析并执行之前，所有的占位符将被其参数值替换。 当给定的占位符不会有参数时，将使用值’null’。 要在动作中使用％字符，需要使用%% 通过参数到变量映射:( 推荐，新的） 对于具有本地作用域的操作，可以将args属性添加到&lt;action>元素。例如： &lt;action ... args =“var1，var2，var3”&gt; 在那里可以定义给定动作参数/参数的args属性变量名称（用逗号分隔）。 每个动作参数将被映射到本地作用域中的一个新变量，其名称是在args属性中设置的。 这些变量可以像操作代码中的任何其他变量一样正常使用（例如，通过get / calc / copy读取）。 当给定变量没有动作参数时，将使用值’null’。 处理包含引号或逗号字符的值时，使用变量映射非常有用。在这种情况下，正常的占位符替换可能会产生问题 注意 - 建议尽可能使用参数变量映射。没有％N占位符的动作可以在内部进行缓存，这使得进一步调用的执行速度更快。 值得注意的属性 Name属性：每个名字都需要以字母字符开头！这意味着不允许使用数字作为名字！当名称仍然以数字字符开头时，名称将被解释为数组索引。这对于动作内部基于动态索引的访问没有问题，但不能用于定义元素！所有名称将自动转换为小写字母，以便直接区分大小写访问！ URL属性：当一个相对路径被用作url值时，路径将被自动调整为相对于定义了url属性的xml文件。这意味着xml中的相对路径总是相对于xml本身，但是请注意 - 当动态设置/更改url属性时，则不再有与xml的自动关系！要使路径相对于某些特定的预定义路径，可以 在url路径中使用这些占位符中的一些：％FIRSTXML％ - 第一个加载的xml文件的路径。％CURRENTXML％ - 当前加载的主要xml文件的路径（不是包含的）。％SWFPATH％ - krpano查看器文件的路径。％HTMLPATH％ - html文件的路径。％BASEDIR％ - 使用basedir路径。％$ VARIABLE％ - 使用给定’VARIABLE’的值 - 这可以是任何krpano变量，但必须在加载当前xml或场景之前定义它，例如，在嵌入过程中（通过initvars）或在loadpano（），loadscene（）调用之前。 Style属性&lt;style>元素是任何类型属性的集合/存储元素。每个其他具有name属性的xml元素也可以有一个style属性。当xml元素首次被创建时，在&lt;style>元素处定义的所有属性将被复制到元素本身。这将在xml元素本身定义的属性被应用之前完成。这意味着可以在&lt;style>元素中预先定义一些设置，然后使用直接在元素上定义的属性稍后覆盖它们。 Get:|Calc方法当xml属性的值以get：或calc：开头时：在这种情况下，xml属性的值将从其他变量获取或使用表达式计算。在get：或calc：中使用的变量需要在当前xml元素之前（=上方）定义。此外，这里有一个特殊情况 - 在&lt;include>元素上使用它时，那么在那里使用的变量需要在当前xml加载之前定义。这可以在嵌入期间通过使用initvars设置或在xml中进行loadpano（）调用之前在html文件中完成。 Javascript krpano操作 （仅限HTML5）12345&lt;action name =“...” type =“ Javascript ” &gt; &lt;！[CDATA [ ... autorun =“” Javascript代码 ... ]]&gt; &lt;/ action&gt; Action type krpano操作的类型：type =“”（默认） - 正常krpano操作 - 适用于Flash和HTML5type =“Javascript” - JavaScript krpano操作 - 仅限HTML5 Action scope在操作中为新生成的变量定义范围：全局或未设置（默认）新变量将被添加到全局变量作用域中。其他任何行为或代码也可以使用它们。这在再使用变量名称时可能会有问题，特别是当变量类型在用法之间会有所不同时。本地新变量将被添加到仅存在于当前操作调用中的局部变量作用域中。当动作完成或调用其他动作时，局部作用域和其中定义的所有变量将不再可用。动作越复杂，它使用的临时变量越多，使用本地作用域进行此操作越有意义，以避免干扰其他动作的问题。设置LocalOnly有些作为scope = local，但区别在于，默认情况下，所有访问仅引用本地作用域本身。全局范围的访问只能由全局对象来实现。亲使用调用者的范围。当调用当前动作的动作具有局部范围时，则可以在当前动作中使用/访问该动作。私人：NAME为该操作定义一个私有本地范围。范围将由自定义的唯一名称进行参考。该范围在多个操作调用之间保持活动状态，并可以在多个操作中共享。有些作为范围= localonly所有访问只涉及本地范围本身。 笔记全局范围访问 - 搜索变量时，首先搜索本地范围，然后搜索全局范围。为了能够将变量添加到全局范围，即使在使用本地范围或直接访问全局范围内的变量时，也存在全局对象。本地范围访问 - 为了能够确保访问本地范围（例如，当可能已经存在具有相同名称的全局变量时定义本地变量），当前本地范围也可用作 操作代码中的本地对象。例如使用def（local.i，integer，0）; 定义一个名为’i’的局部整型变量。为了稍后访问动作代码，只需使用’i’来解决该变量就足够了。延期代码 - 稍后调用其他代码的操作（例如delayedcall，tween，asyncloop等）将使用与该代码中当前操作相同的范围。调用者范围 - 从插件/图层/热点事件调用的代码对于非localscope动作：当一个动作（或任何代码）将从plugin / layer / hotspot事件中被调用时，plugin / layer / hotspot对象本身也将作为搜索变量的范围。但仅限于访问现有的变量！新生成的变量将始终添加到全局范围中。对于localscope动作：在localscope动作中总是有预定义的局部变量调用者。当动作将从插件/图层/热点事件（或通过使用callwith）被调用时，那么该 调用者变量将引用该元素。否则，调用者变量将为空。 本地作用域操作中的 预定义变量：actionname - 当前操作的名称。args - 参数的值数组。访问者：args [index]。通过以下方式获取数字或参数：args.length。调用者 - 从那里调用插件/图层/热点对象，否则为null。全球 - 参考全球范围。本地 - 对当前本地范围本身的引用。parentscope - 父行为的范围引用，当没有父范围时，这指的是全局范围。","tags":[{"name":"krpano","slug":"krpano","permalink":"http://11wy11.github.io/tags/krpano/"}]},{"title":"VS2013/VS2015/VS2017下使用ArcEngine10.1/10.2（一）","date":"2019-03-19T07:51:40.000Z","path":"2019/03/19/arcengine-first/","text":"ArcObjects SDK for Microsoft .Net Framework 10.1或10.2在安装时，会检测VS2010或VS2012的安装路径，而有时因为其他项目使用限制而且不愿同时安装多个版本的VS,通过修改注册表方式实现安装 背景ArcObjects SDK for Microsoft .Net Framework 10.1或10.2在安装时，会检测VS2010或VS2012的安装路径，而有时因为其他项目使用限制而且不愿同时安装多个版本的VS,通过修改注册表方式实现安装 具体步骤1.修改注册表首先打开注册表，window系统可以通过win+R，输入regedit后，回车打开注册表 找到计算机\\HKEY_LOCAL_MACHINE\\SOFTWARE\\WOW6432Node\\Microsoft\\VisualStudio\\10.0，点击10.0文件夹，此时是没有InstallDir和ShellFolder两个字符串值 找到计算机\\HKEY_LOCAL_MACHINE\\SOFTWARE\\WOW6432Node\\Microsoft\\VisualStudio\\12.0,点击12.0文件夹，查看InstallDir值，并复制 回到10.0目录，右键新建->字符串值，新建InstallDir值，双击编辑值，将刚复制的粘贴 同样的处理，添加ShellFolder 2.安装ArcObjects SDK for Microsoft .Net Framework打开ArcGIS Desktop 或ArcEngine安装程序，找到ArcObjects SDK for Microsoft .Net Framework，点击安装，此时就不会提示要求VS2010或VS2012安装环境了，下面以ArcGIS Desktop 为例： 图1-安装 3. 在工具箱中添加ArcGIS相关组件由于通过修改注册表的方式安装的ArcObjects SDK for Microsoft .Net Framework，因此，可能会导致VS中没有ArcGIS相关工具，需要手动添加 打开VS2013,任意打开一个窗体，打开工具箱，会发现没有ArcGIS选项卡，因此，首先右键新建选项卡，然后右键，点击选择项,在.NET Framework组件下，找到下图所示的ArcGIS组件 图2-添加ArcGIS组件 方案1注意，如果在.NET Framework下找不到相关组件，可以点击浏览,找到ArcObjects SDK for Microsoft .Net Framework的安装目录下的DotNet，一般路径为D:\\Program Files (x86)\\ArcGIS\\DeveloperKit10.2\\DotNet如下图所示，可以按需添加，或者按住Shift全选添加。 图3-浏览组件dll 勾选需要的组件，点击确定后，在新建的选项卡下出现组件 红色框为新添加的.NET组件，上面两个是COM组件，暂时不需要使用，下节介绍.NET组件和COM组件的区别 方案2在Desktop安装目录的bin下找到需要的控件，以.ocx为后缀，选中后拖入工具箱 添加引用在不做任何手动操作时，安装了ArcGIS Desktop之后，可以在COM下的类型库中找到ArcGIS 相关的COM组件，如下图所示 图5-COM类型库中的ArcGIS相关组件 注意点击引用这些组件时，引用呈现下图所示结果： 图6-添加COM组件引用后 但会发现找不到Esri.ArcGIS.Version的库，而这个库必须在主函数入口处使用获得授权许可，之后才能使用ArcEngine中相关的类或接口。 因此，这里在添加引用是选择.NET组件，点击浏览找到ArcObjects SDK for Microsoft .Net Framework的安装目录下的DotNet，一般路径为D:\\Program Files (x86)\\ArcGIS\\DeveloperKit10.2\\DotNet如下图所示，选择Esri.ArcGIS.Version.dll，其他库VS会根据需要自动引用。如上图图3所示.注意点击引用这些组件时，引用呈现下图所示结果： 图7-添加NET组件引用后 Program.cs中授权在Main函数中添加 ESRI.ArcGIS.RuntimeManager.Bind(ESRI.ArcGIS.ProductCode.EngineOrDesktop);,如下图所示 图8-添加授权 直至就可以在一个应用程序中使用ArcEngine的功能了。 当然如果你想使用VS创建ArcGIS模板应用程序，此时你会发现Visual C#下没有ArcGIS选项，这时又需要我们手动添加了 图9-手动安装之前 手动添加ArcGIS项目模板由于我们最开始安装SDK时，采用了修改注册表的方式骗过ArcObject检测，因此，模板默认安装在了但是设置的VS2013安装路径Microsoft Visio Studio 12.0下了 将模板拷贝至vs模板库中找到D:\\Program Files (x86)\\Microsoft Visual Studio 12.0\\Microsoft Visual Studio 10.0，在Common7/IDE下有两个文件夹ItemTemplates/CSharp/ArcGIS,ProjectTemplates/CSharp/ArcGIS,分别拷贝在vs2013模板文件位置，如：D:\\Program Files (x86)\\Microsoft Visual Studio 12.0\\Common7\\IDE\\ItemTemplates\\CSharp和I:\\Program Files (x86)\\Microsoft Visual Studio 12.0\\Common7\\IDE\\ProjectTemplates\\CSharp 右键，以管理员权限运行vs2013,也就是启动vs2013 重新安装一次模板 打开vs2013/2015的命令行工具 2013： 开始–&gt; 所有应用 –&gt; Microsoft Visual Studio 2013 –&gt; Visual Studio Tools,打开后 vs2013开发人员命令提示 2015或更高： 开始–&gt; 所有应用 –&gt; Microsoft Visual Studio 2015 –&gt; vs2015开发人员命令提示（可能会叫Visual Studio 2015 Command Prompt ） 执行如下命令devenv.exe/InstallVSTemplates需要注意的事情是，这个命令执行后，不会马上出现项目或项模板，需要重新打开vs2017，新建时会重新初始化模板。 如果第三步有问题，换成用管理员权限运行。 效果C#下出现ArcGIS相关模板","tags":[{"name":"ArcEngine","slug":"ArcEngine","permalink":"http://11wy11.github.io/tags/ArcEngine/"},{"name":"VS","slug":"VS","permalink":"http://11wy11.github.io/tags/VS/"}]},{"title":"GDAL简介","date":"2019-03-18T07:26:26.000Z","path":"2019/03/18/cpp-gdal/","text":"GDAL(Geospatial Data Abstraction Library)是一个在X/MIT许可协议下的开源栅格空间数据转换库持续更新中Table of Contents generated with DocToc 简介 功能特征 OGR体系结构编辑 GDAL中OGR的使用 读数据 写数据 参考资料： 简介它利用抽象数据模型来表达所支持的各种文件格式。它还有一系列命令行工具来进行数据转换和处理。 OGR是GDAL项目的一个分支，功能与GDAL类似，只不过它提供对矢量数据的支持。 有很多著名的GIS类产品都使用了GDAL/OGR库，包括ESRI的ARCGIS 9.3，Google Earth和跨平台的GRASS GIS系统。利用GDAL/OGR库，可以使基于Linux的地理空间数据管理系统提供对矢量和栅格文件数据的支持。 功能特征GDAL提供对多种栅格数据的支持，包括Arc/Info ASCII Grid(asc)，GeoTiff (tiff)，Erdas Imagine Images(img)，ASCII DEM(dem) 等格式。 GDAL使用抽象数据模型(abstract data model)来解析它所支持的数据格式，抽象数据模型包括数据集(dataset)，坐标系统，仿射地理坐标转换(Affine Geo Transform)， 大地控制点(GCPs)， 元数据(Metadata)，栅格波段(Raster Band)，颜色表(Color Table)，子数据集域(Subdatasets Domain)，图像结构域(Image_Structure Domain)，XML域(XML:Domains)。 GDALMajorObject类：带有元数据的对象。 GDALDdataset类：通常是从一个栅格文件中提取的相关联的栅格波段集合和这些波段的元数据;GDALDdataset也负责所有栅格波段的地理坐标转换(georeferencing transform)和坐标系定义。 GDALDriver类：文件格式驱动类，GDAL会为每一个所支持的文件格式创建一个该类的实体，来管理该文件格式。 GDALDriverManager类：文件格式驱动管理类，用来管理GDALDriver类。 OGR体系结构编辑Geometry类：Geometry (包括OGRGeometry等类)封装了OpenGIS的矢量数据模型，并提供了一些几何操作，WKB(Well Knows Binary)和WKT(Well Known Text)格式之间的相互转换，以及空间参考系统(投影)。 Spatial Reference类：OGRSpatialReference封装了投影和基准面的定义。 Feature类：OGRFeature封装了一个完整feature的定义，一个完整的feature包括一个geometry和geometry的一系列属性。 Feature Definition类：OGRFeatureDefn里面封装了feature的属性，类型、名称及其默认的空间参考系统等。一个OGRFeatureDefn对象通常与一个层(layer)对应。 Layer类：OGRLayer是一个抽象基类，表示数据源类OGRDataSource里面的一层要素(feature)。 Data Source类：OGRDataSource是一个抽象基类，表示含有OGRLayer对象的一个文件或一个数据库。 Drivers类：OGRSFDriver对应于每一个所支持的矢量文件格式。类OGRSFDriver由类OGRSFDriverRegistrar来注册和管理。 GDAL中OGR的使用读数据 在工程的Library files中和Include files中分别添加GDAL的LIB文件目录和头文件目录 最初需要注册所需的所有格式驱动程序。这通常通过调用GDALAllRegister（）来完成，该寄存器注册GDAL / OGR中内置的所有格式驱动程序。 接下来我们需要打开输入OGR数据源。数据源可以是文件，RDBMS，充满文件的目录，甚至是远程Web服务，具体取决于所使用的驱动程序。但是，数据源名称始终是单个字符串。在这种情况下，我们硬编码打开一个特定的shapefile。第二个参数（GDAL_OF_VECTOR）告诉OGROpen（）方法我们想要使用向量驱动程序并且不需要更新访问。失败时返回NULL，我们报告错误。 GDALDataset可以潜在地具有与它相关联的许多层。可以使用GDALDataset :: GetLayerCount（）查询可用的图层数，并使用GDALDataset :: GetLayer（）通过索引获取各个图层。但是，我们只是按名称获取图层。 OGRLayer * poLayer; poLayer = poDS-&gt; GetLayerByName（“point”）; 现在我们要开始从图层中读取要素。在我们开始之前，我们可以为图层指定属性或空间过滤器以限制我们获取的功能集，但是现在我们有兴趣获取所有功能。 我们使用OGRLayer :: GetNextFeature（）遍历图层中的所有要素。当我们用完功能时它会返回NULL。 1234OGRFeature *poFeature;poLayer-&gt;ResetReading();while( (poFeature = poLayer-&gt;GetNextFeature()) != NULL )&#123; 为了转储该功能的所有属性字段，获取OGRFeatureDefn会很有帮助。这是与图层关联的对象，包含所有字段的定义。我们遍历所有字段，并根据其类型获取和报告属性。 123456789101112131415161718192021for( auto&amp;&amp; oField: *poFeature )&#123; switch( oField.GetType() ) &#123; case OFTInteger: printf( &quot;%d,&quot;, oField.GetInteger() ); break; case OFTInteger64: printf( CPL_FRMT_GIB &quot;,&quot;, oField.GetInteger64() ); break; case OFTReal: printf( &quot;%.3f,&quot;, oField.GetDouble() ); break; case OFTString: printf( &quot;%s,&quot;, oField.GetString() ); break; default: printf( &quot;%s,&quot;, oField.GetAsString() ); break; &#125;&#125; 除了上面显式处理的字段类型之外，还有一些字段类型，但可以使用OGRFeature :: GetFieldAsString（）方法获取它们的合理表示。事实上，我们可以通过对所有类型使用OGRFeature :: GetFieldAsString（）来缩短上述内容。 接下来，我们要从要素中提取几何体，并写出点几何体x和y。几何图形作为通用OGRGeometry指针返回。然后我们确定特定的几何类型，如果它是一个点，我们将其转换为点并对其进行操作。如果它是别的东西我们写占位符。 12345678910111213141516 OGRGeometry *poGeometry; poGeometry = poFeature-&gt;GetGeometryRef(); if( poGeometry != NULL &amp;&amp; wkbFlatten(poGeometry-&gt;getGeometryType()) == wkbPoint ) &#123;#if GDAL_VERSION_NUM &gt;= GDAL_COMPUTE_VERSION(2,3,0) OGRPoint *poPoint = poGeometry-&gt;toPoint();#else OGRPoint *poPoint = (OGRPoint *) poGeometry;#endif printf( &quot;%.3f,%3.f\\n&quot;, poPoint-&gt;getX(), poPoint-&gt;getY() ); &#125; else &#123; printf( &quot;no point geometry\\n&quot; ); &#125; 所述wkbFlatten（）宏上述用于将类型转换为一个wkbPoint25D（带z坐标的点）到2D的类型代码（wkbPoint）。对于每个2D几何类型，都有相应的2.5D类型代码。2D和2.5D几何案例由相同的C ++类处理，因此我们的代码将正确处理2D或3D案例。 12345678910111213141516171819202122OGRGeometry *poGeometry; int iGeomField; int nGeomFieldCount; nGeomFieldCount = poFeature-&gt;GetGeomFieldCount(); for(iGeomField = 0; iGeomField &lt; nGeomFieldCount; iGeomField ++ ) &#123; poGeometry = poFeature-&gt;GetGeomFieldRef(iGeomField); if( poGeometry != NULL &amp;&amp; wkbFlatten(poGeometry-&gt;getGeometryType()) == wkbPoint ) &#123; #if GDAL_VERSION_NUM &gt;= GDAL_COMPUTE_VERSION(2,3,0) OGRPoint *poPoint = poGeometry-&gt;toPoint(); #else OGRPoint *poPoint = (OGRPoint *) poGeometry; #endif printf( &quot;%.3f,%3.f\\n&quot;, poPoint-&gt;getX(), poPoint-&gt;getY() ); &#125; else &#123; printf( &quot;no point geometry\\n&quot; ); &#125; &#125; 请注意，OGRFeature :: GetGeometryRef（）和OGRFeature :: GetGeomFieldRef（）返回指向OGRFeature所拥有的内部几何的指针。实际上没有删除返回几何。 对于GDAL &lt;2.3，因为OGRLayer :: GetNextFeature（）方法返回现在由我们拥有的功能的副本。因此，在使用结束时，我们必须释放该功能。我们可以“删除”它，但这可能会导致Windows版本中的问题，其中GDAL DLL与主程序具有不同的“堆”。为了安全起见，我们使用GDAL功能删除该功能。 OGRFeature :: DestroyFeature（poFeature）;} 该OGRLayer通过返回的GDALDataset :: GetLayerByName（）也是由拥有一个内部层参考的GDALDataset所以我们并不需要将其删除。但我们确实需要删除数据源才能关闭输入文件。我们再一次使用自定义删除方法来避免特殊的win32堆问题。 GDALClose（poDS）; } 完整模板 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &quot;ogrsf_frmts.h&quot;int main()&#123; GDALAllRegister(); GDALDataset *poDS = static_cast&lt;GDALDataset*&gt;( GDALOpenEx( &quot;point.shp&quot;, GDAL_OF_VECTOR, NULL, NULL, NULL )); if( poDS == NULL ) &#123; printf( &quot;Open failed.\\n&quot; ); exit( 1 ); &#125; OGRLayer *poLayer = poDS-&gt;GetLayerByName( &quot;point&quot; ); OGRFeatureDefn *poFDefn = poLayer-&gt;GetLayerDefn(); poLayer-&gt;ResetReading(); OGRFeature *poFeature; while( (poFeature = poLayer-&gt;GetNextFeature()) != NULL ) &#123; for( int iField = 0; iField &lt; poFDefn-&gt;GetFieldCount(); iField++ ) &#123; OGRFieldDefn *poFieldDefn = poFDefn-&gt;GetFieldDefn( iField ); switch( poFieldDefn-&gt;GetType() ) &#123; case OFTInteger: printf( &quot;%d,&quot;, poFeature-&gt;GetFieldAsInteger( iField ) ); break; case OFTInteger64: printf( CPL_FRMT_GIB &quot;,&quot;, poFeature-&gt;GetFieldAsInteger64( iField ) ); break; case OFTReal: printf( &quot;%.3f,&quot;, poFeature-&gt;GetFieldAsDouble(iField) ); break; case OFTString: printf( &quot;%s,&quot;, poFeature-&gt;GetFieldAsString(iField) ); break; default: printf( &quot;%s,&quot;, poFeature-&gt;GetFieldAsString(iField) ); break; &#125; &#125; OGRGeometry *poGeometry = poFeature-&gt;GetGeometryRef(); if( poGeometry != NULL &amp;&amp; wkbFlatten(poGeometry-&gt;getGeometryType()) == wkbPoint ) &#123; OGRPoint *poPoint = (OGRPoint *) poGeometry; printf( &quot;%.3f,%3.f\\n&quot;, poPoint-&gt;getX(), poPoint-&gt;getY() ); &#125; else &#123; printf( &quot;no point geometry\\n&quot; ); &#125; OGRFeature::DestroyFeature( poFeature ); &#125; GDALClose( poDS );&#125; 写数据 作为通过OGR写作的一个例子，我们将大致与上述相反。从输入文本中读取逗号分隔值的短程序将通过OGR写入点shapefile。 1. 像往常一样，我们首先注册所有驱动程序，然后获取Shapefile驱动程序，因为我们需要它来创建输出文件。 123456789101112#include &quot;ogrsf_frmts.h&quot;int main()&#123; const char *pszDriverName = &quot;ESRI Shapefile&quot;; GDALDriver *poDriver; GDALAllRegister(); poDriver = GetGDALDriverManager()-&gt;GetDriverByName(pszDriverName ); if( poDriver == NULL ) &#123; printf( &quot;%s driver not available.\\n&quot;, pszDriverName ); exit( 1 ); &#125; 2. 接下来我们创建数据源。ESRI Shapefile驱动程序允许我们创建一个完整的shapefile目录，或一个shapefile作为数据源。在这种情况下，我们将通过在名称中包含扩展名来显式创建单个文件。其他驱动程序表现不同。第二个，第三个，第四个和第五个参数与栅格尺寸相关（如果驱动程序具有栅格功能）。调用的最后一个参数是选项值列表，但在这种情况下我们将只使用默认值。支持的选项的详细信息也是特定于格式的。 1234567GDALDataset *poDS;poDS = poDriver-&gt;Create( &quot;point_out.shp&quot;, 0, 0, 0, GDT_Unknown, NULL );if( poDS == NULL )&#123; printf( &quot;Creation of output file failed.\\n&quot; ); exit( 1 );&#125; 3. 现在我们创建输出层。在这种情况下，由于数据源是单个文件，因此我们只能有一个图层。我们传递wkbPoint来指定该层支持的几何类型。在这种情况下，我们不传递任何坐标系信息或其他特殊图层创建选项。 1234567OGRLayer *poLayer;poLayer = poDS-&gt;CreateLayer( &quot;point_out&quot;, NULL, wkbPoint, NULL );if( poLayer == NULL )&#123; printf( &quot;Layer creation failed.\\n&quot; ); exit( 1 );&#125; 4. 现在该图层已存在，我们需要创建应出现在图层上的任何属性字段。必须在写入任何要素之前将字段添加到图层。要创建字段，我们使用有关字段的信息初始化OGRField对象。在Shapefiles的情况下，字段宽度和精度在创建输出.dbf文件时很重要，所以我们专门设置它，尽管通常默认值是OK。对于此示例，我们将只有一个属性，一个与x，y点关联的名称字符串。 请注意，我们传递给CreateField（）的模板OGRField是在内部复制的。我们保留对象的所有权。 12345678910111213OGRFieldDefn oField（“Name”，OFTString）;oField.SetWidth（32）;if（poLayer-&gt; CreateField（＆oField）！= OGRERR_NONE）&#123; printf（“创建名称字段失败。\\ n”）; 退出（1）;&#125;//通过读数据中的x,y,name，写入double x, y; char szName[33]; while( !feof(stdin) &amp;&amp; fscanf( stdin, &quot;%lf,%lf,%32s&quot;, &amp;x, &amp;y, szName ) == 3 ) &#123; 5. 要将功能写入磁盘，我们必须创建本地OGRFeature，设置属性并附加几何体，然后再尝试将其写入图层。必须从与要写入的层关联的OGRFeatureDefn实例化此功能。 123OGRFeature * poFeature;poFeature = OGRFeature :: CreateFeature（poLayer-&gt; GetLayerDefn（））;poFeature-&gt; SetField（“Name”，szName）; 6. 我们创建一个本地几何对象，并将其副本（间接）分配给该功能。的和OGRFeature :: SetGeometryDirectly（）不同于和OGRFeature :: SetGeometry（）在该直接方法给出了几何形状的特征的所有权。这通常更有效，因为它避免了几何体的额外深层对象副本。 1234OGRPoint pt;pt.setX( x );pt.setY( y );poFeature-&gt;SetGeometry( &amp;pt ); 7. 现在我们在文件中创建一个功能。该OGRLayer :: CreateFeature（）不走我们的特点的所有权，所以我们在用它做清理。 1234567 if( poLayer-&gt;CreateFeature( poFeature ) != OGRERR_NONE ) &#123; printf( &quot;Failed to create feature in shapefile.\\n&quot; ); exit( 1 ); &#125; OGRFeature::DestroyFeature( poFeature );&#125; 8. 最后，我们需要关闭数据源，以确保以有序的方式写出标头，并恢复所有资源。`GDALClose（poDS）;}` 9. 模板 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &quot;ogrsf_frmts.h&quot;int main()&#123; const char *pszDriverName = &quot;ESRI Shapefile&quot;; GDALDriver *poDriver; GDALAllRegister(); poDriver = GetGDALDriverManager()-&gt;GetDriverByName(pszDriverName ); if( poDriver == NULL ) &#123; printf( &quot;%s driver not available.\\n&quot;, pszDriverName ); exit( 1 ); &#125; GDALDataset *poDS; poDS = poDriver-&gt;Create( &quot;point_out.shp&quot;, 0, 0, 0, GDT_Unknown, NULL ); if( poDS == NULL ) &#123; printf( &quot;Creation of output file failed.\\n&quot; ); exit( 1 ); &#125; OGRLayer *poLayer; poLayer = poDS-&gt;CreateLayer( &quot;point_out&quot;, NULL, wkbPoint, NULL ); if( poLayer == NULL ) &#123; printf( &quot;Layer creation failed.\\n&quot; ); exit( 1 ); &#125; OGRFieldDefn oField( &quot;Name&quot;, OFTString ); oField.SetWidth(32); if( poLayer-&gt;CreateField( &amp;oField ) != OGRERR_NONE ) &#123; printf( &quot;Creating Name field failed.\\n&quot; ); exit( 1 ); &#125; double x, y; char szName[33]; while( !feof(stdin) &amp;&amp; fscanf( stdin, &quot;%lf,%lf,%32s&quot;, &amp;x, &amp;y, szName ) == 3 ) &#123; OGRFeature *poFeature; poFeature = OGRFeature::CreateFeature( poLayer-&gt;GetLayerDefn() ); poFeature-&gt;SetField( &quot;Name&quot;, szName ); OGRPoint pt; pt.setX( x ); pt.setY( y ); poFeature-&gt;SetGeometry( &amp;pt ); if( poLayer-&gt;CreateFeature( poFeature ) != OGRERR_NONE ) &#123; printf( &quot;Failed to create feature in shapefile.\\n&quot; ); exit( 1 ); &#125; OGRFeature::DestroyFeature( poFeature ); &#125; GDALClose( poDS );&#125; 参考资料： 百度百科：https://baike.baidu.com/item/GDAL/4004525?fr=aladdin 官方网站：https://www.gdal.org/","tags":[{"name":"GDAL","slug":"GDAL","permalink":"http://11wy11.github.io/tags/GDAL/"}]},{"title":"常用工具","date":"2019-03-18T04:46:05.000Z","path":"2019/03/18/tools/","text":"主要介绍doctoc插件自动生成文章目录 markdown相关doctoc(markdown目录自动生成)GitHub中的markdown文件直接写[TOC]是无法生成目录的，可以使用工具doctocnpm install -g doctoc使用方式 对当前文件夹中所有文件生成目录e.g. 1234567 cd D:\\Develop\\Documents\\Notes\\CSDN笔记\\temp doctoc . ``` + 对文件夹中单个文件生成目录（文件名中间不能有空格） `doctoc /path/to/file [...]` 如： doctoc README.md doctoc CONTRIBUTING.md LICENSE.md doctoc D:\\Develop\\Documents\\Notes\\CSDN笔记\\JAVARxJava.md `","tags":[{"name":"tools","slug":"tools","permalink":"http://11wy11.github.io/tags/tools/"}]},{"title":"AI组件开发（二）--AIRealMathSuite","date":"2019-03-18T02:50:27.000Z","path":"2019/03/18/ai-second-note/","text":"主要介绍AIRealMathSuite中使用到的函数，以及部分应用场景，持续更新中 AIRealRectOverlapAIAPI AIBoolean(* AIRealMathSuite::AIRealRectOverlap)(const AIRealRect *a, const AIRealRect *b)Tests whether two rectangles overlap (have any points in common).测试两个矩形是否重叠（有任何共同点） 参数: aThe first rectangle. bThe second rectangle. 返回值：如果矩形重叠，则为真。 AIRealRectInAIRealRectAIAPI AIBoolean(* AIRealMathSuite::AIRealRectInAIRealRect)(const AIRealRect *a, const AIRealRect *b)Tests whether one rectangle is inside (entirely contained in) another rectangle.测试一个矩形是否在另一个矩形内（完全包含在内）。 Both must be open or both closed.两者都必须是开放的或都是封闭的。 参数: aThe first rectangle. bThe second rectangle. 返回值：True if the set of points contained by a is also contained by b.如果a包含的点集也包含在b内，则为真。 AIRealRectSetAIAPI void(* AIRealMathSuite::AIRealRectSet)(AIRealRect *a, AIReal left, AIReal top, AIReal right, AIReal bottom)Sets the coordinate values in a rectangle. 设置矩形中的坐标值(In the Illustrator art coordinate system, the origin, (0, 0), is at the bottom left corner of a page. X and Y values increase upward and to the right.) 参数: aThe rectangle object. ///AI的矩形对象指针 leftThe left side location.///xmin topThe top side location. ///ymax rightThe right side location.///xmax bottomThe bottom side location.///ymin 注意：Illustrator的坐标系原点位于页面左下角，X和Y值向上和向右增加。 AIRealPointInterpolateAIAPI void（* AIRealMathSuite :: AIRealPointInterpolate）（const AIRealPoint * a，const AIRealPoint * b，AIReal t，AIRealPoint * result）通过在点的相应坐标之间插入新坐标值来计算两点之间的点的位置。原理就是向量结果是 a t + b (1-t) 参数：a 第一点。b 第二点。t（b-a）的百分比，表示为0到1之间的数字。result [out]用于返回结果的缓冲区。 参考资料 Adobe Illustrator SDK，下载地址：https://www.adobe.com/devnet/illustrator/sdk.html 相关文章AI组件开发（一）–注记旋转矩阵AI组件开发（二）–AIRealMathSuiteAI组件开发（三）–AIArtboardSuiteAI组件开发（四）–AIDocumentSuiteAI组件开发（五）–AILayerSuiteAI组件开发（六）–AIArtSuiteAI组件开发（七）–AIPathSuite&amp;&amp;AIPathfinderSuiteAI组件开发（八）–AIArtStyleSuite","tags":[{"name":"AI","slug":"AI","permalink":"http://11wy11.github.io/tags/AI/"}]},{"title":"markdown编写技巧","date":"2019-03-17T13:33:53.000Z","path":"2019/03/17/markdown-first-skill/","text":"markdown编写技巧,转义字符及部分基本语法 常用转义字符 \\\\ 反斜杠 \\` 反引号 \\* 星号 \\_ 下划线 \\{\\} 大括号 \\[\\] 中括号 \\(\\) 小括号 \\# 井号 \\+ 加号 \\- 减号 \\. 英文句号 \\! 感叹号也可以用ASCII码代替 1 2 3 4 基本用法 标题设置（让字体变大，和word的标题意思一样）在Markdown当中设置标题，有两种方式：第一种：通过在文字下方添加“=”和“-”，他们分别表示一级标题和二级标题。第二种：在文字开头加上 “#”，通过“#”数量表示几级标题。（一共只有1~6级标题，1级标题字体最大） 块注释（blockquote）通过在文字开头添加“&gt;”表示块注释。（当&gt;和文字之间添加五个blank时，块注释的文字会有变化。） 斜体将需要设置为斜体的文字两端使用1个“*”或者“_”夹起来 粗体将需要设置为斜体的文字两端使用2个“*”或者“_”夹起来 无序列表在文字开头添加(*, +, and -)实现无序列表。但是要注意在(*, +, and -)和文字之间需要添加空格。（建议：一个文档中只是用一种无序列表的表示方式） 有序列表使用数字后面跟上句号。（还要有空格） 链接（Links）Markdown中有两种方式，实现链接，分别为内联方式和引用方式。内联方式：This is an [example link](http://example.com/).引用方式：I get 10 times more traffic from [Google][1] than from [Yahoo][2] or [MSN][3]. [1]: http://google.com/ “Google”[2]: http://search.yahoo.com/ “Yahoo Search”[3]: http://search.msn.com/ “MSN Search” 图片（Images）图片的处理方式和链接的处理方式，非常的类似。内联方式：![alt text](/path/to/img.jpg “Title”)引用方式：![alt text][id] [id]: /path/to/img.jpg “Title” 代码（HTML中所谓的Code）实现方式有两种：第一种：简单文字出现一个代码框。使用&lt;blockquote&gt;。（不是单引号而是左上角的ESC下面~中的）第二种：大片文字需要实现代码框。使用Tab和四个空格。 脚注（footnote）实现方式如下：hello[^hello] 下划线在空白行下方添加三条“-”横线。（前面讲过在文字下方添加“-”，实现的2级标题）参考官方文档http://daringfireball.net/projects/markdown/basics","tags":[{"name":"markdown","slug":"markdown","permalink":"http://11wy11.github.io/tags/markdown/"}]},{"title":"sqlite数据库查询 C++函数","date":"2019-03-17T13:17:22.000Z","path":"2019/03/17/sqlite-first-note/","text":"sqlite部分函数简介主要有打开数据库连接，执行数据库查询语句，关闭连接等函数 sqlite3_open用法打开数据库链接sqlite3_open用法原型：1234int sqlite3_open( const char *filename, /* Database filename (UTF-8) */ sqlite3 **ppDb /* OUT: SQLite db handle */); 用这个函数开始数据库操作。需要传入两个参数，一是数据库文件名，比如：E:/test.db。文件名不需要一定存在，如果此文件不存在，sqlite会自动建立它。如果它存在，就尝试把它当数据库文件来打开。二是sqlite3**，即前面提到的关键数据结构。函数返回值表示操作是否正确，如果是SQLITE_OK则表示操作正常。相关的返回值sqlite定义了一些宏。具体这些宏的含义可以参考sqlite3.h 文件。里面有详细定义。 sqlite3_close用法关闭数据库链接原型：1int sqlite3_close(sqlite3 *ppDb); ppDb为刚才使用sqlite3_open打开的数据库链接 sqlite3_exec用法执行sql操作原型：1234567int sqlite3_exec( sqlite3* ppDb, /* An open database */ const char *sql, /* SQL to be evaluated */ int (*callback)(void*,int,char**,char**), /* Callback function */ void *, /* 1st argument to callback */ char **errmsg /* Error msg written here */); 这就是执行一条sql 语句的函数。第1个参数不再说了，是前面open函数得到的指针。第2个参数constchar*sql是一条sql 语句，以\\0结尾。第3个参数sqlite3_callback 是回调，当这条语句执行之后，sqlite3会去调用你提供的这个函数。第4个参数void*是你所提供的指针，你可以传递任何一个指针参数到这里，这个参数最终会传到回调函数里面，如果不需要传递指针给回调函数，可以填NULL。回调函数的写法，以及这个参数的使用在之后介绍。第5个参数char** errmsg 是错误信息。注意是指针的指针。sqlite3里面有很多固定的错误信息。执行sqlite3_exec 之后，执行失败时可以查阅这个指针（直接cout&lt;&lt;errmsg得到一串字符串信息，这串信息告诉你错在什么地方。sqlite3_exec函数通过修改你传入的指针的指针，把你提供的指针指向错误提示信息，这样sqlite3_exec函数外面就可以通过这个char*得到具体错误提示。说明：通常，sqlite3_callback 和它后面的void*这两个位置都可以填NULL。填NULL表示你不需要回调。比如你做insert 操作，做delete操作，就没有必要使用回调。而当你做select 时，就要使用回调，因为sqlite3 把数据查出来，得通过回调告诉你查出了什么数据。exec 的回调typedef int(*sqlite3_callback)(void*,int,char**,char**);你的回调函数必须定义成上面这个函数的类型。下面给个简单的例子：123456789//sqlite3的回调函数//sqlite 每查到一条记录，就调用一次这个回调int LoadMyInfo(void* para,intn_column,char** column_value,char** column_name);//para是你在sqlite3_exec 里传入的void*参数通过para参数，你可以传入一些特殊的指针（比如类指针、结构指针），//然后在这里面强制转换成对应的类型（这里面是void*类型，必须强制转换成你的类型才可用）。然后操作这些数据//n_column是这一条记录有多少个字段(即这条记录有多少列)//char** column_value 是个关键值，查出来的数据都保存在这里，它实际上是个1维数组（不要以为是2维数组），//每一个元素都是一个char*值，是一个字段内容（用字符串来表示，以\\0结尾）//char** column_name 跟column_value是对应的，表示这个字段的字段名称 实例：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;iostream&gt;using namespace std;#include &quot;sqlite/sqlite3.h&quot;int callback(void*,int,char**,char**);int main()&#123; sqlite3* db; int nResult = sqlite3_open(&quot;test.db&quot;,&amp;db); if (nResult != SQLITE_OK) &#123; cout&lt;&lt;&quot;打开数据库失败：&quot;&lt;&lt;sqlite3_errmsg(db)&lt;&lt;endl; return 0; &#125; else &#123; cout&lt;&lt;&quot;数据库打开成功&quot;&lt;&lt;endl; &#125; char* errmsg; nResult = sqlite3_exec(db,&quot;create table fuck(id integer primary key autoincrement,name varchar(100))&quot;,NULL,NULL,&amp;errmsg); if (nResult != SQLITE_OK) &#123; sqlite3_close(db); cout&lt;&lt;errmsg; sqlite3_free(errmsg); return 0; &#125; string strSql; strSql+=&quot;begin;\\n&quot;; for (int i=0;i&lt;100;i++) &#123; strSql+=&quot;insert into fuck values(null,&apos;heh&apos;);\\n&quot;; &#125; strSql+=&quot;commit;&quot;; //cout&lt;&lt;strSql&lt;&lt;endl; nResult = sqlite3_exec(db,strSql.c_str(),NULL,NULL,&amp;errmsg); if (nResult != SQLITE_OK) &#123; sqlite3_close(db); cout&lt;&lt;errmsg&lt;&lt;endl; sqlite3_free(errmsg); return 0; &#125; strSql = &quot;select * from fuck&quot;; nResult = sqlite3_exec(db,strSql.c_str(),callback,NULL,&amp;errmsg); if (nResult != SQLITE_OK) &#123; sqlite3_close(db); cout&lt;&lt;errmsg&lt;&lt;endl; sqlite3_free(errmsg); return 0; &#125; sqlite3_close(db); return 0;&#125;int callback(void* ,int nCount,char** pValue,char** pName)&#123; string s; for(int i=0;i&lt;nCount;i++) &#123; s+=pName[i]; s+=&quot;:&quot;; s+=pValue[i]; s+=&quot;\\n&quot;; &#125; cout&lt;&lt;s&lt;&lt;endl; return 0;&#125;","tags":[{"name":"sqlite","slug":"sqlite","permalink":"http://11wy11.github.io/tags/sqlite/"},{"name":"C++","slug":"C","permalink":"http://11wy11.github.io/tags/C/"}]},{"title":"C++部分基础知识","date":"2019-03-17T06:09:53.000Z","path":"2019/03/17/cpp-function/","text":"介绍项目中用到的一些常用函数和关键字的使用Table of Contents generated with DocToc 常用函数 1. strtok 2.strcmp 3. Erase 4. List 5. strcpy 6.转换函数 6.1 Atoi 关键字 extern 变量 函数 编译链接 声明外部变量 C++中extern c的深层探索 常用函数1. strtok 分解字符串为一组字符串。s为要分解的字符，delim为分隔符字符（如果传入字符串，则传入的字符串中每个字符均为分割符）。首次调用时，s指向要分解的字符串，之后再次调用要把s设成NULL。 例如：strtok(“abc,def,ghi”,”,”)，最后可以分割成为abc def ghi.尤其在点分十进制的IP中提取应用较多。strtok的函数原型为char strtok(char s, char *delim)，功能为“Parse S into tokens separated by characters in DELIM.If S is NULL, the saved pointer in SAVE_PTR is used as the next starting point. ” 翻译成汉语就是：作用于字符串s，以包含在delim中的字符为分界符，将s切分成一个个子串；如果，s为空值NULL，则函数保存的指针SAVE_PTR在下一次调用中将作为起始位置。123456789101112131415#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;int main()&#123; char sentence[]=&quot;This is a sentence with 7 tokens&quot;; cout &lt;&lt; &quot;The string to be tokenized is:\\n&quot; &lt;&lt; sentence &lt;&lt; &quot;\\n\\nThe tokens are:\\n\\n&quot;; char *tokenPtr=strtok(sentence,&quot; &quot;); while(tokenPtr!=NULL) &#123; cout&lt;&lt;tokenPtr&lt;&lt;endl; tokenPtr=strtok(NULL,&quot; &quot;); &#125; //cout &lt;&lt; &quot;After strtok,sentence=&quot; &lt;&lt; tokenPtr&lt;&lt;endl; return 0;&#125; 函数第一次调用需设置两个参数。第一次分割的结果，返回串中第一个 ‘,’ 之前的字符串,也就是上面的程序第一次输出abc。第二次调用该函数strtok(NULL,”,”),第一个参数设置为NULL。结果返回分割依据后面的字串，即第二次输出d。strtok是一个线程不安全的函数，因为它使用了静态分配的空间来存储被分割的字符串位置线程安全的函数叫strtok_r,ca运用strtok来判断ip或者mac的时候务必要先用其他的方法判断’.’或’:’的个数，因为用strtok截断的话，比 2.strcmpC/C++函数，比较两个字符串设这两个字符串为str1，str2，若str1=str2，则返回零；若str1&lt;str2，则返回负数；若str1&gt;str2，则返回正数。matlab中函数，strcmp(s1，s2) 判断两个字符串s1和s2是否相同，相同返回true ,不同返回false源码：12345678910111213141516int strcmp(const char *str1,const char *str2)&#123; /*不可用while(*str1++==*str2++)来比较，当不相等时仍会执行一次++， return返回的比较值实际上是下一个字符。应将++放到循环体中进行。*/ while(*str1 == *str2) &#123; assert((str1 != NULL) &amp;&amp; (str2 != NULL)); if(*str1 == '\\0') return 0; str1++; str2++; &#125; return *str1 - *str2;&#125; 3. Erase c.erase(k)从c中删除元素k，返回一个size_type值，指出删除的元素的数量 c.erase(p)从c中删除迭代器p指定的元素，p必须指向c中的一个真实元素，不能等于c.end() c.erase(b,e)从c中删除迭代器对b和e所表示的范围中的元素，返回e4. ListList 反向迭代器begin和end成员begin和end操作产生指向容器内第一个元素和最后一个元素的下一个位置的迭代器，如下所示。这两个迭代器通常用于标记包含容器中所有元素的迭代范围。c.begin() 返回一个迭代器，它指向容器c的第一个元素c.end() 返回一个迭代器，它指向容器c的最后一个元素的下一个位置c.rbegin() 返回一个逆序迭代器，它指向容器c的最后一个元素c.rend() 返回一个逆序迭代器，它指向容器c的第一个元素前面的位置上述每个操作都有两个不同的版本：一个是const成员，另一个是非const成员。这些操作返回什么类型取决于容器是否为const。如果容器不是const，则这些操作返回iterator或reverse_iterator类型。如果容器是const，则其返回类型要加上const_前缀，也就是const_iterator和const_reverse_iterator类型。 5. strcpy描述C 库函数 char strcpy(char dest, const char *src) 把 src 所指向的字符串复制到 dest。 声明下面是 strcpy() 函数的声明。char *strcpy(char *dest, const char *src)参数dest – 指向用于存储复制内容的目标数组。src – 要复制的字符串。返回值该函数返回一个指向最终的目标字符串 dest 的指针。实例下面的实例演示了 strcpy() 函数的用法。12345678910111213141516#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main()&#123; char src[40]; char dest[100]; memset(dest, &apos;\\0&apos;, sizeof(dest)); strcpy(src, &quot;This is runoob.com&quot;); strcpy(dest, src); printf(&quot;最终的目标字符串： %s\\n&quot;, dest); return(0);&#125; 6.转换函数6.1 Atoi字符串转整型 6.2 Atof字符串转浮点型 7. malloc动态内存分配用于申请一块连续的指定大小的内存块区域以void类型返回分配的内存区域地址，当无法知道内存具体位置的时候，想要绑定真正的内存空间，就需要用到动态的分配内存。void \\malloc(size_t size);如果分配成功则返回指向被分配内存的指针(此存储区中的初始值不确定)，否则返回空指针NULL。当内存不再使用时，应使用free()函数将内存块释放。函数返回的指针一定要适当对齐，使其可以用于任何数据对象。例：1234567int *p;p = (int*)malloc(sizeof(int) * 128);//分配128个（可根据实际需要替换该数值）整型存储单元，//并将这128个连续的整型存储单元的首地址存储到指针变量p中double *pd = (double*)malloc(sizeof(double) * 12);//分配12个double型存储单元，//并将首地址存储到指针变量pd中 math库中的函数hypot 计算直角三角形的斜边长 关键字externextern是计算机语言中的一个关键字，可置于变量或者函数前，以表示变量或者函数的定义在别的文件中。提示编译器遇到此变量或函数时，在其它模块中寻找其定义，另外，extern也可用来进行链接指定。 变量在一个源文件里定义了一个数组：char a[6];在另外一个文件里用下列语句进行了声明：extern char *a； 请问，这样可以吗？ 答案与分析： 1)、不可以，程序运行时会告诉你非法访问。原因在于，指向类型T的指针并不等价于类型T的数组。extern char *a声明的是一个指针变量而不是字符数组，因此与实际的定义不同，从而造成运行时非法访问。应该将声明改为extern char a[ ]。 2)、例子分析如下，如果a[] = “abcd”,则外部变量a=0x12345678 (数组的起始地址)，而*a是重新定义了一个指针变量，a指向的地址可能是0x87654321,直接使用*a是错误的. 3)、这提示我们，在使用extern时候要严格对应声明时的格式，在实际编程中，这样的错误屡见不鲜。 4)、extern用在变量声明中常常有这样一个作用：你要在*.c文件中引用另一个文件中的一个全局的变量，那就应该放在*.h中用extern来声明这个全局变量。 extern用于变量的用法： extern int a;//声明一个全局变量a int a; //定义一个全局变量a extern int a =0 ;//定义一个全局变量a 并给初值。一旦给予赋值，一定是定义，定义才会分配存储空间。（注意：经过测试在GCC中，这样定义变量是不能通过编译的，而在VS2013可以） int a =0;//定义一个全局变量a,并给初值， 声明之后你不能直接使用这个变量，需要定义之后才能使用。 第四个等于第三个，都是定义一个可以被外部使用的全局变量，并给初值。 糊涂了吧，他们看上去可真像。但是定义只能出现在一处。也就是说，不管是int a;还是int a=0;都只能出现一次，而那个extern int a可以出现很多次。 当你要引用一个全局变量的时候，你就要声明extern int a;这时候extern不能省略，因为省略了，就变成int a;这是一个定义，不是声明。 函数实际上函数的声明和定义都不需要添加extern关键字，在实际使用的时候也最好不要添加关键字。如果一个函数是不会被其它文件调用的，那么这个函数应该被声明成static的。如：extern int func(void){return 0;}跟int func(void){return 0;} 是等价的另外 extern int func(void); 跟int func(void);是等价的。 编译链接声明外部变量现代编译器一般采用按文件编译的方式，因此在编译时，各个文件中定义的全局变量是互相不透明的。也就是说，在编译时，全局变量的可见域限制在文件内部。 下面举一个简单的例子： 创建一个工程，里面含有A.cpp和B.cpp两个简单的C++源文件：123456//A.cppint i;int main()&#123;&#125;//B.cppint i; 这两个文件极为简单，在A.cpp中我们定义了一个全局变量i，在B中我们也定义了一个全局变量i。 我们对A和B分别编译，都可以正常通过编译，但是进行链接的时候，却出现了错误，错误提示如下：12345Linking...B.obj:error LNK2005:&quot;inti&quot;(?i@@3HA)already defined in A.objDebug/A.exe:fatal error LNK1169:one or more multiply defined symbols foundError executing link.exe.A.exe-2 error(s),0 warning(s) 这就是说，在编译阶段，各个文件中定义的全局变量相互是不透明的，编译A时觉察不到B中也定义了i，同样，编译B时觉察不到A中也定义了i。 但是到了链接阶段，要将各个文件的内容“合为一体”，因此，如果某些文件中定义的全局变量名相同的话，在这个时候就会出现错误，也就是上面提示的重复定义的错误。 因此，各个文件中定义的全局变量名不可相同。 在链接阶段，各个文件的内容（实际是编译产生的obj文件）是被合并到一起的，因而，定义于某文件内的全局变量，在链接完成后，它的可见范围被扩大到了整个程序。 这样一来，按道理说，一个文件中定义的全局变量，可以在整个程序的任何地方被使用，举例说，如果A文件中定义了某全局变量，那么B文件中应可以使用该变量。修改我们的程序，加以验证： 1234567//A.cppint main()&#123; i = 100;//试图使用B中定义的全局变量&#125;//B.cppint i; 编译结果如下:12345Compiling...A.cppC:\\Documents and Settings\\桌面\\try extern\\A.cpp(5):error C2065:&apos;i&apos;:undeclared identifierError executing cl.exe.A.obj-1 error(s),0 warning(s) 编译错误。 其实出现这个错误是意料之中的，因为文件中定义的全局变量的可见性扩展到整个程序是在链接完成之后，而在编译阶段，他们的可见性仍局限于各自的文件。 编译器的目光不够长远，编译器没有能够意识到，某个变量符号虽然不是本文件定义的，但是它可能是在其它的文件中定义的。 虽然编译器不够有远见，但是我们可以给它提示，帮助它来解决上面出现的问题。这就是extern的作用了。 extern的原理很简单，就是告诉编译器：“你现在编译的文件中，有一个标识符虽然没有在本文件中定义，但是它是在别的文件中定义的全局变量，你要放行！” 我们为上面的错误程序加上extern关键字： 12345678//A.cppextern int i;int main()&#123; i=100;//试图使用B中定义的全局变量&#125;//B.cppint i; 顺利通过编译，链接。 C++中extern c的深层探索 简介C++语言的创建初衷是“a better C”，但是这并不意味着C++中类似C语言的全局变量和函数所采用的编译和连接方式与C语言完全相同。作为一种欲与C兼容的语言，C++保留了一部分过程式语言的特点（被世人称为“不彻底地面向对象”），因而它可以定义不属于任何类的全局变量和函数。但是，C++毕竟是一种面向对象的程序设计语言，为了支持函数的重载，C++对全局函数的处理方式与C有明显的不同。 从标准头文件说起某企业曾经给出如下的一道面试题：为什么标准头文件都有类似以下的结构？ 12345678910#ifndef __INCvxWorksh#define __INCvxWorksh#ifdef __cplusplusextern &quot;C&quot; &#123;#endif/*...*/#ifdef __cplusplus&#125;#endif#endif /* __INCvxWorksh */ 分析 显然，头文件中的编译宏“#ifndef INCvxWorksh、#define INCvxWorksh、#endif” 的作用是防止该头文件被重复引用。 那么 123456#ifdef __cplusplusextern &quot;C&quot; &#123;#endif#ifdef __cplusplus&#125;#endif 的作用又是什么呢？我们将在下文一一道 深层揭密extern “C” extern “C” 包含双重含义，从字面上即可得到：首先，被它修饰的目标是“extern”的；其次，被它修饰的目标是“C”的。让我们来详细解读这两重含义。 被extern “C”限定的函数或变量是extern类型的； extern是C/C++语言中表明函数和全局变量作用范围（可见性）的关键字，该关键字告诉编译器，其声明的函数和变量可以在本模块或其它模块中使用，记住，下列语句： extern int a; 仅仅是一个变量的声明，其并不是在定义变量a，并未为a分配内存空间。变量a在所有模块中作为一种全局变量只能被定义一次，否则会出现连接错误。 引用一个定义在其它模块的全局变量或函数（如，全局函数或变量定义在A模块，B欲引用）有两种方法， 一、B模块中include模块A的头文件。 二、模块B中对欲引用的模块A的变量或函数重新声明一遍，并前加extern关键字。 通常，在模块的头文件中对本模块提供给其它模块引用的函数和全局变量以关键字extern声明。 例如，如果模块B欲引用该模块A中定义的全局变量和函数时只需包含模块A的头文件即可。这样，模块B中调用模块A中的函数时，在编译阶段，模块B虽然找不到该函数，但是并不会报错；它会在连接阶段中从模块A编译生成的目标代码中找到此函数。 与extern对应的关键字是static，被它修饰的全局变量和函数只能在本模块中使用。因此，一个函数或变量只可能被本模块使用时，其不可能被extern “C”修饰。 被extern “C”修饰的变量和函数是按照C语言方式编译和连接的； 未加extern “C”声明时的编译方式 首先看看C++中对类似C的函数是怎样编译的。 作为一种面向对象的语言，C++支持函数重载，而过程式语言C则不支持。函数被C++编译后在符号库中的名字与C语言的不同。例如，假设某个函数的原型为： void foo( int x, int y ); 该函数被C编译器编译后在符号库中的名字为_foo，而C++编译器则会产生像_foo_int_int之类的名字（不同的编译器可能生成的名字不同，但是都采用了相同的机制，生成的新名字称为“mangled name”）。 _foo_int_int这样的名字包含了函数名、函数参数数量及类型信息，C++就是靠这种机制来实现函数重载的。例如，在C++中，函数void foo( int x, int y )与void foo( int x, float y )编译生成的符号是不相同的，后者为_foo_int_float。 同样地，C++中的变量除支持局部变量外，还支持类成员变量和全局变量。用户所编写程序的类成员变量可能与全局变量同名，我们以”.”来区分。而本质上，编译器在进行编译时，与函数的处理相似，也为类中的变量取了一个独一无二的名字，这个名字与用户程序中同名的全局变量名字不同。 未加extern “C”声明时的连接方式 假设在C++中，模块A的头文件如下： 123456789// 模块A头文件 moduleA.h#ifndef MODULE_A_H#define MODULE_A_Hint foo( int x, int y );#endif在模块B中引用该函数：// 模块B实现文件 moduleB.cpp#include &quot;moduleA.h&quot;foo(2,3); 实际上，在连接阶段，连接器会从模块A生成的目标文件moduleA.obj中寻找_foo_int_int这样的符号！ 加extern “C”声明后的编译和连接方式 加extern “C”声明后，模块A的头文件变为： 12345// 模块A头文件 moduleA.h#ifndef MODULE_A_H#define MODULE_A_Hextern &quot;C&quot; int foo( int x, int y );#endif 在模块B的实现文件中仍然调用foo( 2,3 )，其结果是： （1）模块A编译生成foo的目标代码时，没有对其名字进行特殊处理，采用了C语言的方式； （2）连接器在为模块B的目标代码寻找foo(2,3)调用时，寻找的是未经修改的符号名_foo。 如果在模块A中函数声明了foo为extern “C”类型，而模块B中包含的是extern int foo( int x, int y ) ，则模块B找不到模块A中的函数；反之亦然。 所以，可以用一句话概括extern “C”这个声明的真实目的（任何语言中的任何语法特性的诞生都不是随意而为的，来源于真实世界的需求驱动。我们在思考问题时，不能只停留在这个语言是怎么做的，还要问一问它为什么要这么做，动机是什么，这样我们可以更深入地理解许多问题）： 实现C++与C及其它语言的混合编程。 明白了C++中extern “C”的设立动机，我们下面来具体分析extern “C”通常的使用技巧。 extern “C”的惯用法 （1）在C++中引用C语言中的函数和变量，在包含C语言头文件（假设为cExample.h）时，需进行下列处理： 1234extern &quot;C&quot;&#123;#include &quot;cExample.h&quot;&#125; 而在C语言的头文件中，对其外部函数只能指定为extern类型，C语言中不支持extern “C”声明，在.c文件中包含了extern “C”时会出现编译语法错误。 笔者编写的C++引用C函数例子工程中包含的三个文件的源代码如下： 123456789101112131415161718192021/*c语言头文件：cExample.h */#ifndef C_EXAMPLE_H#define C_EXAMPLE_Hextern int add(int x,int y);#endif/*c语言实现文件：cExample.c */#include &quot;cExample.h&quot;int add( int x, int y )&#123;return x + y;&#125;//c++实现文件，调用add：cppFile.cppextern &quot;C&quot;&#123;#include &quot;cExample.h&quot;&#125;int main(int argc, char* argv[])&#123;add(2,3);return 0;&#125; 如果C++调用一个C语言编写的.DLL时，当包括.DLL的头文件或声明接口函数时，应加extern “C” { }。 （2）在C++引用C语言中的函数和变量时，C++的头文件需添加extern “C”，但是在C语言中不能直接引用声明了extern “C”的该头文件，应该仅将C文件中将C++中定义的extern “C”函数声明为extern类型。 笔者编写的C引用C++函数例子工程中包含的三个文件的源代码如下： 123456789101112131415161718192021//C++头文件 cppExample.h#ifndef CPP_EXAMPLE_H#define CPP_EXAMPLE_Hextern &quot;C&quot; int add( int x, int y );#endif//C++实现文件 cppExample.cpp#include &quot;cppExample.h&quot;int add( int x, int y )&#123;return x + y;&#125;/* C实现文件 cFile.c/* 这样会编译出错：#include &quot;cppExample.h&quot; */extern int add (int x,int y);int main (int argc,char*argv[])&#123; add(2,3); return 0;&#125; 参考：百度百科https://baike.baidu.com/item/extern/4443005?fr=aladdin","tags":[{"name":"C++","slug":"C","permalink":"http://11wy11.github.io/tags/C/"}]},{"title":"krpano快速入门教程（三）之热点Hotspot","date":"2019-03-16T14:54:57.000Z","path":"2019/03/16/krpano-third-note/","text":"使用编辑器热点，添加自定义热点，动态热点等 添加热点及相关内容使用编辑器热点，添加自定义热点，动态热点等 使用tour_editor添加热点及设定起始角度通过Load tour.xml导入要编辑的配置文件点击set as startup view设置初始角度，可以旋转到合适的角度，点击按钮设置全景图默认展示角度。点击Add hotspot按钮，画面中出现一个箭头，将其拖放置你想放置的地方，点击save按钮保存热点编辑。也可以通过编辑按钮设置热点链接场景。点击Save tour.xml按钮保存文件。 编辑 tour.xml添加热点在实际生产中，通常直接编辑xml文件，在相应的场景中添加热点123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687&lt;hotspot name=&quot;...&quot; 定义热点名称 type=&quot;image&quot; 定义热点类型，只能是image url=&quot;...&quot; 热点图像路径，支持SWF, JPG, PNG, GIF alturl=&quot;...&quot; html5状态下显示的图像路径 keep=&quot;false&quot; 是否在下一场景跳转后保持显示 devices=&quot;all&quot; 支持设备类型 visible=&quot;true&quot; 是否可见 enabled=&quot;true&quot; 设置热点是否接收鼠标事件 handcursor=&quot;true&quot; 设置是否鼠标移到上面显示小手 maskchildren=&quot;false&quot; 设置是否将子控件变成蒙板 zorder=&quot;&quot; 插入元素的次序索引，可以是字符也可以是数字，html5输出必须是0-100整数 zorder2=&quot;0.0&quot; 设置为0.0和1.0，分别对应当前热点在扭曲控件之下和之上 capture=&quot;true&quot; 与enabled配合使用，都为true只对热点传递动作，capture=&quot;false&quot;可对子控件传递动作 children=&quot;true&quot; 设置子控件是否接收热点鼠标事件 blendmode=&quot;normal&quot; 设置混合模式，可选：normal, layer, screen, add, subtract, difference, multiply, overlay, lighten, darken, hardlight, invert. style=&quot;&quot; 读入已设置好的style名称 ath=&quot;0.0&quot; atv=&quot;0.0&quot; 设定将场景缩略图为球形热点 edge=&quot;center&quot; 热点的边界对齐点 ox=&quot;0&quot; 边界到对齐点的偏移量 oy=&quot;0&quot; zoom=&quot;false&quot; 设置是否场景缩放时，热点跟随缩放 distorted=&quot;false&quot; rx=&quot;0.0&quot; ry=&quot;0.0&quot; rz=&quot;0.0&quot; 设置热点是否跟随场景进行3D扭曲 details=&quot;8&quot; 热点显示的细节数量，默认为8 inverserotation=&quot;false&quot; 设置是否逆向旋转3D扭曲 flying=&quot;0.0&quot; 设置ath/atv/scale的插值 width=&quot;&quot; height=&quot;&quot; 设置热点宽高 scale=&quot;1.0&quot; 设置热点缩放 rotate=&quot;0.0&quot; 设置热点旋转角度 pixelhittest=&quot;false&quot; 是否启动精确像素测试 smoothing=&quot;true&quot; 设置缩放时，是否平滑化处理 accuracy=&quot;0&quot; 设置像素渲染值（flash下） accuracy2=&quot;1&quot; 设置精度控制（html5下） alpha=&quot;1.0&quot; 设置透明度 autoalpha=&quot;false&quot; 设置是否自动变更透明度 usecontentsize=&quot;false&quot; 是否使用用户指定flash大小，默认false原始大小 scale9grid=&quot;&quot; 定义是否支持矢量缩放，scale9grid=&quot;x-position|y-position|width|height|prescale*&quot; crop=&quot;&quot; 定义元素坐标及宽高 crop=&quot;x-position|y-position|width|height&quot; onovercrop=&quot;&quot; 设置元素鼠标移到上方后的坐标及宽高 ondowncrop=&quot;&quot; 设置元素鼠标按下状态后的坐标及宽高 scalechildren=&quot;false&quot; 子元素是否跟随缩放 mask=&quot;&quot; mask=&quot;name&quot; mask=&quot;layer[name]&quot; mask=&quot;hotspot[name]&quot; effect=&quot;&quot; 热点位图效果3种：glow(color,alpha,range,strength); dropshadow(depth,angle,color,range,strength); blur(radius); onover=&quot;&quot; 鼠标在经过上方时执行动作 onhover=&quot;&quot; 鼠标停在上方时执行动作 onout=&quot;&quot; 鼠标停移出范围时时执行动作 onclick=&quot;&quot; 鼠标停点击时执行动作 ondown=&quot;&quot; 鼠标按下时执行动作 onup=&quot;&quot; 鼠标按键松开时执行动作 onloaded=&quot;&quot; 加载元素完成后执行动作 /&gt; 多边形热点 &lt;hotspot name=&quot;...&quot; keep=&quot;false&quot; visible=&quot;true&quot; enabled=&quot;true&quot; handcursor=&quot;true&quot; zorder=&quot;&quot; capture=&quot;true&quot; blendmode=&quot;normal&quot; style=&quot;&quot; alpha=&quot;1.0&quot; autoalpha=&quot;false&quot; fillcolor=&quot;0xFFFFFF&quot; fillcolorhover=&quot;0xFFFFFF&quot; 填充颜色及鼠标移上后颜色 fillalpha=&quot;0.0&quot; fillalphahover=&quot;0.1&quot; 填充颜色透明度及鼠标移上后颜色透明度 borderwidth=&quot;0.0&quot; borderwidthhover=&quot;4.0&quot; 边界宽度及鼠标移上后边界宽度 bordercolor=&quot;0xFFFFFF&quot; bordercolorhover=&quot;0xFFFFFF&quot; 边界颜色及边界鼠标移上后颜色 borderalpha=&quot;0.0&quot; borderalphahover=&quot;0.8&quot; 边界透明度及鼠标移上后边界透明度 fadeintime=&quot;0.15&quot; fadeincurve=&quot;1.1&quot; 悬停状态变化时间及形式 fadeouttime=&quot;0.3&quot; fadeoutcurve=&quot;0.7&quot; onover=&quot;&quot; onhover=&quot;&quot; onout=&quot;&quot; onclick=&quot;&quot; ondown=&quot;&quot; onup=&quot;&quot; &gt; &lt;point ath=&quot;...&quot; atv=&quot;...&quot; /&gt; 多边形热点坐标 &lt;point ath=&quot;...&quot; atv=&quot;...&quot; /&gt; &lt;point ath=&quot;...&quot; atv=&quot;...&quot; /&gt; ... &lt;/hotspot&gt; 历史文章krpano快速入门教程（一) 使用krpano工具构建即用型panoskrpano快速入门教程（二) vtour全景漫游及vtour文件夹介绍","tags":[{"name":"krpano","slug":"krpano","permalink":"http://11wy11.github.io/tags/krpano/"}]},{"title":"C++之QT的信号和槽的详解","date":"2019-03-16T12:24:56.000Z","path":"2019/03/16/qt-note/","text":"QT的信号和槽的详解，包括简介，信号和槽分析以及一个实例 1 简介 信号和槽是Qt特有的信息传输机制，是Qt设计程序的重要基础，它可以让互不干扰的对象建立一种联系。 在GUI编程中，当我们改变一个部件时，经常想要其他部件被通知。更一般化，我们希望任何一类的对象可以和其它对象进行通讯。例如，如果我们点击一个关闭按钮，我们可能想要窗口的close()函数被调用。 其他工具包通过回调实现了这种通信。回调是一个函数指针，所以如果你希望一个处理函数通知你一些事件，你可以把另一个函数（回调）的指针传递给处理函数。处理函数在适当的时候调用回调。尽管一些成功的框架使用了这个方法，但是回调可能是不直观的，并可能在确保回调参数类型正确性上存在问题。信号槽是 Qt 框架引以为豪的机制之一。所谓信号槽，实际就是观察者模式。当某个事件发生之后，比如，按钮检测到自己被点击了一下，它就会发出一个信号（signal）。这种发出是没有目的的，类似广播。如果有对象对这个信号感兴趣，它就会使用连接（connect）函数，意思是，将想要处理的信号和自己的一个函数（称为槽（slot））绑定来处理这个信号。也就是说，当信号发出时，被连接的槽函数会自动被回调。这就类似观察者模式：当发生了感兴趣的事件，某一个操作就会被自动触发。（这里提一句，Qt 的信号槽使用了额外的处理来实现，并不是 GoF 经典的观察者模式的实现方式。） 信号和槽是Qt特有的信息传输机制，是Qt设计程序的重要基础，它可以让互不干扰的对象建立一种联系。 槽的本质是类的成员函数，其参数可以是任意类型的。和普通C++成员函数几乎没有区别，它可以是虚函数；也可以被重载；可以是公有的、保护的、私有的、也可以被其他C++成员函数调用。唯一区别的是：槽可以与信号连接在一起，每当和槽连接的信号被发射的时候，就会调用这个槽。 Qt的小部件有很多预定义的信号，但是我们总是可以通过继承来加入我们自己的信号。槽就是一个对应于特定信号的被调用的函数。Qt的部件有很多预定义的槽，但同样可以通过子类化加入自己的槽来处理感兴趣的信号。 1.1 对象树(子对象动态分配空间不需要释放) 比如说当应用程序创建了一个具有父窗口部件的对象时，该对象将被加入父窗口部件的孩子列表。当应用程序销毁父窗口部件时，其下的孩子列表中的对象将被一一删除。这让我们在编程时，能够将主要精力放在系统的业务上，提高编程效率，同时也保证了系统的稳健性。 2 信号和槽 在Qt中我们有一种可以替代回调的技术：我们使用信号和槽。当一个特定事件发生的时候，一个信号被发射。Qt的小部件有很多预定义的信号，但是我们总是可以通过继承来加入我们自己的信号。槽就是一个对应于特定信号的被调用的函数。Qt的部件有很多预定义的槽，但同样可以通过子类化加入自己的槽来处理感兴趣的信号。 信号和槽机制是类型安全的：一个信号的签名(参数类型)必须与它的接收槽的签名相匹配。（实际上，一个槽的签名可能比它接收到的信号短，因为它可以忽略额外的参数。）因为签名是兼容的，当使用基于函数指针的语法时，编译器就可以帮助我们检测类型不匹配。基于字符串的信号和槽语法将在运行时检测类型不匹配。信号和插槽是松散耦合的：一个发射信号的类不用知道也不用关心哪个槽要接收这个信号。Qt的信号和槽的机制可以保证如果你把一个信号和一个槽连接起来，槽会在正确的时间使用信号的参数被调用。信号和槽可以使用任何数量、任何类型的参数。它们是完全类型安全的：不会再有回调核心转储(core dump)。 从QObject类或者它的子类（如QWidget类）继承的所有类可以包含信号和槽。当改变它们的状态的时候，信号被发送。从某种意义上说，即它们对其他对象感兴趣。这就是所有的对象通讯时所做的一切。它不知道也不关心是否有其他对象接收到了它发射的信号。这就是真正的信息封装，并且确保对象可以用作一个软件组件使用。 槽可以用来接收信号，但它们也是普通的成员函数。正如一个对象不知道有其他对象收到它的信号一样，一个槽也不知道它是否被任意信号连接。因此，这种方式保证了Qt创建组件的完全独立。 你可以连接多个信号到一个槽，同样一个信号可以被你需要的多个槽连接。甚至可以一个信号连接到另一个信号。（该情况下，只要第一个信 号被发射时，第二个信号立即被发射。） 总体来看，信号和槽构成了一个强有力的组件编程机制。 2.1 信号 当一个对象内部状态发生改变时发射信号，信号就被发射，在某些方面对象的客户端和所有者可能感兴趣。信号是一个public访问函数并可以在任何地方发射，但是我们建议仅在定义了信号的类及他们的子类中发射。 当一个信号被发射，它所连接的槽会被立即执行，类似于一个普通函数的调用。在该情况下，信号/槽机制在任何GUI事件循环中是完全独立的。一旦所有的槽返回了，emit语句随后的代码将会执行。这与queued connections方式有些许不同，queued connections方式下emit关键字随后的代码会立即继续执行，槽在随后执行（相当于异步，参考信号与槽的连接类型）。 如果几个槽被连接到一个信号，当信号被发射时，这些槽就会按它们连接的顺序挨个执行。 信号会由moc自动生成并一定不要在.cpp文件中实现。它们也不能有任何返回类型（也就是 只能使用void）。 2.2 槽 当与槽连接的信号被发射时，该槽被调用。槽是普通的C++函数可以正常调用；它们唯一的特点就是可以被信号连接。 因为槽是普通成员函数，所以被直接调用时遵循一般的C++规则。然而，作为槽，它们能被任何组件调用，通过信号槽连接，无需考虑访问级别。这意味着从一个任意类的实例发出的一个信号可以在一个不相关的类的实例中调用一个私有槽。 同样还可以定义虚拟槽，我们在实践中发现它非常有用。 与回调相比，信号和插槽的速度稍慢，因为它们增加了灵活性，尽管在实际应用程序中的差异是微不足道的。 信号和槽的机制是非常有效的，但是它不像“真正的”回调那样快。信号和槽稍微有些慢，这是因为它们所提供的灵活性造成，尽管在实际应用中这些性能可以被忽略。通常，发射一个和槽相连的信号，大约比直接调接收器非虚函数的调用慢十倍。这是定位连接对象所需的开销，为了安全地遍历所有连接（e.g检查随后的接收器在发射过程中没有被销毁），并以通用的方式安排任意参数。虽然10个非虚函数调用听起来可能很多，但开销比任意new或delete 操作少得多。当执行一个字符串时，vector或list操作在后面的场景中需要new或delete, 但信号和槽在完成函数调用的开销中只占很小的一部分。在一个槽中进行系统调用或者间接地调用超过10个函数，情况也是相同的;。信号/插槽机制的简单和灵活性对于时间的开销是值得，用户甚至不会注意到这点。 注意，与基于qt的应用程序一起编译时，定义变量的其他库调用信号和槽可能会造成编译器警告和错误。要解决这个问题，#undef这些预处理器的冲突符号即可。 2.3 一个Qt Creator的例子 1234567891011#include &lt;QApplication&gt;#include &lt;QPushButton&gt; int main(int argc, char *argv[]) &#123; QApplication app(argc, argv); QPushButton button(&quot;Quit&quot;); QObject::connect(&amp;button, &amp;QPushButton::clicked, &amp;app, &amp;QApplication::quit); button.show(); return app.exec(); &#125; 在 Qt Creator 中创建工程的方法创建好工程，然后将main()函数修改为上面的代码。点击运行，我们会看到一个按钮，上面有“Quit”字样。点击按钮，程序退出。 connect()函数最常用的一般形式： connect(sender, signal, receiver, slot); 参数： sender：发出信号的对象 signal：发送对象发出的信号 receiver：接收信号的对象 slot：接收对象在接收到信号之后所需要调用的函数 信号槽要求信号和槽的参数一致，所谓一致，是参数类型一致。如果不一致，允许的情况是，槽函数的参数可以比信号的少，即便如此，槽函数存在的那些参数的顺序也必须和信号的前面几个一致起来。这是因为，你可以在槽函数中选择忽略信号传来的数据（也就是槽函数的参数比信号的少），但是不能说信号根本没有这个数据，你就要在槽函数中使用（就是槽函数的参数比信号的多，这是不允许的）。 2.4 一个普通C++程序的例子 一个小的C++类声明如下： 12345678910class Counter &#123; public: Counter() &#123; m_value = 0; &#125; int value() const &#123; return m_value; &#125; void setValue(int value); private: int m_value; &#125;; 一个小的基于QObject类如下： 123456789101112131415#include &lt;QObject&gt; class Counter : public QObject &#123; Q_OBJECT public: Counter() &#123; m_value = 0; &#125; int value() const &#123; return m_value; &#125; public slots: void setValue(int value); signals: void valueChanged(int newValue); private: int m_value; &#125;; 这个基于QObject的类有同样的内部状态，并提供公有方法来访问状态。除此之外，这个类可以通过发射一个valueChanged()信号来告诉外部世界关于它的状态改变，并且它有一个槽，其它对象可以发送信号给这个槽。 所有包含信号和/或者槽的类必须在它们的声明中提到Q_OBJECT。它们也必须从QObject继承(直接或间接)。 槽由应用程序的编写者来实现。这里是Counter::setValue()可能的一个槽实现： 1234567void Counter::setValue(int value) &#123; if (value != m_value) &#123; m_value = value; emit valueChanged(value); &#125; &#125; emit这一行从对象中发射valueChanged()信号，以一个新值作为参数。 在下面的小片断中，我们创建了两个Counter对象，并使用QObject::connect()将第一个对象的valueChanget()信号连接到第二个对象的setValue槽。 下面是把两个对象连接在一起的一种方法： 123456Counter a, b; QObject::connect(&amp;a, &amp;Counter::valueChanged, &amp;b, &amp;Counter::setValue); a.setValue(12); // a.value() == 12, b.value() == 12 b.setValue(48); // a.value() == 12, b.value() == 48 调用a.setValue(12)会使a发射一个valueChanged(12) 信号，b将会在它的setValue()槽中接收这个信号，也就是b.setValue(12) 被调用。接下来b会发射同样的valueChanged()信号，但是因为没有槽被连接到b的valueChanged()信号，所以该信号被忽略。 注意只有当value!= m_value的时候setValue()函数才会设置这个值并发射信号。这样就避免了存在环connections的情况下无限循环。（比如b.valueChanged() 和a.setValue()连接在一起）。 默认情况下，对于你做出的每一个连接，一个信号被发射;重复连接下两个信号被发射。你可以调用disconnect()中断所有连接。如果传递了Qt::UniqueConnection类型，连接只有在不重复的情况下才建立。如果已经存在重复连接（同一个对象上确定的信号到确定的槽），则连接将会失败，connect返回fase。 这个例子说明了对象可以协同工作而不需要知道彼此的任何信息。为达到这种效果，对像仅需要相互连接，并用一个简单的QObject::connect()函数调用实现，或者使用uic的自动连接特性。 2.5 带有默认参数的信号和槽 信号和槽的签名可能包含参数，参数可以有默认值。考虑QObject::destroyed()函数。 void destroyed(QObject* = 0); 当一个QObject对象被删除，它发射QObject::destroyed()信号。我们想捕获此信号，无论在我们可能有一个悬空的引用指向删除的QObject对象的情况下，因此我们可以把它清理干净。一个合适的槽签名可能是这样的: void objectDestroyed(QObject* obj = 0); 为连接一个信号到此槽，我们使用QObject::connect。这里有几个方式连接。第一种方式是使用函数指针： connect(sender,&amp;QObject::destroyed,this,&amp;MyObject::objectDestroyed); 连接信号到槽的另一种方法是使用QObject::connect()，SIGNAL和SLOT宏。关于是否在SIGNAL()和SLOT()宏中包含参数的规则，如果参数有默认值，传递给SIGNAL()宏的签名必须不能少于传递给SLOT()宏签名的参数。 下述这些都会生效：12345678connect(sender,SIGNAL(destroyed(QObject*)),this,SLOT(objectDestroyed(Qbject*)));connect(sender,SIGNAL(destroyed(QObject*)),this,SLOT(objectDestroyed()));connect(sender, SIGNAL(destroyed()),this,SLOT(objectDestroyed())); 2.6 信号和槽的进一步使用 对于可能需要信号发送者信息的情况, Qt提供了QObject::sender()函数，它返回一个指向发送信号的对象的指针。 QSignalMapper类为一种情形提供，该情况下多个信号连接到同一个槽，而槽需要以不同的方式处理每个信号。 假设有三个按钮来决定将打开哪个文件: “Tax File”, “Accounts File”, “Report File”. 为了打开正确的文件,使用QSignalMapper:setMapping()来映射所有QPushButton:clicked()到QSignalMapper对象。然后将文件的QPushButton::clicked()信号连接到QSignalMapper::map()槽。 123456789101112131415161718signalMapper = new QSignalMapper(this); signalMapper-&gt;setMapping(taxFileButton, QString(&quot;taxfile.txt&quot;)); signalMapper-&gt;setMapping(accountFileButton, QString(&quot;accountsfile.txt&quot;)); signalMapper-&gt;setMapping(reportFileButton, QString(&quot;reportfile.txt&quot;)); connect(taxFileButton, &amp;QPushButton::clicked, signalMapper, &amp;QSignalMapper::map); connect(accountFileButton, &amp;QPushButton::clicked, signalMapper, &amp;QSignalMapper::map); connect(reportFileButton, &amp;QPushButton::clicked, signalMapper, &amp;QSignalMapper::map); 然后，将mapped()信号连接到readFile()，根据按下的按钮，readFile()打开不同的文件。connect(signalMapper, SIGNAL(mapped(QString)),this, SLOT(readFile(QString))); 2.7 自定义信号槽 发送者和接收者都需要是QObject的子类（当然，槽函数是全局函数、Lambda 表达式等无需接收者的时候除外）； 使用 signals 标记信号函数，信号是一个函数声明，返回 void，不需要实现函数代码； 槽函数是普通的成员函数，作为成员函数，会受到 public、private、protected 的影响； 使用 emit 在恰当的位置发送信号； 使用QObject::connect()函数连接信号和槽。 任何成员函数、static 函数、全局函数和 Lambda 表达式都可以作为槽函数 2.8 信号槽的更多用法 一个信号可以和多个槽相连 如果是这种情况，这些槽会一个接一个的被调用，但是它们的调用顺序是不确定的。 多个信号可以连接到一个槽 只要任意一个信号发出，这个槽就会被调用。 一个信号可以连接到另外的一个信号 当第一个信号发出时，第二个信号被发出。除此之外，这种信号-信号的形式和信号-槽的形式没有什么区别。 槽可以被取消链接 这种情况并不经常出现，因为当一个对象delete之后，Qt自动取消所有连接到这个对象上面的槽。 使用Lambda 表达式 在使用 Qt 5 的时候，能够支持 Qt 5 的编译器都是支持 Lambda 表达式的。 我们的代码可以写成下面这样： 12345QObject::connect(&amp;newspaper, static_cast&lt;void (Newspaper:: *)(const QString &amp;)&gt;(&amp;Newspaper::newPaper),[=](const QString &amp;name) &#123; /* Your code here. */ &#125;); 在连接信号和槽的时候，槽函数可以使用Lambda表达式的方式进行处理。 3 案例mainwidget.h 123456789101112131415161718192021222324252627282930#ifndef MAINWIDGET_H#define MAINWIDGET_H#include &lt;QWidget&gt;#include &lt;QPushButton&gt;#include &quot;subwidget.h&quot; //子窗口头文件class MainWidget : public QWidget&#123; Q_OBJECTpublic: MainWidget(QWidget *parent = 0); ~MainWidget();public slots: void mySlot(); void changeWin(); void dealSub(); void dealSlot(int, QString);private: QPushButton b1; QPushButton *b2; QPushButton b3; SubWidget subWin;&#125;;#endif // MAINWIDGET_H subwidget.h 1234567891011121314151617181920212223242526272829303132#ifndef SUBWIDGET_H#define SUBWIDGET_H#include &lt;QWidget&gt;#include &lt;QPushButton&gt;class SubWidget : public QWidget&#123; Q_OBJECTpublic: explicit SubWidget(QWidget *parent = 0); void sendSlot();signals: /* 信号必须有signals关键字来声明 * 信号没有返回值，但可以有参数 * 信号就是函数的声明，只需声明，无需定义 * 使用：emit mySignal(); * 信号可以重载 */ void mySignal(); void mySignal(int, QString);public slots:private: QPushButton b;&#125;;#endif // SUBWIDGET_H main.cpp 1234567891011#include &quot;mainwidget.h&quot;#include &lt;QApplication&gt;int main(int argc, char *argv[])&#123; QApplication a(argc, argv); MainWidget w;//执行MainWidget的构造函数 w.show(); return a.exec();&#125; mainvidget.cpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120#include &quot;mainwidget.h&quot;#include &lt;QPushButton&gt;#include &lt;QDebug&gt; //打印MainWidget::MainWidget(QWidget *parent) : QWidget(parent)&#123; b1.setParent(this); b1.setText(&quot;close&quot;); b1.move(100, 100); b2 = new QPushButton(this); b2-&gt;setText(&quot;abc&quot;); connect(&amp;b1, &amp;QPushButton::pressed, this, &amp;MainWidget::close); /* &amp;b1: 信号发出者，指针类型 * &amp;QPushButton::pressed：处理的信号， &amp;发送者的类名::信号名字 * this: 信号接收者 * &amp;MainWidget::close： 槽函数，信号处理函数 &amp;接收的类名::槽函数名字 * 发送-处理-接收-处理 */ /* 自定义槽，普通函数的用法 * Qt5：任意的成员函数，普通全局函数，静态函数 * 槽函数需要和信号一致（参数，返回值） * 由于信号都是没有返回值，所以，槽函数一定没有返回值 */ connect(b2, &amp;QPushButton::released, this, &amp;MainWidget::mySlot); connect(b2, &amp;QPushButton::released, &amp;b1, &amp;QPushButton::hide); /* 信号：短信 * 槽函数：接收短信的手机 */ setWindowTitle(&quot;老大&quot;); //this-&gt;setWindowTitle(&quot;老大&quot;);//等价同上 b3.setParent(this); b3.setText(&quot;切换到子窗口&quot;); b3.move(50, 50); //显示子窗口 //subWin.show(); connect(&amp;b3, &amp;QPushButton::released, this, &amp;MainWidget::changeWin); //处理子窗口的信号// void (SubWidget::*funSignal)() = &amp;SubWidget::mySignal;// connect(&amp;subWin, funSignal, this, &amp;MainWidget::dealSub);// void (SubWidget::*testSignal)(int, QString) = &amp;SubWidget::mySignal;// connect(&amp;subWin, testSignal, this, &amp;MainWidget::dealSlot); //Qt4信号连接 //Qt4槽函数必须有slots关键字来修饰 connect(&amp;subWin, SIGNAL(mySignal()), this, SLOT(dealSub()) ); connect(&amp;subWin, SIGNAL(mySignal(int,QString)), this, SLOT(dealSlot(int,QString)) ); //缺点： SIGNAL SLOT 将函数名字 -&gt; 字符串 不进行错误检查 //Lambda表达式, 匿名函数对象 //C++11增加的新特性， 项目文件： CONFIG += C++11 //Qt配合信号一起使用，非常方便 QPushButton *b4 = new QPushButton(this); b4-&gt;setText(&quot;Lambda表达式&quot;); b4-&gt;move(150, 150); int a = 10, b = 100; connect(b4, &amp;QPushButton::clicked, // = :把外部所有局部变量、类中所有成员以值传递方式 // this: 类中所有成员以值传递方式 // &amp; : 把外部所有局部变量， 引用符号 [=](bool isCheck) &#123; qDebug() &lt;&lt; isCheck; &#125; ); resize(400, 300);&#125;void MainWidget::dealSlot(int a, QString str)&#123; // str.toUtf8() -&gt; 字节数组QByteArray // ……data() -&gt; QByteArray -&gt; char * qDebug() &lt;&lt; a &lt;&lt; str.toUtf8().data();&#125;void MainWidget::mySlot()&#123; b2-&gt;setText(&quot;123&quot;);&#125;void MainWidget::changeWin()&#123; //子窗口显示 subWin.show(); //本窗口隐藏 this-&gt;hide();&#125;void MainWidget::dealSub()&#123; //子窗口隐藏 subWin.hide(); //本窗口显示 show();&#125;MainWidget::~MainWidget()&#123;&#125; subwidget.cpp 123456789101112131415161718#include &quot;subwidget.h&quot;SubWidget::SubWidget(QWidget *parent) : QWidget(parent)&#123; this-&gt;setWindowTitle(&quot;小弟&quot;); b.setParent(this); b.setText(&quot;切换到主窗口&quot;); connect(&amp;b, &amp;QPushButton::clicked, this, &amp;SubWidget::sendSlot); resize(400, 300);&#125;void SubWidget::sendSlot()&#123; emit mySignal(); emit mySignal(250, &quot;我是子窗口&quot;);&#125; SingnalAndSlot.pro 12345678910111213141516QT += core guigreaterThan(QT_MAJOR_VERSION, 4): QT += widgetsTARGET = 03_SignalAndSlotTEMPLATE = appSOURCES += main.cpp\\ mainwidget.cpp \\ subwidget.cppHEADERS += mainwidget.h \\ subwidget.hCONFIG += C++11 4 总结 结构图 5 参考博文 C++_之Qt的信号和槽的详解 https://www.cnblogs.com/wanghui1234/p/8964968.html Qt信号和槽机制 https://blog.csdn.net/lsfreeing/article/details/78575246","tags":[{"name":"C++","slug":"C","permalink":"http://11wy11.github.io/tags/C/"},{"name":"QT","slug":"QT","permalink":"http://11wy11.github.io/tags/QT/"}]},{"title":"krpano快速入门教程（二）之vtour简介","date":"2019-03-15T15:19:51.000Z","path":"2019/03/15/krpano-second-note/","text":"主要介绍全景漫游及vtour文件夹介绍 vtour全景漫游及vtour文件夹介绍使用MAKE VTOUR (MULTIRES) droplet工具生成全景漫游 背景在初始学习krpano时，可以借助krpano的工具生成全景漫游文件，之后可以根据需要修改tour.xml,定制skin等；上节简单介绍了krpano使用Make pano的工具创建单场景应用，但大多数应用中场景数量不只一个，彼此之间可以跳转，这就需要借助MAKE VTOUR droplet工具了。而具体选择三种中的哪一种，根据应用场景需要选择，multires支持将全景切片分级，能够达到更好的展示效果，但会使全景文件大小增加，normal生成普通的pano_f.jpg,pano_b.jpg,pano_l.jpg，pano_r.jpg，pano_u.jpg，pano_d.jpg,preview.jpg，分别为全景图的前后左右上下，以及菜单中的预览图。 生成vtour使用MAKE VTOUR (MULTIRES) droplet工具生成的全景漫游场景，场景彼此之间相互连接，能够从一个场景跳转到另一个场景。可以同时选择多张全景图片拖放在该工具上，输入全景图类型，和全景角度，执行切片，等待完成。显示done之后，在全景图文件夹中生成vtour文件夹。 vtour文件夹内容介绍1. tour.html文件--嵌入全景的网页 2. tour.swf文件--krpano的flash viewer 3. tour.js文件--基于swfkrpano.js的一个viewer，即HTML5的viewer及嵌入HTML的js文件的合体 4. tour.xml文件--是krpano xml配置文件，定义全景图配置及皮肤配置 5. panos文件夹--存放处理后的全景图切片 6. plugins文件夹--主要存放使用到的插件 场景Scene它们可用于在当前xml文件中再次定义完整krpano xml文件的内容。它就像一个外部的xml，但只是内联/嵌入到当前的xml中。 在调用具有场景名称的loadscene（） 典型的用法是在一个xml文件中定义几个panos。 使用loadpano（）动作加载新的外部xml文件时，将删除所有当前定义的场景元素。 可以在&lt;scene>元素中存储任何自定义属性 - 查看器本身将忽略它们，但它们可用于自定义操作。1234567891011&lt;scene name=&quot;scene_20171106193359&quot; title=&quot;20171106193359&quot; onstart=&quot;&quot; thumburl=&quot;panos/20171106193359.tiles/thumb.jpg&quot; lat=&quot;51.51500000&quot; lng=&quot;-0.08050000&quot; heading=&quot;0.0&quot;&gt; &lt;view hlookat=&quot;0.0&quot; vlookat=&quot;0.0&quot; fovtype=&quot;MFOV&quot; fov=&quot;120&quot; maxpixelzoom=&quot;2.0&quot; fovmin=&quot;70&quot; fovmax=&quot;140&quot; limitview=&quot;range&quot; vlookatmin=&quot;-56.055&quot; vlookatmax=&quot;56.055&quot; /&gt; &lt;preview url=&quot;panos/20171106193359.tiles/preview.jpg&quot; /&gt; &lt;image prealign=&quot;0|0.0|0&quot;&gt; &lt;cube url=&quot;panos/20171106193359.tiles/pano_%s.jpg&quot; /&gt; &lt;/image&gt; &lt;/scene&gt; 说明： name场景名称，命名规则：每个名字都需要以字母字符开头！这意味着不允许使用数字作为名字！当名称仍然以数字字符开头时，名称将被解释为数组索引。这对于动作内部基于动态索引的访问没有问题，但不能用于定义元素！所有名称将自动转换为小写字母，以便直接区分大小写访问！也是loadscene时设置的参数 title主要显示在缩略图上或者菜单栏名称 onstart此处可以定义将在“开始时”调用全景/场景观看的任何动作/功能。场景启动时调用，可以执行定义好的action thumburl默认视角的展示图路径，使用相对路径，以xml所在位置开始计算相对路径 lat&amp;lon场景所在经纬度，可以用于小地图插件，定位场景 heading仰角度数 视图viewview元素包含有关当前视图的信息。在xml中，它可用于设置启动视图设置。 查找方向将由hlookat / vlookat属性（=水平/垂直lookat）和fov属性中的当前视野定义。要查看部分全景图的限制，可以使用limitview属性。 hlookat&amp;vlookat设置初始视角，分别为水平方向和垂直方向 hlookat:球面坐标的水平方向，以度为单位。典型范围为-180°至+ 180°。该值不会环绕360°，但视图本身会。值0.0指向全景图像的中心。 vlookat:球面坐标的垂直方向，以度为单位。典型范围为-90°至+90°。但视图本身会。值0.0指向全景图像的中心。 fov以度为单位的当前视野 - 从近似0.0到179.0。,默认为90 fovmin&amp;fovmax主要设置视角放大和缩小的最大和最小视角 maxpixelzoom全景图像的最大像素缩放系数。这将根据全景分辨率和当前观察窗口自动限制fov，例如1.0 =限制为100％缩放，不会看到源图像的像素缩放。 预览previewurl:设置预览图路径 全景图image使用&lt;image&gt;元素将定义全景图像。 在此处设置图像/图块的类型，大小和URL路径。 type定义全景图像的类型。 可能的值： CUBE方全景图像 - 六个图像，每个立方体一个图像。 CUBESTRIP在一张图像中作为“图像条”的立方体全景图像。支持的多维数据集格式为6x1,1x6,3x2或2x3。立方体侧对齐本身始终需要：L，F，R，B，U，D（默认为krpano）。 SPHERE球形/ equirectangular全景图像。通过设置自定义hfov， vfov和 voffset设置可以实现部分panos。 CYLINDER一个圆柱形全景图像。通过设置自定义hfov， vfov和 voffset设置可以实现部分panos。 …未设置时：如果未设置类型，则查看器会尝试通过&lt;image>标记内的标记自动检测类型（仅适用于非多图像）。 hfov以度为单位定义全景图像的水平视野（hfov）。这是在全景图像上捕获的可见范围。默认值为360，表示全方位视图。使用较小的值进行部分全景。对于平坦全景（或普通图像），应使用值“1.0”。 multies启用平铺的多分辨率图像。设置为true时，&lt;image>元素需要包含多个&lt;level>元素，其中包含每个多分辨率级别的图像定义。多分辨切片时定义使用 tilesize当全景图为切片时，设置每一级切片大小 level[..].tiledimagewidth level[..].tiledimageheight某一级切片大小 stereo&amp;stereolabels&amp;stereoformat 允许使用立体图像（仅限HTML5和WebGL）。 使用立方体图像时，图像URL应包含％t占位符。此占位符将替换为stereolabels设置中的值。对于左图像，将使用第一个值，对于右图像，将使用第二个值。 对于球形或圆柱形图像或视频，可以使用“帧封装”立体图像。该stereoformat设置定义的打包顺序： stereoformat =“TB” - 上/下 stereoformat =“SBS” - Side-By-Side 示例 - 立体立方体图像： 1234567&lt;image stereo =“true”stereolabels =“1 | 2” &gt; &lt;cube url =“pano_％s_ ％t .jpg”/&gt; &lt;/ image&gt;示例 - 立体全景视频：&lt;image stereo =“true”stereoformat =“TB” &gt; &lt;sphere url =“ plugin：video ”/&gt; &lt;/ image&gt; 注意 - 根据全景图像或视频的像素大小（和侧面），可能需要手动设置hfov，vfov和voffset设置。 fisheye.fov fisheye.align fisheye.crop fisheye.lenscp 鱼眼图像支持（仅限HTML5和WebGL）。 通过鱼眼设置，可以在krpano中使用鱼眼照片和视频。 为了正确地拉直和对齐鱼眼图像，有必要了解一些有关它的参数。获取这些参数的一个好工具是PTGUI。 鱼眼设置： fov = “180.0” 鱼眼图像的视野（以度为单位）。 与crop大小有关。 来源：可以直接从PTGUI fov图像参数中获取。 align = “yaw|pitch|roll” 图像的对齐/旋转/调平（以度为单位）。 来源：可以直接从PTGUI图像参数中获取。（例如，使用垂直线控制点来对齐/调整图像） crop=“left|right|top|bottom” 鱼眼fov裁剪圆的边缘（以像素为单位）。 圆与fov大小有关。 来源：可以直接从PTGUI裁剪设置中获取。 lenscp = “a| b | c | d | e” 的 镜头校正参数。 来源：可以直接从PTGUI镜头设置中获取。 image中URL占位符等根据图像类型和相关设置，图像的URL应包含多个占位符，以允许寻址正确的图像文件。 这些网址占位符可用： 对于立方体的各个面：％s⇒cubelabels的占位符 对于水平图块索引：％h，％x，％u或％c （都相同） 对于垂直图块索引： ％v，％y或％r （都相同） 对于立体图像：％t⇒stereolabels的占位符为当前图像帧：％f ⇒ image.frame （仅限Flash） 每个占位符可以在url中多次使用 - 例如，作为文件名的一部分，也作为foldername的一部分。 平铺索引填充：通过在％字符和tile-index占位符的字符之间插入一个或多个0个字符，可以为数字定义自定义填充。比如:％H ⇒ 1,2,3，…，9,10,11％0H ⇒ 01,02,03，…，09,10,11％00H ⇒ 001,002,003，……，009010011 预览效果 效果图 补充之后的主要工作为：定制skin，定制plugins，定制xml，一些动态操作全景图配置使编辑js文件，能够实现动态配置全景图程序，能够更好的融入到Web应用程序中，作为其中一个子功能模块。后续结合实际案例介绍具体实现方式。历史文章 历史文章krpano快速入门教程（一) 使用krpano工具构建即用型panos","tags":[{"name":"krpano","slug":"krpano","permalink":"http://11wy11.github.io/tags/krpano/"}]},{"title":"krpano快速入门教程（一）之构建panos应用","date":"2019-03-14T07:54:54.000Z","path":"2019/03/14/krpano-first-note/","text":"使用krpano工具构建即用型panos简单使用krpano工具快速生成可执行的pano文件，后续介绍如何自定义编写配置文件切图等 krpano简介Krpano是一款全景漫游制作软件和工具。用krpano所生成的全景，在兼容性、功能性、互动性方面的表现都很不错，而且可以二次开发并拥有自己的编程语言，比如使用专用的krpano xml代码编写全景漫游，可开发出高度定制化的项目。因此，目前主流的全景网站均是在krpano全景的基础上进行开发，并不断进行更新迭代，形成自己独有的全景内容服务。 具体步骤 从krpano下载页面下载适合于自己系统的krpano Tools软件包 将下载的krpano Tools zip文件解压到一个不含中文路径的文件夹下（为了所有稳定使用，推荐） 如果您已拥有krpano许可文件 - 则立即将其复制或移动到krpano Tools文件夹中。如果您没有任何一个，那么只需跳过此步骤即可。之后可以通过注册码注册，具体破解方法请自行百度，注册后能够去掉切片中的krpano水印。 要构建单个全景图 - 打开包含全景图像的文件夹，选择其中一个或全部，拖放到MAKE PANO droplet批处理工具上。等待切片完成，会在全景图像所在文件夹中生成一个以全景图命名的文件夹，里面自动生成一个即用型pano,点击tour_testingsever运行测试服务器，打开index.html查看效果。需要说明的是，这里如果没有注册，运行之后全景图是有krpano水印的。可以运行krpano tools选择 register now 输入序列号完成注册。注册完在按照第4步操作，得到没有水印的全景图注册前 注册后 要构建虚拟游览 - 打开包含全景虚拟游览图像的文件夹，选择所有这些图像拖放到MAKE VTOURdroplet批处理工具上。 其他工具使用类似，主要功能简介如下： MAKE PANO (NORMAL) droplet针对标准全景图（360度），最大值。cubeize默认限制为2200像素（可以在’templates / normal.config’文件中更改），没有皮肤 - 只需pano，HTML5 iPhone / iPad就绪 MAKE PANO（MULTIRES）droplet用于渐进多分辨率的panos，没有尺寸/分辨率限制，快速动态加载，带按钮的默认皮肤，HTML5 iPhone / iPad就绪 MAKE PANO（FLAT）droplet用于平面/ 2D平移/图像，平铺多分辨率，无尺寸/分辨率限制，平坦全景/图像的皮肤/控制，仅限闪光 MAKE PANO（SINGLESWF）droplet只生成一个Flash swf文件，对于标准全景图，完整的pano将立即加载，最大值。cubesize限制为2200像素（可在’templates / singleswf.config’文件中更改），默认皮肤带按钮，仅限Flash MAKE OBJECT droplet用于平铺多分辨率对象影片，一次删除所有对象图像，没有大小/分辨率限制，快速和动态加载，具有按钮和对象旋转控件的对象外观，仅限Flash MAKE VTOUR (NORMAL) droplet / MAKE VTOUR (MULTIRES) droplet 用于自动构建虚拟游览，将所有全景图像放在此工具上，通过自动缩略图生成，准备好HTML5 iPhone / iPad 处理完成后关闭dos / terminal窗口。在源图像的文件夹中会有新文件：典型的.html文件 - 这是嵌入pano的示例网页，.swf文件 - 这是krpano Flash查看器，.js文件 - 这是Javascript Flash到HTML嵌入代码（基于swfkrpano.js）和可选的krpano HTML5 / Javascript iPhone / iPad查看器，一个.xml文件 - 这是krpano xml文件，有pano和皮肤定义，最后有.tiles文件夹 - 有处理过的全景图像。全景图像本身不是观看全景图像所必需的。 6.2。当您使用MAKE VTOUR Droplet时，这些文件将位于’vtour’文件夹中，而pano图像位于其中的’panos’文件夹中。 编辑全景设置打开并在任何文本编辑器中编辑生成的xml文件（带有xml-syntax-highlighting的文本编辑器可能会有帮助）： 在在线文档中查找krpano xml定义：","tags":[{"name":"krpano","slug":"krpano","permalink":"http://11wy11.github.io/tags/krpano/"}]},{"title":"AI组件开发（一）--注记旋转矩阵","date":"2019-03-14T02:56:02.000Z","path":"2019/03/14/ai-first-note/","text":"Adobe Illustrator 组件开发 AIRealMatrixSet介绍及使用方法，参数及原理分析 SDK官方帮助文档AIAPI void( AIRealMathSuite::AIRealMatrixSet)(AIRealMatrix m, AIReal a, AIReal b, AIReal c, AIReal d, AIReal tx, AIReal ty)Sets the scale, rotation, and translation values of a transformation matrix.Parameters:m The matrix object.a New a value.b New b value.c New c value.d New d value.tx New horizontal translation value.ty New vertical translation value. 参数及原理分析ad缩放bc旋转tx,ty位移，基础的2D矩阵 公式 x=ax+cy+tx y=bx+dy+ty 为了把二维图形的变化统一在一个坐标系里，引入了齐次坐标的概念，即把一个图形用一个三维矩阵表示，其中第三列总是(0,0,1)，用来作为坐标系的标准。所以所有的变化都由前两列完成以上参数在矩阵中的表示为： |a b 0| |c d 0| |tx ty 1| 运算原理：原坐标设为（X,Y,1）; |a b 0| [X，Y, 1] |c d 0| = [aX + cY + tx bX + dY + ty 1] ; |tx ty 1| 通过矩阵运算后的坐标[aX + cY + tx bX + dY + ty 1]，我们对比一下可知： 第一种：设a=d=1, b=c=0. 平移 [aX + cY + tx bX + dY + ty 1] = [X + tx Y + ty 1]; 可见，这个时候，坐标是按照向量（tx，ty）进行平移 第二种：设b=c=tx=ty=0. 缩放 [aX + cY + tx bX + dY + ty 1] = [aX dY 1]; 可见，这个时候，坐标X按照a进行缩放，Y按照d进行缩放，a，d就是X，Y的比例系数 第三种：设tx=ty=0，a=cosɵ，b=sinɵ，c=-sinɵ，d=cosɵ。旋转 [aX + cY + tx bX + dY + ty 1] = [Xcosɵ - Ysinɵ Xsinɵ + Ycosɵ 1] ; |cosɵ -sinɵ 0| |sinɵ cosɵ 0| | 0 0 1 | 可见，这个时候，ɵ就是旋转的角度，逆时针为正，顺时针为负 第四种：设tx=ty=0，a=1，b=0，c=-sinɵ，d=cosɵ。倾斜[aX + cY + tx bX + dY + ty 1] = [ - Ysinɵ Ycosɵ 1] ; |1 0 0| |-sinɵ cosɵ 0| | 0 0 1 | 可见，这个时候，ɵ就是倾斜的角度，逆时针为正，顺时针为负 相关文章AI组件开发（一）–注记旋转矩阵AI组件开发（二）–AIRealMathSuiteAI组件开发（三）–AIArtboardSuiteAI组件开发（四）–AIDocumentSuiteAI组件开发（五）–AILayerSuiteAI组件开发（六）–AIArtSuiteAI组件开发（七）–AIPathSuite&amp;&amp;AIPathfinderSuiteAI组件开发（八）–AIArtStyleSuite","tags":[{"name":"AI","slug":"AI","permalink":"http://11wy11.github.io/tags/AI/"}]},{"title":"csdn-markdown编辑器语法","date":"2019-03-13T16:03:21.000Z","path":"2019/03/14/csdn-markdown-grammar/","text":"记录CSDN 的markdown语法，备查@TOC 欢迎使用Markdown编辑器你好！ 这是你第一次使用 Markdown编辑器 所展示的欢迎页。如果你想学习如何使用Markdown编辑器, 可以仔细阅读这篇文章，了解一下Markdown的基本语法知识。 功能快捷键撤销：Ctrl/Command + Z重做：Ctrl/Command + Y加粗：Ctrl/Command + B斜体：Ctrl/Command + I标题：Ctrl/Command + Shift + H无序列表：Ctrl/Command + Shift + U有序列表：Ctrl/Command + Shift + O检查列表：Ctrl/Command + Shift + C插入代码：Ctrl/Command + Shift + K插入链接：Ctrl/Command + Shift + L插入图片：Ctrl/Command + Shift + G 合理的创建标题，有助于目录的生成直接输入1次#，并按下space后，将生成1级标题。输入2次#，并按下space后，将生成2级标题。以此类推，我们支持6级标题。有助于使用TOC语法后生成一个完美的目录。 如何改变文本的样式强调文本 强调文本 加粗文本 加粗文本 ==标记文本== 删除文本 引用文本 H~2~O is是液体。 2^10^ 运算结果是 1024. 插入链接与图片链接: link. 图片: Alt 带尺寸的图片: =30x30 居中的图片: Alt 居中并且带尺寸的图片: =30x30 当然，我们为了让用户更加便捷，我们增加了图片拖拽功能。 如何插入一段漂亮的代码片去博客设置页面，选择一款你喜欢的代码片高亮样式，下面展示同样高亮的 代码片.12// An highlighted blockvar foo = 'bar'; 生成一个适合你的列表 项目 项目 项目 项目1 项目2 项目3 计划任务 完成任务 创建一个表格一个简单的表格是这么创建的：项目 | Value——– | —–电脑 | $1600手机 | $12导管 | $1 设定内容居中、居左、居右使用:---------:居中使用:----------居左使用----------:居右| 第一列 | 第二列 | 第三列 ||:———–:| ————-:|:————-|| 第一列文本居中 | 第二列文本居右 | 第三列文本居左 | SmartyPantsSmartyPants将ASCII标点字符转换为“智能”印刷标点HTML实体。例如：| TYPE |ASCII |HTML|—————-|——————————-|—————————–||Single backticks|&#39;Isn&#39;t this fun?&#39; |’Isn’t this fun?’ ||Quotes |&quot;Isn&#39;t this fun?&quot; |”Isn’t this fun?” ||Dashes |-- is en-dash, --- is em-dash|– is en-dash, — is em-dash| 创建一个自定义列表Markdown: Text-to-HTML conversion tool Authors: John: Luke 如何创建一个注脚一个具有注脚的文本。^2 注释也是必不可少的Markdown将文本转换为 HTML。 *[HTML]: 超文本标记语言 KaTeX数学公式您可以使用渲染LaTeX数学表达式 KaTeX: Gamma公式展示 $\\Gamma(n) = (n-1)!\\quad\\foralln\\in\\mathbb N$ 是通过欧拉积分 $$\\Gamma(z) = \\int_0^\\infty t^{z-1}e^{-t}dt\\,.$$ 你可以找到更多关于的信息 LaTeX 数学表达式here. 新的甘特图功能，丰富你的文章12345678gantt dateFormat YYYY-MM-DD title Adding GANTT diagram functionality to mermaid section 现有任务 已完成 :done, des1, 2014-01-06,2014-01-08 进行中 :active, des2, 2014-01-09, 3d 计划一 : des3, after des2, 5d 计划二 : des4, after des3, 5d 关于 甘特图 语法，参考 这儿, UML 图表可以使用UML图表进行渲染。 Mermaid. 例如下面产生的一个序列图：: 123456789sequenceDiagram张三 -&gt;&gt; 李四: 你好！李四, 最近怎么样?李四--&gt;&gt;王五: 你最近怎么样，王五？李四--x 张三: 我很好，谢谢!李四-x 王五: 我很好，谢谢!Note right of 王五: 李四想了很长时间, 文字太长了&lt;br/&gt;不适合放在一行.李四--&gt;&gt;张三: 打量着王五...张三-&gt;&gt;王五: 很好... 王五, 你怎么样? 这将产生一个流程图。: 12345graph LRA[长方形] -- 链接 --&gt; B((圆))A --&gt; C(圆角长方形)B --&gt; D&#123;菱形&#125;C --&gt; D 关于 Mermaid 语法，参考 这儿, FLowchart流程图我们依旧会支持flowchart的流程图：123456789flowchatst=&gt;start: 开始e=&gt;end: 结束op=&gt;operation: 我的操作cond=&gt;condition: 确认？st-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op 关于 Flowchart流程图 语法，参考 这儿. 导出与导入导出如果你想尝试使用此编辑器, 你可以在此篇文章任意编辑。当你完成了一篇文章的写作, 在上方工具栏找到 文章导出 ，生成一个.md文件或者.html文件进行本地保存。 导入如果你想加载一篇你写过的.md文件或者.html文件，在上方工具栏可以选择导入功能进行对应扩展名的文件导入，继续你的创作。","tags":[{"name":"markdown","slug":"markdown","permalink":"http://11wy11.github.io/tags/markdown/"}]},{"title":"git常用命令","date":"2019-03-13T12:41:15.000Z","path":"2019/03/13/git-command/","text":"记录一些常用的git命令，目前理解还不是很深，有点进一步查阅资料 强制本地覆盖远程分支 1234567 git push origin *** --force ``` 2. 放弃本地分支，远程分支强制覆盖本地 git fetch --all //只是下载代码到本地，不进行合并操作git reset --hard origin/分支名如master //把HEAD指向最新下载的版本3. 删除远程分支和本地分支 git branch -a//查看分支git push origin –delete // 删除远程分支git branch -d //删除本地分支 1234. git diff 检查文件更改内容5. 撤销未提交的修改git checkout git checkout app/src/main/../MainActivity 16、git reset git log #找到需要退回的commit版本号，可以只复制前几位git reset &lt;刚查找到的版本号&gt;`7、git log","tags":[{"name":"git","slug":"git","permalink":"http://11wy11.github.io/tags/git/"}]},{"title":"使用hexo+github创建个人博客并备份源码","date":"2019-03-09T13:52:06.000Z","path":"2019/03/09/create-blog-process/","text":"最基础的hexo+github搭建个人博客的教程 一、准备 安装node.js 安装git-windows 安装hexo-cli 1$npm install hexo-cli -g 在GitHub上创建&lt;username&gt;.github.io的仓库 e.g. 11wy11.github.io 配置SSH key打开本机的控制台，以windows系统为例，可以执行win+R 输入cmd打开，执行 1ssh -keygen -t rsa -C &apos;D:/id.txt&apos; 然后连续按3次回车，最终会在用户目录下生成一个文件，找到目录.ssh/id_rsa.pub文件，用记事本打开全选复制。在你的github上点击头像&gt;设置进入设置页面，选择SSH and GPG keys, 点击New SSH key按钮，名称随意填写，将刚复制的内容粘贴到key,添加 二、搭建流程 本地创建&lt;username&gt;.github.io 在本地&lt;username&gt;.github.io文件夹下初始化hexo项目并安装依赖 123hexo init //初始化工程npm install //安装依赖hexo server //启动本地调试器在localhost:4000预览 修改默认主题，可以在github上clone其他的主题，如yilia,icarus,indigo等 以indigo为例，在本地&lt;username&gt;.github.io文件夹下执行以下命令安装主题 1git clone git@github.com:yscoder/hexo-theme-indigo.git themes/indigo 修改工程中的_config.yml配置文件，将themes: landscope改为themes: indigo 依赖安装分别安装Less,Feed,Json-content依赖，执行如下命令 123$ npm install hexo-renderer-less --save$ npm install hexo-generator-feed --save$ npm install hexo-generator-json-content --save 执行hexo s命令启动服务器在localhost:4000查看效果 新建文章，使用hexo new “my-first blog”，会在source/_posts下创建my-first-blog.md的页面文件进行编写 发布博客首先修改工程中的_config.yml配置文件，在最后三行添加以下代码，将username换成自己的git用户名 1234deploy: type: git repo: git@github.com:&lt;username&gt;/&lt;username&gt;.github.io.git branch: master 其次安装hexo-deployer-git 执行 npm install hexo-deployer-git --save 在工程文件夹内右键git bash进入命令行 输入hexo g，编译为静态文件，生成public文件夹，使用 hexo d 部署，此时可以访问https://&lt;username&gt;.github.io查看你的博客 备份源码 在工程文件夹内右键git bash进入命令行 输入 touch .gitignore ，生成“.gitignore”文件。 在”.gitignore” 文件里输入你要忽略的文件夹及其文件就可以了。（注意格式） 我的 .gitignore：node_modules/ .deploy_git public/ .DS_Store Thumbs.db db.json *.log .deploy*/ 执行以下命令#git初始化 git init #创建hexo分支，用来存放源码 git checkout -b hexo #git 文件添加 git add . #git 提交 git commit -m &quot;init&quot; #添加远程仓库 git remote add origin git@github.com:&lt;username&gt;/&lt;username&gt;.github.io.git #push到hexo分支 git push origin hexo 执行hexo g -d生成网站并部署到GitHub上 这样一来，在GitHub上的git@github.com:&lt;username&gt;/&lt;username&gt;.github.io.git仓库就有两个分支，一个hexo分支用来存放网站的原始文件，一个master分支用来存放生成的静态网页。 其他设备更新博客步骤： 1、先安装hexo $ npm install -g hexo-cli 2、存在github上的git clone下来 git clone -b hexo git@github.com:&lt;username&gt;/&lt;username&gt;.github.io.git 3、项目文件夹下 $ npm install $ npm install hexo-deployer-git 4、重新配置github和coding的公钥 5、编写博客push 到远程分支 补充 有时会出现下载的主题无法上传，首先删除themes/主题文件夹下的.git,使用git rm --cached themes/indigo命令清空后重新上传` 如果最开始.gitignore文件没有配置正确，可以使用git rm -r --cached .命令清楚缓存文件，重新add,commit,push上传","tags":[{"name":"hexo","slug":"hexo","permalink":"http://11wy11.github.io/tags/hexo/"},{"name":"git","slug":"git","permalink":"http://11wy11.github.io/tags/git/"}]},{"title":"Vue全局添加组件","date":"2019-03-09T02:39:22.000Z","path":"2019/03/09/Vue-global-component/","text":"Vue全局添加组件，方便重复使用的功能一次性定义 一. 背景在项目中有时需要反复用到如区域选择器等组件，每次使用时都需要在对应的vue中添加import,并在component中注册，为了避免多次书写引用代码，可以自定义全局组件，只需要在main.js中一次性注册在vue项目中，可以自定义组件像vue-resource一样使用Vue.use（）方法来使用。 二. 具体实现方法1、首先建一个自定义组件的文件夹，比如叫loading，在该文件夹下新建一个index.js，一个自定义组件loading.vue,在这个loading.vue里面就是这个组件的具体的内容， 2、在index.js中，规定使用这个组件的名字，以及使用方法，如： import loadingComponent from &apos;./loading.vue&apos; const loading={ install:function(Vue){ Vue.component(&apos;Loading&apos;,loadingComponent) } //&apos;Loading&apos;这就是后面可以使用的组件的名字，install是默认的一个方法 }; export default loading; 3、只要在main.js中规定了install方法，就可以像一些公共的插件一样使用Vue.use()来使用： import loading from &apos;./loading&apos; Vue.use(loading）","tags":[{"name":"Vue","slug":"Vue","permalink":"http://11wy11.github.io/tags/Vue/"}]},{"title":"Oracle配置SDE支持空间查询","date":"2019-03-09T01:56:40.000Z","path":"2019/03/09/oracle-st-geometry/","text":"Oracle配置SDE支持空间查询,配置oracle外部链接库 配置oracle外部链接库 将ArcGIS Desktop安装目录下DatabaseSupport文件夹下的st_shapelib.dll拷贝到装有oracle的服务器上，可以放置在任意地方，这里推荐放在Oracle安装目录下的bin文件夹下。 例如：st_shapelib.dll所在文件夹路径： C:\\ProgramFiles(x86)\\ArcGIS\\Desktop10.2\\DatabaseSupport\\Oracle\\Windows64\\st_shapelib.dll 拷贝放置位置：E:\\app\\503\\product\\11.2.0\\dbhome_1\\BIN\\ st_shapelib.dll 修改oracle安装目录下的network/admin文件夹下的listener.ora,将步骤1中的st_shapelib.dll路径添加到ENVS”EXTPROC_DLLS=ONLY:E:\\app\\503\\product\\11.2.0\\dbhome_1\\bin\\oraclr11.dll;后面 例如：linstener文件，添加红色字部分 1234567891011121314151617181920212223# listener.ora Network Configuration File: D:\\app\\Administrator\\product\\11.2.0\\dbhome_1\\NETWORK\\ADMIN\\listener.ora# Generated by Oracle configuration tools.SID_LIST_LISTENER = (SID_LIST = (SID_DESC = (SID_NAME = CLRExtProc) (ORACLE_HOME = E:\\app\\503\\product\\11.2.0\\dbhome_1) (PROGRAM = extproc) (ENVS= &quot;EXTPROC_DLLS=ONLY:E:\\app\\503\\product\\11.2.0\\dbhome_1\\bin\\oraclr11.dll;E:\\app\\503\\product\\11.2.0\\dbhome_1\\bin\\st_shapelib.dll&quot;) # interesting ) ) LISTENER = (DESCRIPTION_LIST = (DESCRIPTION = (ADDRESS = (PROTOCOL = TCP)(HOST = 503-PC)(PORT = 1521)) (ADDRESS = (PROTOCOL = IPC)(KEY = EXTPROC1521)) ) (DESCRIPTION = (ADDRESS = (PROTOCOL = TCP)(HOST = 192.168.1.164)(PORT = 1521)) ) ) ADR_BASE_LISTENER = E:\\app\\503 修改oracle安装home目录下的hs/admin文件夹下的extproc.ora，具体路径示例：E:\\app\\503\\product\\11.2.0\\dbhome_1\\hs\\admin\\extproc.ora，将最后一行的SET EXTPROC_DLLS= 设为ANY 通过任何一个数据库管理软件，这里以sql-plus为例，使用sde用户登录首先执行：select * from user_libraries 查看是否有ST_SHAPELIB并检查路径是否与步骤1中的一致，通常默认为c盘第一次安装Arcgis时的相关路径。结果如下： 如果路径与步骤1中st_shapelib的路径不一致，执行以下两条命令： Create or replace library st_SHAPELIB as &lt;步骤1中的st_shapelib路径&gt; Alter package sde.st_geometry_shapelib_pkg compile reuse settings 重启监听器OracleOraDB11g_home1TNSListener，有时也需要重启服务OracleServiceORCL。","tags":[{"name":"ArcGIS","slug":"ArcGIS","permalink":"http://11wy11.github.io/tags/ArcGIS/"},{"name":"Oracle","slug":"Oracle","permalink":"http://11wy11.github.io/tags/Oracle/"}]}]