[{"title":"常用工具","date":"2019-03-18T04:46:05.000Z","path":"2019/03/18/tools/","text":"markdown相关doctoc(markdown目录自动生成)GitHub中的markdown文件直接写[TOC]是无法生成目录的，可以使用工具doctocnpm install -g doctoc使用方式 对当前文件夹中所有文件生成目录e.g. 1234567 cd D:\\Develop\\Documents\\Notes\\CSDN笔记\\temp doctoc . ``` + 对文件夹中单个文件生成目录（文件名中间不能有空格） `doctoc /path/to/file [...]` 如： doctoc README.md doctoc CONTRIBUTING.md LICENSE.md doctoc D:\\Develop\\Documents\\Notes\\CSDN笔记\\JAVARxJava.md `","tags":[{"name":"-tools","slug":"tools","permalink":"http://11wy11.github.io/tags/tools/"}]},{"title":"AI组件开发（二）--AIRealMathSuite","date":"2019-03-18T02:50:27.000Z","path":"2019/03/18/ai-second-note/","text":"主要介绍AIRealMathSuite中使用到的函数，以及部分应用场景，持续更新中 AIRealRectOverlapAIAPI AIBoolean( AIRealMathSuite::AIRealRectOverlap)(const AIRealRect a, const AIRealRect *b)Tests whether two rectangles overlap (have any points in common).测试两个矩形是否重叠（有任何共同点） 参数: aThe first rectangle. bThe second rectangle. 返回值：如果矩形重叠，则为真。AIRealRectInAIRealRectAIAPI AIBoolean( AIRealMathSuite::AIRealRectInAIRealRect)(const AIRealRect a, const AIRealRect *b)Tests whether one rectangle is inside (entirely contained in) another rectangle.测试一个矩形是否在另一个矩形内（完全包含在内）。 Both must be open or both closed.两者都必须是开放的或都是封闭的。 参数: aThe first rectangle. bThe second rectangle. 返回值：True if the set of points contained by a is also contained by b.如果a包含的点集也包含在b内，则为真。AIRealRectSetAIAPI void( AIRealMathSuite::AIRealRectSet)(AIRealRect a, AIReal left, AIReal top, AIReal right, AIReal bottom)Sets the coordinate values in a rectangle. 设置矩形中的坐标值(In the Illustrator art coordinate system, the origin, (0, 0), is at the bottom left corner of a page. X and Y values increase upward and to the right.) 参数: aThe rectangle object. ///AI的矩形对象指针 leftThe left side location.///xmin topThe top side location. ///ymax rightThe right side location.///xmax bottomThe bottom side location.///ymin注意：Illustrator的坐标系原点位于页面左下角，X和Y值向上和向右增加。参考资料Adobe Illustrator SDK，下载地址：https://www.adobe.com/devnet/illustrator/sdk.html","tags":[{"name":"AI","slug":"AI","permalink":"http://11wy11.github.io/tags/AI/"}]},{"title":"markdown编写技巧","date":"2019-03-17T13:33:53.000Z","path":"2019/03/17/markdown-first-skill/","text":"常用转义字符 \\\\ 反斜杠 \\` 反引号 \\* 星号 \\_ 下划线 \\{\\} 大括号 \\[\\] 中括号 \\(\\) 小括号 \\# 井号 \\+ 加号 \\- 减号 \\. 英文句号 \\! 感叹号也可以用ASCII码代替 1 2 3 4 基本用法 标题设置（让字体变大，和word的标题意思一样）在Markdown当中设置标题，有两种方式：第一种：通过在文字下方添加“=”和“-”，他们分别表示一级标题和二级标题。第二种：在文字开头加上 “#”，通过“#”数量表示几级标题。（一共只有1~6级标题，1级标题字体最大） 块注释（blockquote）通过在文字开头添加“&gt;”表示块注释。（当&gt;和文字之间添加五个blank时，块注释的文字会有变化。） 斜体将需要设置为斜体的文字两端使用1个“*”或者“_”夹起来 粗体将需要设置为斜体的文字两端使用2个“*”或者“_”夹起来 无序列表在文字开头添加(*, +, and -)实现无序列表。但是要注意在(*, +, and -)和文字之间需要添加空格。（建议：一个文档中只是用一种无序列表的表示方式） 有序列表使用数字后面跟上句号。（还要有空格） 链接（Links）Markdown中有两种方式，实现链接，分别为内联方式和引用方式。内联方式：This is an [example link](http://example.com/).引用方式：I get 10 times more traffic from [Google][1] than from [Yahoo][2] or [MSN][3]. [1]: http://google.com/ “Google”[2]: http://search.yahoo.com/ “Yahoo Search”[3]: http://search.msn.com/ “MSN Search” 图片（Images）图片的处理方式和链接的处理方式，非常的类似。内联方式：![alt text](/path/to/img.jpg “Title”)引用方式：![alt text][id] [id]: /path/to/img.jpg “Title” 代码（HTML中所谓的Code）实现方式有两种：第一种：简单文字出现一个代码框。使用&lt;blockquote&gt;。（不是单引号而是左上角的ESC下面~中的）第二种：大片文字需要实现代码框。使用Tab和四个空格。 脚注（footnote）实现方式如下：hello[^hello] 下划线在空白行下方添加三条“-”横线。（前面讲过在文字下方添加“-”，实现的2级标题）参考官方文档http://daringfireball.net/projects/markdown/basics","tags":[{"name":"markdown","slug":"markdown","permalink":"http://11wy11.github.io/tags/markdown/"}]},{"title":"sqlite数据库查询 C++函数","date":"2019-03-17T13:17:22.000Z","path":"2019/03/17/sqlite-first-note/","text":"sqlite部分函数简介主要有打开数据库连接，执行数据库查询语句，关闭连接等函数 sqlite3_open用法打开数据库链接sqlite3_open用法原型：1234int sqlite3_open( const char *filename, /* Database filename (UTF-8) */ sqlite3 **ppDb /* OUT: SQLite db handle */); 用这个函数开始数据库操作。需要传入两个参数，一是数据库文件名，比如：E:/test.db。文件名不需要一定存在，如果此文件不存在，sqlite会自动建立它。如果它存在，就尝试把它当数据库文件来打开。二是sqlite3**，即前面提到的关键数据结构。函数返回值表示操作是否正确，如果是SQLITE_OK则表示操作正常。相关的返回值sqlite定义了一些宏。具体这些宏的含义可以参考sqlite3.h 文件。里面有详细定义。 sqlite3_close用法关闭数据库链接原型：1int sqlite3_close(sqlite3 *ppDb); ppDb为刚才使用sqlite3_open打开的数据库链接 sqlite3_exec用法执行sql操作原型：1234567int sqlite3_exec( sqlite3* ppDb, /* An open database */ const char *sql, /* SQL to be evaluated */ int (*callback)(void*,int,char**,char**), /* Callback function */ void *, /* 1st argument to callback */ char **errmsg /* Error msg written here */); 这就是执行一条sql 语句的函数。第1个参数不再说了，是前面open函数得到的指针。第2个参数constchar*sql是一条sql 语句，以\\0结尾。第3个参数sqlite3_callback 是回调，当这条语句执行之后，sqlite3会去调用你提供的这个函数。第4个参数void*是你所提供的指针，你可以传递任何一个指针参数到这里，这个参数最终会传到回调函数里面，如果不需要传递指针给回调函数，可以填NULL。回调函数的写法，以及这个参数的使用在之后介绍。第5个参数char** errmsg 是错误信息。注意是指针的指针。sqlite3里面有很多固定的错误信息。执行sqlite3_exec 之后，执行失败时可以查阅这个指针（直接cout&lt;&lt;errmsg得到一串字符串信息，这串信息告诉你错在什么地方。sqlite3_exec函数通过修改你传入的指针的指针，把你提供的指针指向错误提示信息，这样sqlite3_exec函数外面就可以通过这个char*得到具体错误提示。说明：通常，sqlite3_callback 和它后面的void*这两个位置都可以填NULL。填NULL表示你不需要回调。比如你做insert 操作，做delete操作，就没有必要使用回调。而当你做select 时，就要使用回调，因为sqlite3 把数据查出来，得通过回调告诉你查出了什么数据。exec 的回调typedef int(*sqlite3_callback)(void*,int,char**,char**);你的回调函数必须定义成上面这个函数的类型。下面给个简单的例子：123456789//sqlite3的回调函数//sqlite 每查到一条记录，就调用一次这个回调int LoadMyInfo(void* para,intn_column,char** column_value,char** column_name);//para是你在sqlite3_exec 里传入的void*参数通过para参数，你可以传入一些特殊的指针（比如类指针、结构指针），//然后在这里面强制转换成对应的类型（这里面是void*类型，必须强制转换成你的类型才可用）。然后操作这些数据//n_column是这一条记录有多少个字段(即这条记录有多少列)//char** column_value 是个关键值，查出来的数据都保存在这里，它实际上是个1维数组（不要以为是2维数组），//每一个元素都是一个char*值，是一个字段内容（用字符串来表示，以\\0结尾）//char** column_name 跟column_value是对应的，表示这个字段的字段名称 实例：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;iostream&gt;using namespace std;#include &quot;sqlite/sqlite3.h&quot;int callback(void*,int,char**,char**);int main()&#123; sqlite3* db; int nResult = sqlite3_open(&quot;test.db&quot;,&amp;db); if (nResult != SQLITE_OK) &#123; cout&lt;&lt;&quot;打开数据库失败：&quot;&lt;&lt;sqlite3_errmsg(db)&lt;&lt;endl; return 0; &#125; else &#123; cout&lt;&lt;&quot;数据库打开成功&quot;&lt;&lt;endl; &#125; char* errmsg; nResult = sqlite3_exec(db,&quot;create table fuck(id integer primary key autoincrement,name varchar(100))&quot;,NULL,NULL,&amp;errmsg); if (nResult != SQLITE_OK) &#123; sqlite3_close(db); cout&lt;&lt;errmsg; sqlite3_free(errmsg); return 0; &#125; string strSql; strSql+=&quot;begin;\\n&quot;; for (int i=0;i&lt;100;i++) &#123; strSql+=&quot;insert into fuck values(null,&apos;heh&apos;);\\n&quot;; &#125; strSql+=&quot;commit;&quot;; //cout&lt;&lt;strSql&lt;&lt;endl; nResult = sqlite3_exec(db,strSql.c_str(),NULL,NULL,&amp;errmsg); if (nResult != SQLITE_OK) &#123; sqlite3_close(db); cout&lt;&lt;errmsg&lt;&lt;endl; sqlite3_free(errmsg); return 0; &#125; strSql = &quot;select * from fuck&quot;; nResult = sqlite3_exec(db,strSql.c_str(),callback,NULL,&amp;errmsg); if (nResult != SQLITE_OK) &#123; sqlite3_close(db); cout&lt;&lt;errmsg&lt;&lt;endl; sqlite3_free(errmsg); return 0; &#125; sqlite3_close(db); return 0;&#125;int callback(void* ,int nCount,char** pValue,char** pName)&#123; string s; for(int i=0;i&lt;nCount;i++) &#123; s+=pName[i]; s+=&quot;:&quot;; s+=pValue[i]; s+=&quot;\\n&quot;; &#125; cout&lt;&lt;s&lt;&lt;endl; return 0;&#125;","tags":[{"name":"C++","slug":"C","permalink":"http://11wy11.github.io/tags/C/"},{"name":"sqlite","slug":"sqlite","permalink":"http://11wy11.github.io/tags/sqlite/"}]},{"title":"C++部分基础知识","date":"2019-03-17T06:09:53.000Z","path":"2019/03/17/cpp-function/","text":"介绍项目中用到的一些常用函数和关键字的使用Table of Contents generated with DocToc 常用函数 1. strtok 2.strcmp 3. Erase 4. List 5. strcpy 6.转换函数 6.1 Atoi 关键字 extern 变量 函数 编译链接 声明外部变量 C++中extern c的深层探索 常用函数1. strtok 分解字符串为一组字符串。s为要分解的字符，delim为分隔符字符（如果传入字符串，则传入的字符串中每个字符均为分割符）。首次调用时，s指向要分解的字符串，之后再次调用要把s设成NULL。 例如：strtok(“abc,def,ghi”,”,”)，最后可以分割成为abc def ghi.尤其在点分十进制的IP中提取应用较多。strtok的函数原型为char strtok(char s, char *delim)，功能为“Parse S into tokens separated by characters in DELIM.If S is NULL, the saved pointer in SAVE_PTR is used as the next starting point. ” 翻译成汉语就是：作用于字符串s，以包含在delim中的字符为分界符，将s切分成一个个子串；如果，s为空值NULL，则函数保存的指针SAVE_PTR在下一次调用中将作为起始位置。123456789101112131415#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;int main()&#123; char sentence[]=&quot;This is a sentence with 7 tokens&quot;; cout &lt;&lt; &quot;The string to be tokenized is:\\n&quot; &lt;&lt; sentence &lt;&lt; &quot;\\n\\nThe tokens are:\\n\\n&quot;; char *tokenPtr=strtok(sentence,&quot; &quot;); while(tokenPtr!=NULL) &#123; cout&lt;&lt;tokenPtr&lt;&lt;endl; tokenPtr=strtok(NULL,&quot; &quot;); &#125; //cout &lt;&lt; &quot;After strtok,sentence=&quot; &lt;&lt; tokenPtr&lt;&lt;endl; return 0;&#125; 函数第一次调用需设置两个参数。第一次分割的结果，返回串中第一个 ‘,’ 之前的字符串,也就是上面的程序第一次输出abc。第二次调用该函数strtok(NULL,”,”),第一个参数设置为NULL。结果返回分割依据后面的字串，即第二次输出d。strtok是一个线程不安全的函数，因为它使用了静态分配的空间来存储被分割的字符串位置线程安全的函数叫strtok_r,ca运用strtok来判断ip或者mac的时候务必要先用其他的方法判断’.’或’:’的个数，因为用strtok截断的话，比 2.strcmpC/C++函数，比较两个字符串设这两个字符串为str1，str2，若str1=str2，则返回零；若str1&lt;str2，则返回负数；若str1&gt;str2，则返回正数。matlab中函数，strcmp(s1，s2) 判断两个字符串s1和s2是否相同，相同返回true ,不同返回false源码：12345678910111213141516int strcmp(const char *str1,const char *str2)&#123; /*不可用while(*str1++==*str2++)来比较，当不相等时仍会执行一次++， return返回的比较值实际上是下一个字符。应将++放到循环体中进行。*/ while(*str1 == *str2) &#123; assert((str1 != NULL) &amp;&amp; (str2 != NULL)); if(*str1 == '\\0') return 0; str1++; str2++; &#125; return *str1 - *str2;&#125; 3. Erase c.erase(k)从c中删除元素k，返回一个size_type值，指出删除的元素的数量 c.erase(p)从c中删除迭代器p指定的元素，p必须指向c中的一个真实元素，不能等于c.end() c.erase(b,e)从c中删除迭代器对b和e所表示的范围中的元素，返回e4. ListList 反向迭代器begin和end成员begin和end操作产生指向容器内第一个元素和最后一个元素的下一个位置的迭代器，如下所示。这两个迭代器通常用于标记包含容器中所有元素的迭代范围。c.begin() 返回一个迭代器，它指向容器c的第一个元素c.end() 返回一个迭代器，它指向容器c的最后一个元素的下一个位置c.rbegin() 返回一个逆序迭代器，它指向容器c的最后一个元素c.rend() 返回一个逆序迭代器，它指向容器c的第一个元素前面的位置上述每个操作都有两个不同的版本：一个是const成员，另一个是非const成员。这些操作返回什么类型取决于容器是否为const。如果容器不是const，则这些操作返回iterator或reverse_iterator类型。如果容器是const，则其返回类型要加上const_前缀，也就是const_iterator和const_reverse_iterator类型。 5. strcpy描述C 库函数 char strcpy(char dest, const char *src) 把 src 所指向的字符串复制到 dest。 声明下面是 strcpy() 函数的声明。char *strcpy(char *dest, const char *src)参数dest – 指向用于存储复制内容的目标数组。src – 要复制的字符串。返回值该函数返回一个指向最终的目标字符串 dest 的指针。实例下面的实例演示了 strcpy() 函数的用法。12345678910111213141516#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main()&#123; char src[40]; char dest[100]; memset(dest, &apos;\\0&apos;, sizeof(dest)); strcpy(src, &quot;This is runoob.com&quot;); strcpy(dest, src); printf(&quot;最终的目标字符串： %s\\n&quot;, dest); return(0);&#125; 6.转换函数6.1 Atoi字符串转整型 关键字externextern是计算机语言中的一个关键字，可置于变量或者函数前，以表示变量或者函数的定义在别的文件中。提示编译器遇到此变量或函数时，在其它模块中寻找其定义，另外，extern也可用来进行链接指定。 变量在一个源文件里定义了一个数组：char a[6];在另外一个文件里用下列语句进行了声明：extern char *a； 请问，这样可以吗？ 答案与分析： 1)、不可以，程序运行时会告诉你非法访问。原因在于，指向类型T的指针并不等价于类型T的数组。extern char *a声明的是一个指针变量而不是字符数组，因此与实际的定义不同，从而造成运行时非法访问。应该将声明改为extern char a[ ]。 2)、例子分析如下，如果a[] = “abcd”,则外部变量a=0x12345678 (数组的起始地址)，而*a是重新定义了一个指针变量，a指向的地址可能是0x87654321,直接使用*a是错误的. 3)、这提示我们，在使用extern时候要严格对应声明时的格式，在实际编程中，这样的错误屡见不鲜。 4)、extern用在变量声明中常常有这样一个作用：你要在*.c文件中引用另一个文件中的一个全局的变量，那就应该放在*.h中用extern来声明这个全局变量。 extern用于变量的用法： extern int a;//声明一个全局变量a int a; //定义一个全局变量a extern int a =0 ;//定义一个全局变量a 并给初值。一旦给予赋值，一定是定义，定义才会分配存储空间。（注意：经过测试在GCC中，这样定义变量是不能通过编译的，而在VS2013可以） int a =0;//定义一个全局变量a,并给初值， 声明之后你不能直接使用这个变量，需要定义之后才能使用。 第四个等于第三个，都是定义一个可以被外部使用的全局变量，并给初值。 糊涂了吧，他们看上去可真像。但是定义只能出现在一处。也就是说，不管是int a;还是int a=0;都只能出现一次，而那个extern int a可以出现很多次。 当你要引用一个全局变量的时候，你就要声明extern int a;这时候extern不能省略，因为省略了，就变成int a;这是一个定义，不是声明。 函数实际上函数的声明和定义都不需要添加extern关键字，在实际使用的时候也最好不要添加关键字。如果一个函数是不会被其它文件调用的，那么这个函数应该被声明成static的。如：extern int func(void){return 0;}跟int func(void){return 0;} 是等价的另外 extern int func(void); 跟int func(void);是等价的。 编译链接声明外部变量现代编译器一般采用按文件编译的方式，因此在编译时，各个文件中定义的全局变量是互相不透明的。也就是说，在编译时，全局变量的可见域限制在文件内部。 下面举一个简单的例子： 创建一个工程，里面含有A.cpp和B.cpp两个简单的C++源文件：123456//A.cppint i;int main()&#123;&#125;//B.cppint i; 这两个文件极为简单，在A.cpp中我们定义了一个全局变量i，在B中我们也定义了一个全局变量i。 我们对A和B分别编译，都可以正常通过编译，但是进行链接的时候，却出现了错误，错误提示如下：12345Linking...B.obj:error LNK2005:&quot;inti&quot;(?i@@3HA)already defined in A.objDebug/A.exe:fatal error LNK1169:one or more multiply defined symbols foundError executing link.exe.A.exe-2 error(s),0 warning(s) 这就是说，在编译阶段，各个文件中定义的全局变量相互是不透明的，编译A时觉察不到B中也定义了i，同样，编译B时觉察不到A中也定义了i。 但是到了链接阶段，要将各个文件的内容“合为一体”，因此，如果某些文件中定义的全局变量名相同的话，在这个时候就会出现错误，也就是上面提示的重复定义的错误。 因此，各个文件中定义的全局变量名不可相同。 在链接阶段，各个文件的内容（实际是编译产生的obj文件）是被合并到一起的，因而，定义于某文件内的全局变量，在链接完成后，它的可见范围被扩大到了整个程序。 这样一来，按道理说，一个文件中定义的全局变量，可以在整个程序的任何地方被使用，举例说，如果A文件中定义了某全局变量，那么B文件中应可以使用该变量。修改我们的程序，加以验证： 1234567//A.cppint main()&#123; i = 100;//试图使用B中定义的全局变量&#125;//B.cppint i; 编译结果如下:12345Compiling...A.cppC:\\Documents and Settings\\桌面\\try extern\\A.cpp(5):error C2065:&apos;i&apos;:undeclared identifierError executing cl.exe.A.obj-1 error(s),0 warning(s) 编译错误。 其实出现这个错误是意料之中的，因为文件中定义的全局变量的可见性扩展到整个程序是在链接完成之后，而在编译阶段，他们的可见性仍局限于各自的文件。 编译器的目光不够长远，编译器没有能够意识到，某个变量符号虽然不是本文件定义的，但是它可能是在其它的文件中定义的。 虽然编译器不够有远见，但是我们可以给它提示，帮助它来解决上面出现的问题。这就是extern的作用了。 extern的原理很简单，就是告诉编译器：“你现在编译的文件中，有一个标识符虽然没有在本文件中定义，但是它是在别的文件中定义的全局变量，你要放行！” 我们为上面的错误程序加上extern关键字： 12345678//A.cppextern int i;int main()&#123; i=100;//试图使用B中定义的全局变量&#125;//B.cppint i; 顺利通过编译，链接。 C++中extern c的深层探索 简介C++语言的创建初衷是“a better C”，但是这并不意味着C++中类似C语言的全局变量和函数所采用的编译和连接方式与C语言完全相同。作为一种欲与C兼容的语言，C++保留了一部分过程式语言的特点（被世人称为“不彻底地面向对象”），因而它可以定义不属于任何类的全局变量和函数。但是，C++毕竟是一种面向对象的程序设计语言，为了支持函数的重载，C++对全局函数的处理方式与C有明显的不同。 从标准头文件说起某企业曾经给出如下的一道面试题：为什么标准头文件都有类似以下的结构？ 12345678910#ifndef __INCvxWorksh#define __INCvxWorksh#ifdef __cplusplusextern &quot;C&quot; &#123;#endif/*...*/#ifdef __cplusplus&#125;#endif#endif /* __INCvxWorksh */ 分析 显然，头文件中的编译宏“#ifndef INCvxWorksh、#define INCvxWorksh、#endif” 的作用是防止该头文件被重复引用。 那么 123456#ifdef __cplusplusextern &quot;C&quot; &#123;#endif#ifdef __cplusplus&#125;#endif 的作用又是什么呢？我们将在下文一一道 深层揭密extern “C” extern “C” 包含双重含义，从字面上即可得到：首先，被它修饰的目标是“extern”的；其次，被它修饰的目标是“C”的。让我们来详细解读这两重含义。 被extern “C”限定的函数或变量是extern类型的； extern是C/C++语言中表明函数和全局变量作用范围（可见性）的关键字，该关键字告诉编译器，其声明的函数和变量可以在本模块或其它模块中使用，记住，下列语句： extern int a; 仅仅是一个变量的声明，其并不是在定义变量a，并未为a分配内存空间。变量a在所有模块中作为一种全局变量只能被定义一次，否则会出现连接错误。 引用一个定义在其它模块的全局变量或函数（如，全局函数或变量定义在A模块，B欲引用）有两种方法， 一、B模块中include模块A的头文件。 二、模块B中对欲引用的模块A的变量或函数重新声明一遍，并前加extern关键字。 通常，在模块的头文件中对本模块提供给其它模块引用的函数和全局变量以关键字extern声明。 例如，如果模块B欲引用该模块A中定义的全局变量和函数时只需包含模块A的头文件即可。这样，模块B中调用模块A中的函数时，在编译阶段，模块B虽然找不到该函数，但是并不会报错；它会在连接阶段中从模块A编译生成的目标代码中找到此函数。 与extern对应的关键字是static，被它修饰的全局变量和函数只能在本模块中使用。因此，一个函数或变量只可能被本模块使用时，其不可能被extern “C”修饰。 被extern “C”修饰的变量和函数是按照C语言方式编译和连接的； 未加extern “C”声明时的编译方式 首先看看C++中对类似C的函数是怎样编译的。 作为一种面向对象的语言，C++支持函数重载，而过程式语言C则不支持。函数被C++编译后在符号库中的名字与C语言的不同。例如，假设某个函数的原型为： void foo( int x, int y ); 该函数被C编译器编译后在符号库中的名字为_foo，而C++编译器则会产生像_foo_int_int之类的名字（不同的编译器可能生成的名字不同，但是都采用了相同的机制，生成的新名字称为“mangled name”）。 _foo_int_int这样的名字包含了函数名、函数参数数量及类型信息，C++就是靠这种机制来实现函数重载的。例如，在C++中，函数void foo( int x, int y )与void foo( int x, float y )编译生成的符号是不相同的，后者为_foo_int_float。 同样地，C++中的变量除支持局部变量外，还支持类成员变量和全局变量。用户所编写程序的类成员变量可能与全局变量同名，我们以”.”来区分。而本质上，编译器在进行编译时，与函数的处理相似，也为类中的变量取了一个独一无二的名字，这个名字与用户程序中同名的全局变量名字不同。 未加extern “C”声明时的连接方式 假设在C++中，模块A的头文件如下： 123456789// 模块A头文件 moduleA.h#ifndef MODULE_A_H#define MODULE_A_Hint foo( int x, int y );#endif在模块B中引用该函数：// 模块B实现文件 moduleB.cpp#include &quot;moduleA.h&quot;foo(2,3); 实际上，在连接阶段，连接器会从模块A生成的目标文件moduleA.obj中寻找_foo_int_int这样的符号！ 加extern “C”声明后的编译和连接方式 加extern “C”声明后，模块A的头文件变为： 12345// 模块A头文件 moduleA.h#ifndef MODULE_A_H#define MODULE_A_Hextern &quot;C&quot; int foo( int x, int y );#endif 在模块B的实现文件中仍然调用foo( 2,3 )，其结果是： （1）模块A编译生成foo的目标代码时，没有对其名字进行特殊处理，采用了C语言的方式； （2）连接器在为模块B的目标代码寻找foo(2,3)调用时，寻找的是未经修改的符号名_foo。 如果在模块A中函数声明了foo为extern “C”类型，而模块B中包含的是extern int foo( int x, int y ) ，则模块B找不到模块A中的函数；反之亦然。 所以，可以用一句话概括extern “C”这个声明的真实目的（任何语言中的任何语法特性的诞生都不是随意而为的，来源于真实世界的需求驱动。我们在思考问题时，不能只停留在这个语言是怎么做的，还要问一问它为什么要这么做，动机是什么，这样我们可以更深入地理解许多问题）： 实现C++与C及其它语言的混合编程。 明白了C++中extern “C”的设立动机，我们下面来具体分析extern “C”通常的使用技巧。 extern “C”的惯用法 （1）在C++中引用C语言中的函数和变量，在包含C语言头文件（假设为cExample.h）时，需进行下列处理： 1234extern &quot;C&quot;&#123;#include &quot;cExample.h&quot;&#125; 而在C语言的头文件中，对其外部函数只能指定为extern类型，C语言中不支持extern “C”声明，在.c文件中包含了extern “C”时会出现编译语法错误。 笔者编写的C++引用C函数例子工程中包含的三个文件的源代码如下： 123456789101112131415161718192021/*c语言头文件：cExample.h */#ifndef C_EXAMPLE_H#define C_EXAMPLE_Hextern int add(int x,int y);#endif/*c语言实现文件：cExample.c */#include &quot;cExample.h&quot;int add( int x, int y )&#123;return x + y;&#125;//c++实现文件，调用add：cppFile.cppextern &quot;C&quot;&#123;#include &quot;cExample.h&quot;&#125;int main(int argc, char* argv[])&#123;add(2,3);return 0;&#125; 如果C++调用一个C语言编写的.DLL时，当包括.DLL的头文件或声明接口函数时，应加extern “C” { }。 （2）在C++引用C语言中的函数和变量时，C++的头文件需添加extern “C”，但是在C语言中不能直接引用声明了extern “C”的该头文件，应该仅将C文件中将C++中定义的extern “C”函数声明为extern类型。 笔者编写的C引用C++函数例子工程中包含的三个文件的源代码如下： 123456789101112131415161718192021//C++头文件 cppExample.h#ifndef CPP_EXAMPLE_H#define CPP_EXAMPLE_Hextern &quot;C&quot; int add( int x, int y );#endif//C++实现文件 cppExample.cpp#include &quot;cppExample.h&quot;int add( int x, int y )&#123;return x + y;&#125;/* C实现文件 cFile.c/* 这样会编译出错：#include &quot;cppExample.h&quot; */extern int add (int x,int y);int main (int argc,char*argv[])&#123; add(2,3); return 0;&#125; 参考：百度百科https://baike.baidu.com/item/extern/4443005?fr=aladdin","tags":[{"name":"C++","slug":"C","permalink":"http://11wy11.github.io/tags/C/"}]},{"title":"krpano快速入门教程（三）","date":"2019-03-16T14:54:57.000Z","path":"2019/03/16/krpano-third-note/","text":"添加热点及相关内容使用编辑器热点，添加自定义热点，动态热点等 使用tour_editor添加热点及设定起始角度通过Load tour.xml导入要编辑的配置文件点击set as startup view设置初始角度，可以旋转到合适的角度，点击按钮设置全景图默认展示角度。点击Add hotspot按钮，画面中出现一个箭头，将其拖放置你想放置的地方，点击save按钮保存热点编辑。也可以通过编辑按钮设置热点链接场景。点击Save tour.xml按钮保存文件。 编辑 tour.xml添加热点在实际生产中，通常直接编辑xml文件，在相应的场景中添加热点123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687&lt;hotspot name=&quot;...&quot; 定义热点名称 type=&quot;image&quot; 定义热点类型，只能是image url=&quot;...&quot; 热点图像路径，支持SWF, JPG, PNG, GIF alturl=&quot;...&quot; html5状态下显示的图像路径 keep=&quot;false&quot; 是否在下一场景跳转后保持显示 devices=&quot;all&quot; 支持设备类型 visible=&quot;true&quot; 是否可见 enabled=&quot;true&quot; 设置热点是否接收鼠标事件 handcursor=&quot;true&quot; 设置是否鼠标移到上面显示小手 maskchildren=&quot;false&quot; 设置是否将子控件变成蒙板 zorder=&quot;&quot; 插入元素的次序索引，可以是字符也可以是数字，html5输出必须是0-100整数 zorder2=&quot;0.0&quot; 设置为0.0和1.0，分别对应当前热点在扭曲控件之下和之上 capture=&quot;true&quot; 与enabled配合使用，都为true只对热点传递动作，capture=&quot;false&quot;可对子控件传递动作 children=&quot;true&quot; 设置子控件是否接收热点鼠标事件 blendmode=&quot;normal&quot; 设置混合模式，可选：normal, layer, screen, add, subtract, difference, multiply, overlay, lighten, darken, hardlight, invert. style=&quot;&quot; 读入已设置好的style名称 ath=&quot;0.0&quot; atv=&quot;0.0&quot; 设定将场景缩略图为球形热点 edge=&quot;center&quot; 热点的边界对齐点 ox=&quot;0&quot; 边界到对齐点的偏移量 oy=&quot;0&quot; zoom=&quot;false&quot; 设置是否场景缩放时，热点跟随缩放 distorted=&quot;false&quot; rx=&quot;0.0&quot; ry=&quot;0.0&quot; rz=&quot;0.0&quot; 设置热点是否跟随场景进行3D扭曲 details=&quot;8&quot; 热点显示的细节数量，默认为8 inverserotation=&quot;false&quot; 设置是否逆向旋转3D扭曲 flying=&quot;0.0&quot; 设置ath/atv/scale的插值 width=&quot;&quot; height=&quot;&quot; 设置热点宽高 scale=&quot;1.0&quot; 设置热点缩放 rotate=&quot;0.0&quot; 设置热点旋转角度 pixelhittest=&quot;false&quot; 是否启动精确像素测试 smoothing=&quot;true&quot; 设置缩放时，是否平滑化处理 accuracy=&quot;0&quot; 设置像素渲染值（flash下） accuracy2=&quot;1&quot; 设置精度控制（html5下） alpha=&quot;1.0&quot; 设置透明度 autoalpha=&quot;false&quot; 设置是否自动变更透明度 usecontentsize=&quot;false&quot; 是否使用用户指定flash大小，默认false原始大小 scale9grid=&quot;&quot; 定义是否支持矢量缩放，scale9grid=&quot;x-position|y-position|width|height|prescale*&quot; crop=&quot;&quot; 定义元素坐标及宽高 crop=&quot;x-position|y-position|width|height&quot; onovercrop=&quot;&quot; 设置元素鼠标移到上方后的坐标及宽高 ondowncrop=&quot;&quot; 设置元素鼠标按下状态后的坐标及宽高 scalechildren=&quot;false&quot; 子元素是否跟随缩放 mask=&quot;&quot; mask=&quot;name&quot; mask=&quot;layer[name]&quot; mask=&quot;hotspot[name]&quot; effect=&quot;&quot; 热点位图效果3种：glow(color,alpha,range,strength); dropshadow(depth,angle,color,range,strength); blur(radius); onover=&quot;&quot; 鼠标在经过上方时执行动作 onhover=&quot;&quot; 鼠标停在上方时执行动作 onout=&quot;&quot; 鼠标停移出范围时时执行动作 onclick=&quot;&quot; 鼠标停点击时执行动作 ondown=&quot;&quot; 鼠标按下时执行动作 onup=&quot;&quot; 鼠标按键松开时执行动作 onloaded=&quot;&quot; 加载元素完成后执行动作 /&gt; 多边形热点 &lt;hotspot name=&quot;...&quot; keep=&quot;false&quot; visible=&quot;true&quot; enabled=&quot;true&quot; handcursor=&quot;true&quot; zorder=&quot;&quot; capture=&quot;true&quot; blendmode=&quot;normal&quot; style=&quot;&quot; alpha=&quot;1.0&quot; autoalpha=&quot;false&quot; fillcolor=&quot;0xFFFFFF&quot; fillcolorhover=&quot;0xFFFFFF&quot; 填充颜色及鼠标移上后颜色 fillalpha=&quot;0.0&quot; fillalphahover=&quot;0.1&quot; 填充颜色透明度及鼠标移上后颜色透明度 borderwidth=&quot;0.0&quot; borderwidthhover=&quot;4.0&quot; 边界宽度及鼠标移上后边界宽度 bordercolor=&quot;0xFFFFFF&quot; bordercolorhover=&quot;0xFFFFFF&quot; 边界颜色及边界鼠标移上后颜色 borderalpha=&quot;0.0&quot; borderalphahover=&quot;0.8&quot; 边界透明度及鼠标移上后边界透明度 fadeintime=&quot;0.15&quot; fadeincurve=&quot;1.1&quot; 悬停状态变化时间及形式 fadeouttime=&quot;0.3&quot; fadeoutcurve=&quot;0.7&quot; onover=&quot;&quot; onhover=&quot;&quot; onout=&quot;&quot; onclick=&quot;&quot; ondown=&quot;&quot; onup=&quot;&quot; &gt; &lt;point ath=&quot;...&quot; atv=&quot;...&quot; /&gt; 多边形热点坐标 &lt;point ath=&quot;...&quot; atv=&quot;...&quot; /&gt; &lt;point ath=&quot;...&quot; atv=&quot;...&quot; /&gt; ... &lt;/hotspot&gt;","tags":[{"name":"krpano","slug":"krpano","permalink":"http://11wy11.github.io/tags/krpano/"}]},{"title":"C++之QT的信号和槽的详解","date":"2019-03-16T12:24:56.000Z","path":"2019/03/16/qt-note/","text":"1 简介 信号和槽是Qt特有的信息传输机制，是Qt设计程序的重要基础，它可以让互不干扰的对象建立一种联系。 在GUI编程中，当我们改变一个部件时，经常想要其他部件被通知。更一般化，我们希望任何一类的对象可以和其它对象进行通讯。例如，如果我们点击一个关闭按钮，我们可能想要窗口的close()函数被调用。 其他工具包通过回调实现了这种通信。回调是一个函数指针，所以如果你希望一个处理函数通知你一些事件，你可以把另一个函数（回调）的指针传递给处理函数。处理函数在适当的时候调用回调。尽管一些成功的框架使用了这个方法，但是回调可能是不直观的，并可能在确保回调参数类型正确性上存在问题。信号槽是 Qt 框架引以为豪的机制之一。所谓信号槽，实际就是观察者模式。当某个事件发生之后，比如，按钮检测到自己被点击了一下，它就会发出一个信号（signal）。这种发出是没有目的的，类似广播。如果有对象对这个信号感兴趣，它就会使用连接（connect）函数，意思是，将想要处理的信号和自己的一个函数（称为槽（slot））绑定来处理这个信号。也就是说，当信号发出时，被连接的槽函数会自动被回调。这就类似观察者模式：当发生了感兴趣的事件，某一个操作就会被自动触发。（这里提一句，Qt 的信号槽使用了额外的处理来实现，并不是 GoF 经典的观察者模式的实现方式。） 信号和槽是Qt特有的信息传输机制，是Qt设计程序的重要基础，它可以让互不干扰的对象建立一种联系。 槽的本质是类的成员函数，其参数可以是任意类型的。和普通C++成员函数几乎没有区别，它可以是虚函数；也可以被重载；可以是公有的、保护的、私有的、也可以被其他C++成员函数调用。唯一区别的是：槽可以与信号连接在一起，每当和槽连接的信号被发射的时候，就会调用这个槽。 Qt的小部件有很多预定义的信号，但是我们总是可以通过继承来加入我们自己的信号。槽就是一个对应于特定信号的被调用的函数。Qt的部件有很多预定义的槽，但同样可以通过子类化加入自己的槽来处理感兴趣的信号。 1.1 对象树(子对象动态分配空间不需要释放) 比如说当应用程序创建了一个具有父窗口部件的对象时，该对象将被加入父窗口部件的孩子列表。当应用程序销毁父窗口部件时，其下的孩子列表中的对象将被一一删除。这让我们在编程时，能够将主要精力放在系统的业务上，提高编程效率，同时也保证了系统的稳健性。 2 信号和槽 在Qt中我们有一种可以替代回调的技术：我们使用信号和槽。当一个特定事件发生的时候，一个信号被发射。Qt的小部件有很多预定义的信号，但是我们总是可以通过继承来加入我们自己的信号。槽就是一个对应于特定信号的被调用的函数。Qt的部件有很多预定义的槽，但同样可以通过子类化加入自己的槽来处理感兴趣的信号。 信号和槽机制是类型安全的：一个信号的签名(参数类型)必须与它的接收槽的签名相匹配。（实际上，一个槽的签名可能比它接收到的信号短，因为它可以忽略额外的参数。）因为签名是兼容的，当使用基于函数指针的语法时，编译器就可以帮助我们检测类型不匹配。基于字符串的信号和槽语法将在运行时检测类型不匹配。信号和插槽是松散耦合的：一个发射信号的类不用知道也不用关心哪个槽要接收这个信号。Qt的信号和槽的机制可以保证如果你把一个信号和一个槽连接起来，槽会在正确的时间使用信号的参数被调用。信号和槽可以使用任何数量、任何类型的参数。它们是完全类型安全的：不会再有回调核心转储(core dump)。 从QObject类或者它的子类（如QWidget类）继承的所有类可以包含信号和槽。当改变它们的状态的时候，信号被发送。从某种意义上说，即它们对其他对象感兴趣。这就是所有的对象通讯时所做的一切。它不知道也不关心是否有其他对象接收到了它发射的信号。这就是真正的信息封装，并且确保对象可以用作一个软件组件使用。 槽可以用来接收信号，但它们也是普通的成员函数。正如一个对象不知道有其他对象收到它的信号一样，一个槽也不知道它是否被任意信号连接。因此，这种方式保证了Qt创建组件的完全独立。 你可以连接多个信号到一个槽，同样一个信号可以被你需要的多个槽连接。甚至可以一个信号连接到另一个信号。（该情况下，只要第一个信 号被发射时，第二个信号立即被发射。） 总体来看，信号和槽构成了一个强有力的组件编程机制。 2.1 信号 当一个对象内部状态发生改变时发射信号，信号就被发射，在某些方面对象的客户端和所有者可能感兴趣。信号是一个public访问函数并可以在任何地方发射，但是我们建议仅在定义了信号的类及他们的子类中发射。 当一个信号被发射，它所连接的槽会被立即执行，类似于一个普通函数的调用。在该情况下，信号/槽机制在任何GUI事件循环中是完全独立的。一旦所有的槽返回了，emit语句随后的代码将会执行。这与queued connections方式有些许不同，queued connections方式下emit关键字随后的代码会立即继续执行，槽在随后执行（相当于异步，参考信号与槽的连接类型）。 如果几个槽被连接到一个信号，当信号被发射时，这些槽就会按它们连接的顺序挨个执行。 信号会由moc自动生成并一定不要在.cpp文件中实现。它们也不能有任何返回类型（也就是 只能使用void）。 2.2 槽 当与槽连接的信号被发射时，该槽被调用。槽是普通的C++函数可以正常调用；它们唯一的特点就是可以被信号连接。 因为槽是普通成员函数，所以被直接调用时遵循一般的C++规则。然而，作为槽，它们能被任何组件调用，通过信号槽连接，无需考虑访问级别。这意味着从一个任意类的实例发出的一个信号可以在一个不相关的类的实例中调用一个私有槽。 同样还可以定义虚拟槽，我们在实践中发现它非常有用。 与回调相比，信号和插槽的速度稍慢，因为它们增加了灵活性，尽管在实际应用程序中的差异是微不足道的。 信号和槽的机制是非常有效的，但是它不像“真正的”回调那样快。信号和槽稍微有些慢，这是因为它们所提供的灵活性造成，尽管在实际应用中这些性能可以被忽略。通常，发射一个和槽相连的信号，大约比直接调接收器非虚函数的调用慢十倍。这是定位连接对象所需的开销，为了安全地遍历所有连接（e.g检查随后的接收器在发射过程中没有被销毁），并以通用的方式安排任意参数。虽然10个非虚函数调用听起来可能很多，但开销比任意new或delete 操作少得多。当执行一个字符串时，vector或list操作在后面的场景中需要new或delete, 但信号和槽在完成函数调用的开销中只占很小的一部分。在一个槽中进行系统调用或者间接地调用超过10个函数，情况也是相同的;。信号/插槽机制的简单和灵活性对于时间的开销是值得，用户甚至不会注意到这点。 注意，与基于qt的应用程序一起编译时，定义变量的其他库调用信号和槽可能会造成编译器警告和错误。要解决这个问题，#undef这些预处理器的冲突符号即可。 2.3 一个Qt Creator的例子 1234567891011#include &lt;QApplication&gt;#include &lt;QPushButton&gt; int main(int argc, char *argv[]) &#123; QApplication app(argc, argv); QPushButton button(&quot;Quit&quot;); QObject::connect(&amp;button, &amp;QPushButton::clicked, &amp;app, &amp;QApplication::quit); button.show(); return app.exec(); &#125; 在 Qt Creator 中创建工程的方法创建好工程，然后将main()函数修改为上面的代码。点击运行，我们会看到一个按钮，上面有“Quit”字样。点击按钮，程序退出。 connect()函数最常用的一般形式： connect(sender, signal, receiver, slot); 参数： sender：发出信号的对象 signal：发送对象发出的信号 receiver：接收信号的对象 slot：接收对象在接收到信号之后所需要调用的函数 信号槽要求信号和槽的参数一致，所谓一致，是参数类型一致。如果不一致，允许的情况是，槽函数的参数可以比信号的少，即便如此，槽函数存在的那些参数的顺序也必须和信号的前面几个一致起来。这是因为，你可以在槽函数中选择忽略信号传来的数据（也就是槽函数的参数比信号的少），但是不能说信号根本没有这个数据，你就要在槽函数中使用（就是槽函数的参数比信号的多，这是不允许的）。 2.4 一个普通C++程序的例子 一个小的C++类声明如下： 12345678910class Counter &#123; public: Counter() &#123; m_value = 0; &#125; int value() const &#123; return m_value; &#125; void setValue(int value); private: int m_value; &#125;; 一个小的基于QObject类如下： 123456789101112131415#include &lt;QObject&gt; class Counter : public QObject &#123; Q_OBJECT public: Counter() &#123; m_value = 0; &#125; int value() const &#123; return m_value; &#125; public slots: void setValue(int value); signals: void valueChanged(int newValue); private: int m_value; &#125;; 这个基于QObject的类有同样的内部状态，并提供公有方法来访问状态。除此之外，这个类可以通过发射一个valueChanged()信号来告诉外部世界关于它的状态改变，并且它有一个槽，其它对象可以发送信号给这个槽。 所有包含信号和/或者槽的类必须在它们的声明中提到Q_OBJECT。它们也必须从QObject继承(直接或间接)。 槽由应用程序的编写者来实现。这里是Counter::setValue()可能的一个槽实现： 1234567void Counter::setValue(int value) &#123; if (value != m_value) &#123; m_value = value; emit valueChanged(value); &#125; &#125; emit这一行从对象中发射valueChanged()信号，以一个新值作为参数。 在下面的小片断中，我们创建了两个Counter对象，并使用QObject::connect()将第一个对象的valueChanget()信号连接到第二个对象的setValue槽。 下面是把两个对象连接在一起的一种方法： 123456Counter a, b; QObject::connect(&amp;a, &amp;Counter::valueChanged, &amp;b, &amp;Counter::setValue); a.setValue(12); // a.value() == 12, b.value() == 12 b.setValue(48); // a.value() == 12, b.value() == 48 调用a.setValue(12)会使a发射一个valueChanged(12) 信号，b将会在它的setValue()槽中接收这个信号，也就是b.setValue(12) 被调用。接下来b会发射同样的valueChanged()信号，但是因为没有槽被连接到b的valueChanged()信号，所以该信号被忽略。 注意只有当value!= m_value的时候setValue()函数才会设置这个值并发射信号。这样就避免了存在环connections的情况下无限循环。（比如b.valueChanged() 和a.setValue()连接在一起）。 默认情况下，对于你做出的每一个连接，一个信号被发射;重复连接下两个信号被发射。你可以调用disconnect()中断所有连接。如果传递了Qt::UniqueConnection类型，连接只有在不重复的情况下才建立。如果已经存在重复连接（同一个对象上确定的信号到确定的槽），则连接将会失败，connect返回fase。 这个例子说明了对象可以协同工作而不需要知道彼此的任何信息。为达到这种效果，对像仅需要相互连接，并用一个简单的QObject::connect()函数调用实现，或者使用uic的自动连接特性。 2.5 带有默认参数的信号和槽 信号和槽的签名可能包含参数，参数可以有默认值。考虑QObject::destroyed()函数。 void destroyed(QObject* = 0); 当一个QObject对象被删除，它发射QObject::destroyed()信号。我们想捕获此信号，无论在我们可能有一个悬空的引用指向删除的QObject对象的情况下，因此我们可以把它清理干净。一个合适的槽签名可能是这样的: void objectDestroyed(QObject* obj = 0); 为连接一个信号到此槽，我们使用QObject::connect。这里有几个方式连接。第一种方式是使用函数指针： connect(sender,&amp;QObject::destroyed,this,&amp;MyObject::objectDestroyed); 连接信号到槽的另一种方法是使用QObject::connect()，SIGNAL和SLOT宏。关于是否在SIGNAL()和SLOT()宏中包含参数的规则，如果参数有默认值，传递给SIGNAL()宏的签名必须不能少于传递给SLOT()宏签名的参数。 下述这些都会生效：12345678connect(sender,SIGNAL(destroyed(QObject*)),this,SLOT(objectDestroyed(Qbject*)));connect(sender,SIGNAL(destroyed(QObject*)),this,SLOT(objectDestroyed()));connect(sender, SIGNAL(destroyed()),this,SLOT(objectDestroyed())); 2.6 信号和槽的进一步使用 对于可能需要信号发送者信息的情况, Qt提供了QObject::sender()函数，它返回一个指向发送信号的对象的指针。 QSignalMapper类为一种情形提供，该情况下多个信号连接到同一个槽，而槽需要以不同的方式处理每个信号。 假设有三个按钮来决定将打开哪个文件: “Tax File”, “Accounts File”, “Report File”. 为了打开正确的文件,使用QSignalMapper:setMapping()来映射所有QPushButton:clicked()到QSignalMapper对象。然后将文件的QPushButton::clicked()信号连接到QSignalMapper::map()槽。 123456789101112131415161718signalMapper = new QSignalMapper(this); signalMapper-&gt;setMapping(taxFileButton, QString(&quot;taxfile.txt&quot;)); signalMapper-&gt;setMapping(accountFileButton, QString(&quot;accountsfile.txt&quot;)); signalMapper-&gt;setMapping(reportFileButton, QString(&quot;reportfile.txt&quot;)); connect(taxFileButton, &amp;QPushButton::clicked, signalMapper, &amp;QSignalMapper::map); connect(accountFileButton, &amp;QPushButton::clicked, signalMapper, &amp;QSignalMapper::map); connect(reportFileButton, &amp;QPushButton::clicked, signalMapper, &amp;QSignalMapper::map); 然后，将mapped()信号连接到readFile()，根据按下的按钮，readFile()打开不同的文件。connect(signalMapper, SIGNAL(mapped(QString)),this, SLOT(readFile(QString))); 2.7 自定义信号槽 发送者和接收者都需要是QObject的子类（当然，槽函数是全局函数、Lambda 表达式等无需接收者的时候除外）； 使用 signals 标记信号函数，信号是一个函数声明，返回 void，不需要实现函数代码； 槽函数是普通的成员函数，作为成员函数，会受到 public、private、protected 的影响； 使用 emit 在恰当的位置发送信号； 使用QObject::connect()函数连接信号和槽。 任何成员函数、static 函数、全局函数和 Lambda 表达式都可以作为槽函数 2.8 信号槽的更多用法 一个信号可以和多个槽相连 如果是这种情况，这些槽会一个接一个的被调用，但是它们的调用顺序是不确定的。 多个信号可以连接到一个槽 只要任意一个信号发出，这个槽就会被调用。 一个信号可以连接到另外的一个信号 当第一个信号发出时，第二个信号被发出。除此之外，这种信号-信号的形式和信号-槽的形式没有什么区别。 槽可以被取消链接 这种情况并不经常出现，因为当一个对象delete之后，Qt自动取消所有连接到这个对象上面的槽。 使用Lambda 表达式 在使用 Qt 5 的时候，能够支持 Qt 5 的编译器都是支持 Lambda 表达式的。 我们的代码可以写成下面这样： 12345QObject::connect(&amp;newspaper, static_cast&lt;void (Newspaper:: *)(const QString &amp;)&gt;(&amp;Newspaper::newPaper),[=](const QString &amp;name) &#123; /* Your code here. */ &#125;); 在连接信号和槽的时候，槽函数可以使用Lambda表达式的方式进行处理。 3 案例mainwidget.h 123456789101112131415161718192021222324252627282930#ifndef MAINWIDGET_H#define MAINWIDGET_H#include &lt;QWidget&gt;#include &lt;QPushButton&gt;#include &quot;subwidget.h&quot; //子窗口头文件class MainWidget : public QWidget&#123; Q_OBJECTpublic: MainWidget(QWidget *parent = 0); ~MainWidget();public slots: void mySlot(); void changeWin(); void dealSub(); void dealSlot(int, QString);private: QPushButton b1; QPushButton *b2; QPushButton b3; SubWidget subWin;&#125;;#endif // MAINWIDGET_H subwidget.h 1234567891011121314151617181920212223242526272829303132#ifndef SUBWIDGET_H#define SUBWIDGET_H#include &lt;QWidget&gt;#include &lt;QPushButton&gt;class SubWidget : public QWidget&#123; Q_OBJECTpublic: explicit SubWidget(QWidget *parent = 0); void sendSlot();signals: /* 信号必须有signals关键字来声明 * 信号没有返回值，但可以有参数 * 信号就是函数的声明，只需声明，无需定义 * 使用：emit mySignal(); * 信号可以重载 */ void mySignal(); void mySignal(int, QString);public slots:private: QPushButton b;&#125;;#endif // SUBWIDGET_H main.cpp 1234567891011#include &quot;mainwidget.h&quot;#include &lt;QApplication&gt;int main(int argc, char *argv[])&#123; QApplication a(argc, argv); MainWidget w;//执行MainWidget的构造函数 w.show(); return a.exec();&#125; mainvidget.cpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120#include &quot;mainwidget.h&quot;#include &lt;QPushButton&gt;#include &lt;QDebug&gt; //打印MainWidget::MainWidget(QWidget *parent) : QWidget(parent)&#123; b1.setParent(this); b1.setText(&quot;close&quot;); b1.move(100, 100); b2 = new QPushButton(this); b2-&gt;setText(&quot;abc&quot;); connect(&amp;b1, &amp;QPushButton::pressed, this, &amp;MainWidget::close); /* &amp;b1: 信号发出者，指针类型 * &amp;QPushButton::pressed：处理的信号， &amp;发送者的类名::信号名字 * this: 信号接收者 * &amp;MainWidget::close： 槽函数，信号处理函数 &amp;接收的类名::槽函数名字 * 发送-处理-接收-处理 */ /* 自定义槽，普通函数的用法 * Qt5：任意的成员函数，普通全局函数，静态函数 * 槽函数需要和信号一致（参数，返回值） * 由于信号都是没有返回值，所以，槽函数一定没有返回值 */ connect(b2, &amp;QPushButton::released, this, &amp;MainWidget::mySlot); connect(b2, &amp;QPushButton::released, &amp;b1, &amp;QPushButton::hide); /* 信号：短信 * 槽函数：接收短信的手机 */ setWindowTitle(&quot;老大&quot;); //this-&gt;setWindowTitle(&quot;老大&quot;);//等价同上 b3.setParent(this); b3.setText(&quot;切换到子窗口&quot;); b3.move(50, 50); //显示子窗口 //subWin.show(); connect(&amp;b3, &amp;QPushButton::released, this, &amp;MainWidget::changeWin); //处理子窗口的信号// void (SubWidget::*funSignal)() = &amp;SubWidget::mySignal;// connect(&amp;subWin, funSignal, this, &amp;MainWidget::dealSub);// void (SubWidget::*testSignal)(int, QString) = &amp;SubWidget::mySignal;// connect(&amp;subWin, testSignal, this, &amp;MainWidget::dealSlot); //Qt4信号连接 //Qt4槽函数必须有slots关键字来修饰 connect(&amp;subWin, SIGNAL(mySignal()), this, SLOT(dealSub()) ); connect(&amp;subWin, SIGNAL(mySignal(int,QString)), this, SLOT(dealSlot(int,QString)) ); //缺点： SIGNAL SLOT 将函数名字 -&gt; 字符串 不进行错误检查 //Lambda表达式, 匿名函数对象 //C++11增加的新特性， 项目文件： CONFIG += C++11 //Qt配合信号一起使用，非常方便 QPushButton *b4 = new QPushButton(this); b4-&gt;setText(&quot;Lambda表达式&quot;); b4-&gt;move(150, 150); int a = 10, b = 100; connect(b4, &amp;QPushButton::clicked, // = :把外部所有局部变量、类中所有成员以值传递方式 // this: 类中所有成员以值传递方式 // &amp; : 把外部所有局部变量， 引用符号 [=](bool isCheck) &#123; qDebug() &lt;&lt; isCheck; &#125; ); resize(400, 300);&#125;void MainWidget::dealSlot(int a, QString str)&#123; // str.toUtf8() -&gt; 字节数组QByteArray // ……data() -&gt; QByteArray -&gt; char * qDebug() &lt;&lt; a &lt;&lt; str.toUtf8().data();&#125;void MainWidget::mySlot()&#123; b2-&gt;setText(&quot;123&quot;);&#125;void MainWidget::changeWin()&#123; //子窗口显示 subWin.show(); //本窗口隐藏 this-&gt;hide();&#125;void MainWidget::dealSub()&#123; //子窗口隐藏 subWin.hide(); //本窗口显示 show();&#125;MainWidget::~MainWidget()&#123;&#125; subwidget.cpp 123456789101112131415161718#include &quot;subwidget.h&quot;SubWidget::SubWidget(QWidget *parent) : QWidget(parent)&#123; this-&gt;setWindowTitle(&quot;小弟&quot;); b.setParent(this); b.setText(&quot;切换到主窗口&quot;); connect(&amp;b, &amp;QPushButton::clicked, this, &amp;SubWidget::sendSlot); resize(400, 300);&#125;void SubWidget::sendSlot()&#123; emit mySignal(); emit mySignal(250, &quot;我是子窗口&quot;);&#125; SingnalAndSlot.pro 12345678910111213141516QT += core guigreaterThan(QT_MAJOR_VERSION, 4): QT += widgetsTARGET = 03_SignalAndSlotTEMPLATE = appSOURCES += main.cpp\\ mainwidget.cpp \\ subwidget.cppHEADERS += mainwidget.h \\ subwidget.hCONFIG += C++11 4 总结 结构图 5 参考博文 C++_之Qt的信号和槽的详解 https://www.cnblogs.com/wanghui1234/p/8964968.html Qt信号和槽机制 https://blog.csdn.net/lsfreeing/article/details/78575246","tags":[{"name":"C++","slug":"C","permalink":"http://11wy11.github.io/tags/C/"},{"name":"QT","slug":"QT","permalink":"http://11wy11.github.io/tags/QT/"}]},{"title":"krpano快速入门教程（二）","date":"2019-03-15T15:19:51.000Z","path":"2019/03/15/krpano-second-note/","text":"vtour全景漫游及vtour文件夹介绍使用MAKE VTOUR (MULTIRES) droplet工具生成全景漫游 背景在初始学习krpano时，可以借助krpano的工具生成全景漫游文件，之后可以根据需要修改tour.xml,定制skin等；上节简单介绍了krpano使用Make pano的工具创建单场景应用，但大多数应用中场景数量不只一个，彼此之间可以跳转，这就需要借助MAKE VTOUR droplet工具了。而具体选择三种中的哪一种，根据应用场景需要选择，multires支持将全景切片分级，能够达到更好的展示效果，但会使全景文件大小增加，normal生成普通的pano_f.jpg,pano_b.jpg,pano_l.jpg，pano_r.jpg，pano_u.jpg，pano_d.jpg,preview.jpg，分别为全景图的前后左右上下，以及菜单中的预览图。 生成vtour使用MAKE VTOUR (MULTIRES) droplet工具生成的全景漫游场景，场景彼此之间相互连接，能够从一个场景跳转到另一个场景。可以同时选择多张全景图片拖放在该工具上，输入全景图类型，和全景角度，执行切片，等待完成。显示done之后，在全景图文件夹中生成vtour文件夹。 vtour文件夹内容介绍 tour.html文件–嵌入全景的网页 tour.swf文件–krpano的flash viewer tour.js文件–基于swfkrpano.js的一个viewer，即HTML5的viewer及嵌入HTML的js文件的合体 tour.xml文件–是krpano xml配置文件，定义全景图配置及皮肤配置 panos文件夹–存放处理后的全景图切片 plugins文件夹–主要存放使用到的插件 预览效果 效果图 补充之后的主要工作为：定制skin，定制plugins，定制xml，一些动态操作全景图配置使编辑js文件，能够实现动态配置全景图程序，能够更好的融入到Web应用程序中，作为其中一个子功能模块。后续结合实际案例介绍具体实现方式。历史文章 历史文章krpano快速入门教程（一)","tags":[{"name":"krpano","slug":"krpano","permalink":"http://11wy11.github.io/tags/krpano/"}]},{"title":"krpano快速入门教程（一）","date":"2019-03-14T07:54:54.000Z","path":"2019/03/14/krpano-first-note/","text":"使用krpano工具构建即用型panos简单使用krpano工具快速生成可执行的pano文件，后续介绍如何自定义编写配置文件切图等 krpano简介Krpano是一款全景漫游制作软件和工具。用krpano所生成的全景，在兼容性、功能性、互动性方面的表现都很不错，而且可以二次开发并拥有自己的编程语言，比如使用专用的krpano xml代码编写全景漫游，可开发出高度定制化的项目。因此，目前主流的全景网站均是在krpano全景的基础上进行开发，并不断进行更新迭代，形成自己独有的全景内容服务。 具体步骤 从krpano下载页面下载适合于自己系统的krpano Tools软件包 将下载的krpano Tools zip文件解压到一个不含中文路径的文件夹下（为了所有稳定使用，推荐） 如果您已拥有krpano许可文件 - 则立即将其复制或移动到krpano Tools文件夹中。如果您没有任何一个，那么只需跳过此步骤即可。之后可以通过注册码注册，具体破解方法请自行百度，注册后能够去掉切片中的krpano水印。 要构建单个全景图 - 打开包含全景图像的文件夹，选择其中一个或全部，拖放到MAKE PANO droplet批处理工具上。等待切片完成，会在全景图像所在文件夹中生成一个以全景图命名的文件夹，里面自动生成一个即用型pano,点击tour_testingsever运行测试服务器，打开index.html查看效果。需要说明的是，这里如果没有注册，运行之后全景图是有krpano水印的。可以运行krpano tools选择 register now 输入序列号完成注册。注册完在按照第4步操作，得到没有水印的全景图注册前 注册后 要构建虚拟游览 - 打开包含全景虚拟游览图像的文件夹，选择所有这些图像拖放到MAKE VTOURdroplet批处理工具上。 其他工具使用类似，主要功能简介如下： MAKE PANO (NORMAL) droplet针对标准全景图（360度），最大值。cubeize默认限制为2200像素（可以在’templates / normal.config’文件中更改），没有皮肤 - 只需pano，HTML5 iPhone / iPad就绪 MAKE PANO（MULTIRES）droplet用于渐进多分辨率的panos，没有尺寸/分辨率限制，快速动态加载，带按钮的默认皮肤，HTML5 iPhone / iPad就绪 MAKE PANO（FLAT）droplet用于平面/ 2D平移/图像，平铺多分辨率，无尺寸/分辨率限制，平坦全景/图像的皮肤/控制，仅限闪光 MAKE PANO（SINGLESWF）droplet只生成一个Flash swf文件，对于标准全景图，完整的pano将立即加载，最大值。cubesize限制为2200像素（可在’templates / singleswf.config’文件中更改），默认皮肤带按钮，仅限Flash MAKE OBJECT droplet用于平铺多分辨率对象影片，一次删除所有对象图像，没有大小/分辨率限制，快速和动态加载，具有按钮和对象旋转控件的对象外观，仅限Flash MAKE VTOUR (NORMAL) droplet / MAKE VTOUR (MULTIRES) droplet 用于自动构建虚拟游览，将所有全景图像放在此工具上，通过自动缩略图生成，准备好HTML5 iPhone / iPad 处理完成后关闭dos / terminal窗口。在源图像的文件夹中会有新文件：典型的.html文件 - 这是嵌入pano的示例网页，.swf文件 - 这是krpano Flash查看器，.js文件 - 这是Javascript Flash到HTML嵌入代码（基于swfkrpano.js）和可选的krpano HTML5 / Javascript iPhone / iPad查看器，一个.xml文件 - 这是krpano xml文件，有pano和皮肤定义，最后有.tiles文件夹 - 有处理过的全景图像。全景图像本身不是观看全景图像所必需的。 6.2。当您使用MAKE VTOUR Droplet时，这些文件将位于’vtour’文件夹中，而pano图像位于其中的’panos’文件夹中。 编辑全景设置打开并在任何文本编辑器中编辑生成的xml文件（带有xml-syntax-highlighting的文本编辑器可能会有帮助）： 在在线文档中查找krpano xml定义：","tags":[{"name":"krpano","slug":"krpano","permalink":"http://11wy11.github.io/tags/krpano/"}]},{"title":"AI组件开发（一）--注记旋转矩阵","date":"2019-03-14T02:56:02.000Z","path":"2019/03/14/ai-first-note/","text":"SDK官方帮助文档AIAPI void( AIRealMathSuite::AIRealMatrixSet)(AIRealMatrix m, AIReal a, AIReal b, AIReal c, AIReal d, AIReal tx, AIReal ty)Sets the scale, rotation, and translation values of a transformation matrix.Parameters:m The matrix object.a New a value.b New b value.c New c value.d New d value.tx New horizontal translation value.ty New vertical translation value. 参数及原理分析ad缩放bc旋转tx,ty位移，基础的2D矩阵 公式 x=ax+cy+tx y=bx+dy+ty 为了把二维图形的变化统一在一个坐标系里，引入了齐次坐标的概念，即把一个图形用一个三维矩阵表示，其中第三列总是(0,0,1)，用来作为坐标系的标准。所以所有的变化都由前两列完成以上参数在矩阵中的表示为： |a b 0| |c d 0| |tx ty 1| 运算原理：原坐标设为（X,Y,1）; |a b 0| [X，Y, 1] |c d 0| = [aX + cY + tx bX + dY + ty 1] ; |tx ty 1| 通过矩阵运算后的坐标[aX + cY + tx bX + dY + ty 1]，我们对比一下可知： 第一种：设a=d=1, b=c=0. [aX + cY + tx bX + dY + ty 1] = [X + tx Y + ty 1]; 可见，这个时候，坐标是按照向量（tx，ty）进行平移，其实这也就是函数 第二种：设b=c=tx=ty=0. [aX + cY + tx bX + dY + ty 1] = [aX dY 1]; 可见，这个时候，坐标X按照a进行缩放，Y按照d进行缩放，a，d就是X，Y的比例系数，其实这也就是函数 第三种：设tx=ty=0，a=cosɵ，b=sinɵ，c=-sinɵ，d=cosɵ。 [aX + cY + tx bX + dY + ty 1] = [Xcosɵ - Ysinɵ Xsinɵ + Ycosɵ 1] ; 可见，这个时候，ɵ就是旋转的角度，逆时针为正，顺时针为负。其实这也就是函数","tags":[{"name":"AI","slug":"AI","permalink":"http://11wy11.github.io/tags/AI/"}]},{"title":"csdn-markdown编辑器语法","date":"2019-03-13T16:03:21.000Z","path":"2019/03/14/csdn-markdown-grammar/","text":"@TOC 欢迎使用Markdown编辑器你好！ 这是你第一次使用 Markdown编辑器 所展示的欢迎页。如果你想学习如何使用Markdown编辑器, 可以仔细阅读这篇文章，了解一下Markdown的基本语法知识。 功能快捷键撤销：Ctrl/Command + Z重做：Ctrl/Command + Y加粗：Ctrl/Command + B斜体：Ctrl/Command + I标题：Ctrl/Command + Shift + H无序列表：Ctrl/Command + Shift + U有序列表：Ctrl/Command + Shift + O检查列表：Ctrl/Command + Shift + C插入代码：Ctrl/Command + Shift + K插入链接：Ctrl/Command + Shift + L插入图片：Ctrl/Command + Shift + G 合理的创建标题，有助于目录的生成直接输入1次#，并按下space后，将生成1级标题。输入2次#，并按下space后，将生成2级标题。以此类推，我们支持6级标题。有助于使用TOC语法后生成一个完美的目录。 如何改变文本的样式强调文本 强调文本 加粗文本 加粗文本 ==标记文本== 删除文本 引用文本 H~2~O is是液体。 2^10^ 运算结果是 1024. 插入链接与图片链接: link. 图片: Alt 带尺寸的图片: =30x30 居中的图片: Alt 居中并且带尺寸的图片: =30x30 当然，我们为了让用户更加便捷，我们增加了图片拖拽功能。 如何插入一段漂亮的代码片去博客设置页面，选择一款你喜欢的代码片高亮样式，下面展示同样高亮的 代码片.12// An highlighted blockvar foo = 'bar'; 生成一个适合你的列表 项目 项目 项目 项目1 项目2 项目3 计划任务 完成任务 创建一个表格一个简单的表格是这么创建的：项目 | Value——– | —–电脑 | $1600手机 | $12导管 | $1 设定内容居中、居左、居右使用:---------:居中使用:----------居左使用----------:居右| 第一列 | 第二列 | 第三列 ||:———–:| ————-:|:————-|| 第一列文本居中 | 第二列文本居右 | 第三列文本居左 | SmartyPantsSmartyPants将ASCII标点字符转换为“智能”印刷标点HTML实体。例如：| TYPE |ASCII |HTML|—————-|——————————-|—————————–||Single backticks|&#39;Isn&#39;t this fun?&#39; |’Isn’t this fun?’ ||Quotes |&quot;Isn&#39;t this fun?&quot; |”Isn’t this fun?” ||Dashes |-- is en-dash, --- is em-dash|– is en-dash, — is em-dash| 创建一个自定义列表Markdown: Text-to-HTML conversion tool Authors: John: Luke 如何创建一个注脚一个具有注脚的文本。^2 注释也是必不可少的Markdown将文本转换为 HTML。 *[HTML]: 超文本标记语言 KaTeX数学公式您可以使用渲染LaTeX数学表达式 KaTeX: Gamma公式展示 $\\Gamma(n) = (n-1)!\\quad\\foralln\\in\\mathbb N$ 是通过欧拉积分 $$\\Gamma(z) = \\int_0^\\infty t^{z-1}e^{-t}dt\\,.$$ 你可以找到更多关于的信息 LaTeX 数学表达式here. 新的甘特图功能，丰富你的文章12345678gantt dateFormat YYYY-MM-DD title Adding GANTT diagram functionality to mermaid section 现有任务 已完成 :done, des1, 2014-01-06,2014-01-08 进行中 :active, des2, 2014-01-09, 3d 计划一 : des3, after des2, 5d 计划二 : des4, after des3, 5d 关于 甘特图 语法，参考 这儿, UML 图表可以使用UML图表进行渲染。 Mermaid. 例如下面产生的一个序列图：: 123456789sequenceDiagram张三 -&gt;&gt; 李四: 你好！李四, 最近怎么样?李四--&gt;&gt;王五: 你最近怎么样，王五？李四--x 张三: 我很好，谢谢!李四-x 王五: 我很好，谢谢!Note right of 王五: 李四想了很长时间, 文字太长了&lt;br/&gt;不适合放在一行.李四--&gt;&gt;张三: 打量着王五...张三-&gt;&gt;王五: 很好... 王五, 你怎么样? 这将产生一个流程图。: 12345graph LRA[长方形] -- 链接 --&gt; B((圆))A --&gt; C(圆角长方形)B --&gt; D&#123;菱形&#125;C --&gt; D 关于 Mermaid 语法，参考 这儿, FLowchart流程图我们依旧会支持flowchart的流程图：123456789flowchatst=&gt;start: 开始e=&gt;end: 结束op=&gt;operation: 我的操作cond=&gt;condition: 确认？st-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op 关于 Flowchart流程图 语法，参考 这儿. 导出与导入导出如果你想尝试使用此编辑器, 你可以在此篇文章任意编辑。当你完成了一篇文章的写作, 在上方工具栏找到 文章导出 ，生成一个.md文件或者.html文件进行本地保存。 导入如果你想加载一篇你写过的.md文件或者.html文件，在上方工具栏可以选择导入功能进行对应扩展名的文件导入，继续你的创作。","tags":[{"name":"markdown","slug":"markdown","permalink":"http://11wy11.github.io/tags/markdown/"}]},{"title":"git常用命令","date":"2019-03-13T12:41:15.000Z","path":"2019/03/13/git-command/","text":"强制本地覆盖远程分支 1234567 git push origin *** --force ``` 2. 放弃本地分支，远程分支强制覆盖本地 git fetch --all //只是下载代码到本地，不进行合并操作git reset --hard origin/分支名如master //把HEAD指向最新下载的版本3. 删除远程分支和本地分支 git branch -a//查看分支git push origin –delete // 删除远程分支git branch -d //删除本地分支 1234. git diff 检查文件更改内容5. 撤销未提交的修改git checkout git checkout app/src/main/../MainActivity 16、git reset git log #找到需要退回的commit版本号，可以只复制前几位git reset &lt;刚查找到的版本号&gt;`7、git log","tags":[{"name":"git","slug":"git","permalink":"http://11wy11.github.io/tags/git/"}]},{"title":"使用hexo+github创建个人博客并备份源码","date":"2019-03-09T13:52:06.000Z","path":"2019/03/09/create-blog-process/","text":"一、准备 安装node.js 安装git-windows 安装hexo-cli 1$npm install hexo-cli -g 在GitHub上创建&lt;username&gt;.github.io的仓库 e.g. 11wy11.github.io 配置SSH key打开本机的控制台，以windows系统为例，可以执行win+R 输入cmd打开，执行 1ssh -keygen -t rsa -C &apos;D:/id.txt&apos; 然后连续按3次回车，最终会在用户目录下生成一个文件，找到目录.ssh/id_rsa.pub文件，用记事本打开全选复制。在你的github上点击头像&gt;设置进入设置页面，选择SSH and GPG keys, 点击New SSH key按钮，名称随意填写，将刚复制的内容粘贴到key,添加 二、搭建流程 本地创建&lt;username&gt;.github.io 在本地&lt;username&gt;.github.io文件夹下初始化hexo项目并安装依赖 123hexo init //初始化工程npm install //安装依赖hexo server //启动本地调试器在localhost:4000预览 修改默认主题，可以在github上clone其他的主题，如yilia,icarus,indigo等 以indigo为例，在本地&lt;username&gt;.github.io文件夹下执行以下命令安装主题 1git clone git@github.com:yscoder/hexo-theme-indigo.git themes/indigo 修改工程中的_config.yml配置文件，将themes: landscope改为themes: indigo 依赖安装分别安装Less,Feed,Json-content依赖，执行如下命令 123$ npm install hexo-renderer-less --save$ npm install hexo-generator-feed --save$ npm install hexo-generator-json-content --save 执行hexo s命令启动服务器在localhost:4000查看效果 新建文章，使用hexo new “my-first blog”，会在source/_posts下创建my-first-blog.md的页面文件进行编写 发布博客首先修改工程中的_config.yml配置文件，在最后三行添加以下代码，将username换成自己的git用户名 1234deploy: type: git repo: git@github.com:&lt;username&gt;/&lt;username&gt;.github.io.git branch: master 其次安装hexo-deployer-git 执行 npm install hexo-deployer-git --save 在工程文件夹内右键git bash进入命令行 输入hexo g，编译为静态文件，生成public文件夹，使用 hexo d 部署，此时可以访问https://&lt;username&gt;.github.io查看你的博客 备份源码 在工程文件夹内右键git bash进入命令行 输入 touch .gitignore ，生成“.gitignore”文件。 在”.gitignore” 文件里输入你要忽略的文件夹及其文件就可以了。（注意格式） 我的 .gitignore：node_modules/ .deploy_git public/ .DS_Store Thumbs.db db.json *.log .deploy*/ 执行以下命令#git初始化 git init #创建hexo分支，用来存放源码 git checkout -b hexo #git 文件添加 git add . #git 提交 git commit -m &quot;init&quot; #添加远程仓库 git remote add origin git@github.com:&lt;username&gt;/&lt;username&gt;.github.io.git #push到hexo分支 git push origin hexo 执行hexo g -d生成网站并部署到GitHub上 这样一来，在GitHub上的git@github.com:&lt;username&gt;/&lt;username&gt;.github.io.git仓库就有两个分支，一个hexo分支用来存放网站的原始文件，一个master分支用来存放生成的静态网页。 其他设备更新博客步骤： 1、先安装hexo $ npm install -g hexo-cli 2、存在github上的git clone下来 git clone -b hexo git@github.com:&lt;username&gt;/&lt;username&gt;.github.io.git 3、项目文件夹下 $ npm install $ npm install hexo-deployer-git 4、重新配置github和coding的公钥 5、编写博客push 到远程分支 补充 有时会出现下载的主题无法上传，首先删除themes/主题文件夹下的.git,使用git rm --cached themes/indigo命令清空后重新上传` 如果最开始.gitignore文件没有配置正确，可以使用git rm -r --cached .命令清楚缓存文件，重新add,commit,push上传","tags":[{"name":"hexo","slug":"hexo","permalink":"http://11wy11.github.io/tags/hexo/"},{"name":"git","slug":"git","permalink":"http://11wy11.github.io/tags/git/"}]},{"title":"Vue全局添加组件","date":"2019-03-09T02:39:22.000Z","path":"2019/03/09/Vue-global-component/","text":"一. 背景在项目中有时需要反复用到如区域选择器等组件，每次使用时都需要在对应的vue中添加import,并在component中注册，为了避免多次书写引用代码，可以自定义全局组件，只需要在main.js中一次性注册在vue项目中，可以自定义组件像vue-resource一样使用Vue.use（）方法来使用。 二. 具体实现方法1、首先建一个自定义组件的文件夹，比如叫loading，在该文件夹下新建一个index.js，一个自定义组件loading.vue,在这个loading.vue里面就是这个组件的具体的内容， 2、在index.js中，规定使用这个组件的名字，以及使用方法，如： import loadingComponent from &apos;./loading.vue&apos; const loading={ install:function(Vue){ Vue.component(&apos;Loading&apos;,loadingComponent) } //&apos;Loading&apos;这就是后面可以使用的组件的名字，install是默认的一个方法 }; export default loading; 3、只要在main.js中规定了install方法，就可以像一些公共的插件一样使用Vue.use()来使用： import loading from &apos;./loading&apos; Vue.use(loading）","tags":[{"name":"Vue","slug":"Vue","permalink":"http://11wy11.github.io/tags/Vue/"}]},{"title":"Oracle配置SDE支持空间查询","date":"2019-03-09T01:56:40.000Z","path":"2019/03/09/oracle-st-geometry/","text":"配置oracle外部链接库 将ArcGIS Desktop安装目录下DatabaseSupport文件夹下的st_shapelib.dll拷贝到装有oracle的服务器上，可以放置在任意地方，这里推荐放在Oracle安装目录下的bin文件夹下。 例如：st_shapelib.dll所在文件夹路径： C:\\ProgramFiles(x86)\\ArcGIS\\Desktop10.2\\DatabaseSupport\\Oracle\\Windows64\\st_shapelib.dll 拷贝放置位置：E:\\app\\503\\product\\11.2.0\\dbhome_1\\BIN\\ st_shapelib.dll 修改oracle安装目录下的network/admin文件夹下的listener.ora,将步骤1中的st_shapelib.dll路径添加到ENVS”EXTPROC_DLLS=ONLY:E:\\app\\503\\product\\11.2.0\\dbhome_1\\bin\\oraclr11.dll;后面 例如：linstener文件，添加红色字部分 1234567891011121314151617181920212223# listener.ora Network Configuration File: D:\\app\\Administrator\\product\\11.2.0\\dbhome_1\\NETWORK\\ADMIN\\listener.ora# Generated by Oracle configuration tools.SID_LIST_LISTENER = (SID_LIST = (SID_DESC = (SID_NAME = CLRExtProc) (ORACLE_HOME = E:\\app\\503\\product\\11.2.0\\dbhome_1) (PROGRAM = extproc) (ENVS= &quot;EXTPROC_DLLS=ONLY:E:\\app\\503\\product\\11.2.0\\dbhome_1\\bin\\oraclr11.dll;E:\\app\\503\\product\\11.2.0\\dbhome_1\\bin\\st_shapelib.dll&quot;) # interesting ) ) LISTENER = (DESCRIPTION_LIST = (DESCRIPTION = (ADDRESS = (PROTOCOL = TCP)(HOST = 503-PC)(PORT = 1521)) (ADDRESS = (PROTOCOL = IPC)(KEY = EXTPROC1521)) ) (DESCRIPTION = (ADDRESS = (PROTOCOL = TCP)(HOST = 192.168.1.164)(PORT = 1521)) ) ) ADR_BASE_LISTENER = E:\\app\\503 修改oracle安装home目录下的hs/admin文件夹下的extproc.ora，具体路径示例：E:\\app\\503\\product\\11.2.0\\dbhome_1\\hs\\admin\\extproc.ora，将最后一行的SET EXTPROC_DLLS= 设为ANY 通过任何一个数据库管理软件，这里以sql-plus为例，使用sde用户登录首先执行：select * from user_libraries 查看是否有ST_SHAPELIB并检查路径是否与步骤1中的一致，通常默认为c盘第一次安装Arcgis时的相关路径。结果如下： 如果路径与步骤1中st_shapelib的路径不一致，执行以下两条命令： Create or replace library st_SHAPELIB as &lt;步骤1中的st_shapelib路径&gt; Alter package sde.st_geometry_shapelib_pkg compile reuse settings 重启监听器OracleOraDB11g_home1TNSListener，有时也需要重启服务OracleServiceORCL。","tags":[{"name":"ArcGIS","slug":"ArcGIS","permalink":"http://11wy11.github.io/tags/ArcGIS/"},{"name":"Oracle","slug":"Oracle","permalink":"http://11wy11.github.io/tags/Oracle/"}]}]