[{"title":"krpano学习笔记--干货","date":"2019-03-19T16:46:27.000Z","path":"2019/03/20/krpano-learn-note/","text":"1.Krpano xml Onstartonstart事件将在xml加载和解析之后直接调用。 Basedirbasedir设置为所有下面的loadpano（）动作调用定义了基本目录。这可以是相对路径或绝对路径，也可以在这里使用 url占位符。默认值是％FIRSTXML％，这意味着所有下面的loadpano（）动作调用的所有相对xml路径都是相对于第一个加载的xml文件。 关于vars和initvars区别vars在加载xml后加载图像前赋值，而initvars在加载xml前赋值，一般用于构建url。由于get:variable或calc:variable中的变量值需要在加载xml中定义，所以使用vars不能在开始加载时控制krpano的某些设置，但是可以在之后动态的修改其显示状态。 Action: 参数/参数传递/解析当调用一个动作时，可以将参数/参数传递给它。为了访问参数/参数，有两种可能性： 通过占位符替换：（ 旧版本的方法） 可以使用从％0到％99形式的操作代码中的数字占位符来获取给定的参数。 其中％0是操作本身的名称， ％1表示第一个参数， ％2表示第二个参数，依此类推。 这些占位符可以在代码中的任何地方使用。 在实际的操作代码将被解析并执行之前，所有的占位符将被其参数值替换。 当给定的占位符不会有参数时，将使用值’null’。 要在动作中使用％字符，需要使用%% 通过参数到变量映射:( 推荐，新的） 对于具有本地作用域的操作，可以将args属性添加到&lt;action>元素。例如： &lt;action ... args =“var1，var2，var3”&gt; 在那里可以定义给定动作参数/参数的args属性变量名称（用逗号分隔）。 每个动作参数将被映射到本地作用域中的一个新变量，其名称是在args属性中设置的。 这些变量可以像操作代码中的任何其他变量一样正常使用（例如，通过get / calc / copy读取）。 当给定变量没有动作参数时，将使用值’null’。 处理包含引号或逗号字符的值时，使用变量映射非常有用。在这种情况下，正常的占位符替换可能会产生问题 注意 - 建议尽可能使用参数变量映射。没有％N占位符的动作可以在内部进行缓存，这使得进一步调用的执行速度更快。 值得注意的属性 Name属性：每个名字都需要以字母字符开头！这意味着不允许使用数字作为名字！当名称仍然以数字字符开头时，名称将被解释为数组索引。这对于动作内部基于动态索引的访问没有问题，但不能用于定义元素！所有名称将自动转换为小写字母，以便直接区分大小写访问！ URL属性：当一个相对路径被用作url值时，路径将被自动调整为相对于定义了url属性的xml文件。这意味着xml中的相对路径总是相对于xml本身，但是请注意 - 当动态设置/更改url属性时，则不再有与xml的自动关系！要使路径相对于某些特定的预定义路径，可以 在url路径中使用这些占位符中的一些：％FIRSTXML％ - 第一个加载的xml文件的路径。％CURRENTXML％ - 当前加载的主要xml文件的路径（不是包含的）。％SWFPATH％ - krpano查看器文件的路径。％HTMLPATH％ - html文件的路径。％BASEDIR％ - 使用basedir路径。％$ VARIABLE％ - 使用给定’VARIABLE’的值 - 这可以是任何krpano变量，但必须在加载当前xml或场景之前定义它，例如，在嵌入过程中（通过initvars）或在loadpano（），loadscene（）调用之前。 Style属性&lt;style>元素是任何类型属性的集合/存储元素。每个其他具有name属性的xml元素也可以有一个style属性。当xml元素首次被创建时，在&lt;style>元素处定义的所有属性将被复制到元素本身。这将在xml元素本身定义的属性被应用之前完成。这意味着可以在&lt;style>元素中预先定义一些设置，然后使用直接在元素上定义的属性稍后覆盖它们。 Get:|Calc方法当xml属性的值以get：或calc：开头时：在这种情况下，xml属性的值将从其他变量获取或使用表达式计算。在get：或calc：中使用的变量需要在当前xml元素之前（=上方）定义。此外，这里有一个特殊情况 - 在&lt;include>元素上使用它时，那么在那里使用的变量需要在当前xml加载之前定义。这可以在嵌入期间通过使用initvars设置或在xml中进行loadpano（）调用之前在html文件中完成。 Javascript krpano操作 （仅限HTML5）12345&lt;action name =“...” type =“ Javascript ” &gt; &lt;！[CDATA [ ... autorun =“” Javascript代码 ... ]]&gt; &lt;/ action&gt; Action type krpano操作的类型：type =“”（默认） - 正常krpano操作 - 适用于Flash和HTML5type =“Javascript” - JavaScript krpano操作 - 仅限HTML5 Action scope在操作中为新生成的变量定义范围：全局或未设置（默认）新变量将被添加到全局变量作用域中。其他任何行为或代码也可以使用它们。这在再使用变量名称时可能会有问题，特别是当变量类型在用法之间会有所不同时。本地新变量将被添加到仅存在于当前操作调用中的局部变量作用域中。当动作完成或调用其他动作时，局部作用域和其中定义的所有变量将不再可用。动作越复杂，它使用的临时变量越多，使用本地作用域进行此操作越有意义，以避免干扰其他动作的问题。设置LocalOnly有些作为scope = local，但区别在于，默认情况下，所有访问仅引用本地作用域本身。全局范围的访问只能由全局对象来实现。亲使用调用者的范围。当调用当前动作的动作具有局部范围时，则可以在当前动作中使用/访问该动作。私人：NAME为该操作定义一个私有本地范围。范围将由自定义的唯一名称进行参考。该范围在多个操作调用之间保持活动状态，并可以在多个操作中共享。有些作为范围= localonly所有访问只涉及本地范围本身。 笔记全局范围访问 - 搜索变量时，首先搜索本地范围，然后搜索全局范围。为了能够将变量添加到全局范围，即使在使用本地范围或直接访问全局范围内的变量时，也存在全局对象。本地范围访问 - 为了能够确保访问本地范围（例如，当可能已经存在具有相同名称的全局变量时定义本地变量），当前本地范围也可用作 操作代码中的本地对象。例如使用def（local.i，integer，0）; 定义一个名为’i’的局部整型变量。为了稍后访问动作代码，只需使用’i’来解决该变量就足够了。延期代码 - 稍后调用其他代码的操作（例如delayedcall，tween，asyncloop等）将使用与该代码中当前操作相同的范围。调用者范围 - 从插件/图层/热点事件调用的代码对于非localscope动作：当一个动作（或任何代码）将从plugin / layer / hotspot事件中被调用时，plugin / layer / hotspot对象本身也将作为搜索变量的范围。但仅限于访问现有的变量！新生成的变量将始终添加到全局范围中。对于localscope动作：在localscope动作中总是有预定义的局部变量调用者。当动作将从插件/图层/热点事件（或通过使用callwith）被调用时，那么该 调用者变量将引用该元素。否则，调用者变量将为空。 本地作用域操作中的 预定义变量：actionname - 当前操作的名称。args - 参数的值数组。访问者：args [index]。通过以下方式获取数字或参数：args.length。调用者 - 从那里调用插件/图层/热点对象，否则为null。全球 - 参考全球范围。本地 - 对当前本地范围本身的引用。parentscope - 父行为的范围引用，当没有父范围时，这指的是全局范围。","tags":[{"name":"krpano","slug":"krpano","permalink":"http://11wy11.github.io/tags/krpano/"}]},{"title":"VS2013/VS2015/VS2017下使用ArcEngine10.1/10.2（一）","date":"2019-03-19T07:51:40.000Z","path":"2019/03/19/arcengine-first/","text":"ArcObjects SDK for Microsoft .Net Framework 10.1或10.2在安装时，会检测VS2010或VS2012的安装路径，而有时因为其他项目使用限制而且不愿同时安装多个版本的VS,通过修改注册表方式实现安装 背景ArcObjects SDK for Microsoft .Net Framework 10.1或10.2在安装时，会检测VS2010或VS2012的安装路径，而有时因为其他项目使用限制而且不愿同时安装多个版本的VS,通过修改注册表方式实现安装 具体步骤1.修改注册表首先打开注册表，window系统可以通过win+R，输入regedit后，回车打开注册表 找到计算机\\HKEY_LOCAL_MACHINE\\SOFTWARE\\WOW6432Node\\Microsoft\\VisualStudio\\10.0，点击10.0文件夹，此时是没有InstallDir和ShellFolder两个字符串值 找到计算机\\HKEY_LOCAL_MACHINE\\SOFTWARE\\WOW6432Node\\Microsoft\\VisualStudio\\12.0,点击12.0文件夹，查看InstallDir值，并复制 回到10.0目录，右键新建->字符串值，新建InstallDir值，双击编辑值，将刚复制的粘贴 同样的处理，添加ShellFolder 2.安装ArcObjects SDK for Microsoft .Net Framework打开ArcGIS Desktop 或ArcEngine安装程序，找到ArcObjects SDK for Microsoft .Net Framework，点击安装，此时就不会提示要求VS2010或VS2012安装环境了，下面以ArcGIS Desktop 为例： 图1-安装 3. 在工具箱中添加ArcGIS相关组件由于通过修改注册表的方式安装的ArcObjects SDK for Microsoft .Net Framework，因此，可能会导致VS中没有ArcGIS相关工具，需要手动添加 打开VS2013,任意打开一个窗体，打开工具箱，会发现没有ArcGIS选项卡，因此，首先右键新建选项卡，然后右键，点击选择项,在.NET Framework组件下，找到下图所示的ArcGIS组件 图2-添加ArcGIS组件 方案1注意，如果在.NET Framework下找不到相关组件，可以点击浏览,找到ArcObjects SDK for Microsoft .Net Framework的安装目录下的DotNet，一般路径为D:\\Program Files (x86)\\ArcGIS\\DeveloperKit10.2\\DotNet如下图所示，可以按需添加，或者按住Shift全选添加。 图3-浏览组件dll 勾选需要的组件，点击确定后，在新建的选项卡下出现组件 红色框为新添加的.NET组件，上面两个是COM组件，暂时不需要使用，下节介绍.NET组件和COM组件的区别 方案2在Desktop安装目录的bin下找到需要的控件，以.ocx为后缀，选中后拖入工具箱 添加引用在不做任何手动操作时，安装了ArcGIS Desktop之后，可以在COM下的类型库中找到ArcGIS 相关的COM组件，如下图所示 图5-COM类型库中的ArcGIS相关组件 注意点击引用这些组件时，引用呈现下图所示结果： 图6-添加COM组件引用后 但会发现找不到Esri.ArcGIS.Version的库，而这个库必须在主函数入口处使用获得授权许可，之后才能使用ArcEngine中相关的类或接口。 因此，这里在添加引用是选择.NET组件，点击浏览找到ArcObjects SDK for Microsoft .Net Framework的安装目录下的DotNet，一般路径为D:\\Program Files (x86)\\ArcGIS\\DeveloperKit10.2\\DotNet如下图所示，选择Esri.ArcGIS.Version.dll，其他库VS会根据需要自动引用。如上图图3所示.注意点击引用这些组件时，引用呈现下图所示结果： 图7-添加NET组件引用后 Program.cs中授权在Main函数中添加 ESRI.ArcGIS.RuntimeManager.Bind(ESRI.ArcGIS.ProductCode.EngineOrDesktop);,如下图所示 图8-添加授权 直至就可以在一个应用程序中使用ArcEngine的功能了。 当然如果你想使用VS创建ArcGIS模板应用程序，此时你会发现Visual C#下没有ArcGIS选项，这时又需要我们手动添加了 图9-手动安装之前 手动添加ArcGIS项目模板由于我们最开始安装SDK时，采用了修改注册表的方式骗过ArcObject检测，因此，模板默认安装在了但是设置的VS2013安装路径Microsoft Visio Studio 12.0下了 将模板拷贝至vs模板库中找到D:\\Program Files (x86)\\Microsoft Visual Studio 12.0\\Microsoft Visual Studio 10.0，在Common7/IDE下有两个文件夹ItemTemplates/CSharp/ArcGIS,ProjectTemplates/CSharp/ArcGIS,分别拷贝在vs2013模板文件位置，如：D:\\Program Files (x86)\\Microsoft Visual Studio 12.0\\Common7\\IDE\\ItemTemplates\\CSharp和I:\\Program Files (x86)\\Microsoft Visual Studio 12.0\\Common7\\IDE\\ProjectTemplates\\CSharp 右键，以管理员权限运行vs2013,也就是启动vs2013 重新安装一次模板 打开vs2013/2015的命令行工具 2013： 开始–&gt; 所有应用 –&gt; Microsoft Visual Studio 2013 –&gt; Visual Studio Tools,打开后 vs2013开发人员命令提示 2015或更高： 开始–&gt; 所有应用 –&gt; Microsoft Visual Studio 2015 –&gt; vs2015开发人员命令提示（可能会叫Visual Studio 2015 Command Prompt ） 执行如下命令devenv.exe/InstallVSTemplates需要注意的事情是，这个命令执行后，不会马上出现项目或项模板，需要重新打开vs2017，新建时会重新初始化模板。 如果第三步有问题，换成用管理员权限运行。 效果C#下出现ArcGIS相关模板","tags":[{"name":"ArcEngine","slug":"ArcEngine","permalink":"http://11wy11.github.io/tags/ArcEngine/"},{"name":"VS","slug":"VS","permalink":"http://11wy11.github.io/tags/VS/"}]},{"title":"GDAL简介及函数","date":"2019-03-18T07:26:26.000Z","path":"2019/03/18/cpp-gdal/","text":"GDAL(Geospatial Data Abstraction Library)是一个在X/MIT许可协议下的开源栅格空间数据转换库持续更新中Table of Contents generated with DocToc 简介 功能特征 OGR体系结构编辑 GDAL中OGR的使用 读数据 GDAL 基本使用函数 GDALAllRegister GDALOpenEx GDALDataSet GetLayerByName OGR类或函数 OGRLayer OGRGEometry OGREnvelope 参考资料： 简介它利用抽象数据模型来表达所支持的各种文件格式。它还有一系列命令行工具来进行数据转换和处理。 OGR是GDAL项目的一个分支，功能与GDAL类似，只不过它提供对矢量数据的支持。 有很多著名的GIS类产品都使用了GDAL/OGR库，包括ESRI的ARCGIS 9.3，Google Earth和跨平台的GRASS GIS系统。利用GDAL/OGR库，可以使基于Linux的地理空间数据管理系统提供对矢量和栅格文件数据的支持。 功能特征GDAL提供对多种栅格数据的支持，包括Arc/Info ASCII Grid(asc)，GeoTiff (tiff)，Erdas Imagine Images(img)，ASCII DEM(dem) 等格式。 GDAL使用抽象数据模型(abstract data model)来解析它所支持的数据格式，抽象数据模型包括数据集(dataset)，坐标系统，仿射地理坐标转换(Affine Geo Transform)， 大地控制点(GCPs)， 元数据(Metadata)，栅格波段(Raster Band)，颜色表(Color Table)，子数据集域(Subdatasets Domain)，图像结构域(Image_Structure Domain)，XML域(XML:Domains)。 GDALMajorObject类：带有元数据的对象。 GDALDdataset类：通常是从一个栅格文件中提取的相关联的栅格波段集合和这些波段的元数据;GDALDdataset也负责所有栅格波段的地理坐标转换(georeferencing transform)和坐标系定义。 GDALDriver类：文件格式驱动类，GDAL会为每一个所支持的文件格式创建一个该类的实体，来管理该文件格式。 GDALDriverManager类：文件格式驱动管理类，用来管理GDALDriver类。 OGR体系结构编辑Geometry类：Geometry (包括OGRGeometry等类)封装了OpenGIS的矢量数据模型，并提供了一些几何操作，WKB(Well Knows Binary)和WKT(Well Known Text)格式之间的相互转换，以及空间参考系统(投影)。 Spatial Reference类：OGRSpatialReference封装了投影和基准面的定义。 Feature类：OGRFeature封装了一个完整feature的定义，一个完整的feature包括一个geometry和geometry的一系列属性。 Feature Definition类：OGRFeatureDefn里面封装了feature的属性，类型、名称及其默认的空间参考系统等。一个OGRFeatureDefn对象通常与一个层(layer)对应。 Layer类：OGRLayer是一个抽象基类，表示数据源类OGRDataSource里面的一层要素(feature)。 Data Source类：OGRDataSource是一个抽象基类，表示含有OGRLayer对象的一个文件或一个数据库。 Drivers类：OGRSFDriver对应于每一个所支持的矢量文件格式。类OGRSFDriver由类OGRSFDriverRegistrar来注册和管理。 GDAL中OGR的使用读数据 在工程的Library files中和Include files中分别添加GDAL的LIB文件目录和头文件目录 最初需要注册所需的所有格式驱动程序。这通常通过调用GDALAllRegister（）来完成，该寄存器注册GDAL / OGR中内置的所有格式驱动程序。 接下来我们需要打开输入OGR数据源。数据源可以是文件，RDBMS，充满文件的目录，甚至是远程Web服务，具体取决于所使用的驱动程序。但是，数据源名称始终是单个字符串。在这种情况下，我们硬编码打开一个特定的shapefile。第二个参数（GDAL_OF_VECTOR）告诉OGROpen（）方法我们想要使用向量驱动程序并且不需要更新访问。失败时返回NULL，我们报告错误。 GDALDataset可以潜在地具有与它相关联的许多层。可以使用GDALDataset :: GetLayerCount（）查询可用的图层数，并使用GDALDataset :: GetLayer（）通过索引获取各个图层。但是，我们只是按名称获取图层。 OGRLayer * poLayer; poLayer = poDS-&gt; GetLayerByName（“point”）; 现在我们要开始从图层中读取要素。在我们开始之前，我们可以为图层指定属性或空间过滤器以限制我们获取的功能集，但是现在我们有兴趣获取所有功能。 我们使用OGRLayer :: GetNextFeature（）遍历图层中的所有要素。当我们用完功能时它会返回NULL。 1234OGRFeature *poFeature;poLayer-&gt;ResetReading();while( (poFeature = poLayer-&gt;GetNextFeature()) != NULL )&#123; 为了转储该功能的所有属性字段，获取OGRFeatureDefn会很有帮助。这是与图层关联的对象，包含所有字段的定义。我们遍历所有字段，并根据其类型获取和报告属性。 123456789101112131415161718192021for( auto&amp;&amp; oField: *poFeature )&#123; switch( oField.GetType() ) &#123; case OFTInteger: printf( &quot;%d,&quot;, oField.GetInteger() ); break; case OFTInteger64: printf( CPL_FRMT_GIB &quot;,&quot;, oField.GetInteger64() ); break; case OFTReal: printf( &quot;%.3f,&quot;, oField.GetDouble() ); break; case OFTString: printf( &quot;%s,&quot;, oField.GetString() ); break; default: printf( &quot;%s,&quot;, oField.GetAsString() ); break; &#125;&#125; 除了上面显式处理的字段类型之外，还有一些字段类型，但可以使用OGRFeature :: GetFieldAsString（）方法获取它们的合理表示。事实上，我们可以通过对所有类型使用OGRFeature :: GetFieldAsString（）来缩短上述内容。 接下来，我们要从要素中提取几何体，并写出点几何体x和y。几何图形作为通用OGRGeometry指针返回。然后我们确定特定的几何类型，如果它是一个点，我们将其转换为点并对其进行操作。如果它是别的东西我们写占位符。 12345678910111213141516 OGRGeometry *poGeometry; poGeometry = poFeature-&gt;GetGeometryRef(); if( poGeometry != NULL &amp;&amp; wkbFlatten(poGeometry-&gt;getGeometryType()) == wkbPoint ) &#123;#if GDAL_VERSION_NUM &gt;= GDAL_COMPUTE_VERSION(2,3,0) OGRPoint *poPoint = poGeometry-&gt;toPoint();#else OGRPoint *poPoint = (OGRPoint *) poGeometry;#endif printf( &quot;%.3f,%3.f\\n&quot;, poPoint-&gt;getX(), poPoint-&gt;getY() ); &#125; else &#123; printf( &quot;no point geometry\\n&quot; ); &#125; 所述wkbFlatten（）宏上述用于将类型转换为一个wkbPoint25D（带z坐标的点）到2D的类型代码（wkbPoint）。对于每个2D几何类型，都有相应的2.5D类型代码。2D和2.5D几何案例由相同的C ++类处理，因此我们的代码将正确处理2D或3D案例。 12345678910111213141516171819202122OGRGeometry *poGeometry; int iGeomField; int nGeomFieldCount; nGeomFieldCount = poFeature-&gt;GetGeomFieldCount(); for(iGeomField = 0; iGeomField &lt; nGeomFieldCount; iGeomField ++ ) &#123; poGeometry = poFeature-&gt;GetGeomFieldRef(iGeomField); if( poGeometry != NULL &amp;&amp; wkbFlatten(poGeometry-&gt;getGeometryType()) == wkbPoint ) &#123; #if GDAL_VERSION_NUM &gt;= GDAL_COMPUTE_VERSION(2,3,0) OGRPoint *poPoint = poGeometry-&gt;toPoint(); #else OGRPoint *poPoint = (OGRPoint *) poGeometry; #endif printf( &quot;%.3f,%3.f\\n&quot;, poPoint-&gt;getX(), poPoint-&gt;getY() ); &#125; else &#123; printf( &quot;no point geometry\\n&quot; ); &#125; &#125; 请注意，OGRFeature :: GetGeometryRef（）和OGRFeature :: GetGeomFieldRef（）返回指向OGRFeature所拥有的内部几何的指针。实际上没有删除返回几何。 对于GDAL &lt;2.3，因为OGRLayer :: GetNextFeature（）方法返回现在由我们拥有的功能的副本。因此，在使用结束时，我们必须释放该功能。我们可以“删除”它，但这可能会导致Windows版本中的问题，其中GDAL DLL与主程序具有不同的“堆”。为了安全起见，我们使用GDAL功能删除该功能。 OGRFeature :: DestroyFeature（poFeature）;} 该OGRLayer通过返回的GDALDataset :: GetLayerByName（）也是由拥有一个内部层参考的GDALDataset所以我们并不需要将其删除。但我们确实需要删除数据源才能关闭输入文件。我们再一次使用自定义删除方法来避免特殊的win32堆问题。 GDALClose（poDS）; } 完整模板 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &quot;ogrsf_frmts.h&quot;int main()&#123; GDALAllRegister(); GDALDataset *poDS = static_cast&lt;GDALDataset*&gt;( GDALOpenEx( &quot;point.shp&quot;, GDAL_OF_VECTOR, NULL, NULL, NULL )); if( poDS == NULL ) &#123; printf( &quot;Open failed.\\n&quot; ); exit( 1 ); &#125; OGRLayer *poLayer = poDS-&gt;GetLayerByName( &quot;point&quot; ); OGRFeatureDefn *poFDefn = poLayer-&gt;GetLayerDefn(); poLayer-&gt;ResetReading(); OGRFeature *poFeature; while( (poFeature = poLayer-&gt;GetNextFeature()) != NULL ) &#123; for( int iField = 0; iField &lt; poFDefn-&gt;GetFieldCount(); iField++ ) &#123; OGRFieldDefn *poFieldDefn = poFDefn-&gt;GetFieldDefn( iField ); switch( poFieldDefn-&gt;GetType() ) &#123; case OFTInteger: printf( &quot;%d,&quot;, poFeature-&gt;GetFieldAsInteger( iField ) ); break; case OFTInteger64: printf( CPL_FRMT_GIB &quot;,&quot;, poFeature-&gt;GetFieldAsInteger64( iField ) ); break; case OFTReal: printf( &quot;%.3f,&quot;, poFeature-&gt;GetFieldAsDouble(iField) ); break; case OFTString: printf( &quot;%s,&quot;, poFeature-&gt;GetFieldAsString(iField) ); break; default: printf( &quot;%s,&quot;, poFeature-&gt;GetFieldAsString(iField) ); break; &#125; &#125; OGRGeometry *poGeometry = poFeature-&gt;GetGeometryRef(); if( poGeometry != NULL &amp;&amp; wkbFlatten(poGeometry-&gt;getGeometryType()) == wkbPoint ) &#123; OGRPoint *poPoint = (OGRPoint *) poGeometry; printf( &quot;%.3f,%3.f\\n&quot;, poPoint-&gt;getX(), poPoint-&gt;getY() ); &#125; else &#123; printf( &quot;no point geometry\\n&quot; ); &#125; OGRFeature::DestroyFeature( poFeature ); &#125; GDALClose( poDS );&#125; 写数据作为通过OGR写作的一个例子，我们将大致与上述相反。从输入文本中读取逗号分隔值的短程序将通过OGR写入点shapefile。 像往常一样，我们首先注册所有驱动程序，然后获取Shapefile驱动程序，因为我们需要它来创建输出文件。 123456789101112#include &quot;ogrsf_frmts.h&quot;int main()&#123; const char *pszDriverName = &quot;ESRI Shapefile&quot;; GDALDriver *poDriver; GDALAllRegister(); poDriver = GetGDALDriverManager()-&gt;GetDriverByName(pszDriverName ); if( poDriver == NULL ) &#123; printf( &quot;%s driver not available.\\n&quot;, pszDriverName ); exit( 1 ); &#125; 接下来我们创建数据源。ESRI Shapefile驱动程序允许我们创建一个完整的shapefile目录，或一个shapefile作为数据源。在这种情况下，我们将通过在名称中包含扩展名来显式创建单个文件。其他驱动程序表现不同。第二个，第三个，第四个和第五个参数与栅格尺寸相关（如果驱动程序具有栅格功能）。调用的最后一个参数是选项值列表，但在这种情况下我们将只使用默认值。支持的选项的详细信息也是特定于格式的。 1234567GDALDataset *poDS;poDS = poDriver-&gt;Create( &quot;point_out.shp&quot;, 0, 0, 0, GDT_Unknown, NULL );if( poDS == NULL )&#123; printf( &quot;Creation of output file failed.\\n&quot; ); exit( 1 );&#125; 现在我们创建输出层。在这种情况下，由于数据源是单个文件，因此我们只能有一个图层。我们传递wkbPoint来指定该层支持的几何类型。在这种情况下，我们不传递任何坐标系信息或其他特殊图层创建选项。 1234567OGRLayer *poLayer;poLayer = poDS-&gt;CreateLayer( &quot;point_out&quot;, NULL, wkbPoint, NULL );if( poLayer == NULL )&#123; printf( &quot;Layer creation failed.\\n&quot; ); exit( 1 );&#125; 现在该图层已存在，我们需要创建应出现在图层上的任何属性字段。必须在写入任何要素之前将字段添加到图层。要创建字段，我们使用有关字段的信息初始化OGRField对象。在Shapefiles的情况下，字段宽度和精度在创建输出.dbf文件时很重要，所以我们专门设置它，尽管通常默认值是OK。对于此示例，我们将只有一个属性，一个与x，y点关联的名称字符串。 请注意，我们传递给CreateField（）的模板OGRField是在内部复制的。我们保留对象的所有权。 12345678910111213OGRFieldDefn oField（“Name”，OFTString）;oField.SetWidth（32）;if（poLayer-&gt; CreateField（＆oField）！= OGRERR_NONE）&#123; printf（“创建名称字段失败。\\ n”）; 退出（1）;&#125;//通过读数据中的x,y,name，写入double x, y; char szName[33]; while( !feof(stdin) &amp;&amp; fscanf( stdin, &quot;%lf,%lf,%32s&quot;, &amp;x, &amp;y, szName ) == 3 ) &#123; 要将功能写入磁盘，我们必须创建本地OGRFeature，设置属性并附加几何体，然后再尝试将其写入图层。必须从与要写入的层关联的OGRFeatureDefn实例化此功能。 123OGRFeature * poFeature;poFeature = OGRFeature :: CreateFeature（poLayer-&gt; GetLayerDefn（））;poFeature-&gt; SetField（“Name”，szName）; 我们创建一个本地几何对象，并将其副本（间接）分配给该功能。的和OGRFeature :: SetGeometryDirectly（）不同于和OGRFeature :: SetGeometry（）在该直接方法给出了几何形状的特征的所有权。这通常更有效，因为它避免了几何体的额外深层对象副本。 1234OGRPoint pt;pt.setX( x );pt.setY( y );poFeature-&gt;SetGeometry( &amp;pt ); 现在我们在文件中创建一个功能。该OGRLayer :: CreateFeature（）不走我们的特点的所有权，所以我们在用它做清理。 1234567 if( poLayer-&gt;CreateFeature( poFeature ) != OGRERR_NONE ) &#123; printf( &quot;Failed to create feature in shapefile.\\n&quot; ); exit( 1 ); &#125; OGRFeature::DestroyFeature( poFeature );&#125; 最后，我们需要关闭数据源，以确保以有序的方式写出标头，并恢复所有资源。GDALClose（poDS）;} 模板 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &quot;ogrsf_frmts.h&quot;int main()&#123; const char *pszDriverName = &quot;ESRI Shapefile&quot;; GDALDriver *poDriver; GDALAllRegister(); poDriver = GetGDALDriverManager()-&gt;GetDriverByName(pszDriverName ); if( poDriver == NULL ) &#123; printf( &quot;%s driver not available.\\n&quot;, pszDriverName ); exit( 1 ); &#125; GDALDataset *poDS; poDS = poDriver-&gt;Create( &quot;point_out.shp&quot;, 0, 0, 0, GDT_Unknown, NULL ); if( poDS == NULL ) &#123; printf( &quot;Creation of output file failed.\\n&quot; ); exit( 1 ); &#125; OGRLayer *poLayer; poLayer = poDS-&gt;CreateLayer( &quot;point_out&quot;, NULL, wkbPoint, NULL ); if( poLayer == NULL ) &#123; printf( &quot;Layer creation failed.\\n&quot; ); exit( 1 ); &#125; OGRFieldDefn oField( &quot;Name&quot;, OFTString ); oField.SetWidth(32); if( poLayer-&gt;CreateField( &amp;oField ) != OGRERR_NONE ) &#123; printf( &quot;Creating Name field failed.\\n&quot; ); exit( 1 ); &#125; double x, y; char szName[33]; while( !feof(stdin) &amp;&amp; fscanf( stdin, &quot;%lf,%lf,%32s&quot;, &amp;x, &amp;y, szName ) == 3 ) &#123; OGRFeature *poFeature; poFeature = OGRFeature::CreateFeature( poLayer-&gt;GetLayerDefn() ); poFeature-&gt;SetField( &quot;Name&quot;, szName ); OGRPoint pt; pt.setX( x ); pt.setY( y ); poFeature-&gt;SetGeometry( &amp;pt ); if( poLayer-&gt;CreateFeature( poFeature ) != OGRERR_NONE ) &#123; printf( &quot;Failed to create feature in shapefile.\\n&quot; ); exit( 1 ); &#125; OGRFeature::DestroyFeature( poFeature ); &#125; GDALClose( poDS );&#125; GDAL 基本使用函数GDALAllRegister 最初需要注册所需的所有格式驱动程序。这通常通过调用GDALAllRegister（）来完成，该寄存器注册GDAL / OGR中内置的所有格式驱动程序。 原型： 12345678910111213void GDALAllRegister(void) //Register all known configured GDAL drivers.//注册所有已知配置的GDAL驱动程序。 //This function will drive any of the following that are configured into GDAL. See raster list and vector full list //此功能将驱动配置为GDAL的以下任何内容。请参阅栅格列表和矢量完整列表 //This function should generally be called once at the beginning of the application.//通常应在应用程序开始时调用此函数一次。 //使用#include“ ogrsf_frmts.h ” int main（） &#123; GDALAllRegister（）; GDALOpenEx以GDALDataset打开栅格或矢量文件。 此函数将尝试依次调用每个已注册的GDALDriver的Open方法来打开传递的文件或虚拟数据集名称。第一次成功打开将导致返回的数据集。如果所有驱动程序都失败，则返回NULL并发出错误。 几条建议： 如果打开具有GDAL_OF_UPDATE访问权限的数据集对象，则不建议在同一基础文件上打开新数据集。 返回的数据集一次只能由一个线程访问。如果要从不同的线程中使用它，则必须添加所有必需的代码（互斥锁等）以避免并发使用该对象。（某些驱动程序，如GeoTIFF，维护每次读取新块时更新的内部状态变量，从而防止并发使用。） 原型： 123456GDALDatasetH GDALOpenEx （ const char * pszFilename，unsigned int nOpenFlags，const char * const * papszAllowedDrivers，const char * const * papszOpenOptions，const char * const * papszSiblingFiles ） 参数 pszFilename 要访问的文件的名称。在外来驱动程序的情况下，这可能不是指物理文件，而是包含驱动程序有关如何访问数据集的信息。它应该是UTF-8编码。 nOpenFlags GDAL_OF_标志的组合，可以通过逻辑或运算符组合。 驱动程序类型：用于光栅驱动程序的GDAL_OF_RASTER，用于矢量驱动程序的GDAL_OF_VECTOR，用于地理网络模型驱动程序的GDAL_OF_GNM。如果未指定任何值，则隐含所有类型。 访问模式：GDAL_OF_READONLY（独占）或GDAL_OF_UPDATE。 共享模式：GDAL_OF_SHARED。如果设置，它允许与已设置GDAL_OF_SHARED的其他调用者共享数据集的GDALDataset句柄。特别是，GDALOpenEx（）将首先查询其当前打开和共享GDALDataset的列表，如果一个GetDescription（）名称与传递给GDALOpenEx（）的pszFilename完全匹配，则将引用并返回它，如果GDALOpenEx（）是从同一个线程调用。 详细错误：GDAL_OF_VERBOSE_ERROR。如果设置，则尝试打开文件失败将导致报告错误消息。 papszAllowedDrivers NULL考虑所有候选驱动程序，或NULL终止的字符串列表，其中包含必须考虑的驱动程序短名称。 papszOpenOptions NULL或NULL终止的字符串列表，其中打开选项传递给候选驱动程序。所有驱动程序OVERVIEW_LEVEL = level都存在一个选项，用于选择数据集的特定概述级别。级别索引从0开始。级别编号可以以“仅”为后缀，以指定只有此概述级别必须可见，而不是子级别。默认情况下会验证打开选项，如果无法识别选项，则会发出警告。在某些情况下，可能不需要（例如，当不知道哪个驱动程序将打开文件时），因此可以将特殊打开选项VALIDATE_OPEN_OPTIONS设置为NO以避免此类警告。或者，从GDAL 2.1开始，选项名称前面可以加上@字符，表示如果驱动程序没有声明此选项，它可能不会引发警告。 papszSiblingFiles NULL或NULL终止的字符串列表，这些字符串是主文件名的辅助文件名。如果传递NULL，则将完成对文件系统的探测。 返回一个GDALDatasetH句柄或失败时为NULL。对于C ++应用程序，此句柄可以转换为GDALDataset *。 1234567GDALDataset *poDS;poDS = (GDALDataset*) GDALOpenEx( &quot;point.shp&quot;, GDAL_OF_VECTOR, NULL, NULL, NULL );if( poDS == NULL )&#123; printf( &quot;Open failed.\\n&quot; ); exit( 1 );&#125; 使用实例：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184GDALDataset *poDS;poDS = (GDALDataset*) GDALOpenEx( &quot;point.shp&quot;, GDAL_OF_VECTOR, NULL, NULL, NULL );if( poDS == NULL )&#123; printf( &quot;Open failed.\\n&quot; ); exit( 1 );&#125;``` ## GDALDataSet帮助文档https://www.gdal.org/classGDALDataset.html![类图](cpp-gdal/pic2.png) 部分函数介绍### GetLayerByNameFetch a layer by name.The returned layer remains owned by the GDALDataset and should not be deleted by the application.This method is the same as the C function GDALDatasetGetLayerByName() and the deprecated OGR_DS_GetLayerByName().In GDAL 1.X, this method used to be in the OGRDataSource class.ParameterspszName the layer name of the layer to fetch.Returnsthe layer, or NULL if Layer is not found or an error occurs.# OGR类或函数## OGRLayer帮助文档https://www.gdal.org/classOGRLayer.html![类图](cpp-gdal/pic1.png)| 返回值 | 函数 | | | ||--------------------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------|---|---|---|| FeatureIterator | begin () | | | || | Return begin of feature iterator. More... | | | || | | | | || FeatureIterator | end () | | | || | Return end of feature iterator. More... | | | || | | | | || virtual OGRGeometry * | GetSpatialFilter () | | | || | This method returns the current spatial filter for this layer. More... | | | || | | | | || virtual void | SetSpatialFilter (OGRGeometry *) | | | || | Set a new spatial filter. More... | | | || | | | | || virtual void | SetSpatialFilterRect (double dfMinX, double dfMinY, double dfMaxX, double dfMaxY) | | | || | Set a new rectangular spatial filter. More... | | | || | | | | || virtual void | SetSpatialFilter (int iGeomField, OGRGeometry *) | | | || | Set a new spatial filter. More... | | | || | | | | || virtual void | SetSpatialFilterRect (int iGeomField, double dfMinX, double dfMinY, double dfMaxX, double dfMaxY) | | | || | Set a new rectangular spatial filter. More... | | | || | | | | || virtual OGRErr | SetAttributeFilter (const char *) | | | || | Set a new attribute query. More... | | | || | | | | || virtual void | ResetReading ()=0 | | | || | Reset feature reading to start on the first feature. More... | | | || | | | | || virtual OGRFeature * | GetNextFeature () CPL_WARN_UNUSED_RESULT=0 | | | || | Fetch the next available feature from this layer. More... | | | || | | | | || virtual OGRErr | SetNextByIndex (GIntBig nIndex) | | | || | Move read cursor to the nIndex&apos;th feature in the current resultset. More... | | | || | | | | || virtual OGRFeature * | GetFeature (GIntBig nFID) CPL_WARN_UNUSED_RESULT | | | || | Fetch a feature by its identifier. More... | | | || | | | | || OGRErr | SetFeature (OGRFeature *poFeature) CPL_WARN_UNUSED_RESULT | | | || | Rewrite an existing feature. More... | | | || | | | | || OGRErr | CreateFeature (OGRFeature *poFeature) CPL_WARN_UNUSED_RESULT | | | || | Create and write a new feature within a layer. More... | | | || | | | | || virtual OGRErr | DeleteFeature (GIntBig nFID) CPL_WARN_UNUSED_RESULT | | | || | Delete feature from layer. More... | | | || | | | | || virtual const char * | GetName () | | | || | Return the layer name. More... | | | || | | | | || virtual OGRwkbGeometryType | GetGeomType () | | | || | Return the layer geometry type. More... | | | || | | | | || virtual OGRFeatureDefn * | GetLayerDefn ()=0 | | | || | Fetch the schema information for this layer. More... | | | || | | | | || virtual int | FindFieldIndex (const char *pszFieldName, int bExactMatch) | | | || | Find the index of field in the layer. More... | | | || | | | | || virtual OGRSpatialReference * | GetSpatialRef () | | | || | Fetch the spatial reference system for this layer. More... | | | || | | | | || virtual GIntBig | GetFeatureCount (int bForce=TRUE) | | | || | Fetch the feature count in this layer. More... | | | || | | | | || virtual OGRErr | GetExtent (OGREnvelope *psExtent, int bForce=TRUE) CPL_WARN_UNUSED_RESULT | | | || | Fetch the extent of this layer. More... | | | || | | | | || virtual OGRErr | GetExtent (int iGeomField, OGREnvelope *psExtent, int bForce=TRUE) CPL_WARN_UNUSED_RESULT | | | || | Fetch the extent of this layer, on the specified geometry field. More... | | | || | | | | || virtual int | TestCapability (const char *)=0 | | | || | Test if this layer supported the named capability. More... | | | || | | | | || virtual OGRErr | CreateField (OGRFieldDefn *poField, int bApproxOK=TRUE) | | | || | Create a new field on a layer. More... | | | || | | | | || virtual OGRErr | DeleteField (int iField) | | | || | Delete an existing field on a layer. More... | | | || | | | | || virtual OGRErr | ReorderFields (int *panMap) | | | || | Reorder all the fields of a layer. More... | | | || | | | | || virtual OGRErr | AlterFieldDefn (int iField, OGRFieldDefn *poNewFieldDefn, int nFlagsIn) | | | || | Alter the definition of an existing field on a layer. More... | | | || | | | | || virtual OGRErr | CreateGeomField (OGRGeomFieldDefn *poField, int bApproxOK=TRUE) | | | || | Create a new geometry field on a layer. More... | | | || | | | | || virtual OGRErr | SyncToDisk () | | | || | Flush pending changes to disk. More... | | | || | | | | || virtual OGRStyleTable * | GetStyleTable () | | | || | Returns layer style table. More... | | | || | | | | || virtual void | SetStyleTableDirectly (OGRStyleTable *poStyleTable) | | | || | Set layer style table. More... | | | || | | | | || virtual void | SetStyleTable (OGRStyleTable *poStyleTable) | | | || | Set layer style table. More... | | | || | | | | || virtual OGRErr | StartTransaction () CPL_WARN_UNUSED_RESULT | | | || | For datasources which support transactions, StartTransaction creates a transaction. More... | | | || | | | | || virtual OGRErr | CommitTransaction () CPL_WARN_UNUSED_RESULT | | | || | For datasources which support transactions, CommitTransaction commits a transaction. More... | | | || | | | | || virtual OGRErr | RollbackTransaction () | | | || | For datasources which support transactions, RollbackTransaction will roll back a datasource to its state before the start of the current transaction. More... | | | || | | | | || virtual const char * | GetFIDColumn () | | | || | This method returns the name of the underlying database column being used as the FID column, or &quot;&quot; if not supported. More... | | | || | | | | || virtual const char * | GetGeometryColumn () | | | || | This method returns the name of the underlying database column being used as the geometry column, or &quot;&quot; if not supported. More... | | | || | | | | || virtual OGRErr | SetIgnoredFields (const char **papszFields) | | | || | Set which fields can be omitted when retrieving features from the layer. More... | | | || | | | | || OGRErr | Intersection (OGRLayer *pLayerMethod, OGRLayer *pLayerResult, char **papszOptions=nullptr, GDALProgressFunc pfnProgress=nullptr, void *pProgressArg=nullptr) | | | || | Intersection of two layers. More... | | | || | | | | || OGRErr | Union (OGRLayer *pLayerMethod, OGRLayer *pLayerResult, char **papszOptions=nullptr, GDALProgressFunc pfnProgress=nullptr, void *pProgressArg=nullptr) | | | || | Union of two layers. More... | | | || | | | | || OGRErr | SymDifference (OGRLayer *pLayerMethod, OGRLayer *pLayerResult, char **papszOptions, GDALProgressFunc pfnProgress, void *pProgressArg) | | | || | Symmetrical difference of two layers. More... | | | || | | | | || OGRErr | Identity (OGRLayer *pLayerMethod, OGRLayer *pLayerResult, char **papszOptions=nullptr, GDALProgressFunc pfnProgress=nullptr, void *pProgressArg=nullptr) | | | || | Identify the features of this layer with the ones from the identity layer. More... | | | || | | | | || OGRErr | Update (OGRLayer *pLayerMethod, OGRLayer *pLayerResult, char **papszOptions=nullptr, GDALProgressFunc pfnProgress=nullptr, void *pProgressArg=nullptr) | | | || | Update this layer with features from the update layer. More... | | | || | | | | || OGRErr | Clip (OGRLayer *pLayerMethod, OGRLayer *pLayerResult, char **papszOptions=nullptr, GDALProgressFunc pfnProgress=nullptr, void *pProgressArg=nullptr) | | | || | Clip off areas that are not covered by the method layer. More... | | | || | | | | || OGRErr | Erase (OGRLayer *pLayerMethod, OGRLayer *pLayerResult, char **papszOptions=nullptr, GDALProgressFunc pfnProgress=nullptr, void *pProgressArg=nullptr) | | | || | Remove areas that are covered by the method layer. More... | | | || | | | | || int | Reference () | | | || | Increment layer reference count. More... | | | || | | | | || int | Dereference () | | | || | Decrement layer reference count. More... | | | || | | | | || int | GetRefCount () const | | | || | Fetch reference count. More... | | | || | | | | || OGRErr | ReorderField (int iOldFieldPos, int iNewFieldPos) | | | || | Reorder an existing field on a layer. More... | | | |## OGRGEometry## OGREnvelope class CPL_DLL OGREnvelope{ public: OGREnvelope() : MinX(std::numeric_limits::infinity()), MaxX(-std::numeric_limits::infinity()), MinY(std::numeric_limits::infinity()), MaxY(-std::numeric_limits::infinity()) { } OGREnvelope(const OGREnvelope&amp; oOther) : MinX(oOther.MinX),MaxX(oOther.MaxX), MinY(oOther.MinY), MaxY(oOther.MaxY) { } double MinX; double MaxX; double MinY; double MaxY; #ifdef HAVE_GCC_DIAGNOSTIC_PUSH #pragma GCC diagnostic push #pragma GCC diagnostic ignored “-Wfloat-equal” #endif int IsInit() const { return MinX != std::numeric_limits::infinity(); } #ifdef HAVE_GCC_DIAGNOSTIC_PUSH #pragma GCC diagnostic pop #endif void Merge( OGREnvelope const&amp; sOther ) { MinX = MIN(MinX,sOther.MinX); MaxX = MAX(MaxX,sOther.MaxX); MinY = MIN(MinY,sOther.MinY); MaxY = MAX(MaxY,sOther.MaxY); } void Merge( double dfX, double dfY ) { MinX = MIN(MinX,dfX); MaxX = MAX(MaxX,dfX); MinY = MIN(MinY,dfY); MaxY = MAX(MaxY,dfY); } void Intersect( OGREnvelope const&amp; sOther ) { if(Intersects(sOther)) { if( IsInit() ) { MinX = MAX(MinX,sOther.MinX); MaxX = MIN(MaxX,sOther.MaxX); MinY = MAX(MinY,sOther.MinY); MaxY = MIN(MaxY,sOther.MaxY); } else { MinX = sOther.MinX; MaxX = sOther.MaxX; MinY = sOther.MinY; MaxY = sOther.MaxY; } } else { *this = OGREnvelope(); } } int Intersects(OGREnvelope const&amp; other) const { return MinX &lt;= other.MaxX &amp;&amp; MaxX &gt;= other.MinX &amp;&amp; MinY &lt;= other.MaxY &amp;&amp; MaxY &gt;= other.MinY; } int Contains(OGREnvelope const&amp; other) const { return MinX &lt;= other.MinX &amp;&amp; MinY &lt;= other.MinY &amp;&amp; MaxX &gt;= other.MaxX &amp;&amp; MaxY &gt;= other.MaxY; } };` 参考资料： 百度百科：https://baike.baidu.com/item/GDAL/4004525?fr=aladdin 官方网站：https://www.gdal.org/","tags":[{"name":"GDAL","slug":"GDAL","permalink":"http://11wy11.github.io/tags/GDAL/"}]},{"title":"常用工具","date":"2019-03-18T04:46:05.000Z","path":"2019/03/18/tools/","text":"markdown相关doctoc(markdown目录自动生成)GitHub中的markdown文件直接写[TOC]是无法生成目录的，可以使用工具doctocnpm install -g doctoc使用方式 对当前文件夹中所有文件生成目录e.g. 1234567 cd D:\\Develop\\Documents\\Notes\\CSDN笔记\\temp doctoc . ``` + 对文件夹中单个文件生成目录（文件名中间不能有空格） `doctoc /path/to/file [...]` 如： doctoc README.md doctoc CONTRIBUTING.md LICENSE.md doctoc D:\\Develop\\Documents\\Notes\\CSDN笔记\\JAVARxJava.md `","tags":[{"name":"tools","slug":"tools","permalink":"http://11wy11.github.io/tags/tools/"}]},{"title":"AI组件开发（二）--AIRealMathSuite","date":"2019-03-18T02:50:27.000Z","path":"2019/03/18/ai-second-note/","text":"主要介绍AIRealMathSuite中使用到的函数，以及部分应用场景，持续更新中 AIRealRectOverlapAIAPI AIBoolean( AIRealMathSuite::AIRealRectOverlap)(const AIRealRect a, const AIRealRect *b)Tests whether two rectangles overlap (have any points in common).测试两个矩形是否重叠（有任何共同点） 参数: aThe first rectangle. bThe second rectangle. 返回值：如果矩形重叠，则为真。AIRealRectInAIRealRectAIAPI AIBoolean( AIRealMathSuite::AIRealRectInAIRealRect)(const AIRealRect a, const AIRealRect *b)Tests whether one rectangle is inside (entirely contained in) another rectangle.测试一个矩形是否在另一个矩形内（完全包含在内）。 Both must be open or both closed.两者都必须是开放的或都是封闭的。 参数: aThe first rectangle. bThe second rectangle. 返回值：True if the set of points contained by a is also contained by b.如果a包含的点集也包含在b内，则为真。AIRealRectSetAIAPI void( AIRealMathSuite::AIRealRectSet)(AIRealRect a, AIReal left, AIReal top, AIReal right, AIReal bottom)Sets the coordinate values in a rectangle. 设置矩形中的坐标值(In the Illustrator art coordinate system, the origin, (0, 0), is at the bottom left corner of a page. X and Y values increase upward and to the right.) 参数: aThe rectangle object. ///AI的矩形对象指针 leftThe left side location.///xmin topThe top side location. ///ymax rightThe right side location.///xmax bottomThe bottom side location.///ymin注意：Illustrator的坐标系原点位于页面左下角，X和Y值向上和向右增加。参考资料Adobe Illustrator SDK，下载地址：https://www.adobe.com/devnet/illustrator/sdk.html","tags":[{"name":"AI","slug":"AI","permalink":"http://11wy11.github.io/tags/AI/"}]},{"title":"markdown编写技巧","date":"2019-03-17T13:33:53.000Z","path":"2019/03/17/markdown-first-skill/","text":"常用转义字符 \\\\ 反斜杠 \\` 反引号 \\* 星号 \\_ 下划线 \\{\\} 大括号 \\[\\] 中括号 \\(\\) 小括号 \\# 井号 \\+ 加号 \\- 减号 \\. 英文句号 \\! 感叹号也可以用ASCII码代替 1 2 3 4 基本用法 标题设置（让字体变大，和word的标题意思一样）在Markdown当中设置标题，有两种方式：第一种：通过在文字下方添加“=”和“-”，他们分别表示一级标题和二级标题。第二种：在文字开头加上 “#”，通过“#”数量表示几级标题。（一共只有1~6级标题，1级标题字体最大） 块注释（blockquote）通过在文字开头添加“&gt;”表示块注释。（当&gt;和文字之间添加五个blank时，块注释的文字会有变化。） 斜体将需要设置为斜体的文字两端使用1个“*”或者“_”夹起来 粗体将需要设置为斜体的文字两端使用2个“*”或者“_”夹起来 无序列表在文字开头添加(*, +, and -)实现无序列表。但是要注意在(*, +, and -)和文字之间需要添加空格。（建议：一个文档中只是用一种无序列表的表示方式） 有序列表使用数字后面跟上句号。（还要有空格） 链接（Links）Markdown中有两种方式，实现链接，分别为内联方式和引用方式。内联方式：This is an [example link](http://example.com/).引用方式：I get 10 times more traffic from [Google][1] than from [Yahoo][2] or [MSN][3]. [1]: http://google.com/ “Google”[2]: http://search.yahoo.com/ “Yahoo Search”[3]: http://search.msn.com/ “MSN Search” 图片（Images）图片的处理方式和链接的处理方式，非常的类似。内联方式：![alt text](/path/to/img.jpg “Title”)引用方式：![alt text][id] [id]: /path/to/img.jpg “Title” 代码（HTML中所谓的Code）实现方式有两种：第一种：简单文字出现一个代码框。使用&lt;blockquote&gt;。（不是单引号而是左上角的ESC下面~中的）第二种：大片文字需要实现代码框。使用Tab和四个空格。 脚注（footnote）实现方式如下：hello[^hello] 下划线在空白行下方添加三条“-”横线。（前面讲过在文字下方添加“-”，实现的2级标题）参考官方文档http://daringfireball.net/projects/markdown/basics","tags":[{"name":"markdown","slug":"markdown","permalink":"http://11wy11.github.io/tags/markdown/"}]},{"title":"sqlite数据库查询 C++函数","date":"2019-03-17T13:17:22.000Z","path":"2019/03/17/sqlite-first-note/","text":"sqlite部分函数简介主要有打开数据库连接，执行数据库查询语句，关闭连接等函数 sqlite3_open用法打开数据库链接sqlite3_open用法原型：1234int sqlite3_open( const char *filename, /* Database filename (UTF-8) */ sqlite3 **ppDb /* OUT: SQLite db handle */); 用这个函数开始数据库操作。需要传入两个参数，一是数据库文件名，比如：E:/test.db。文件名不需要一定存在，如果此文件不存在，sqlite会自动建立它。如果它存在，就尝试把它当数据库文件来打开。二是sqlite3**，即前面提到的关键数据结构。函数返回值表示操作是否正确，如果是SQLITE_OK则表示操作正常。相关的返回值sqlite定义了一些宏。具体这些宏的含义可以参考sqlite3.h 文件。里面有详细定义。 sqlite3_close用法关闭数据库链接原型：1int sqlite3_close(sqlite3 *ppDb); ppDb为刚才使用sqlite3_open打开的数据库链接 sqlite3_exec用法执行sql操作原型：1234567int sqlite3_exec( sqlite3* ppDb, /* An open database */ const char *sql, /* SQL to be evaluated */ int (*callback)(void*,int,char**,char**), /* Callback function */ void *, /* 1st argument to callback */ char **errmsg /* Error msg written here */); 这就是执行一条sql 语句的函数。第1个参数不再说了，是前面open函数得到的指针。第2个参数constchar*sql是一条sql 语句，以\\0结尾。第3个参数sqlite3_callback 是回调，当这条语句执行之后，sqlite3会去调用你提供的这个函数。第4个参数void*是你所提供的指针，你可以传递任何一个指针参数到这里，这个参数最终会传到回调函数里面，如果不需要传递指针给回调函数，可以填NULL。回调函数的写法，以及这个参数的使用在之后介绍。第5个参数char** errmsg 是错误信息。注意是指针的指针。sqlite3里面有很多固定的错误信息。执行sqlite3_exec 之后，执行失败时可以查阅这个指针（直接cout&lt;&lt;errmsg得到一串字符串信息，这串信息告诉你错在什么地方。sqlite3_exec函数通过修改你传入的指针的指针，把你提供的指针指向错误提示信息，这样sqlite3_exec函数外面就可以通过这个char*得到具体错误提示。说明：通常，sqlite3_callback 和它后面的void*这两个位置都可以填NULL。填NULL表示你不需要回调。比如你做insert 操作，做delete操作，就没有必要使用回调。而当你做select 时，就要使用回调，因为sqlite3 把数据查出来，得通过回调告诉你查出了什么数据。exec 的回调typedef int(*sqlite3_callback)(void*,int,char**,char**);你的回调函数必须定义成上面这个函数的类型。下面给个简单的例子：123456789//sqlite3的回调函数//sqlite 每查到一条记录，就调用一次这个回调int LoadMyInfo(void* para,intn_column,char** column_value,char** column_name);//para是你在sqlite3_exec 里传入的void*参数通过para参数，你可以传入一些特殊的指针（比如类指针、结构指针），//然后在这里面强制转换成对应的类型（这里面是void*类型，必须强制转换成你的类型才可用）。然后操作这些数据//n_column是这一条记录有多少个字段(即这条记录有多少列)//char** column_value 是个关键值，查出来的数据都保存在这里，它实际上是个1维数组（不要以为是2维数组），//每一个元素都是一个char*值，是一个字段内容（用字符串来表示，以\\0结尾）//char** column_name 跟column_value是对应的，表示这个字段的字段名称 实例：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;iostream&gt;using namespace std;#include &quot;sqlite/sqlite3.h&quot;int callback(void*,int,char**,char**);int main()&#123; sqlite3* db; int nResult = sqlite3_open(&quot;test.db&quot;,&amp;db); if (nResult != SQLITE_OK) &#123; cout&lt;&lt;&quot;打开数据库失败：&quot;&lt;&lt;sqlite3_errmsg(db)&lt;&lt;endl; return 0; &#125; else &#123; cout&lt;&lt;&quot;数据库打开成功&quot;&lt;&lt;endl; &#125; char* errmsg; nResult = sqlite3_exec(db,&quot;create table fuck(id integer primary key autoincrement,name varchar(100))&quot;,NULL,NULL,&amp;errmsg); if (nResult != SQLITE_OK) &#123; sqlite3_close(db); cout&lt;&lt;errmsg; sqlite3_free(errmsg); return 0; &#125; string strSql; strSql+=&quot;begin;\\n&quot;; for (int i=0;i&lt;100;i++) &#123; strSql+=&quot;insert into fuck values(null,&apos;heh&apos;);\\n&quot;; &#125; strSql+=&quot;commit;&quot;; //cout&lt;&lt;strSql&lt;&lt;endl; nResult = sqlite3_exec(db,strSql.c_str(),NULL,NULL,&amp;errmsg); if (nResult != SQLITE_OK) &#123; sqlite3_close(db); cout&lt;&lt;errmsg&lt;&lt;endl; sqlite3_free(errmsg); return 0; &#125; strSql = &quot;select * from fuck&quot;; nResult = sqlite3_exec(db,strSql.c_str(),callback,NULL,&amp;errmsg); if (nResult != SQLITE_OK) &#123; sqlite3_close(db); cout&lt;&lt;errmsg&lt;&lt;endl; sqlite3_free(errmsg); return 0; &#125; sqlite3_close(db); return 0;&#125;int callback(void* ,int nCount,char** pValue,char** pName)&#123; string s; for(int i=0;i&lt;nCount;i++) &#123; s+=pName[i]; s+=&quot;:&quot;; s+=pValue[i]; s+=&quot;\\n&quot;; &#125; cout&lt;&lt;s&lt;&lt;endl; return 0;&#125;","tags":[{"name":"sqlite","slug":"sqlite","permalink":"http://11wy11.github.io/tags/sqlite/"},{"name":"C++","slug":"C","permalink":"http://11wy11.github.io/tags/C/"}]},{"title":"C++部分基础知识","date":"2019-03-17T06:09:53.000Z","path":"2019/03/17/cpp-function/","text":"介绍项目中用到的一些常用函数和关键字的使用Table of Contents generated with DocToc 常用函数 1. strtok 2.strcmp 3. Erase 4. List 5. strcpy 6.转换函数 6.1 Atoi 关键字 extern 变量 函数 编译链接 声明外部变量 C++中extern c的深层探索 常用函数1. strtok 分解字符串为一组字符串。s为要分解的字符，delim为分隔符字符（如果传入字符串，则传入的字符串中每个字符均为分割符）。首次调用时，s指向要分解的字符串，之后再次调用要把s设成NULL。 例如：strtok(“abc,def,ghi”,”,”)，最后可以分割成为abc def ghi.尤其在点分十进制的IP中提取应用较多。strtok的函数原型为char strtok(char s, char *delim)，功能为“Parse S into tokens separated by characters in DELIM.If S is NULL, the saved pointer in SAVE_PTR is used as the next starting point. ” 翻译成汉语就是：作用于字符串s，以包含在delim中的字符为分界符，将s切分成一个个子串；如果，s为空值NULL，则函数保存的指针SAVE_PTR在下一次调用中将作为起始位置。123456789101112131415#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;int main()&#123; char sentence[]=&quot;This is a sentence with 7 tokens&quot;; cout &lt;&lt; &quot;The string to be tokenized is:\\n&quot; &lt;&lt; sentence &lt;&lt; &quot;\\n\\nThe tokens are:\\n\\n&quot;; char *tokenPtr=strtok(sentence,&quot; &quot;); while(tokenPtr!=NULL) &#123; cout&lt;&lt;tokenPtr&lt;&lt;endl; tokenPtr=strtok(NULL,&quot; &quot;); &#125; //cout &lt;&lt; &quot;After strtok,sentence=&quot; &lt;&lt; tokenPtr&lt;&lt;endl; return 0;&#125; 函数第一次调用需设置两个参数。第一次分割的结果，返回串中第一个 ‘,’ 之前的字符串,也就是上面的程序第一次输出abc。第二次调用该函数strtok(NULL,”,”),第一个参数设置为NULL。结果返回分割依据后面的字串，即第二次输出d。strtok是一个线程不安全的函数，因为它使用了静态分配的空间来存储被分割的字符串位置线程安全的函数叫strtok_r,ca运用strtok来判断ip或者mac的时候务必要先用其他的方法判断’.’或’:’的个数，因为用strtok截断的话，比 2.strcmpC/C++函数，比较两个字符串设这两个字符串为str1，str2，若str1=str2，则返回零；若str1&lt;str2，则返回负数；若str1&gt;str2，则返回正数。matlab中函数，strcmp(s1，s2) 判断两个字符串s1和s2是否相同，相同返回true ,不同返回false源码：12345678910111213141516int strcmp(const char *str1,const char *str2)&#123; /*不可用while(*str1++==*str2++)来比较，当不相等时仍会执行一次++， return返回的比较值实际上是下一个字符。应将++放到循环体中进行。*/ while(*str1 == *str2) &#123; assert((str1 != NULL) &amp;&amp; (str2 != NULL)); if(*str1 == '\\0') return 0; str1++; str2++; &#125; return *str1 - *str2;&#125; 3. Erase c.erase(k)从c中删除元素k，返回一个size_type值，指出删除的元素的数量 c.erase(p)从c中删除迭代器p指定的元素，p必须指向c中的一个真实元素，不能等于c.end() c.erase(b,e)从c中删除迭代器对b和e所表示的范围中的元素，返回e4. ListList 反向迭代器begin和end成员begin和end操作产生指向容器内第一个元素和最后一个元素的下一个位置的迭代器，如下所示。这两个迭代器通常用于标记包含容器中所有元素的迭代范围。c.begin() 返回一个迭代器，它指向容器c的第一个元素c.end() 返回一个迭代器，它指向容器c的最后一个元素的下一个位置c.rbegin() 返回一个逆序迭代器，它指向容器c的最后一个元素c.rend() 返回一个逆序迭代器，它指向容器c的第一个元素前面的位置上述每个操作都有两个不同的版本：一个是const成员，另一个是非const成员。这些操作返回什么类型取决于容器是否为const。如果容器不是const，则这些操作返回iterator或reverse_iterator类型。如果容器是const，则其返回类型要加上const_前缀，也就是const_iterator和const_reverse_iterator类型。 5. strcpy描述C 库函数 char strcpy(char dest, const char *src) 把 src 所指向的字符串复制到 dest。 声明下面是 strcpy() 函数的声明。char *strcpy(char *dest, const char *src)参数dest – 指向用于存储复制内容的目标数组。src – 要复制的字符串。返回值该函数返回一个指向最终的目标字符串 dest 的指针。实例下面的实例演示了 strcpy() 函数的用法。12345678910111213141516#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main()&#123; char src[40]; char dest[100]; memset(dest, &apos;\\0&apos;, sizeof(dest)); strcpy(src, &quot;This is runoob.com&quot;); strcpy(dest, src); printf(&quot;最终的目标字符串： %s\\n&quot;, dest); return(0);&#125; 6.转换函数6.1 Atoi字符串转整型 关键字externextern是计算机语言中的一个关键字，可置于变量或者函数前，以表示变量或者函数的定义在别的文件中。提示编译器遇到此变量或函数时，在其它模块中寻找其定义，另外，extern也可用来进行链接指定。 变量在一个源文件里定义了一个数组：char a[6];在另外一个文件里用下列语句进行了声明：extern char *a； 请问，这样可以吗？ 答案与分析： 1)、不可以，程序运行时会告诉你非法访问。原因在于，指向类型T的指针并不等价于类型T的数组。extern char *a声明的是一个指针变量而不是字符数组，因此与实际的定义不同，从而造成运行时非法访问。应该将声明改为extern char a[ ]。 2)、例子分析如下，如果a[] = “abcd”,则外部变量a=0x12345678 (数组的起始地址)，而*a是重新定义了一个指针变量，a指向的地址可能是0x87654321,直接使用*a是错误的. 3)、这提示我们，在使用extern时候要严格对应声明时的格式，在实际编程中，这样的错误屡见不鲜。 4)、extern用在变量声明中常常有这样一个作用：你要在*.c文件中引用另一个文件中的一个全局的变量，那就应该放在*.h中用extern来声明这个全局变量。 extern用于变量的用法： extern int a;//声明一个全局变量a int a; //定义一个全局变量a extern int a =0 ;//定义一个全局变量a 并给初值。一旦给予赋值，一定是定义，定义才会分配存储空间。（注意：经过测试在GCC中，这样定义变量是不能通过编译的，而在VS2013可以） int a =0;//定义一个全局变量a,并给初值， 声明之后你不能直接使用这个变量，需要定义之后才能使用。 第四个等于第三个，都是定义一个可以被外部使用的全局变量，并给初值。 糊涂了吧，他们看上去可真像。但是定义只能出现在一处。也就是说，不管是int a;还是int a=0;都只能出现一次，而那个extern int a可以出现很多次。 当你要引用一个全局变量的时候，你就要声明extern int a;这时候extern不能省略，因为省略了，就变成int a;这是一个定义，不是声明。 函数实际上函数的声明和定义都不需要添加extern关键字，在实际使用的时候也最好不要添加关键字。如果一个函数是不会被其它文件调用的，那么这个函数应该被声明成static的。如：extern int func(void){return 0;}跟int func(void){return 0;} 是等价的另外 extern int func(void); 跟int func(void);是等价的。 编译链接声明外部变量现代编译器一般采用按文件编译的方式，因此在编译时，各个文件中定义的全局变量是互相不透明的。也就是说，在编译时，全局变量的可见域限制在文件内部。 下面举一个简单的例子： 创建一个工程，里面含有A.cpp和B.cpp两个简单的C++源文件：123456//A.cppint i;int main()&#123;&#125;//B.cppint i; 这两个文件极为简单，在A.cpp中我们定义了一个全局变量i，在B中我们也定义了一个全局变量i。 我们对A和B分别编译，都可以正常通过编译，但是进行链接的时候，却出现了错误，错误提示如下：12345Linking...B.obj:error LNK2005:&quot;inti&quot;(?i@@3HA)already defined in A.objDebug/A.exe:fatal error LNK1169:one or more multiply defined symbols foundError executing link.exe.A.exe-2 error(s),0 warning(s) 这就是说，在编译阶段，各个文件中定义的全局变量相互是不透明的，编译A时觉察不到B中也定义了i，同样，编译B时觉察不到A中也定义了i。 但是到了链接阶段，要将各个文件的内容“合为一体”，因此，如果某些文件中定义的全局变量名相同的话，在这个时候就会出现错误，也就是上面提示的重复定义的错误。 因此，各个文件中定义的全局变量名不可相同。 在链接阶段，各个文件的内容（实际是编译产生的obj文件）是被合并到一起的，因而，定义于某文件内的全局变量，在链接完成后，它的可见范围被扩大到了整个程序。 这样一来，按道理说，一个文件中定义的全局变量，可以在整个程序的任何地方被使用，举例说，如果A文件中定义了某全局变量，那么B文件中应可以使用该变量。修改我们的程序，加以验证： 1234567//A.cppint main()&#123; i = 100;//试图使用B中定义的全局变量&#125;//B.cppint i; 编译结果如下:12345Compiling...A.cppC:\\Documents and Settings\\桌面\\try extern\\A.cpp(5):error C2065:&apos;i&apos;:undeclared identifierError executing cl.exe.A.obj-1 error(s),0 warning(s) 编译错误。 其实出现这个错误是意料之中的，因为文件中定义的全局变量的可见性扩展到整个程序是在链接完成之后，而在编译阶段，他们的可见性仍局限于各自的文件。 编译器的目光不够长远，编译器没有能够意识到，某个变量符号虽然不是本文件定义的，但是它可能是在其它的文件中定义的。 虽然编译器不够有远见，但是我们可以给它提示，帮助它来解决上面出现的问题。这就是extern的作用了。 extern的原理很简单，就是告诉编译器：“你现在编译的文件中，有一个标识符虽然没有在本文件中定义，但是它是在别的文件中定义的全局变量，你要放行！” 我们为上面的错误程序加上extern关键字： 12345678//A.cppextern int i;int main()&#123; i=100;//试图使用B中定义的全局变量&#125;//B.cppint i; 顺利通过编译，链接。 C++中extern c的深层探索 简介C++语言的创建初衷是“a better C”，但是这并不意味着C++中类似C语言的全局变量和函数所采用的编译和连接方式与C语言完全相同。作为一种欲与C兼容的语言，C++保留了一部分过程式语言的特点（被世人称为“不彻底地面向对象”），因而它可以定义不属于任何类的全局变量和函数。但是，C++毕竟是一种面向对象的程序设计语言，为了支持函数的重载，C++对全局函数的处理方式与C有明显的不同。 从标准头文件说起某企业曾经给出如下的一道面试题：为什么标准头文件都有类似以下的结构？ 12345678910#ifndef __INCvxWorksh#define __INCvxWorksh#ifdef __cplusplusextern &quot;C&quot; &#123;#endif/*...*/#ifdef __cplusplus&#125;#endif#endif /* __INCvxWorksh */ 分析 显然，头文件中的编译宏“#ifndef INCvxWorksh、#define INCvxWorksh、#endif” 的作用是防止该头文件被重复引用。 那么 123456#ifdef __cplusplusextern &quot;C&quot; &#123;#endif#ifdef __cplusplus&#125;#endif 的作用又是什么呢？我们将在下文一一道 深层揭密extern “C” extern “C” 包含双重含义，从字面上即可得到：首先，被它修饰的目标是“extern”的；其次，被它修饰的目标是“C”的。让我们来详细解读这两重含义。 被extern “C”限定的函数或变量是extern类型的； extern是C/C++语言中表明函数和全局变量作用范围（可见性）的关键字，该关键字告诉编译器，其声明的函数和变量可以在本模块或其它模块中使用，记住，下列语句： extern int a; 仅仅是一个变量的声明，其并不是在定义变量a，并未为a分配内存空间。变量a在所有模块中作为一种全局变量只能被定义一次，否则会出现连接错误。 引用一个定义在其它模块的全局变量或函数（如，全局函数或变量定义在A模块，B欲引用）有两种方法， 一、B模块中include模块A的头文件。 二、模块B中对欲引用的模块A的变量或函数重新声明一遍，并前加extern关键字。 通常，在模块的头文件中对本模块提供给其它模块引用的函数和全局变量以关键字extern声明。 例如，如果模块B欲引用该模块A中定义的全局变量和函数时只需包含模块A的头文件即可。这样，模块B中调用模块A中的函数时，在编译阶段，模块B虽然找不到该函数，但是并不会报错；它会在连接阶段中从模块A编译生成的目标代码中找到此函数。 与extern对应的关键字是static，被它修饰的全局变量和函数只能在本模块中使用。因此，一个函数或变量只可能被本模块使用时，其不可能被extern “C”修饰。 被extern “C”修饰的变量和函数是按照C语言方式编译和连接的； 未加extern “C”声明时的编译方式 首先看看C++中对类似C的函数是怎样编译的。 作为一种面向对象的语言，C++支持函数重载，而过程式语言C则不支持。函数被C++编译后在符号库中的名字与C语言的不同。例如，假设某个函数的原型为： void foo( int x, int y ); 该函数被C编译器编译后在符号库中的名字为_foo，而C++编译器则会产生像_foo_int_int之类的名字（不同的编译器可能生成的名字不同，但是都采用了相同的机制，生成的新名字称为“mangled name”）。 _foo_int_int这样的名字包含了函数名、函数参数数量及类型信息，C++就是靠这种机制来实现函数重载的。例如，在C++中，函数void foo( int x, int y )与void foo( int x, float y )编译生成的符号是不相同的，后者为_foo_int_float。 同样地，C++中的变量除支持局部变量外，还支持类成员变量和全局变量。用户所编写程序的类成员变量可能与全局变量同名，我们以”.”来区分。而本质上，编译器在进行编译时，与函数的处理相似，也为类中的变量取了一个独一无二的名字，这个名字与用户程序中同名的全局变量名字不同。 未加extern “C”声明时的连接方式 假设在C++中，模块A的头文件如下： 123456789// 模块A头文件 moduleA.h#ifndef MODULE_A_H#define MODULE_A_Hint foo( int x, int y );#endif在模块B中引用该函数：// 模块B实现文件 moduleB.cpp#include &quot;moduleA.h&quot;foo(2,3); 实际上，在连接阶段，连接器会从模块A生成的目标文件moduleA.obj中寻找_foo_int_int这样的符号！ 加extern “C”声明后的编译和连接方式 加extern “C”声明后，模块A的头文件变为： 12345// 模块A头文件 moduleA.h#ifndef MODULE_A_H#define MODULE_A_Hextern &quot;C&quot; int foo( int x, int y );#endif 在模块B的实现文件中仍然调用foo( 2,3 )，其结果是： （1）模块A编译生成foo的目标代码时，没有对其名字进行特殊处理，采用了C语言的方式； （2）连接器在为模块B的目标代码寻找foo(2,3)调用时，寻找的是未经修改的符号名_foo。 如果在模块A中函数声明了foo为extern “C”类型，而模块B中包含的是extern int foo( int x, int y ) ，则模块B找不到模块A中的函数；反之亦然。 所以，可以用一句话概括extern “C”这个声明的真实目的（任何语言中的任何语法特性的诞生都不是随意而为的，来源于真实世界的需求驱动。我们在思考问题时，不能只停留在这个语言是怎么做的，还要问一问它为什么要这么做，动机是什么，这样我们可以更深入地理解许多问题）： 实现C++与C及其它语言的混合编程。 明白了C++中extern “C”的设立动机，我们下面来具体分析extern “C”通常的使用技巧。 extern “C”的惯用法 （1）在C++中引用C语言中的函数和变量，在包含C语言头文件（假设为cExample.h）时，需进行下列处理： 1234extern &quot;C&quot;&#123;#include &quot;cExample.h&quot;&#125; 而在C语言的头文件中，对其外部函数只能指定为extern类型，C语言中不支持extern “C”声明，在.c文件中包含了extern “C”时会出现编译语法错误。 笔者编写的C++引用C函数例子工程中包含的三个文件的源代码如下： 123456789101112131415161718192021/*c语言头文件：cExample.h */#ifndef C_EXAMPLE_H#define C_EXAMPLE_Hextern int add(int x,int y);#endif/*c语言实现文件：cExample.c */#include &quot;cExample.h&quot;int add( int x, int y )&#123;return x + y;&#125;//c++实现文件，调用add：cppFile.cppextern &quot;C&quot;&#123;#include &quot;cExample.h&quot;&#125;int main(int argc, char* argv[])&#123;add(2,3);return 0;&#125; 如果C++调用一个C语言编写的.DLL时，当包括.DLL的头文件或声明接口函数时，应加extern “C” { }。 （2）在C++引用C语言中的函数和变量时，C++的头文件需添加extern “C”，但是在C语言中不能直接引用声明了extern “C”的该头文件，应该仅将C文件中将C++中定义的extern “C”函数声明为extern类型。 笔者编写的C引用C++函数例子工程中包含的三个文件的源代码如下： 123456789101112131415161718192021//C++头文件 cppExample.h#ifndef CPP_EXAMPLE_H#define CPP_EXAMPLE_Hextern &quot;C&quot; int add( int x, int y );#endif//C++实现文件 cppExample.cpp#include &quot;cppExample.h&quot;int add( int x, int y )&#123;return x + y;&#125;/* C实现文件 cFile.c/* 这样会编译出错：#include &quot;cppExample.h&quot; */extern int add (int x,int y);int main (int argc,char*argv[])&#123; add(2,3); return 0;&#125; 参考：百度百科https://baike.baidu.com/item/extern/4443005?fr=aladdin","tags":[{"name":"C++","slug":"C","permalink":"http://11wy11.github.io/tags/C/"}]},{"title":"krpano快速入门教程（三）","date":"2019-03-16T14:54:57.000Z","path":"2019/03/16/krpano-third-note/","text":"添加热点及相关内容使用编辑器热点，添加自定义热点，动态热点等 使用tour_editor添加热点及设定起始角度通过Load tour.xml导入要编辑的配置文件点击set as startup view设置初始角度，可以旋转到合适的角度，点击按钮设置全景图默认展示角度。点击Add hotspot按钮，画面中出现一个箭头，将其拖放置你想放置的地方，点击save按钮保存热点编辑。也可以通过编辑按钮设置热点链接场景。点击Save tour.xml按钮保存文件。 编辑 tour.xml添加热点在实际生产中，通常直接编辑xml文件，在相应的场景中添加热点123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687&lt;hotspot name=&quot;...&quot; 定义热点名称 type=&quot;image&quot; 定义热点类型，只能是image url=&quot;...&quot; 热点图像路径，支持SWF, JPG, PNG, GIF alturl=&quot;...&quot; html5状态下显示的图像路径 keep=&quot;false&quot; 是否在下一场景跳转后保持显示 devices=&quot;all&quot; 支持设备类型 visible=&quot;true&quot; 是否可见 enabled=&quot;true&quot; 设置热点是否接收鼠标事件 handcursor=&quot;true&quot; 设置是否鼠标移到上面显示小手 maskchildren=&quot;false&quot; 设置是否将子控件变成蒙板 zorder=&quot;&quot; 插入元素的次序索引，可以是字符也可以是数字，html5输出必须是0-100整数 zorder2=&quot;0.0&quot; 设置为0.0和1.0，分别对应当前热点在扭曲控件之下和之上 capture=&quot;true&quot; 与enabled配合使用，都为true只对热点传递动作，capture=&quot;false&quot;可对子控件传递动作 children=&quot;true&quot; 设置子控件是否接收热点鼠标事件 blendmode=&quot;normal&quot; 设置混合模式，可选：normal, layer, screen, add, subtract, difference, multiply, overlay, lighten, darken, hardlight, invert. style=&quot;&quot; 读入已设置好的style名称 ath=&quot;0.0&quot; atv=&quot;0.0&quot; 设定将场景缩略图为球形热点 edge=&quot;center&quot; 热点的边界对齐点 ox=&quot;0&quot; 边界到对齐点的偏移量 oy=&quot;0&quot; zoom=&quot;false&quot; 设置是否场景缩放时，热点跟随缩放 distorted=&quot;false&quot; rx=&quot;0.0&quot; ry=&quot;0.0&quot; rz=&quot;0.0&quot; 设置热点是否跟随场景进行3D扭曲 details=&quot;8&quot; 热点显示的细节数量，默认为8 inverserotation=&quot;false&quot; 设置是否逆向旋转3D扭曲 flying=&quot;0.0&quot; 设置ath/atv/scale的插值 width=&quot;&quot; height=&quot;&quot; 设置热点宽高 scale=&quot;1.0&quot; 设置热点缩放 rotate=&quot;0.0&quot; 设置热点旋转角度 pixelhittest=&quot;false&quot; 是否启动精确像素测试 smoothing=&quot;true&quot; 设置缩放时，是否平滑化处理 accuracy=&quot;0&quot; 设置像素渲染值（flash下） accuracy2=&quot;1&quot; 设置精度控制（html5下） alpha=&quot;1.0&quot; 设置透明度 autoalpha=&quot;false&quot; 设置是否自动变更透明度 usecontentsize=&quot;false&quot; 是否使用用户指定flash大小，默认false原始大小 scale9grid=&quot;&quot; 定义是否支持矢量缩放，scale9grid=&quot;x-position|y-position|width|height|prescale*&quot; crop=&quot;&quot; 定义元素坐标及宽高 crop=&quot;x-position|y-position|width|height&quot; onovercrop=&quot;&quot; 设置元素鼠标移到上方后的坐标及宽高 ondowncrop=&quot;&quot; 设置元素鼠标按下状态后的坐标及宽高 scalechildren=&quot;false&quot; 子元素是否跟随缩放 mask=&quot;&quot; mask=&quot;name&quot; mask=&quot;layer[name]&quot; mask=&quot;hotspot[name]&quot; effect=&quot;&quot; 热点位图效果3种：glow(color,alpha,range,strength); dropshadow(depth,angle,color,range,strength); blur(radius); onover=&quot;&quot; 鼠标在经过上方时执行动作 onhover=&quot;&quot; 鼠标停在上方时执行动作 onout=&quot;&quot; 鼠标停移出范围时时执行动作 onclick=&quot;&quot; 鼠标停点击时执行动作 ondown=&quot;&quot; 鼠标按下时执行动作 onup=&quot;&quot; 鼠标按键松开时执行动作 onloaded=&quot;&quot; 加载元素完成后执行动作 /&gt; 多边形热点 &lt;hotspot name=&quot;...&quot; keep=&quot;false&quot; visible=&quot;true&quot; enabled=&quot;true&quot; handcursor=&quot;true&quot; zorder=&quot;&quot; capture=&quot;true&quot; blendmode=&quot;normal&quot; style=&quot;&quot; alpha=&quot;1.0&quot; autoalpha=&quot;false&quot; fillcolor=&quot;0xFFFFFF&quot; fillcolorhover=&quot;0xFFFFFF&quot; 填充颜色及鼠标移上后颜色 fillalpha=&quot;0.0&quot; fillalphahover=&quot;0.1&quot; 填充颜色透明度及鼠标移上后颜色透明度 borderwidth=&quot;0.0&quot; borderwidthhover=&quot;4.0&quot; 边界宽度及鼠标移上后边界宽度 bordercolor=&quot;0xFFFFFF&quot; bordercolorhover=&quot;0xFFFFFF&quot; 边界颜色及边界鼠标移上后颜色 borderalpha=&quot;0.0&quot; borderalphahover=&quot;0.8&quot; 边界透明度及鼠标移上后边界透明度 fadeintime=&quot;0.15&quot; fadeincurve=&quot;1.1&quot; 悬停状态变化时间及形式 fadeouttime=&quot;0.3&quot; fadeoutcurve=&quot;0.7&quot; onover=&quot;&quot; onhover=&quot;&quot; onout=&quot;&quot; onclick=&quot;&quot; ondown=&quot;&quot; onup=&quot;&quot; &gt; &lt;point ath=&quot;...&quot; atv=&quot;...&quot; /&gt; 多边形热点坐标 &lt;point ath=&quot;...&quot; atv=&quot;...&quot; /&gt; &lt;point ath=&quot;...&quot; atv=&quot;...&quot; /&gt; ... &lt;/hotspot&gt; 历史文章krpano快速入门教程（一) 使用krpano工具构建即用型panoskrpano快速入门教程（二) vtour全景漫游及vtour文件夹介绍","tags":[{"name":"krpano","slug":"krpano","permalink":"http://11wy11.github.io/tags/krpano/"}]},{"title":"C++之QT的信号和槽的详解","date":"2019-03-16T12:24:56.000Z","path":"2019/03/16/qt-note/","text":"1 简介 信号和槽是Qt特有的信息传输机制，是Qt设计程序的重要基础，它可以让互不干扰的对象建立一种联系。 在GUI编程中，当我们改变一个部件时，经常想要其他部件被通知。更一般化，我们希望任何一类的对象可以和其它对象进行通讯。例如，如果我们点击一个关闭按钮，我们可能想要窗口的close()函数被调用。 其他工具包通过回调实现了这种通信。回调是一个函数指针，所以如果你希望一个处理函数通知你一些事件，你可以把另一个函数（回调）的指针传递给处理函数。处理函数在适当的时候调用回调。尽管一些成功的框架使用了这个方法，但是回调可能是不直观的，并可能在确保回调参数类型正确性上存在问题。信号槽是 Qt 框架引以为豪的机制之一。所谓信号槽，实际就是观察者模式。当某个事件发生之后，比如，按钮检测到自己被点击了一下，它就会发出一个信号（signal）。这种发出是没有目的的，类似广播。如果有对象对这个信号感兴趣，它就会使用连接（connect）函数，意思是，将想要处理的信号和自己的一个函数（称为槽（slot））绑定来处理这个信号。也就是说，当信号发出时，被连接的槽函数会自动被回调。这就类似观察者模式：当发生了感兴趣的事件，某一个操作就会被自动触发。（这里提一句，Qt 的信号槽使用了额外的处理来实现，并不是 GoF 经典的观察者模式的实现方式。） 信号和槽是Qt特有的信息传输机制，是Qt设计程序的重要基础，它可以让互不干扰的对象建立一种联系。 槽的本质是类的成员函数，其参数可以是任意类型的。和普通C++成员函数几乎没有区别，它可以是虚函数；也可以被重载；可以是公有的、保护的、私有的、也可以被其他C++成员函数调用。唯一区别的是：槽可以与信号连接在一起，每当和槽连接的信号被发射的时候，就会调用这个槽。 Qt的小部件有很多预定义的信号，但是我们总是可以通过继承来加入我们自己的信号。槽就是一个对应于特定信号的被调用的函数。Qt的部件有很多预定义的槽，但同样可以通过子类化加入自己的槽来处理感兴趣的信号。 1.1 对象树(子对象动态分配空间不需要释放) 比如说当应用程序创建了一个具有父窗口部件的对象时，该对象将被加入父窗口部件的孩子列表。当应用程序销毁父窗口部件时，其下的孩子列表中的对象将被一一删除。这让我们在编程时，能够将主要精力放在系统的业务上，提高编程效率，同时也保证了系统的稳健性。 2 信号和槽 在Qt中我们有一种可以替代回调的技术：我们使用信号和槽。当一个特定事件发生的时候，一个信号被发射。Qt的小部件有很多预定义的信号，但是我们总是可以通过继承来加入我们自己的信号。槽就是一个对应于特定信号的被调用的函数。Qt的部件有很多预定义的槽，但同样可以通过子类化加入自己的槽来处理感兴趣的信号。 信号和槽机制是类型安全的：一个信号的签名(参数类型)必须与它的接收槽的签名相匹配。（实际上，一个槽的签名可能比它接收到的信号短，因为它可以忽略额外的参数。）因为签名是兼容的，当使用基于函数指针的语法时，编译器就可以帮助我们检测类型不匹配。基于字符串的信号和槽语法将在运行时检测类型不匹配。信号和插槽是松散耦合的：一个发射信号的类不用知道也不用关心哪个槽要接收这个信号。Qt的信号和槽的机制可以保证如果你把一个信号和一个槽连接起来，槽会在正确的时间使用信号的参数被调用。信号和槽可以使用任何数量、任何类型的参数。它们是完全类型安全的：不会再有回调核心转储(core dump)。 从QObject类或者它的子类（如QWidget类）继承的所有类可以包含信号和槽。当改变它们的状态的时候，信号被发送。从某种意义上说，即它们对其他对象感兴趣。这就是所有的对象通讯时所做的一切。它不知道也不关心是否有其他对象接收到了它发射的信号。这就是真正的信息封装，并且确保对象可以用作一个软件组件使用。 槽可以用来接收信号，但它们也是普通的成员函数。正如一个对象不知道有其他对象收到它的信号一样，一个槽也不知道它是否被任意信号连接。因此，这种方式保证了Qt创建组件的完全独立。 你可以连接多个信号到一个槽，同样一个信号可以被你需要的多个槽连接。甚至可以一个信号连接到另一个信号。（该情况下，只要第一个信 号被发射时，第二个信号立即被发射。） 总体来看，信号和槽构成了一个强有力的组件编程机制。 2.1 信号 当一个对象内部状态发生改变时发射信号，信号就被发射，在某些方面对象的客户端和所有者可能感兴趣。信号是一个public访问函数并可以在任何地方发射，但是我们建议仅在定义了信号的类及他们的子类中发射。 当一个信号被发射，它所连接的槽会被立即执行，类似于一个普通函数的调用。在该情况下，信号/槽机制在任何GUI事件循环中是完全独立的。一旦所有的槽返回了，emit语句随后的代码将会执行。这与queued connections方式有些许不同，queued connections方式下emit关键字随后的代码会立即继续执行，槽在随后执行（相当于异步，参考信号与槽的连接类型）。 如果几个槽被连接到一个信号，当信号被发射时，这些槽就会按它们连接的顺序挨个执行。 信号会由moc自动生成并一定不要在.cpp文件中实现。它们也不能有任何返回类型（也就是 只能使用void）。 2.2 槽 当与槽连接的信号被发射时，该槽被调用。槽是普通的C++函数可以正常调用；它们唯一的特点就是可以被信号连接。 因为槽是普通成员函数，所以被直接调用时遵循一般的C++规则。然而，作为槽，它们能被任何组件调用，通过信号槽连接，无需考虑访问级别。这意味着从一个任意类的实例发出的一个信号可以在一个不相关的类的实例中调用一个私有槽。 同样还可以定义虚拟槽，我们在实践中发现它非常有用。 与回调相比，信号和插槽的速度稍慢，因为它们增加了灵活性，尽管在实际应用程序中的差异是微不足道的。 信号和槽的机制是非常有效的，但是它不像“真正的”回调那样快。信号和槽稍微有些慢，这是因为它们所提供的灵活性造成，尽管在实际应用中这些性能可以被忽略。通常，发射一个和槽相连的信号，大约比直接调接收器非虚函数的调用慢十倍。这是定位连接对象所需的开销，为了安全地遍历所有连接（e.g检查随后的接收器在发射过程中没有被销毁），并以通用的方式安排任意参数。虽然10个非虚函数调用听起来可能很多，但开销比任意new或delete 操作少得多。当执行一个字符串时，vector或list操作在后面的场景中需要new或delete, 但信号和槽在完成函数调用的开销中只占很小的一部分。在一个槽中进行系统调用或者间接地调用超过10个函数，情况也是相同的;。信号/插槽机制的简单和灵活性对于时间的开销是值得，用户甚至不会注意到这点。 注意，与基于qt的应用程序一起编译时，定义变量的其他库调用信号和槽可能会造成编译器警告和错误。要解决这个问题，#undef这些预处理器的冲突符号即可。 2.3 一个Qt Creator的例子 1234567891011#include &lt;QApplication&gt;#include &lt;QPushButton&gt; int main(int argc, char *argv[]) &#123; QApplication app(argc, argv); QPushButton button(&quot;Quit&quot;); QObject::connect(&amp;button, &amp;QPushButton::clicked, &amp;app, &amp;QApplication::quit); button.show(); return app.exec(); &#125; 在 Qt Creator 中创建工程的方法创建好工程，然后将main()函数修改为上面的代码。点击运行，我们会看到一个按钮，上面有“Quit”字样。点击按钮，程序退出。 connect()函数最常用的一般形式： connect(sender, signal, receiver, slot); 参数： sender：发出信号的对象 signal：发送对象发出的信号 receiver：接收信号的对象 slot：接收对象在接收到信号之后所需要调用的函数 信号槽要求信号和槽的参数一致，所谓一致，是参数类型一致。如果不一致，允许的情况是，槽函数的参数可以比信号的少，即便如此，槽函数存在的那些参数的顺序也必须和信号的前面几个一致起来。这是因为，你可以在槽函数中选择忽略信号传来的数据（也就是槽函数的参数比信号的少），但是不能说信号根本没有这个数据，你就要在槽函数中使用（就是槽函数的参数比信号的多，这是不允许的）。 2.4 一个普通C++程序的例子 一个小的C++类声明如下： 12345678910class Counter &#123; public: Counter() &#123; m_value = 0; &#125; int value() const &#123; return m_value; &#125; void setValue(int value); private: int m_value; &#125;; 一个小的基于QObject类如下： 123456789101112131415#include &lt;QObject&gt; class Counter : public QObject &#123; Q_OBJECT public: Counter() &#123; m_value = 0; &#125; int value() const &#123; return m_value; &#125; public slots: void setValue(int value); signals: void valueChanged(int newValue); private: int m_value; &#125;; 这个基于QObject的类有同样的内部状态，并提供公有方法来访问状态。除此之外，这个类可以通过发射一个valueChanged()信号来告诉外部世界关于它的状态改变，并且它有一个槽，其它对象可以发送信号给这个槽。 所有包含信号和/或者槽的类必须在它们的声明中提到Q_OBJECT。它们也必须从QObject继承(直接或间接)。 槽由应用程序的编写者来实现。这里是Counter::setValue()可能的一个槽实现： 1234567void Counter::setValue(int value) &#123; if (value != m_value) &#123; m_value = value; emit valueChanged(value); &#125; &#125; emit这一行从对象中发射valueChanged()信号，以一个新值作为参数。 在下面的小片断中，我们创建了两个Counter对象，并使用QObject::connect()将第一个对象的valueChanget()信号连接到第二个对象的setValue槽。 下面是把两个对象连接在一起的一种方法： 123456Counter a, b; QObject::connect(&amp;a, &amp;Counter::valueChanged, &amp;b, &amp;Counter::setValue); a.setValue(12); // a.value() == 12, b.value() == 12 b.setValue(48); // a.value() == 12, b.value() == 48 调用a.setValue(12)会使a发射一个valueChanged(12) 信号，b将会在它的setValue()槽中接收这个信号，也就是b.setValue(12) 被调用。接下来b会发射同样的valueChanged()信号，但是因为没有槽被连接到b的valueChanged()信号，所以该信号被忽略。 注意只有当value!= m_value的时候setValue()函数才会设置这个值并发射信号。这样就避免了存在环connections的情况下无限循环。（比如b.valueChanged() 和a.setValue()连接在一起）。 默认情况下，对于你做出的每一个连接，一个信号被发射;重复连接下两个信号被发射。你可以调用disconnect()中断所有连接。如果传递了Qt::UniqueConnection类型，连接只有在不重复的情况下才建立。如果已经存在重复连接（同一个对象上确定的信号到确定的槽），则连接将会失败，connect返回fase。 这个例子说明了对象可以协同工作而不需要知道彼此的任何信息。为达到这种效果，对像仅需要相互连接，并用一个简单的QObject::connect()函数调用实现，或者使用uic的自动连接特性。 2.5 带有默认参数的信号和槽 信号和槽的签名可能包含参数，参数可以有默认值。考虑QObject::destroyed()函数。 void destroyed(QObject* = 0); 当一个QObject对象被删除，它发射QObject::destroyed()信号。我们想捕获此信号，无论在我们可能有一个悬空的引用指向删除的QObject对象的情况下，因此我们可以把它清理干净。一个合适的槽签名可能是这样的: void objectDestroyed(QObject* obj = 0); 为连接一个信号到此槽，我们使用QObject::connect。这里有几个方式连接。第一种方式是使用函数指针： connect(sender,&amp;QObject::destroyed,this,&amp;MyObject::objectDestroyed); 连接信号到槽的另一种方法是使用QObject::connect()，SIGNAL和SLOT宏。关于是否在SIGNAL()和SLOT()宏中包含参数的规则，如果参数有默认值，传递给SIGNAL()宏的签名必须不能少于传递给SLOT()宏签名的参数。 下述这些都会生效：12345678connect(sender,SIGNAL(destroyed(QObject*)),this,SLOT(objectDestroyed(Qbject*)));connect(sender,SIGNAL(destroyed(QObject*)),this,SLOT(objectDestroyed()));connect(sender, SIGNAL(destroyed()),this,SLOT(objectDestroyed())); 2.6 信号和槽的进一步使用 对于可能需要信号发送者信息的情况, Qt提供了QObject::sender()函数，它返回一个指向发送信号的对象的指针。 QSignalMapper类为一种情形提供，该情况下多个信号连接到同一个槽，而槽需要以不同的方式处理每个信号。 假设有三个按钮来决定将打开哪个文件: “Tax File”, “Accounts File”, “Report File”. 为了打开正确的文件,使用QSignalMapper:setMapping()来映射所有QPushButton:clicked()到QSignalMapper对象。然后将文件的QPushButton::clicked()信号连接到QSignalMapper::map()槽。 123456789101112131415161718signalMapper = new QSignalMapper(this); signalMapper-&gt;setMapping(taxFileButton, QString(&quot;taxfile.txt&quot;)); signalMapper-&gt;setMapping(accountFileButton, QString(&quot;accountsfile.txt&quot;)); signalMapper-&gt;setMapping(reportFileButton, QString(&quot;reportfile.txt&quot;)); connect(taxFileButton, &amp;QPushButton::clicked, signalMapper, &amp;QSignalMapper::map); connect(accountFileButton, &amp;QPushButton::clicked, signalMapper, &amp;QSignalMapper::map); connect(reportFileButton, &amp;QPushButton::clicked, signalMapper, &amp;QSignalMapper::map); 然后，将mapped()信号连接到readFile()，根据按下的按钮，readFile()打开不同的文件。connect(signalMapper, SIGNAL(mapped(QString)),this, SLOT(readFile(QString))); 2.7 自定义信号槽 发送者和接收者都需要是QObject的子类（当然，槽函数是全局函数、Lambda 表达式等无需接收者的时候除外）； 使用 signals 标记信号函数，信号是一个函数声明，返回 void，不需要实现函数代码； 槽函数是普通的成员函数，作为成员函数，会受到 public、private、protected 的影响； 使用 emit 在恰当的位置发送信号； 使用QObject::connect()函数连接信号和槽。 任何成员函数、static 函数、全局函数和 Lambda 表达式都可以作为槽函数 2.8 信号槽的更多用法 一个信号可以和多个槽相连 如果是这种情况，这些槽会一个接一个的被调用，但是它们的调用顺序是不确定的。 多个信号可以连接到一个槽 只要任意一个信号发出，这个槽就会被调用。 一个信号可以连接到另外的一个信号 当第一个信号发出时，第二个信号被发出。除此之外，这种信号-信号的形式和信号-槽的形式没有什么区别。 槽可以被取消链接 这种情况并不经常出现，因为当一个对象delete之后，Qt自动取消所有连接到这个对象上面的槽。 使用Lambda 表达式 在使用 Qt 5 的时候，能够支持 Qt 5 的编译器都是支持 Lambda 表达式的。 我们的代码可以写成下面这样： 12345QObject::connect(&amp;newspaper, static_cast&lt;void (Newspaper:: *)(const QString &amp;)&gt;(&amp;Newspaper::newPaper),[=](const QString &amp;name) &#123; /* Your code here. */ &#125;); 在连接信号和槽的时候，槽函数可以使用Lambda表达式的方式进行处理。 3 案例mainwidget.h 123456789101112131415161718192021222324252627282930#ifndef MAINWIDGET_H#define MAINWIDGET_H#include &lt;QWidget&gt;#include &lt;QPushButton&gt;#include &quot;subwidget.h&quot; //子窗口头文件class MainWidget : public QWidget&#123; Q_OBJECTpublic: MainWidget(QWidget *parent = 0); ~MainWidget();public slots: void mySlot(); void changeWin(); void dealSub(); void dealSlot(int, QString);private: QPushButton b1; QPushButton *b2; QPushButton b3; SubWidget subWin;&#125;;#endif // MAINWIDGET_H subwidget.h 1234567891011121314151617181920212223242526272829303132#ifndef SUBWIDGET_H#define SUBWIDGET_H#include &lt;QWidget&gt;#include &lt;QPushButton&gt;class SubWidget : public QWidget&#123; Q_OBJECTpublic: explicit SubWidget(QWidget *parent = 0); void sendSlot();signals: /* 信号必须有signals关键字来声明 * 信号没有返回值，但可以有参数 * 信号就是函数的声明，只需声明，无需定义 * 使用：emit mySignal(); * 信号可以重载 */ void mySignal(); void mySignal(int, QString);public slots:private: QPushButton b;&#125;;#endif // SUBWIDGET_H main.cpp 1234567891011#include &quot;mainwidget.h&quot;#include &lt;QApplication&gt;int main(int argc, char *argv[])&#123; QApplication a(argc, argv); MainWidget w;//执行MainWidget的构造函数 w.show(); return a.exec();&#125; mainvidget.cpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120#include &quot;mainwidget.h&quot;#include &lt;QPushButton&gt;#include &lt;QDebug&gt; //打印MainWidget::MainWidget(QWidget *parent) : QWidget(parent)&#123; b1.setParent(this); b1.setText(&quot;close&quot;); b1.move(100, 100); b2 = new QPushButton(this); b2-&gt;setText(&quot;abc&quot;); connect(&amp;b1, &amp;QPushButton::pressed, this, &amp;MainWidget::close); /* &amp;b1: 信号发出者，指针类型 * &amp;QPushButton::pressed：处理的信号， &amp;发送者的类名::信号名字 * this: 信号接收者 * &amp;MainWidget::close： 槽函数，信号处理函数 &amp;接收的类名::槽函数名字 * 发送-处理-接收-处理 */ /* 自定义槽，普通函数的用法 * Qt5：任意的成员函数，普通全局函数，静态函数 * 槽函数需要和信号一致（参数，返回值） * 由于信号都是没有返回值，所以，槽函数一定没有返回值 */ connect(b2, &amp;QPushButton::released, this, &amp;MainWidget::mySlot); connect(b2, &amp;QPushButton::released, &amp;b1, &amp;QPushButton::hide); /* 信号：短信 * 槽函数：接收短信的手机 */ setWindowTitle(&quot;老大&quot;); //this-&gt;setWindowTitle(&quot;老大&quot;);//等价同上 b3.setParent(this); b3.setText(&quot;切换到子窗口&quot;); b3.move(50, 50); //显示子窗口 //subWin.show(); connect(&amp;b3, &amp;QPushButton::released, this, &amp;MainWidget::changeWin); //处理子窗口的信号// void (SubWidget::*funSignal)() = &amp;SubWidget::mySignal;// connect(&amp;subWin, funSignal, this, &amp;MainWidget::dealSub);// void (SubWidget::*testSignal)(int, QString) = &amp;SubWidget::mySignal;// connect(&amp;subWin, testSignal, this, &amp;MainWidget::dealSlot); //Qt4信号连接 //Qt4槽函数必须有slots关键字来修饰 connect(&amp;subWin, SIGNAL(mySignal()), this, SLOT(dealSub()) ); connect(&amp;subWin, SIGNAL(mySignal(int,QString)), this, SLOT(dealSlot(int,QString)) ); //缺点： SIGNAL SLOT 将函数名字 -&gt; 字符串 不进行错误检查 //Lambda表达式, 匿名函数对象 //C++11增加的新特性， 项目文件： CONFIG += C++11 //Qt配合信号一起使用，非常方便 QPushButton *b4 = new QPushButton(this); b4-&gt;setText(&quot;Lambda表达式&quot;); b4-&gt;move(150, 150); int a = 10, b = 100; connect(b4, &amp;QPushButton::clicked, // = :把外部所有局部变量、类中所有成员以值传递方式 // this: 类中所有成员以值传递方式 // &amp; : 把外部所有局部变量， 引用符号 [=](bool isCheck) &#123; qDebug() &lt;&lt; isCheck; &#125; ); resize(400, 300);&#125;void MainWidget::dealSlot(int a, QString str)&#123; // str.toUtf8() -&gt; 字节数组QByteArray // ……data() -&gt; QByteArray -&gt; char * qDebug() &lt;&lt; a &lt;&lt; str.toUtf8().data();&#125;void MainWidget::mySlot()&#123; b2-&gt;setText(&quot;123&quot;);&#125;void MainWidget::changeWin()&#123; //子窗口显示 subWin.show(); //本窗口隐藏 this-&gt;hide();&#125;void MainWidget::dealSub()&#123; //子窗口隐藏 subWin.hide(); //本窗口显示 show();&#125;MainWidget::~MainWidget()&#123;&#125; subwidget.cpp 123456789101112131415161718#include &quot;subwidget.h&quot;SubWidget::SubWidget(QWidget *parent) : QWidget(parent)&#123; this-&gt;setWindowTitle(&quot;小弟&quot;); b.setParent(this); b.setText(&quot;切换到主窗口&quot;); connect(&amp;b, &amp;QPushButton::clicked, this, &amp;SubWidget::sendSlot); resize(400, 300);&#125;void SubWidget::sendSlot()&#123; emit mySignal(); emit mySignal(250, &quot;我是子窗口&quot;);&#125; SingnalAndSlot.pro 12345678910111213141516QT += core guigreaterThan(QT_MAJOR_VERSION, 4): QT += widgetsTARGET = 03_SignalAndSlotTEMPLATE = appSOURCES += main.cpp\\ mainwidget.cpp \\ subwidget.cppHEADERS += mainwidget.h \\ subwidget.hCONFIG += C++11 4 总结 结构图 5 参考博文 C++_之Qt的信号和槽的详解 https://www.cnblogs.com/wanghui1234/p/8964968.html Qt信号和槽机制 https://blog.csdn.net/lsfreeing/article/details/78575246","tags":[{"name":"C++","slug":"C","permalink":"http://11wy11.github.io/tags/C/"},{"name":"QT","slug":"QT","permalink":"http://11wy11.github.io/tags/QT/"}]},{"title":"krpano快速入门教程（二）","date":"2019-03-15T15:19:51.000Z","path":"2019/03/15/krpano-second-note/","text":"vtour全景漫游及vtour文件夹介绍使用MAKE VTOUR (MULTIRES) droplet工具生成全景漫游 背景在初始学习krpano时，可以借助krpano的工具生成全景漫游文件，之后可以根据需要修改tour.xml,定制skin等；上节简单介绍了krpano使用Make pano的工具创建单场景应用，但大多数应用中场景数量不只一个，彼此之间可以跳转，这就需要借助MAKE VTOUR droplet工具了。而具体选择三种中的哪一种，根据应用场景需要选择，multires支持将全景切片分级，能够达到更好的展示效果，但会使全景文件大小增加，normal生成普通的pano_f.jpg,pano_b.jpg,pano_l.jpg，pano_r.jpg，pano_u.jpg，pano_d.jpg,preview.jpg，分别为全景图的前后左右上下，以及菜单中的预览图。 生成vtour使用MAKE VTOUR (MULTIRES) droplet工具生成的全景漫游场景，场景彼此之间相互连接，能够从一个场景跳转到另一个场景。可以同时选择多张全景图片拖放在该工具上，输入全景图类型，和全景角度，执行切片，等待完成。显示done之后，在全景图文件夹中生成vtour文件夹。 vtour文件夹内容介绍1. tour.html文件--嵌入全景的网页 2. tour.swf文件--krpano的flash viewer 3. tour.js文件--基于swfkrpano.js的一个viewer，即HTML5的viewer及嵌入HTML的js文件的合体 4. tour.xml文件--是krpano xml配置文件，定义全景图配置及皮肤配置 5. panos文件夹--存放处理后的全景图切片 6. plugins文件夹--主要存放使用到的插件 场景Scene它们可用于在当前xml文件中再次定义完整krpano xml文件的内容。它就像一个外部的xml，但只是内联/嵌入到当前的xml中。 在调用具有场景名称的loadscene（） 典型的用法是在一个xml文件中定义几个panos。 使用loadpano（）动作加载新的外部xml文件时，将删除所有当前定义的场景元素。 可以在&lt;scene>元素中存储任何自定义属性 - 查看器本身将忽略它们，但它们可用于自定义操作。1234567891011&lt;scene name=&quot;scene_20171106193359&quot; title=&quot;20171106193359&quot; onstart=&quot;&quot; thumburl=&quot;panos/20171106193359.tiles/thumb.jpg&quot; lat=&quot;51.51500000&quot; lng=&quot;-0.08050000&quot; heading=&quot;0.0&quot;&gt; &lt;view hlookat=&quot;0.0&quot; vlookat=&quot;0.0&quot; fovtype=&quot;MFOV&quot; fov=&quot;120&quot; maxpixelzoom=&quot;2.0&quot; fovmin=&quot;70&quot; fovmax=&quot;140&quot; limitview=&quot;range&quot; vlookatmin=&quot;-56.055&quot; vlookatmax=&quot;56.055&quot; /&gt; &lt;preview url=&quot;panos/20171106193359.tiles/preview.jpg&quot; /&gt; &lt;image prealign=&quot;0|0.0|0&quot;&gt; &lt;cube url=&quot;panos/20171106193359.tiles/pano_%s.jpg&quot; /&gt; &lt;/image&gt; &lt;/scene&gt; 说明： name场景名称，命名规则：每个名字都需要以字母字符开头！这意味着不允许使用数字作为名字！当名称仍然以数字字符开头时，名称将被解释为数组索引。这对于动作内部基于动态索引的访问没有问题，但不能用于定义元素！所有名称将自动转换为小写字母，以便直接区分大小写访问！也是loadscene时设置的参数 title主要显示在缩略图上或者菜单栏名称 onstart此处可以定义将在“开始时”调用全景/场景观看的任何动作/功能。场景启动时调用，可以执行定义好的action thumburl默认视角的展示图路径，使用相对路径，以xml所在位置开始计算相对路径 lat&amp;lon场景所在经纬度，可以用于小地图插件，定位场景 heading仰角度数 视图viewview元素包含有关当前视图的信息。在xml中，它可用于设置启动视图设置。 查找方向将由hlookat / vlookat属性（=水平/垂直lookat）和fov属性中的当前视野定义。要查看部分全景图的限制，可以使用limitview属性。 hlookat&amp;vlookat设置初始视角，分别为水平方向和垂直方向 hlookat:球面坐标的水平方向，以度为单位。典型范围为-180°至+ 180°。该值不会环绕360°，但视图本身会。值0.0指向全景图像的中心。 vlookat:球面坐标的垂直方向，以度为单位。典型范围为-90°至+90°。但视图本身会。值0.0指向全景图像的中心。 fov以度为单位的当前视野 - 从近似0.0到179.0。,默认为90 fovmin&amp;fovmax主要设置视角放大和缩小的最大和最小视角 maxpixelzoom全景图像的最大像素缩放系数。这将根据全景分辨率和当前观察窗口自动限制fov，例如1.0 =限制为100％缩放，不会看到源图像的像素缩放。 预览previewurl:设置预览图路径 全景图image使用&lt;image&gt;元素将定义全景图像。 在此处设置图像/图块的类型，大小和URL路径。 type定义全景图像的类型。 可能的值： CUBE方全景图像 - 六个图像，每个立方体一个图像。 CUBESTRIP在一张图像中作为“图像条”的立方体全景图像。支持的多维数据集格式为6x1,1x6,3x2或2x3。立方体侧对齐本身始终需要：L，F，R，B，U，D（默认为krpano）。 SPHERE球形/ equirectangular全景图像。通过设置自定义hfov， vfov和 voffset设置可以实现部分panos。 CYLINDER一个圆柱形全景图像。通过设置自定义hfov， vfov和 voffset设置可以实现部分panos。 …未设置时：如果未设置类型，则查看器会尝试通过&lt;image>标记内的标记自动检测类型（仅适用于非多图像）。 hfov以度为单位定义全景图像的水平视野（hfov）。这是在全景图像上捕获的可见范围。默认值为360，表示全方位视图。使用较小的值进行部分全景。对于平坦全景（或普通图像），应使用值“1.0”。 multies启用平铺的多分辨率图像。设置为true时，&lt;image>元素需要包含多个&lt;level>元素，其中包含每个多分辨率级别的图像定义。多分辨切片时定义使用 tilesize当全景图为切片时，设置每一级切片大小 level[..].tiledimagewidth level[..].tiledimageheight某一级切片大小 stereo&amp;stereolabels&amp;stereoformat 允许使用立体图像（仅限HTML5和WebGL）。 使用立方体图像时，图像URL应包含％t占位符。此占位符将替换为stereolabels设置中的值。对于左图像，将使用第一个值，对于右图像，将使用第二个值。 对于球形或圆柱形图像或视频，可以使用“帧封装”立体图像。该stereoformat设置定义的打包顺序： stereoformat =“TB” - 上/下 stereoformat =“SBS” - Side-By-Side 示例 - 立体立方体图像： 1234567&lt;image stereo =“true”stereolabels =“1 | 2” &gt; &lt;cube url =“pano_％s_ ％t .jpg”/&gt; &lt;/ image&gt;示例 - 立体全景视频：&lt;image stereo =“true”stereoformat =“TB” &gt; &lt;sphere url =“ plugin：video ”/&gt; &lt;/ image&gt; 注意 - 根据全景图像或视频的像素大小（和侧面），可能需要手动设置hfov，vfov和voffset设置。 fisheye.fov fisheye.align fisheye.crop fisheye.lenscp 鱼眼图像支持（仅限HTML5和WebGL）。 通过鱼眼设置，可以在krpano中使用鱼眼照片和视频。 为了正确地拉直和对齐鱼眼图像，有必要了解一些有关它的参数。获取这些参数的一个好工具是PTGUI。 鱼眼设置： fov = “180.0” 鱼眼图像的视野（以度为单位）。 与crop大小有关。 来源：可以直接从PTGUI fov图像参数中获取。 align = “yaw|pitch|roll” 图像的对齐/旋转/调平（以度为单位）。 来源：可以直接从PTGUI图像参数中获取。（例如，使用垂直线控制点来对齐/调整图像） crop=“left|right|top|bottom” 鱼眼fov裁剪圆的边缘（以像素为单位）。 圆与fov大小有关。 来源：可以直接从PTGUI裁剪设置中获取。 lenscp = “a| b | c | d | e” 的 镜头校正参数。 来源：可以直接从PTGUI镜头设置中获取。 image中URL占位符等根据图像类型和相关设置，图像的URL应包含多个占位符，以允许寻址正确的图像文件。 这些网址占位符可用： 对于立方体的各个面：％s⇒cubelabels的占位符 对于水平图块索引：％h，％x，％u或％c （都相同） 对于垂直图块索引： ％v，％y或％r （都相同） 对于立体图像：％t⇒stereolabels的占位符为当前图像帧：％f ⇒ image.frame （仅限Flash） 每个占位符可以在url中多次使用 - 例如，作为文件名的一部分，也作为foldername的一部分。 平铺索引填充：通过在％字符和tile-index占位符的字符之间插入一个或多个0个字符，可以为数字定义自定义填充。比如:％H ⇒ 1,2,3，…，9,10,11％0H ⇒ 01,02,03，…，09,10,11％00H ⇒ 001,002,003，……，009010011 预览效果 效果图 补充之后的主要工作为：定制skin，定制plugins，定制xml，一些动态操作全景图配置使编辑js文件，能够实现动态配置全景图程序，能够更好的融入到Web应用程序中，作为其中一个子功能模块。后续结合实际案例介绍具体实现方式。历史文章 历史文章krpano快速入门教程（一) 使用krpano工具构建即用型panos","tags":[{"name":"krpano","slug":"krpano","permalink":"http://11wy11.github.io/tags/krpano/"}]},{"title":"krpano快速入门教程（一）","date":"2019-03-14T07:54:54.000Z","path":"2019/03/14/krpano-first-note/","text":"使用krpano工具构建即用型panos简单使用krpano工具快速生成可执行的pano文件，后续介绍如何自定义编写配置文件切图等 krpano简介Krpano是一款全景漫游制作软件和工具。用krpano所生成的全景，在兼容性、功能性、互动性方面的表现都很不错，而且可以二次开发并拥有自己的编程语言，比如使用专用的krpano xml代码编写全景漫游，可开发出高度定制化的项目。因此，目前主流的全景网站均是在krpano全景的基础上进行开发，并不断进行更新迭代，形成自己独有的全景内容服务。 具体步骤 从krpano下载页面下载适合于自己系统的krpano Tools软件包 将下载的krpano Tools zip文件解压到一个不含中文路径的文件夹下（为了所有稳定使用，推荐） 如果您已拥有krpano许可文件 - 则立即将其复制或移动到krpano Tools文件夹中。如果您没有任何一个，那么只需跳过此步骤即可。之后可以通过注册码注册，具体破解方法请自行百度，注册后能够去掉切片中的krpano水印。 要构建单个全景图 - 打开包含全景图像的文件夹，选择其中一个或全部，拖放到MAKE PANO droplet批处理工具上。等待切片完成，会在全景图像所在文件夹中生成一个以全景图命名的文件夹，里面自动生成一个即用型pano,点击tour_testingsever运行测试服务器，打开index.html查看效果。需要说明的是，这里如果没有注册，运行之后全景图是有krpano水印的。可以运行krpano tools选择 register now 输入序列号完成注册。注册完在按照第4步操作，得到没有水印的全景图注册前 注册后 要构建虚拟游览 - 打开包含全景虚拟游览图像的文件夹，选择所有这些图像拖放到MAKE VTOURdroplet批处理工具上。 其他工具使用类似，主要功能简介如下： MAKE PANO (NORMAL) droplet针对标准全景图（360度），最大值。cubeize默认限制为2200像素（可以在’templates / normal.config’文件中更改），没有皮肤 - 只需pano，HTML5 iPhone / iPad就绪 MAKE PANO（MULTIRES）droplet用于渐进多分辨率的panos，没有尺寸/分辨率限制，快速动态加载，带按钮的默认皮肤，HTML5 iPhone / iPad就绪 MAKE PANO（FLAT）droplet用于平面/ 2D平移/图像，平铺多分辨率，无尺寸/分辨率限制，平坦全景/图像的皮肤/控制，仅限闪光 MAKE PANO（SINGLESWF）droplet只生成一个Flash swf文件，对于标准全景图，完整的pano将立即加载，最大值。cubesize限制为2200像素（可在’templates / singleswf.config’文件中更改），默认皮肤带按钮，仅限Flash MAKE OBJECT droplet用于平铺多分辨率对象影片，一次删除所有对象图像，没有大小/分辨率限制，快速和动态加载，具有按钮和对象旋转控件的对象外观，仅限Flash MAKE VTOUR (NORMAL) droplet / MAKE VTOUR (MULTIRES) droplet 用于自动构建虚拟游览，将所有全景图像放在此工具上，通过自动缩略图生成，准备好HTML5 iPhone / iPad 处理完成后关闭dos / terminal窗口。在源图像的文件夹中会有新文件：典型的.html文件 - 这是嵌入pano的示例网页，.swf文件 - 这是krpano Flash查看器，.js文件 - 这是Javascript Flash到HTML嵌入代码（基于swfkrpano.js）和可选的krpano HTML5 / Javascript iPhone / iPad查看器，一个.xml文件 - 这是krpano xml文件，有pano和皮肤定义，最后有.tiles文件夹 - 有处理过的全景图像。全景图像本身不是观看全景图像所必需的。 6.2。当您使用MAKE VTOUR Droplet时，这些文件将位于’vtour’文件夹中，而pano图像位于其中的’panos’文件夹中。 编辑全景设置打开并在任何文本编辑器中编辑生成的xml文件（带有xml-syntax-highlighting的文本编辑器可能会有帮助）： 在在线文档中查找krpano xml定义：","tags":[{"name":"krpano","slug":"krpano","permalink":"http://11wy11.github.io/tags/krpano/"}]},{"title":"AI组件开发（一）--注记旋转矩阵","date":"2019-03-14T02:56:02.000Z","path":"2019/03/14/ai-first-note/","text":"SDK官方帮助文档AIAPI void( AIRealMathSuite::AIRealMatrixSet)(AIRealMatrix m, AIReal a, AIReal b, AIReal c, AIReal d, AIReal tx, AIReal ty)Sets the scale, rotation, and translation values of a transformation matrix.Parameters:m The matrix object.a New a value.b New b value.c New c value.d New d value.tx New horizontal translation value.ty New vertical translation value. 参数及原理分析ad缩放bc旋转tx,ty位移，基础的2D矩阵 公式 x=ax+cy+tx y=bx+dy+ty 为了把二维图形的变化统一在一个坐标系里，引入了齐次坐标的概念，即把一个图形用一个三维矩阵表示，其中第三列总是(0,0,1)，用来作为坐标系的标准。所以所有的变化都由前两列完成以上参数在矩阵中的表示为： |a b 0| |c d 0| |tx ty 1| 运算原理：原坐标设为（X,Y,1）; |a b 0| [X，Y, 1] |c d 0| = [aX + cY + tx bX + dY + ty 1] ; |tx ty 1| 通过矩阵运算后的坐标[aX + cY + tx bX + dY + ty 1]，我们对比一下可知： 第一种：设a=d=1, b=c=0. [aX + cY + tx bX + dY + ty 1] = [X + tx Y + ty 1]; 可见，这个时候，坐标是按照向量（tx，ty）进行平移，其实这也就是函数 第二种：设b=c=tx=ty=0. [aX + cY + tx bX + dY + ty 1] = [aX dY 1]; 可见，这个时候，坐标X按照a进行缩放，Y按照d进行缩放，a，d就是X，Y的比例系数，其实这也就是函数 第三种：设tx=ty=0，a=cosɵ，b=sinɵ，c=-sinɵ，d=cosɵ。 [aX + cY + tx bX + dY + ty 1] = [Xcosɵ - Ysinɵ Xsinɵ + Ycosɵ 1] ; 可见，这个时候，ɵ就是旋转的角度，逆时针为正，顺时针为负。其实这也就是函数","tags":[{"name":"AI","slug":"AI","permalink":"http://11wy11.github.io/tags/AI/"}]},{"title":"csdn-markdown编辑器语法","date":"2019-03-13T16:03:21.000Z","path":"2019/03/14/csdn-markdown-grammar/","text":"@TOC 欢迎使用Markdown编辑器你好！ 这是你第一次使用 Markdown编辑器 所展示的欢迎页。如果你想学习如何使用Markdown编辑器, 可以仔细阅读这篇文章，了解一下Markdown的基本语法知识。 功能快捷键撤销：Ctrl/Command + Z重做：Ctrl/Command + Y加粗：Ctrl/Command + B斜体：Ctrl/Command + I标题：Ctrl/Command + Shift + H无序列表：Ctrl/Command + Shift + U有序列表：Ctrl/Command + Shift + O检查列表：Ctrl/Command + Shift + C插入代码：Ctrl/Command + Shift + K插入链接：Ctrl/Command + Shift + L插入图片：Ctrl/Command + Shift + G 合理的创建标题，有助于目录的生成直接输入1次#，并按下space后，将生成1级标题。输入2次#，并按下space后，将生成2级标题。以此类推，我们支持6级标题。有助于使用TOC语法后生成一个完美的目录。 如何改变文本的样式强调文本 强调文本 加粗文本 加粗文本 ==标记文本== 删除文本 引用文本 H~2~O is是液体。 2^10^ 运算结果是 1024. 插入链接与图片链接: link. 图片: Alt 带尺寸的图片: =30x30 居中的图片: Alt 居中并且带尺寸的图片: =30x30 当然，我们为了让用户更加便捷，我们增加了图片拖拽功能。 如何插入一段漂亮的代码片去博客设置页面，选择一款你喜欢的代码片高亮样式，下面展示同样高亮的 代码片.12// An highlighted blockvar foo = 'bar'; 生成一个适合你的列表 项目 项目 项目 项目1 项目2 项目3 计划任务 完成任务 创建一个表格一个简单的表格是这么创建的：项目 | Value——– | —–电脑 | $1600手机 | $12导管 | $1 设定内容居中、居左、居右使用:---------:居中使用:----------居左使用----------:居右| 第一列 | 第二列 | 第三列 ||:———–:| ————-:|:————-|| 第一列文本居中 | 第二列文本居右 | 第三列文本居左 | SmartyPantsSmartyPants将ASCII标点字符转换为“智能”印刷标点HTML实体。例如：| TYPE |ASCII |HTML|—————-|——————————-|—————————–||Single backticks|&#39;Isn&#39;t this fun?&#39; |’Isn’t this fun?’ ||Quotes |&quot;Isn&#39;t this fun?&quot; |”Isn’t this fun?” ||Dashes |-- is en-dash, --- is em-dash|– is en-dash, — is em-dash| 创建一个自定义列表Markdown: Text-to-HTML conversion tool Authors: John: Luke 如何创建一个注脚一个具有注脚的文本。^2 注释也是必不可少的Markdown将文本转换为 HTML。 *[HTML]: 超文本标记语言 KaTeX数学公式您可以使用渲染LaTeX数学表达式 KaTeX: Gamma公式展示 $\\Gamma(n) = (n-1)!\\quad\\foralln\\in\\mathbb N$ 是通过欧拉积分 $$\\Gamma(z) = \\int_0^\\infty t^{z-1}e^{-t}dt\\,.$$ 你可以找到更多关于的信息 LaTeX 数学表达式here. 新的甘特图功能，丰富你的文章12345678gantt dateFormat YYYY-MM-DD title Adding GANTT diagram functionality to mermaid section 现有任务 已完成 :done, des1, 2014-01-06,2014-01-08 进行中 :active, des2, 2014-01-09, 3d 计划一 : des3, after des2, 5d 计划二 : des4, after des3, 5d 关于 甘特图 语法，参考 这儿, UML 图表可以使用UML图表进行渲染。 Mermaid. 例如下面产生的一个序列图：: 123456789sequenceDiagram张三 -&gt;&gt; 李四: 你好！李四, 最近怎么样?李四--&gt;&gt;王五: 你最近怎么样，王五？李四--x 张三: 我很好，谢谢!李四-x 王五: 我很好，谢谢!Note right of 王五: 李四想了很长时间, 文字太长了&lt;br/&gt;不适合放在一行.李四--&gt;&gt;张三: 打量着王五...张三-&gt;&gt;王五: 很好... 王五, 你怎么样? 这将产生一个流程图。: 12345graph LRA[长方形] -- 链接 --&gt; B((圆))A --&gt; C(圆角长方形)B --&gt; D&#123;菱形&#125;C --&gt; D 关于 Mermaid 语法，参考 这儿, FLowchart流程图我们依旧会支持flowchart的流程图：123456789flowchatst=&gt;start: 开始e=&gt;end: 结束op=&gt;operation: 我的操作cond=&gt;condition: 确认？st-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op 关于 Flowchart流程图 语法，参考 这儿. 导出与导入导出如果你想尝试使用此编辑器, 你可以在此篇文章任意编辑。当你完成了一篇文章的写作, 在上方工具栏找到 文章导出 ，生成一个.md文件或者.html文件进行本地保存。 导入如果你想加载一篇你写过的.md文件或者.html文件，在上方工具栏可以选择导入功能进行对应扩展名的文件导入，继续你的创作。","tags":[{"name":"markdown","slug":"markdown","permalink":"http://11wy11.github.io/tags/markdown/"}]},{"title":"git常用命令","date":"2019-03-13T12:41:15.000Z","path":"2019/03/13/git-command/","text":"强制本地覆盖远程分支 1234567 git push origin *** --force ``` 2. 放弃本地分支，远程分支强制覆盖本地 git fetch --all //只是下载代码到本地，不进行合并操作git reset --hard origin/分支名如master //把HEAD指向最新下载的版本3. 删除远程分支和本地分支 git branch -a//查看分支git push origin –delete // 删除远程分支git branch -d //删除本地分支 1234. git diff 检查文件更改内容5. 撤销未提交的修改git checkout git checkout app/src/main/../MainActivity 16、git reset git log #找到需要退回的commit版本号，可以只复制前几位git reset &lt;刚查找到的版本号&gt;`7、git log","tags":[{"name":"git","slug":"git","permalink":"http://11wy11.github.io/tags/git/"}]},{"title":"使用hexo+github创建个人博客并备份源码","date":"2019-03-09T13:52:06.000Z","path":"2019/03/09/create-blog-process/","text":"一、准备 安装node.js 安装git-windows 安装hexo-cli 1$npm install hexo-cli -g 在GitHub上创建&lt;username&gt;.github.io的仓库 e.g. 11wy11.github.io 配置SSH key打开本机的控制台，以windows系统为例，可以执行win+R 输入cmd打开，执行 1ssh -keygen -t rsa -C &apos;D:/id.txt&apos; 然后连续按3次回车，最终会在用户目录下生成一个文件，找到目录.ssh/id_rsa.pub文件，用记事本打开全选复制。在你的github上点击头像&gt;设置进入设置页面，选择SSH and GPG keys, 点击New SSH key按钮，名称随意填写，将刚复制的内容粘贴到key,添加 二、搭建流程 本地创建&lt;username&gt;.github.io 在本地&lt;username&gt;.github.io文件夹下初始化hexo项目并安装依赖 123hexo init //初始化工程npm install //安装依赖hexo server //启动本地调试器在localhost:4000预览 修改默认主题，可以在github上clone其他的主题，如yilia,icarus,indigo等 以indigo为例，在本地&lt;username&gt;.github.io文件夹下执行以下命令安装主题 1git clone git@github.com:yscoder/hexo-theme-indigo.git themes/indigo 修改工程中的_config.yml配置文件，将themes: landscope改为themes: indigo 依赖安装分别安装Less,Feed,Json-content依赖，执行如下命令 123$ npm install hexo-renderer-less --save$ npm install hexo-generator-feed --save$ npm install hexo-generator-json-content --save 执行hexo s命令启动服务器在localhost:4000查看效果 新建文章，使用hexo new “my-first blog”，会在source/_posts下创建my-first-blog.md的页面文件进行编写 发布博客首先修改工程中的_config.yml配置文件，在最后三行添加以下代码，将username换成自己的git用户名 1234deploy: type: git repo: git@github.com:&lt;username&gt;/&lt;username&gt;.github.io.git branch: master 其次安装hexo-deployer-git 执行 npm install hexo-deployer-git --save 在工程文件夹内右键git bash进入命令行 输入hexo g，编译为静态文件，生成public文件夹，使用 hexo d 部署，此时可以访问https://&lt;username&gt;.github.io查看你的博客 备份源码 在工程文件夹内右键git bash进入命令行 输入 touch .gitignore ，生成“.gitignore”文件。 在”.gitignore” 文件里输入你要忽略的文件夹及其文件就可以了。（注意格式） 我的 .gitignore：node_modules/ .deploy_git public/ .DS_Store Thumbs.db db.json *.log .deploy*/ 执行以下命令#git初始化 git init #创建hexo分支，用来存放源码 git checkout -b hexo #git 文件添加 git add . #git 提交 git commit -m &quot;init&quot; #添加远程仓库 git remote add origin git@github.com:&lt;username&gt;/&lt;username&gt;.github.io.git #push到hexo分支 git push origin hexo 执行hexo g -d生成网站并部署到GitHub上 这样一来，在GitHub上的git@github.com:&lt;username&gt;/&lt;username&gt;.github.io.git仓库就有两个分支，一个hexo分支用来存放网站的原始文件，一个master分支用来存放生成的静态网页。 其他设备更新博客步骤： 1、先安装hexo $ npm install -g hexo-cli 2、存在github上的git clone下来 git clone -b hexo git@github.com:&lt;username&gt;/&lt;username&gt;.github.io.git 3、项目文件夹下 $ npm install $ npm install hexo-deployer-git 4、重新配置github和coding的公钥 5、编写博客push 到远程分支 补充 有时会出现下载的主题无法上传，首先删除themes/主题文件夹下的.git,使用git rm --cached themes/indigo命令清空后重新上传` 如果最开始.gitignore文件没有配置正确，可以使用git rm -r --cached .命令清楚缓存文件，重新add,commit,push上传","tags":[{"name":"hexo","slug":"hexo","permalink":"http://11wy11.github.io/tags/hexo/"},{"name":"git","slug":"git","permalink":"http://11wy11.github.io/tags/git/"}]},{"title":"Vue全局添加组件","date":"2019-03-09T02:39:22.000Z","path":"2019/03/09/Vue-global-component/","text":"一. 背景在项目中有时需要反复用到如区域选择器等组件，每次使用时都需要在对应的vue中添加import,并在component中注册，为了避免多次书写引用代码，可以自定义全局组件，只需要在main.js中一次性注册在vue项目中，可以自定义组件像vue-resource一样使用Vue.use（）方法来使用。 二. 具体实现方法1、首先建一个自定义组件的文件夹，比如叫loading，在该文件夹下新建一个index.js，一个自定义组件loading.vue,在这个loading.vue里面就是这个组件的具体的内容， 2、在index.js中，规定使用这个组件的名字，以及使用方法，如： import loadingComponent from &apos;./loading.vue&apos; const loading={ install:function(Vue){ Vue.component(&apos;Loading&apos;,loadingComponent) } //&apos;Loading&apos;这就是后面可以使用的组件的名字，install是默认的一个方法 }; export default loading; 3、只要在main.js中规定了install方法，就可以像一些公共的插件一样使用Vue.use()来使用： import loading from &apos;./loading&apos; Vue.use(loading）","tags":[{"name":"Vue","slug":"Vue","permalink":"http://11wy11.github.io/tags/Vue/"}]},{"title":"Oracle配置SDE支持空间查询","date":"2019-03-09T01:56:40.000Z","path":"2019/03/09/oracle-st-geometry/","text":"配置oracle外部链接库 将ArcGIS Desktop安装目录下DatabaseSupport文件夹下的st_shapelib.dll拷贝到装有oracle的服务器上，可以放置在任意地方，这里推荐放在Oracle安装目录下的bin文件夹下。 例如：st_shapelib.dll所在文件夹路径： C:\\ProgramFiles(x86)\\ArcGIS\\Desktop10.2\\DatabaseSupport\\Oracle\\Windows64\\st_shapelib.dll 拷贝放置位置：E:\\app\\503\\product\\11.2.0\\dbhome_1\\BIN\\ st_shapelib.dll 修改oracle安装目录下的network/admin文件夹下的listener.ora,将步骤1中的st_shapelib.dll路径添加到ENVS”EXTPROC_DLLS=ONLY:E:\\app\\503\\product\\11.2.0\\dbhome_1\\bin\\oraclr11.dll;后面 例如：linstener文件，添加红色字部分 1234567891011121314151617181920212223# listener.ora Network Configuration File: D:\\app\\Administrator\\product\\11.2.0\\dbhome_1\\NETWORK\\ADMIN\\listener.ora# Generated by Oracle configuration tools.SID_LIST_LISTENER = (SID_LIST = (SID_DESC = (SID_NAME = CLRExtProc) (ORACLE_HOME = E:\\app\\503\\product\\11.2.0\\dbhome_1) (PROGRAM = extproc) (ENVS= &quot;EXTPROC_DLLS=ONLY:E:\\app\\503\\product\\11.2.0\\dbhome_1\\bin\\oraclr11.dll;E:\\app\\503\\product\\11.2.0\\dbhome_1\\bin\\st_shapelib.dll&quot;) # interesting ) ) LISTENER = (DESCRIPTION_LIST = (DESCRIPTION = (ADDRESS = (PROTOCOL = TCP)(HOST = 503-PC)(PORT = 1521)) (ADDRESS = (PROTOCOL = IPC)(KEY = EXTPROC1521)) ) (DESCRIPTION = (ADDRESS = (PROTOCOL = TCP)(HOST = 192.168.1.164)(PORT = 1521)) ) ) ADR_BASE_LISTENER = E:\\app\\503 修改oracle安装home目录下的hs/admin文件夹下的extproc.ora，具体路径示例：E:\\app\\503\\product\\11.2.0\\dbhome_1\\hs\\admin\\extproc.ora，将最后一行的SET EXTPROC_DLLS= 设为ANY 通过任何一个数据库管理软件，这里以sql-plus为例，使用sde用户登录首先执行：select * from user_libraries 查看是否有ST_SHAPELIB并检查路径是否与步骤1中的一致，通常默认为c盘第一次安装Arcgis时的相关路径。结果如下： 如果路径与步骤1中st_shapelib的路径不一致，执行以下两条命令： Create or replace library st_SHAPELIB as &lt;步骤1中的st_shapelib路径&gt; Alter package sde.st_geometry_shapelib_pkg compile reuse settings 重启监听器OracleOraDB11g_home1TNSListener，有时也需要重启服务OracleServiceORCL。","tags":[{"name":"ArcGIS","slug":"ArcGIS","permalink":"http://11wy11.github.io/tags/ArcGIS/"},{"name":"Oracle","slug":"Oracle","permalink":"http://11wy11.github.io/tags/Oracle/"}]}]