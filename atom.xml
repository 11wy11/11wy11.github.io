<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>WeiYuan&#39;s Blog</title>
  
  <subtitle>学习随记</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://11wy11.github.io/"/>
  <updated>2019-03-29T13:42:11.444Z</updated>
  <id>http://11wy11.github.io/</id>
  
  <author>
    <name>11wy11</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>C# Regex正则表达式</title>
    <link href="http://11wy11.github.io/2019/03/29/cplusplus-regex-note/"/>
    <id>http://11wy11.github.io/2019/03/29/cplusplus-regex-note/</id>
    <published>2019-03-29T12:30:30.000Z</published>
    <updated>2019-03-29T13:42:11.444Z</updated>
    
    <content type="html"><![CDATA[<p>正则表达式的本质是使用一系列特殊字符模式，来表示某一类字符串。<br><a id="more"></a></p><h1 id="Regex-正则表达式"><a href="#Regex-正则表达式" class="headerlink" title="Regex 正则表达式"></a>Regex 正则表达式</h1><p>正则表达式的本质是使用一系列特殊字符模式，来表示某一类字符串。正则表达式无疑是处理文本最有力的工具，而.NET提供的Regex类实现了验证正则表达式的方法。Regex 类表示不可变（只读）的正则表达式。它还包含各种静态方法，允许在不显式创建其他类的实例的情况下使用其他正则表达式类。</p><h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="cplusplus-regex-note/pic1.png" alt="基础1" title>                </div>                <div class="image-caption">基础1</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="cplusplus-regex-note/pic2.png" alt="基础2" title>                </div>                <div class="image-caption">基础2</div>            </figure><h1 id="数字常用表达式"><a href="#数字常用表达式" class="headerlink" title="数字常用表达式"></a>数字常用表达式</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">//数字</span><br><span class="line">    Regex reg = new Regex(@&quot;^[0-9]*$&quot;);</span><br><span class="line">    //n位的数字</span><br><span class="line">    Regex reg = new Regex(@&quot;^\d&#123;n&#125;$&quot;);</span><br><span class="line">    //至少n位的数字</span><br><span class="line">    Regex reg = new Regex(@&quot;^\d&#123;n,&#125;$&quot;);</span><br><span class="line">    //m-n位的数字</span><br><span class="line">    Regex reg = new Regex(@&quot;^\d&#123;m,n&#125;$&quot;);</span><br><span class="line">    //零和非零开头的数字</span><br><span class="line">    Regex reg = new Regex(@&quot;^(0|[1-9][0-9]*)$&quot;);</span><br><span class="line">    //非零开头的最多带两位小数的数字</span><br><span class="line">    Regex reg = new Regex(@&quot;^([1-9][0-9]*)+(.[0-9]&#123;1,2&#125;)?$&quot;);</span><br><span class="line">    //带1-2位小数的正数或负数</span><br><span class="line">    Regex reg = new Regex(@&quot;^(\-)?\d+(\.\d&#123;1,2&#125;)?$&quot;);</span><br><span class="line">    //正数、负数、和小数</span><br><span class="line">    Regex reg = new Regex(@&quot;^(\-|\+)?\d+(\.\d+)?$&quot;);</span><br><span class="line">    //有两位小数的正实数</span><br><span class="line">    Regex reg = new Regex(@&quot;^[0-9]+(.[0-9]&#123;2&#125;)?$&quot;);</span><br><span class="line">    //有1~3位小数的正实数</span><br><span class="line">    Regex reg = new Regex(@&quot;^[0-9]+(.[0-9]&#123;1,3&#125;)?$&quot;);</span><br><span class="line">    //非零的正整数</span><br><span class="line">    Regex reg = new Regex(@&quot;^[1-9]\d*$ 或 ^([1-9][0-9]*)&#123;1,3&#125;$ 或 ^\+?[1-9][0-9]*$&quot;);</span><br><span class="line">    //非零的负整数</span><br><span class="line">    Regex reg = new Regex(@&quot;^\-[1-9][]0-9″*$ 或 ^-[1-9]\d*$&quot;);</span><br><span class="line">    //非负整数</span><br><span class="line">    Regex reg = new Regex(@&quot;^\d+$ 或 ^[1-9]\d*|0$&quot;);</span><br><span class="line">    //非正整数</span><br><span class="line">    Regex reg = new Regex(@&quot;^-[1-9]\d*|0$ 或 ^((-\d+)|(0+))$&quot;);</span><br><span class="line">    //非负浮点数</span><br><span class="line">    Regex reg = new Regex(@&quot;^\d+(\.\d+)?$ 或 ^[1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0$&quot;);</span><br><span class="line">    //非正浮点数</span><br><span class="line">    Regex reg = new Regex(@&quot;^((-\d+(\.\d+)?)|(0+(\.0+)?))$ 或 ^(-([1-9]\d*\.\d*|0\.\d*[1-9]\d*))|0?\.0+|0$&quot;);</span><br><span class="line">    //正浮点数</span><br><span class="line">    Regex reg = new Regex(@&quot;^[1-9]\d*\.\d*|0\.\d*[1-9]\d*$ 或 ^(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*))$&quot;);</span><br><span class="line">    //负浮点数</span><br><span class="line">    Regex reg = new Regex(@&quot;^-([1-9]\d*\.\d*|0\.\d*[1-9]\d*)$ 或 ^(-(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*)))$&quot;);</span><br><span class="line">    //浮点数</span><br><span class="line">    Regex reg = new Regex(@&quot;^(-?\d+)(\.\d+)?$ 或 ^-?([1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0)$&quot;);</span><br></pre></td></tr></table></figure><h1 id="字符"><a href="#字符" class="headerlink" title="字符"></a>字符</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">//汉字</span><br><span class="line">    Regex reg = new Regex(@&quot;^[\u4e00-\u9fa5]&#123;0,&#125;$&quot;);</span><br><span class="line">    //英文和数字</span><br><span class="line">    Regex reg = new Regex(@&quot;^[A-Za-z0-9]+$ 或 ^[A-Za-z0-9]&#123;4,40&#125;$&quot;);</span><br><span class="line">    //长度为3-20的所有字符</span><br><span class="line">    Regex reg = new Regex(@&quot;^.&#123;3,20&#125;$&quot;);</span><br><span class="line">    //由26个英文字母组成的字符串</span><br><span class="line">    Regex reg = new Regex(@&quot;^[A-Za-z]+$&quot;);</span><br><span class="line">    //由26个大写英文字母组成的字符串</span><br><span class="line">    Regex reg = new Regex(@&quot;^[A-Z]+$&quot;);</span><br><span class="line">    //由26个小写英文字母组成的字符串</span><br><span class="line">    Regex reg = new Regex(@&quot;^[a-z]+$&quot;);</span><br><span class="line">    //由数字和26个英文字母组成的字符串</span><br><span class="line">    Regex reg = new Regex(@&quot;^[A-Za-z0-9]+$&quot;);</span><br><span class="line">    //由数字、26个英文字母或者下划线组成的字符串</span><br><span class="line">    Regex reg = new Regex(@&quot;^\w+$ 或 ^\w&#123;3,20&#125;$&quot;);</span><br><span class="line">    //中文、英文、数字包括下划线</span><br><span class="line">    Regex reg = new Regex(@&quot;^[\u4E00-\u9FA5A-Za-z0-9_]+$&quot;);</span><br><span class="line">    //中文、英文、数字但不包括下划线等符号</span><br><span class="line">    Regex reg = new Regex(@&quot;^[\u4E00-\u9FA5A-Za-z0-9]+$ 或 ^[\u4E00-\u9FA5A-Za-z0-9]&#123;2,20&#125;$&quot;);</span><br><span class="line">    //可以输入含有^%&amp;’,;=?$\”等字符</span><br><span class="line">    Regex reg = new Regex(@&quot;[^%&amp;’,;=?$\x22]+&quot;);</span><br><span class="line">    //禁止输入含有~的字符</span><br><span class="line">    Regex reg = new Regex(@&quot;[^~\x22]+&quot;);</span><br></pre></td></tr></table></figure><h1 id="其他表达式"><a href="#其他表达式" class="headerlink" title="其他表达式"></a>其他表达式</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">//Email地址</span><br><span class="line">    Regex reg = new Regex(@&quot;^\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$&quot;);</span><br><span class="line">    //域名</span><br><span class="line">    Regex reg = new Regex(@&quot;[a-zA-Z0-9][-a-zA-Z0-9]&#123;0,62&#125;(/.[a-zA-Z0-9][-a-zA-Z0-9]&#123;0,62&#125;)+/.?&quot;);</span><br><span class="line">    //InternetURL</span><br><span class="line">    Regex reg = new Regex(@&quot;[a-zA-z]+://[^\s]* 或 ^http://([\w-]+\.)+[\w-]+(/[\w-./?%&amp;=]*)?$&quot;);</span><br><span class="line">    //手机号码</span><br><span class="line">    Regex reg = new Regex(@&quot;^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\d&#123;8&#125;$&quot;);</span><br><span class="line">    //电话号码(“XXX-XXXXXXX”、”XXXX-XXXXXXXX”、”XXX-XXXXXXX”、”XXX-XXXXXXXX”、”XXXXXXX”和”XXXXXXXX)</span><br><span class="line">    Regex reg = new Regex(@&quot;^($$\d&#123;3,4&#125;-)|\d&#123;3.4&#125;-)?\d&#123;7,8&#125;$&quot;);</span><br><span class="line">    //国内电话号码(0511-4405222、021-87888822)</span><br><span class="line">    Regex reg = new Regex(@&quot;\d&#123;3&#125;-\d&#123;8&#125;|\d&#123;4&#125;-\d&#123;7&#125;&quot;);</span><br><span class="line">    //身份证号(15位、18位数字)</span><br><span class="line">    Regex reg = new Regex(@&quot;^\d&#123;15&#125;|\d&#123;18&#125;$&quot;);</span><br><span class="line">    //短身份证号码(数字、字母x结尾)</span><br><span class="line">    Regex reg = new Regex(@&quot;^([0-9])&#123;7,18&#125;(x|X)?$ 或 ^\d&#123;8,18&#125;|[0-9x]&#123;8,18&#125;|[0-9X]&#123;8,18&#125;?$&quot;);</span><br><span class="line">    //帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)</span><br><span class="line">    Regex reg = new Regex(@&quot;^[a-zA-Z][a-zA-Z0-9_]&#123;4,15&#125;$&quot;);</span><br><span class="line">    //密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)</span><br><span class="line">    Regex reg = new Regex(@&quot;^[a-zA-Z]\w&#123;5,17&#125;$&quot;);</span><br><span class="line">    //强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间)</span><br><span class="line">    Regex reg = new Regex(@&quot;^(?=.*\d)(?=.*[a-z])(?=.*[A-Z]).&#123;8,10&#125;$&quot;);</span><br><span class="line">    //日期格式</span><br><span class="line">    Regex reg = new Regex(@&quot;^\d&#123;4&#125;-\d&#123;1,2&#125;-\d&#123;1,2&#125;&quot;);</span><br><span class="line">    //一年的12个月(01～09和1～12)</span><br><span class="line">    Regex reg = new Regex(@&quot;^(0?[1-9]|1[0-2])$&quot;);</span><br><span class="line">    //一个月的31天(01～09和1～31)</span><br><span class="line">    Regex reg = new Regex(@&quot;^((0?[1-9])|((1|2)[0-9])|30|31)$&quot;);</span><br><span class="line">    //钱的输入格式：</span><br><span class="line">    //有四种钱的表示形式我们可以接受:”10000.00″ 和 “10,000.00”, 和没有 “分” 的 “10000” 和 “10,000”</span><br><span class="line">    Regex reg = new Regex(@&quot;^[1-9][0-9]*$&quot;);</span><br><span class="line">    //这表示任意一个不以0开头的数字，但是，这也意味着一个字符”0″不通过，所以我们采用下面的形式</span><br><span class="line">    Regex reg = new Regex(@&quot;^(0|[1-9][0-9]*)$&quot;);</span><br><span class="line">    //一个0或者一个不以0开头的数字.我们还可以允许开头有一个负号</span><br><span class="line">    Regex reg = new Regex(@&quot;^(0|-?[1-9][0-9]*)$&quot;);</span><br><span class="line">    //这表示一个0或者一个可能为负的开头不为0的数字.让用户以0开头好了.把负号的也去掉，因为钱总不能是负的吧.下面我们要加的是说明可能的小数部分</span><br><span class="line">    Regex reg = new Regex(@&quot;^[0-9]+(.[0-9]+)?$&quot;);</span><br><span class="line">    //必须说明的是，小数点后面至少应该有1位数，所以”10.”是不通过的，但是 “10” 和 “10.2” 是通过的</span><br><span class="line">    Regex reg = new Regex(@&quot;^[0-9]+(.[0-9]&#123;2&#125;)?$&quot;);</span><br><span class="line">    //这样我们规定小数点后面必须有两位，如果你认为太苛刻了，可以这样</span><br><span class="line">    Regex reg = new Regex(@&quot;^[0-9]+(.[0-9]&#123;1,2&#125;)?$&quot;);</span><br><span class="line">    //这样就允许用户只写一位小数。下面我们该考虑数字中的逗号了，我们可以这样</span><br><span class="line">    Regex reg = new Regex(@&quot;^[0-9]&#123;1,3&#125;(,[0-9]&#123;3&#125;)*(.[0-9]&#123;1,2&#125;)?$&quot;);</span><br><span class="line">    //1到3个数字，后面跟着任意个 逗号+3个数字，逗号成为可选，而不是必须</span><br><span class="line">    Regex reg = new Regex(@&quot;^([0-9]+|[0-9]&#123;1,3&#125;(,[0-9]&#123;3&#125;)*)(.[0-9]&#123;1,2&#125;)?$&quot;);</span><br><span class="line">    //备注：这就是最终结果了，别忘了”+”可以用”*”替代。如果你觉得空字符串也可以接受的话(奇怪，为什么?)最后，别忘了在用函数时去掉去掉那个反斜杠，一般的错误都在这里</span><br><span class="line">    //xml文件</span><br><span class="line">    Regex reg = new Regex(@&quot;^([a-zA-Z]+-?)+[a-zA-Z0-9]+\\.[x|X][m|M][l|L]$&quot;);</span><br><span class="line">    //中文字符的正则表达式</span><br><span class="line">    Regex reg = new Regex(@&quot;[\u4e00-\u9fa5]&quot;);</span><br><span class="line">    //双字节字符</span><br><span class="line">    Regex reg = new Regex(@&quot;[^\x00-\xff] (包括汉字在内，可以用来计算字符串的长度(一个双字节字符长度计2，ASCII字符计1))&quot;);</span><br><span class="line">    //空白行的正则表达式，可用来删除空白行</span><br><span class="line">    Regex reg = new Regex(@&quot;\n\s*\r&quot;);</span><br><span class="line">    //HTML标记的正则表达式</span><br><span class="line">    Regex reg = new Regex(@&quot;&lt;(\S*?)[^&gt;]*&gt;.*?&lt;/\1&gt;|&lt;.*? /&gt;&quot;);// (网上流传的版本太糟糕，上面这个也仅仅能部分，对于复杂的嵌套标记依旧无能为力)</span><br><span class="line">    //首尾空白字符的正则表达式</span><br><span class="line">    Regex reg = new Regex(@&quot;^\s*|\s*$或(^\s*)|(\s*$)&quot;);// (可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式)</span><br><span class="line">    //腾讯QQ号</span><br><span class="line">    Regex reg = new Regex(@&quot;[1-9][0-9]&#123;4,&#125;&quot;); //(腾讯QQ号从10000开始)</span><br><span class="line">    //中国邮政编码</span><br><span class="line">    Regex reg = new Regex(@&quot;[1-9]\d&#123;5&#125;(?!\d)&quot;);// (中国邮政编码为6位数字)</span><br><span class="line">    //IP地址</span><br><span class="line">    Regex reg = new Regex(@&quot;\d+\.\d+\.\d+\.\d+&quot;);// (提取IP地址时有用)</span><br><span class="line">    //IP地址</span><br><span class="line">    Regex reg = new Regex(@&quot;((?:(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d)\\.)&#123;3&#125;(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d))&quot;);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;正则表达式的本质是使用一系列特殊字符模式，来表示某一类字符串。&lt;br&gt;
    
    </summary>
    
      <category term="C#" scheme="http://11wy11.github.io/categories/C/"/>
    
    
      <category term="C#" scheme="http://11wy11.github.io/tags/C/"/>
    
      <category term="Regex" scheme="http://11wy11.github.io/tags/Regex/"/>
    
  </entry>
  
  <entry>
    <title>ai组件开发--虚线定义原理及编程实现</title>
    <link href="http://11wy11.github.io/2019/03/25/ai-dash-line-note/"/>
    <id>http://11wy11.github.io/2019/03/25/ai-dash-line-note/</id>
    <published>2019-03-25T07:41:27.000Z</published>
    <updated>2019-03-25T10:57:50.309Z</updated>
    
    <content type="html"><![CDATA[<p>illustrator中定义虚线形式可以最多设置三个虚线长度和三个间隙长度<br><a id="more"></a></p><h1 id="虚线定义"><a href="#虚线定义" class="headerlink" title="虚线定义"></a>虚线定义</h1><p>illustrator中定义虚线形式可以最多设置三个虚线长度和三个间隙长度<br>__需要特别注意如果定义奇数个参数，即没有定义spaceA，spaceB，spaceC时的情况,其中spaceB和spaceC的循环情况原理一致<br>依次标记为dashA,spaceA,dashB,spaceB,dashC,spaceC<br>为更明显的展示，定义：<br>dashA: 3<br>spaceA: 5</p><p>dashB: 4<br>spaceB:6</p><p>dashC: 2<br>spaceC: 1<br>虚线：—表示一个pt<br>间隙：#表示一个pt<br>结果形式：展示两次循环，每次循环间为区分明显添加了一个空格<br>下面简单介绍定义规则</p><ol><li>设置dashA，其他值为空<br>一次循环：此时按照dashA的长度绘制实部，此时，illustrator默认spaceA=dashA，因此间隙也是dashA的长度<br>结果形式:———### ———###  </li><li>设置dashA，spaceA,其他值为空<br>一次循环：此时按照dashA的长度绘制实部，间隙是spaceA的长度<br>结果形式:———##### ———#####</li><li>设置dashA，spaceA,dashB,其他值为空，<strong>需注意</strong><br>一次循环：此时按照dashA的长度绘制第一个实部，间隙是spaceA的长度,按照dashB的长度绘制第二个实部，按照dashA绘制间隙，按照spaceA绘制第三个实部，按照dashB绘制间隙<br>结果形式:———#####————####—————#### ———#####————####—————####</li><li>设置dashA，spaceA,dashB,spaceB,其他值为空<br> 一次循环：此时按照dashA的长度绘制第一个实部，间隙是spaceA的长度,按照dashB的长度绘制第二个实部，间隙是spaceB的长度,<br> 结果形式:———#####————###### ———#####————######</li><li>设置dashA，spaceA,dashB,spaceB,dashC,其他值为空<br> 一次循环：此时按照dashA的长度绘制第一个实部，间隙是spaceA的长度,按照dashB的长度绘制第二个实部，间隙是spaceB的长度,按照dashC的长度绘制第三个实部,间隙是spaceC的长度，按照dashA绘制间隙，按照spaceA绘制第四个实部，按照dashB绘制间隙，按照spaceB绘制第五个实部，按照dashC绘制间隙,按照spaceC绘制第六个实部<br> 结果形式:———#####————######——###—————####——————## ———#####————######——###—————####——————##</li><li>设置dashA，spaceA,dashB,spaceB,dashC,spaceC<br> 原理同4一致，不再赘述</li></ol><p><strong>概括来说，AI本身每次循环使用六个参数定义虚线，如果不足就会重复前面定义的参数</strong></p><h1 id="illustrator-SDK接口实现"><a href="#illustrator-SDK接口实现" class="headerlink" title="illustrator SDK接口实现"></a>illustrator SDK接口实现</h1>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;illustrator中定义虚线形式可以最多设置三个虚线长度和三个间隙长度&lt;br&gt;
    
    </summary>
    
      <category term="AI组件开发" scheme="http://11wy11.github.io/categories/AI%E7%BB%84%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="AI" scheme="http://11wy11.github.io/tags/AI/"/>
    
  </entry>
  
  <entry>
    <title>AI组件开发（八）--AIArtStyleSuite</title>
    <link href="http://11wy11.github.io/2019/03/25/ai-eight-style-note/"/>
    <id>http://11wy11.github.io/2019/03/25/ai-eight-style-note/</id>
    <published>2019-03-25T01:46:16.000Z</published>
    <updated>2019-03-25T09:12:22.322Z</updated>
    
    <content type="html"><![CDATA[<p>Art Style套件中的功能用于访问和修改Illustrator文档中图稿的art样式<br><a id="more"></a><br><!-- START doctoc generated TOC please keep comment here to allow auto update --><br><!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE --><br><strong>Table of Contents</strong>  <em>generated with <a href="https://github.com/thlorenz/doctoc" target="_blank" rel="noopener">DocToc</a></em></p><ul><li><a href="#aiartstylesuite">AIArtStyleSuite</a><ul><li><a href="#%E6%96%B9%E6%B3%95">方法</a></li></ul></li><li><a href="#%E7%9B%B8%E5%85%B3%E7%B1%BB%E7%BB%93%E6%9E%84%E4%BD%93%E6%8C%87%E9%92%88">相关类，结构体，指针</a><ul><li><a href="#aiarthandle">AIArtHandle</a></li><li><a href="#aiartstylehandle">AIArtStyleHandle</a></li><li><a href="#aipathstyle">AIPathStyle</a></li><li><a href="#aistrokestyle">AIStrokeStyle</a></li><li><a href="#aifillstyle">AIFillStyle</a></li></ul></li><li><a href="#%E4%BD%BF%E7%94%A8%E5%AE%9E%E4%BE%8B">使用实例</a></li></ul><!-- END doctoc generated TOC please keep comment here to allow auto update --><h1 id="AIArtStyleSuite"><a href="#AIArtStyleSuite" class="headerlink" title="AIArtStyleSuite"></a>AIArtStyleSuite</h1><p>Art Style套件中的功能用于访问和修改Illustrator文档中图稿的art样式<br>在AI8中，Illustrator引入了插件组的概念，其中实际打印的art（结果art）与用户编辑的art（编辑art）分开。随着art风格的引入，这一概念在AI9中得到了扩展。现在，文档中的任何art对象（包括组和文本对象）都可以选择附加“样式art”。正是这种“风格art”得到了印刷，而不是原始的“源art”。</p><p>应用于art的art风格控制着风格art的生成方式。插件不应该直接修改样式art本身，可以随时重新生成，但应该使用art风格。</p><p>导出插件应导出应用于对象的样式化art（如果有），而不是原始源art。</p><p>在UI中，应用于Illustratorart对象的art风格称为对象的外观，并通过“外观”调板进行操作。外观也可以通过“图形样式”调板保存并在其他对象上重复使用。</p><p>使用SPBasicSuite::AcquireSuite()常量kAIArtStyleSuite和使用获取此套件kAIArtStyleVersion。</p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><ul><li>AIAPI AIErr（*     GetStyledArt）（AIArtHandle art，AIArtHandle * styledArt）<br>   获得art对象的样式。<br>   返回 styleArt [out]用于返回样式化art对象的缓冲区，如果没有应用特殊样式，则返回原始art对象。NULL出错时返回; 例如，如果由于内存限制而无法执行动态效果。</li><li>AIAPI AIErr（*     GetArtStyle）（AIArtHandle art，AIArtStyleHandle * artStyle）<br>   获得与art对象关联的art风格。 </li><li>AIAPI AIErr（*     GetCurrentArtStyle）（AIArtStyleHandle * artStyle，AIBoolean * mixedState）<br>   获得“外观”调板中当前显示的art样式。<br>   artStyle     [out]用于返回art风格参考的缓冲区。<br>  mixedState     [out]如果Appearance调色板显示“Mixed”，则返回true的缓冲区。在这种情况下，返回的art风格是一种简单的风格，它试图收集附加到当前文档中当前所选对象的art风格的公共属性。</li><li>AIAPI AIErr（*     GetArtStyleByName）（AIArtStyleHandle * artStyle，const ai :: UnicodeString＆name，AIBoolean searchAllStyles）<br>   从当前文档中按唯一名称获得art样式。 </li><li>AIAPI AIErr（*     CountNamedArtStyles）（ai :: int32 * count）<br>   获取“图形样式”调板中当前列出的art样式的数量。 </li><li>AIAPI AIErr（*     GetNthNamedArtStyle）（ai :: int32 n，AIArtStyleHandle * artStyle）<br>   按索引获得命名的art样式。 </li><li>AIAPI AIErr（*     SetArtStyle）（AIArtHandle art，AIArtStyleHandle artStyle）<br>   将art样式应用于ar品。 </li><li>AIAPI AIErr（*     SetCurrentArtStyle）（AIArtStyleHandle artStyle）<br>   将art样式应用于画板上当前目标对象。 </li><li>AIAPI AIErr（*     GetArtStyleName）（AIArtStyleHandle artStyle，ai :: UnicodeString＆name，AIBoolean * isAnonymous）<br>   获得art样式的唯一名称。 </li><li>AIAPI AIErr（*     SetArtStyleName）（AIArtStyleHandle artStyle，const ai :: UnicodeString＆name）<br>   设置命名art样式的唯一名称; 也就是说，在“图形样式”调板中显示的那个。 </li><li>AIAPI AIErr（*     GetPaintAttributes）（AIArtStyleHandle artStyle，AIPathStyle * aiPathStyle，AIArtStylePaintData * paintData）<br>   获得art样式的绘画信息。 </li><li>AIAPI AIErr（*     NewStyle）（AIPathStyle * aiPathStyle，AIArtStylePaintData * paintData，AIDictionaryRef blendDict，AIArtStyleHandle * newStyle）<br>   创造一种新的art风格。 </li><li>AIAPI AIErr（*     AddNamedStyle）（AIArtStyleHandle artStyle，const ai :: UnicodeString＆name，AIBoolean uniquify，AIArtStyleHandle * namedStyle）<br>   将匿名样式转换为命名样式，该样式显示在“图形样式”调板中。 </li><li>AIAPI AIErr（*     RemoveNamedStyle）（AIArtStyleHandle namedStyle，AIArtStyleHandle * anonStyle）<br>   将命名样式（在“图形样式”调板中显示）转换为匿名样式，</li><li>AIAPI AIErr（*     CreateAnonymousStyle）（AIArtStyleHandle namedStyle，AIArtStyleHandle * anonStyle）<br>   创建命名art样式的匿名副本（显示在“图形样式”调板中）。 </li><li>AIAPI AIErr（*     RedefineNamedStyle）（AIArtStyleHandle namedStyle，AIArtStyleHandle dstStyle）<br>   重新定义命名的art样式以具有与另一样式相同的特征。 </li><li>AIAPI AIErr（*     MoveNamedStyle）（AIArtStyleHandle namedStyle，ai :: int32 index）<br>   将命名的art样式移动到“图形样式”调板中的位置。 </li><li>AIAPI AIErr（*     GetArtStyleByNameFromDocument）（AIArtStyleHandle * artStyle，const ai :: UnicodeString＆name，AIDocumentHandle document）<br>   通过指定文档中的唯一名称获得命名的art样式。 </li><li>AIAPI AIErr（*     CountNamedArtStylesFromDocument）（ai :: int32 * count，AIDocumentHandle document）<br>   获取指定文档中命名的art样式的数量（当该文档是最新的时，在“图形样式”调板中显示的样式）。 </li><li>AIAPI AIErr（*     GetNthNamedArtStyleFromDocument）（ai :: int32 n，AIArtStyleHandle * artStyle，AIDocumentHandle document）<br>   按索引获得指定文档的命名art样式。 </li><li>AIAPI AIErr（*     当量）（AIArtStyleHandle artStyle1，AIArtStyleHandle artStyle2，AIBoolean *结果）<br>   测试两种art风格之间的等价性。 </li><li>AIAPI AIErr（*     SortNamedStyles）（void）<br>   按名称按字母顺序对当前文档中的命名art样式进行排序。 </li><li>AIAPI AIErr（*     GetDefaultArtStyle）（AIArtStyleHandle * artStyle）<br>   获得当前文档的默认art样式，该样式始终首先列在“图形样式”调板中。 </li><li>AIAPI AIErr（*     GetDefaultArtStyleName）（ai :: UnicodeString＆name）<br>   获得当前文档的默认art样式的名称，该名称始终首先列在“图形样式”调板中。 </li><li>AIAPI AIBoolean（*     ValidateArtStyle）（AIArtStyleHandle artStyle）<br>   报告当前文档中是否存在artstyle。 </li><li>AIAPI AIErr（*     FlattenStyle）（AIArtHandle art）<br>   扩展art的风格，将art品替换为可返回的GetStyledArt()。 </li><li>AIAPI AIErr（*     GetArtStyleType）（AIArtStyleHandle artStyle，ai :: int16 * type）<br>   获得art风格的类型。 </li><li>AIAPI AIBoolean（*     CanExecute）（AIArtStyleHandle artStyle）<br>   报告art风格是否包含执行所需的所有部分。 </li><li><p>AIAPI AIReal（*     GetArtStyleScaleFactor）（AIArtHandle art）<br>   返回art对象样式的比例因子。<br>   “缩放笔触和效果”选项允许缩放笔画粗细和附加到art对象的效果。缩放因子与art对象一起存储，并且在应用样式后应用。例如，如果附加到对象的样式具有权重为2 pt的笔划，并且对象的比例因子为2.5，则视觉笔触权重为5 pt。<br> 注意：<br> GetPaintAttributes()获取未缩放的参数值，以及来自的函数AIArtStyleParserSuite。<br> 但是，AIPathStyleSuite调用返回附加到对象的缩放笔画粗细。<br> 参数：art<br> 返回：<br> 比例因子。  </p></li><li><p>AIAPI AIErr（*     SetArtStyleScaleFactor）（AIArtHandle art，AIReal scaleFactor）<br>   设置art对象样式的比例因子。 </p></li><li>AIAPI AIErr（*     ResetArtStyleScaleFactor）（AIArtHandle art）<br>   将新样式应用于按对象的当前比例因子缩放的art对象，并将对象的比例因子重置为1。 </li><li>AIAPI AIErr（*     TransformObjectArtStyle）（AIArtHandle art，AIRealMatrix * matrix，AIReal lineScale，ai :: int32 flags）<br>   改变对象的art风格。<br>   参数：<br>   art 需要变换的art对象<br>  matrix     指向转换矩阵的指针。<br>  lineScale     要应用于art对象当前样式中指定的线条绘制样式值的比例因子。<br>  flags     控制转换执行方式的位标志。AITransformArtOptions值的逻辑OR 。如果kTransformObjects标志打开，则假设art对象本身也已经被相同的矩阵变换，并且已经执行了点，后代art等的任何变换。这允许立即调整梯度向量和依赖于对象边界的其他样式属性，而不是延迟到art同步。</li><li>AIAPI AIArtStyleHasAttrs（*     ExamineStyle）（AIArtStyleHandle artStyle，AIArtStyleHasAttrs checkFor）<br>   检查特定属性的art风格，并返回找到的属性。 </li><li>AIAPI AIErr（*     GetToolArtStyle）（AIArtStyleHandle * artStyle）<br>   根据应用程序首选项获得将用于工具创建的新art的artstyle。 </li><li>AIAPI AIErr（*     GetFlattenedArt）（AIArtHandle art，AIArtHandle * flattenedArt）<br>   扩展ar的风格，将art替换为可返回的art GetStyledArt()。 </li><li>AIAPI AIBoolean（*     HasEffectiveNullStyle）（AIArtHandle art）<br>   报告art对象是否具有等效于null样式的样式。 </li><li>AIAPI AIErr（*     GetPaintMap）（AIArtStyleHandle artStyle，AIPathStyleMap * aiPathStyleMap）<br>   获得art样式的路径样式的地图，如下所示GetPaintAttributes()。 </li></ul><h1 id="相关类，结构体，指针"><a href="#相关类，结构体，指针" class="headerlink" title="相关类，结构体，指针"></a>相关类，结构体，指针</h1><h2 id="AIArtHandle"><a href="#AIArtHandle" class="headerlink" title="AIArtHandle"></a>AIArtHandle</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">typedef struct ArtObject* AIArtHandle</span><br><span class="line">Opaque reference to an art object.</span><br><span class="line">Access using AIArtSuite.</span><br></pre></td></tr></table></figure><h2 id="AIArtStyleHandle"><a href="#AIArtStyleHandle" class="headerlink" title="AIArtStyleHandle"></a>AIArtStyleHandle</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _t_AIArtStyle* AIArtStyleHandle</span><br><span class="line">A reference to an art style.</span><br><span class="line">See also:</span><br><span class="line">AIArtStyleSuite.</span><br></pre></td></tr></table></figure><h2 id="AIPathStyle"><a href="#AIPathStyle" class="headerlink" title="AIPathStyle"></a>AIPathStyle</h2><p>描述如何绘制路径的填充和描边。</p><p>完整样式完全指定绘画信息。<br>一个部分款式可以指定的绘画信息的子集。例如，它可用于表示选择的常见绘制属性，或修改属性的子集而不影响其他属性。在这种情况下，路径样式与样式映射配对，AIPathStyleMap指定具有有效值的属性子集。<br>注意不要将部分样式传递给需要完整样式的函数; 未指定的字段可以包含无效值。  </p><ul><li>AIBoolean     fillPaint<br>   Whether or not to fill the path.   </li><li>AIBoolean     strokePaint<br>   Whether or not to stroke the path.   </li><li>struct AIFillStyle     fill<br>   Fill style, if fillPaint is true.   </li><li>struct AIStrokeStyle     stroke<br>   Stroke style, if strokePaint is true.    </li><li>AIBoolean     clip  </li><li>AIBoolean     lockClip  </li><li>AIBoolean     evenodd<br>   When true, use the even-odd rule to determine path insideness.   </li><li>AIReal     resolution<br>   Path’s resolution.   <h2 id="AIStrokeStyle"><a href="#AIStrokeStyle" class="headerlink" title="AIStrokeStyle"></a>AIStrokeStyle</h2></li><li>AIColor     color<br>   Stroke color.   </li><li>AIBoolean     overprint<br>   Overprint - not meaningful if the color is a pattern.   </li><li>AIReal     width<br>   Line width in points.   </li><li>struct AIDashStyle     dash<br>   Stroke dash.   </li><li><p>enum AILineCap     cap<br>   Line cap.</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Types of line caps for strokes.</span><br><span class="line">    Enumerator:</span><br><span class="line">    kAIButtCap </span><br><span class="line">    Butt line caps.//平头</span><br><span class="line">    </span><br><span class="line">    kAIRoundCap </span><br><span class="line">    Round line caps.//圆头</span><br><span class="line">    </span><br><span class="line">    kAIProjectingCap </span><br><span class="line">    Projecting line caps.//方头</span><br></pre></td></tr></table></figure></li><li><p>enum AILineJoin     join<br>   Line join</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Types of line joins for strokes.</span><br><span class="line"></span><br><span class="line">Enumerator:</span><br><span class="line">kAIMiterJoin </span><br><span class="line">Miter line joins.//斜接连接</span><br><span class="line"></span><br><span class="line">kAIRoundJoin </span><br><span class="line">Round line joins.//圆角连接</span><br></pre></td></tr></table></figure></li><li><p>AIReal     miterLimit<br>   Line miter limit. </p><h2 id="AIFillStyle"><a href="#AIFillStyle" class="headerlink" title="AIFillStyle"></a>AIFillStyle</h2></li><li>AIColor     color<br>   Fill color. </li><li>AIBoolean overprint<br>   When true, print any art beneath this, then print the fill of this object over it. </li></ul><h1 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">bool isArtStyle=true;//是否使用图形样式库设置样式</span><br><span class="line">if (isArtStyle)&#123;</span><br><span class="line">    AIArtStyleHandle artStyle=NULL;</span><br><span class="line">    sAIArtStyle-&gt;GetArtStyleByName(&amp;artStyle, ai::UnicodeString(artStyleName), 1);</span><br><span class="line">    if (!artStyle)&#123;</span><br><span class="line">        sAIArt-&gt;DisposeArt(art);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    sAIArtStyle-&gt;SetArtStyle(art, artStyle);</span><br><span class="line">&#125;</span><br><span class="line">else&#123;</span><br><span class="line">     AIColor color;</span><br><span class="line">AIColor colorFill;</span><br><span class="line">float CMYK[4] = &#123;23,211,22,56&#125;;</span><br><span class="line">float CMYKFill[4] = &#123;23,223,12,53&#125;;</span><br><span class="line">   // 描边颜色</span><br><span class="line">color.kind = kFourColor;</span><br><span class="line">color.c.f.cyan = CMYK[0];</span><br><span class="line">color.c.f.magenta = CMYK[1];</span><br><span class="line">color.c.f.yellow = CMYK[2];</span><br><span class="line">color.c.f.black = CMYK[3];</span><br><span class="line"></span><br><span class="line">//内部填充颜色</span><br><span class="line">colorFill.kind = kFourColor;</span><br><span class="line">colorFill.c.f.cyan = CMYKFill[0];</span><br><span class="line">colorFill.c.f.magenta = CMYKFill[1];</span><br><span class="line">colorFill.c.f.yellow = CMYKFill[2];</span><br><span class="line">colorFill.c.f.black = CMYKFill[3];</span><br><span class="line"></span><br><span class="line">AIPathStyle PathStyle;</span><br><span class="line">PathStyle.fillPaint = true; // 面内颜色填充 设置为true 否则无法在面内填充颜色</span><br><span class="line">PathStyle.strokePaint = true;</span><br><span class="line">PathStyle.stroke.width = 0.5;</span><br><span class="line">PathStyle.stroke.color = color;</span><br><span class="line">PathStyle.fill.color = colorFill; // 内部填充</span><br><span class="line">    sAIPathStyle-&gt;SetPathStyle(art, &amp;PathStyle);</span><br><span class="line">    //设置透明度</span><br><span class="line">    sAIBlendStyle-&gt;SetOpacity(art, 0.4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h1><p><a href="/2019/03/14/ai-first-note">AI组件开发（一）–注记旋转矩阵</a><br><a href="/2019/03/18/ai-second-note">AI组件开发（二）–AIRealMathSuite</a><br><a href="/2019/03/24/ai-third-note">AI组件开发（三）–AIArtboardSuite</a><br><a href="/2019/03/24/ai-forth-document-note">AI组件开发（四）–AIDocumentSuite</a><br><a href="/2019/03/24/ai-fifth-ailayer-note">AI组件开发（五）–AILayerSuite</a><br><a href="/2019/03/24/ai-six-aiart-note">AI组件开发（六）–AIArtSuite</a><br><a href="/2019/03/25/ai-seven-path-note">AI组件开发（七）–AIPathSuite&amp;&amp;AIPathfinderSuite</a><br><a href="/2019/03/25/ai-eight-style-note">AI组件开发（八）–AIArtStyleSuite</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Art Style套件中的功能用于访问和修改Illustrator文档中图稿的art样式&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>AI组件开发（七）--AIPathSuite&amp;&amp;AIPathfinderSuite</title>
    <link href="http://11wy11.github.io/2019/03/25/ai-seven-path-note/"/>
    <id>http://11wy11.github.io/2019/03/25/ai-seven-path-note/</id>
    <published>2019-03-25T01:11:13.000Z</published>
    <updated>2019-03-25T06:08:15.685Z</updated>
    
    <content type="html"><![CDATA[<p>AIPathSuite提供的功能允许检查和操作路径,AIPathfinderSuite提供了对路径执行操作的功能，这些功能将各种效果应用于选定的路径图<br><a id="more"></a><br><!-- START doctoc generated TOC please keep comment here to allow auto update --><br><!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE --><br><strong>Table of Contents</strong>  <em>generated with <a href="https://github.com/thlorenz/doctoc" target="_blank" rel="noopener">DocToc</a></em></p><ul><li><a href="#aipathsuite">AIPathSuite</a><ul><li><a href="#%E6%B3%A8%E5%86%8C%E5%A3%B0%E6%98%8E">注册声明</a></li><li><a href="#%E6%96%B9%E6%B3%95">方法</a></li><li><a href="#aipathsegment">AIPathSegment</a></li><li><a href="#%E4%BD%BF%E7%94%A8%E5%AE%9E%E4%BE%8B">使用实例</a></li></ul></li><li><a href="#aipathfindersuite">AIPathfinderSuite</a><ul><li><a href="#%E6%B3%A8%E5%86%8C%E5%A3%B0%E6%98%8E-1">注册声明</a></li><li><a href="#%E6%96%B9%E6%B3%95-1">方法</a></li><li><a href="#%E7%9B%B8%E5%85%B3%E7%B1%BB%E7%BB%93%E6%9E%84%E4%BD%93%E6%8C%87%E9%92%88">相关类，结构体，指针</a><ul><li><a href="#aipathfinderdata">AIPathfinderData</a><ul><li><a href="#aioptions">AIOptions</a></li><li><a href="#aiparameters">AIParameters</a><ul><li><a href="#aimixparameters">AIMixParameters</a></li><li><a href="#aitrapparameters">AITrapParameters</a></li></ul></li></ul></li><li><a href="#aifiltermessage">AIFilterMessage</a><ul><li><a href="#spmessagedata">SPMessageData</a></li><li><a href="#aifilterhandle">AIFilterHandle</a></li><li><a href="#platformfilterparameters">PlatformFilterParameters</a></li></ul></li></ul></li></ul></li></ul><!-- END doctoc generated TOC please keep comment here to allow auto update --><h1 id="AIPathSuite"><a href="#AIPathSuite" class="headerlink" title="AIPathSuite"></a>AIPathSuite</h1><p>此套件提供的功能允许您检查和操作路径，这些路径是art类型的对象kPathArt。</p><p>路径的形状由一个或多个路径段定义。路径的每一个段对应于一个锚点，它是在选择路径时显示的手柄。路径上的锚点数或段 数包括每端的两个。段由AIPathSegment结构定义。段索引号从零开始。路径可以有一个锚点。</p><p>段的入点和出点定义点p处的曲线的切线。中间点不用于开放路径的初始段和最终段。段可以是角点或平滑点。对于一个角落，进出点可以在任何地方。要形成一条直线，请将每个端点的入点和出点放在它们的p点上。</p><p>路径可以是关闭的或打开的。如果路径是打开的，则仅由其段定义。如果它已关闭，Illustrator将在第一个和最后一个锚点之间绘制一个段，该段使用最后一个段的out切线和第一个段的切线。</p><p>一些路径也用作指南。在所有其他方面，它们是具有相同内容和属性的路径。绘制属性与通过路径 样式的路径相关联。见AIPathStyleSuite。</p><p>使用SPBasicSuite::AcquireSuite()常量kAIPathSuite和使用获取此套件kAIPathVersion。</p><h2 id="注册声明"><a href="#注册声明" class="headerlink" title="注册声明"></a>注册声明</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//xxxSuites.h</span><br><span class="line">#include &quot;Suites.hpp&quot;</span><br><span class="line">#include &quot;AIArtConverter.h&quot;</span><br><span class="line">extern&quot;C&quot; AIPathSuite* sAIPath;</span><br><span class="line"></span><br><span class="line">//xxxSuites.cpp</span><br><span class="line">extern &quot;C&quot;&#123;</span><br><span class="line"> AIPathSuite* sAIPath=NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ImportSuite gImportSuites[] = &#123;</span><br><span class="line">    IMPORT_TEXT_SUITES</span><br><span class="line">    kAIPathSuite,kAIPathSuiteVersion,&amp;sAIPath,</span><br><span class="line">        nil, 0, nil</span><br><span class="line">      &#125;;</span><br></pre></td></tr></table></figure><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><ul><li>AIAPI AIErr（*     GetPathSegmentCount）（AIArtHandle path，ai :: int16 * count）<br>   获取路径上的锚点数，包括每端的两个锚点。 </li><li>AIAPI AIErr（*     SetPathSegmentCount）（AIArtHandle path，ai :: int16 count）<br>   从段中删除段或将段附加到路径末尾。 </li><li>AIAPI AIErr（*     GetPathSegments）（AIArtHandle path，ai :: int16 segNumber，ai :: int16 count，AIPathSegment segments []）<br>   从路径中检索一组段。 </li><li>AIAPI AIErr（*     SetPathSegments）（AIArtHandle path，ai :: int16 segNumber，ai :: int16 count，const AIPathSegment segments []）<br>   添加或更新路径中的段。 </li><li>AIAPI AIErr（*     InsertPathSegments）（AIArtHandle path，ai :: int16 segNumber，ai :: int16 count，const AIPathSegment segments []）<br>   将段插入路径。 </li><li>AIAPI AIErr（*     DeletePathSegments）（AIArtHandle path，ai :: int16 segNumber，ai :: int16 count）<br>   从路径中删除段。 </li><li>AIAPI AIErr（*     GetPathClosed）（AIArtHandle path，AIBoolean *closed）<br>   报告路径是否已关闭。 </li><li>AIAPI AIErr（*     SetPathClosed）（AIArtHandle path，AIBoolean closed）<br>   打开或关闭路径。 </li><li>AIAPI AIErr（*     GetPathGuide）（AIArtHandle path，AIBoolean * isGuide）<br>   报告路径是否用作指南。 </li><li>AIAPI AIErr（*     SetPathGuide）（AIArtHandle path，AIBoolean isGuide）<br>   设置是否将路径用作指南。 </li><li>AIAPI AIErr（*     GetPathSegmentSelected）（AIArtHandle path，ai :: int16 segNumber，ai :: int16 *selected）<br>   报告是否选择了路径段的任何部分。 </li><li>AIAPI AIErr（*     SetPathSegmentSelected）（选择AIArtHandle path，ai :: int16 segNumber，ai :: int16 selected）<br>   设置段的选择状态。 </li><li>AIAPI AIErr（*     ReversePathSegments）（AIArtHandle path）<br>   反转路径中段的顺序。 </li><li>AIAPI AIErr（*     GetPathArea）（AIArtHandle path，AIReal *area）<br>   计算路径的面积。 </li><li>AIAPI AIErr（*     GetPathLength）（AIArtHandle path，AIReal *length，AIReal flatness）<br>   计算以点为单位测量的路径周长。 </li><li>AIAPI AIErr（*     GetPathBezier）（AIArtHandle path，ai :: int16 segNumber，AIRealBezier * bezier）<br>   计算路径段的贝塞尔曲线值。 </li><li>AIAPI AIErr（*     PathHasLength）（AIArtHandle path，AIBoolean * hasLength）<br>   报告路径是否有长度。 </li><li>AIAPI AIErr（*     GetPathIsClip）（AIArtHandle path，AIBoolean * isClip）<br>   报告路径是否为剪切路径。 </li><li>AIAPI AIErr（*     GetPathAllSegmentsSelected）（AIArtHandle path，选择AIBoolean *）<br>   报告是否选择了路径的所有段。 </li><li>AIAPI AIErr（*     GetKeySegment）（AIArtHandle * path，ai :: int16 * segmentNumber）<br>   检索关键锚点的路径对象和段号（即，其他锚点对齐的那个）。 </li><li>AIAPI AIErr（*     CancelKeySegment）（void）</li><li>AIAPI AIBoolean（*     IsPath9SliceSplitter）（AIArtHandle path）<br>   报告路径是否为9切片分割器; 也就是说，该指南定义了将艺术板分成9个区域的线。 </li><li>AIAPI AIErr（*     SetKeySegment）（AIArtHandle path，ai :: int16 segmentNumber）<br>   设置艺术对象的关键锚点。 </li><li>AIAPI AIErr（*     MeasureSegments）（AIArtHandle path，ai :: int16 startSeg，ai :: int16 count，AIReal pieceLengths []，AIReal accumulationLengths []）<br>   测量路径段的长度。 </li><li>AIAPI AIErr（*     LengthFractionToBezierPos）（AIArtHandle path，AIReal lengthFraction，ai :: int16＆segIndex，AIReal＆bezierT，const AIReal pieceLengths []，const AIReal accumulationLengths []）<br>   计算作为沿路径的路径长度的给定分数的点的段索引和参数贝塞尔t值。 </li><li>AIAPI AIErr（*     BezierPosToLengthFraction）（AIArtHandle path，ai :: int16 segIndex，AIReal bezierT，AIReal＆lengthFraction，const AIReal pieceLengths []，const AIReal accumulationLengths []）<br>   计算对应于沿路径的位置的总路径长度的分数，该路径表示为段索引，并且将参数贝塞尔t值表示到该段中。 </li><li>AIAPI AIErr（*     BezierPosToAnchoredPos）（AIArtHandle path，ai :: int16 segIndex，AIReal t，AIReal * segLength，AIReal * segLengthFraction）<br>   从参数贝塞尔曲线t值转换为线段长度的一部分。 </li><li>AIAPI AIErr（*     PerpendicularsAtBezierT）（AIArtHandle path，ai :: int16 segIndex，AIReal t，AIReal leftDistance，AIReal rightDistance，AIRealPoint＆pointOnPath，AIRealPoint * leftPoint，AIRealPoint * rightPoint）<br>   计算与表示为段索引和参数贝塞尔t值的位置处的路径垂直（正常）的线段的端点</li></ul><h2 id="AIPathSegment"><a href="#AIPathSegment" class="headerlink" title="AIPathSegment"></a>AIPathSegment</h2><p>Contents    Suites    Classes    Class Index    Member Index<br>AIPathSegment Struct Reference<br>Defines a path segment. More…</p><p>#include &lt;AIPath.h&gt;</p><p>List of all members.</p><p>Public Attributes<br>AIRealPoint     p<br>AIRealPoint     in<br>AIRealPoint     out<br>AIBoolean     corner  </p><h2 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">//SetPathSegmentCount</span><br><span class="line">long curCount=10;//定义环面点数</span><br><span class="line">AIArtHandle artGroup = NULL;</span><br><span class="line">sAIArt-&gt;GetFirstArtOfLayer(PolygonLayer, &amp;artGroup);</span><br><span class="line">AIArtHandle art = NULL;</span><br><span class="line">sAIArt-&gt;NewArt(kPathArt, kPlaceInsideOnTop, artGroup, &amp;art);</span><br><span class="line">sAIPath-&gt;SetPathSegmentCount(art, (short)curCount);</span><br><span class="line">AIPathSegment *segment = new AIPathSegment[curCount];</span><br><span class="line">AIRealPoint *AIPoint = new AIRealPoint[curCount];</span><br><span class="line">...</span><br><span class="line">//赋值操作</span><br><span class="line">for (int i = 0; i &lt; curCount; i++)</span><br><span class="line">&#123;</span><br><span class="line">    segment[i].p.h = AIPoint[i].h;</span><br><span class="line">    segment[i].p.v = AIPoint[i].v;</span><br><span class="line">    segment[i].in = segment[i].out = segment[i].p;</span><br><span class="line">    segment[i].corner = true;</span><br><span class="line">&#125;</span><br><span class="line">//SetPathSegments</span><br><span class="line">sAIPath-&gt;SetPathSegments(art, 0, curCount, segment);</span><br><span class="line">delete[] segment;</span><br><span class="line">delete[] AIPoint;</span><br><span class="line">//SetPathClosed</span><br><span class="line">sAIPath-&gt;SetPathClosed(art, 1);</span><br><span class="line">arts.push_back(art);</span><br></pre></td></tr></table></figure><h1 id="AIPathfinderSuite"><a href="#AIPathfinderSuite" class="headerlink" title="AIPathfinderSuite"></a>AIPathfinderSuite</h1><p>该套件提供了对路径（类型的艺术对象kPathArt）执行操作的功能，这些功能将各种效果应用于选定的路径图。<br><strong>这些操作与“路径查找器”调板和“效果”菜单中的操作相对应。</strong><br>附加功能允许操作复合 形状，可以应用效果的插件组。见AIPluginGroupSuite。在复合形状组中，绘制组中的底部对象，然后根据交互模式（AIShapeMode）由其上方的下一个对象进行修改。可以将每个后续对象添加到图形中，从图形中减去，相交或从图形中排除。</p><p>使用SPBasicSuite::AcquireSuite()常量kAIPathfinderSuite和使用获取此套件kAIPathfinderVersion。</p><h2 id="注册声明-1"><a href="#注册声明-1" class="headerlink" title="注册声明"></a>注册声明</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//xxxSuites.h</span><br><span class="line">#include &quot;Suites.hpp&quot;</span><br><span class="line">#include &quot;AIPathfinder.h&quot;</span><br><span class="line">extern  &quot;C&quot; AIPathfinderSuite*          sAIPathfinder;</span><br><span class="line"></span><br><span class="line">//xxxSuites.cpp</span><br><span class="line">extern &quot;C&quot;&#123;</span><br><span class="line"> AIPathfinderSuite*  sAIPathfinder=NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ImportSuite gImportSuites[] = &#123;</span><br><span class="line">    IMPORT_TEXT_SUITES</span><br><span class="line">    kAIPathfinderSuite,kAIPathfinderSuiteVersion,&amp;sAIPathfinder,</span><br><span class="line">        nil, 0, nil</span><br><span class="line">      &#125;;</span><br></pre></td></tr></table></figure><h2 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h2><ul><li>AIAPI AIErr（*     DoUniteEffect）（AIPathfinderData *data，AIFilterMessage *message）<br>   对选定的艺术应用Unite效果。 </li><li>AIAPI AIErr（*     DoIntersectEffect）（AIPathfinderData * data，AIFilterMessage * message）<br>   将相交效果应用于选定的art。 </li><li>AIAPI AIErr（*     DoExcludeEffect）（AIPathfinderData *data，AIFilterMessage *message）<br>   对所选art应用排除效果。 </li><li>AIAPI AIErr（*     DoBackMinusFrontEffect）（AIPathfinderData * data，AIFilterMessage * message）<br>   对选定的art应用前后减去效果。 </li><li>AIAPI AIErr（*     DoFrontMinusBackEffect）（AIPathfinderData *data，AIFilterMessage *message）<br>   对选定的art应用前后减去效果。 </li><li>AIAPI AIErr（*     DoDivideEffect）（AIPathfinderData *data，AIFilterMessage *message）<br>   对所选art应用分割效果。 </li><li>AIAPI AIErr（*     DoOutlineEffect）（AIPathfinderData * data，AIFilterMessage * message）<br>   将轮廓效果应用于选定的art。 </li><li>AIAPI AIErr（*     DoTrimEffect）（AIPathfinderData *data，AIFilterMessage *message）<br>   对所选art应用修剪效果。 </li><li>AIAPI AIErr（*     DoMergeEffect）（AIPathfinderData *data，AIFilterMessage *message）<br>   对选定的art应用合并效果。 </li><li>AIAPI AIErr（*     DoCropEffect）（AIPathfinderData *data，AIFilterMessage *message）<br>   将裁剪效果应用于选定的art。 </li><li>AIAPI AIErr（*     DoHardEffect）（AIPathfinderData *data，AIFilterMessage *message）<br>   对选定的art应用硬效果。 </li><li>AIAPI AIErr（*     DoSoftEffect）（AIPathfinderData *data，AIFilterMessage *message）<br>   对选定的art应用柔和效果。 </li><li>AIAPI AIErr（*     DoTrapEffect）（AIPathfinderData *data，AIFilterMessage *message）<br>   对选定的art应用陷印效果。 </li><li>AIAPI AIErr（*     GetHardEffectParameters）（AIPathfinderData *data，AIFilterMessage *message）<br>   获得硬效果路径查找器操作的参数。 </li><li>AIAPI AIErr（*     GetSoftEffectParameters）（AIPathfinderData *data，AIFilterMessage *message）<br>   获得Soft效果路径查找器操作的参数。 </li><li>AIAPI AIErr（*     GetTrapEffectParameters）（AIPathfinderData * data，AIFilterMessage * message）<br>   获得陷阱效果路径查找器操作的参数。 </li><li>AIAPI AIErr（*     GetGlobalOptions）（AIPathfinderData *data，AIFilterMessage *message）<br>   获得“路径查找器”和“效果”操作的全局选项。<br>AIAPI AIShapeMode（*     GetShapeMode）（AIArtHandle art）<br>   获得art插件组对象的复合形状模式。 </li><li>AIAPI AIErr（*     SetShapeMode）（AIArtHandle art，AIShapeMode mode）<br>   设置art插件组对象的复合形状模式。 </li><li>AIAPI AIErr（*     NewCompoundShape）（ai :: int16 paintOrder，AIArtHandle prep，AIArtHandle * newArt）<br>   在当前文档的art树的绘制顺序中的指定位置创建新的空复合形状。 </li><li>AIAPI AIErr（*     IsCompoundShape）（AIArtHandle art，AIBoolean * isCompoundShape）<br>   报告art品是否为复合形状。 </li><li>AIAPI AIErr（*     FlattenArt）（AIArtHandle * inOutArt）<br>   通过将Unite效果应用于每个组件art对象，将形状扩展为单个路径或复合路径。</li></ul><h2 id="相关类，结构体，指针"><a href="#相关类，结构体，指针" class="headerlink" title="相关类，结构体，指针"></a>相关类，结构体，指针</h2><h3 id="AIPathfinderData"><a href="#AIPathfinderData" class="headerlink" title="AIPathfinderData"></a>AIPathfinderData</h3><p>AIOptions     options<br>     Options that control how pathfinder operations are performed.<br>AIParameters     parameters<br>     Parameters for mixing and trapping operations.<br>AIArtHandle *     fSelectedArt<br>     A pointer to an array of selected art objects on which to perform the operation.<br>ai::int32     fSelectedArtCount<br>     The number of members of the fSelectedArt array.<br>ai::int32     fAlertInfoID<br>     Not used.   </p><h4 id="AIOptions"><a href="#AIOptions" class="headerlink" title="AIOptions"></a>AIOptions</h4><p>控制路径查找器操作执行方式的选项。<br>double     ipmPrecision<br>     Pathfinding precision, in microns.<br>ai::int32     removeRedundantPoints<br>     Nonzero to remove redundant points.<br>ai::int32     flags<br>     Option flags, a logical OR of AIOptionsFlagValues.</p><ul><li>AIOptionsFlagValues<ul><li>kExtractUnpaintedArtwork<br>设置后，从处理结果中删除未配色的图稿。  </li><li>kAllowEmptyOutput<br>当设置时，这些功能可以产生空的输出：<br>AIPathfinderSuite::DoBackMinusFrontEffect()，AIPathfinderSuite::DoFrontMinusBackEffect()，AIPathfinderSuite::DoIntersectEffect()，AIPathfinderSuite::DoExcludeEffect()。  </li><li>kIgnoreEvenOddFillRule<br>设置时，假设所有路径都使用非零填充规则而不是偶数填充规则。    </li><li>kSuppressProgressDialog<br>设置后，在路径查找器操作期间禁止进度报告。<br>适用于AI 13及更高版本。    </li><li>kDeselectResultArts<br>设置后，将取消选择结果对象。<br>适用于AI 13及更高版本。</li></ul></li></ul><h4 id="AIParameters"><a href="#AIParameters" class="headerlink" title="AIParameters"></a>AIParameters</h4><p>混合和捕获参数<br>AIMixParameters     mixParameters<br>     Parameters for mixing operations.<br>AITrapParameters     trapParameters<br>     Parameters for trapping operations.   </p><h5 id="AIMixParameters"><a href="#AIMixParameters" class="headerlink" title="AIMixParameters"></a>AIMixParameters</h5><p>double     softRate<br>     The percentage of visibility in overlapping colors.<br>ai::int32     convertCustomColors<br>     Nonzero to convert custom colors when mixing.   </p><h5 id="AITrapParameters"><a href="#AITrapParameters" class="headerlink" title="AITrapParameters"></a>AITrapParameters</h5><p>这些对应于Pathfinder调色板的Trap对话框中提供的UI值; 有关说明，请参阅用户文档<br>double     trapThickness<br>     Trap thickness, in points.<br>double     heightWidthAspectRatio<br>     Height to width aspect ratio.<br>double     trapTint<br>     Tint.<br>double     maximumTint<br>     Maximum tint (default is recommended).<br>double     tintTolerance<br>     Tint tolerance (default is recommended).<br>ai::int32     reverseTrap<br>     Nonzero to reverse trap.<br>ai::int32     convertCustomColors<br>     Nonzero to convert custom colors.   </p><h3 id="AIFilterMessage"><a href="#AIFilterMessage" class="headerlink" title="AIFilterMessage"></a>AIFilterMessage</h3><p>过滤器获取参数或Go选择器的消息。<br>SPMessageData     d<br>     The message data.<br>AIFilterHandle     filter<br>     The filter object.<br>PlatformFilterParameters     parameters<br>     The parameter values, in a developer-defined parameter structure.   </p><h4 id="SPMessageData"><a href="#SPMessageData" class="headerlink" title="SPMessageData"></a>SPMessageData</h4><p>ai::int32     SPCheck<br>     kSPValidSPMessageData if this is a valid PICA message.<br>struct SPPlugin *     self<br>     This plug-in, an SPPluginRef.<br>void *     globals<br>     An array of application-wide global variables.<br>struct SPBasicSuite *     basic<br>     A pointer to the basic PICA suite, which you use to obtain all other suites.   </p><h4 id="AIFilterHandle"><a href="#AIFilterHandle" class="headerlink" title="AIFilterHandle"></a>AIFilterHandle</h4><p>typedef struct _t_AIFilterOpaque *     AIFilterHandle<br>     Opaque reference to a filter. </p><h4 id="PlatformFilterParameters"><a href="#PlatformFilterParameters" class="headerlink" title="PlatformFilterParameters"></a>PlatformFilterParameters</h4><h2 id="使用实例-1"><a href="#使用实例-1" class="headerlink" title="使用实例"></a>使用实例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//arts已定义好的art对象数组</span><br><span class="line">list&lt;AIArtHandle&gt;::iterator artIT = arts.begin();</span><br><span class="line">if (artCount &gt; 1)&#123;</span><br><span class="line">AIArtHandle* artArr = (AIArtHandle *)(malloc(sizeof(AIArtHandle)*artCount));</span><br><span class="line">for (int i = 0; i &lt; artCount; i++)&#123;</span><br><span class="line">artArr[i] = *artIT;</span><br><span class="line">artIT++;</span><br><span class="line">&#125;</span><br><span class="line">AIFilterMessage message;</span><br><span class="line">AIPathfinderData findData;</span><br><span class="line">findData.fSelectedArt = artArr;</span><br><span class="line">findData.fSelectedArtCount = artCount;</span><br><span class="line">AIOptions option;</span><br><span class="line">option.ipmPrecision = 100;</span><br><span class="line">option.flags = kExtractUnpaintedArtwork;</span><br><span class="line">option.removeRedundantPoints = 1;</span><br><span class="line">findData.options = option;</span><br><span class="line">//应用排除效果</span><br><span class="line">sAIPathfinder-&gt;DoExcludeEffect(&amp;findData, &amp;message);</span><br><span class="line">delete[] artArr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h1><p><a href="/2019/03/14/ai-first-note">AI组件开发（一）–注记旋转矩阵</a><br><a href="/2019/03/18/ai-second-note">AI组件开发（二）–AIRealMathSuite</a><br><a href="/2019/03/24/ai-third-note">AI组件开发（三）–AIArtboardSuite</a><br><a href="/2019/03/24/ai-forth-document-note">AI组件开发（四）–AIDocumentSuite</a><br><a href="/2019/03/24/ai-fifth-ailayer-note">AI组件开发（五）–AILayerSuite</a><br><a href="/2019/03/24/ai-six-aiart-note">AI组件开发（六）–AIArtSuite</a><br><a href="/2019/03/25/ai-seven-path-note">AI组件开发（七）–AIPathSuite&amp;&amp;AIPathfinderSuite</a><br><a href="/2019/03/25/ai-eight-style-note">AI组件开发（八）–AIArtStyleSuite</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;AIPathSuite提供的功能允许检查和操作路径,AIPathfinderSuite提供了对路径执行操作的功能，这些功能将各种效果应用于选定的路径图&lt;br&gt;
    
    </summary>
    
      <category term="AI组件开发" scheme="http://11wy11.github.io/categories/AI%E7%BB%84%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="AI" scheme="http://11wy11.github.io/tags/AI/"/>
    
  </entry>
  
  <entry>
    <title>AI组件开发（六）--AIArtSuite</title>
    <link href="http://11wy11.github.io/2019/03/24/ai-six-aiart-note/"/>
    <id>http://11wy11.github.io/2019/03/24/ai-six-aiart-note/</id>
    <published>2019-03-24T13:43:22.000Z</published>
    <updated>2019-03-25T06:08:15.341Z</updated>
    
    <content type="html"><![CDATA[<p>Adobe Illustrator 文档中绘制的所有图形均为Art，相关操作函数在AIArtSuite中定义<br><a id="more"></a></p><h1 id="AIArtSuite"><a href="#AIArtSuite" class="headerlink" title="AIArtSuite"></a>AIArtSuite</h1><p>此套件允许您访问和修改Illustrator文档中的图稿。</p><p>它提供了创建和删除对象，重新排列对象以及获取和设置对象信息的功能。您可以使用这些函数来导航图形对象树，以及获得或修改有关图形对象的一般信息，例如它们的边界或锁定状态。</p><p>Art套件是实现大多数插件的基础。Illustrator文档由一个由a引用的图形对象的集合组成AIArtHandle。这是指向文档图稿数据库中图形对象的不透明指针。通过Art suite的访问器功能访问这些字段。</p><p>艺术对象可以表示单个实体，诸如路径，文本块或放置的图像，或一组对象，诸如路径的集合。艺术类型标识符（AIArtType）表示艺术品的类型。</p><p>使用SPBasicSuite::AcquireSuite()常量kAIArtSuite和使用获取此套件kAIArtVersion。</p><h2 id="注册声明"><a href="#注册声明" class="headerlink" title="注册声明"></a>注册声明</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//xxxSuites.h</span><br><span class="line">#include &quot;Suites.hpp&quot;</span><br><span class="line">#include &quot;AIArtConverter.h&quot;</span><br><span class="line">extern  &quot;C&quot; AAIArtSuite*sAIArt ;</span><br><span class="line"></span><br><span class="line">//xxxSuites.cpp</span><br><span class="line">extern &quot;C&quot;&#123;</span><br><span class="line">AIArtSuite*sAIArt = NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ImportSuite gImportSuites[] = &#123;</span><br><span class="line">    IMPORT_TEXT_SUITES</span><br><span class="line">    kAIArtSuite, kAIArtSuiteVersion, &amp;sAIArt,</span><br><span class="line">        nil, 0, nil</span><br><span class="line">      &#125;;</span><br></pre></td></tr></table></figure><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><ul><li>AIAPI AIErr（*     NewArt）（ai :: int16类型，ai :: int16 paintOrder，AIArtHandle prep，AIArtHandle * newArt）<br>   创建一个新的Art对象。 </li><li>AIAPI AIErr（*     DisposeArt）（AIArtHandle Art）<br>   从文档中删除Art对象。 </li><li>AIAPI AIErr（*     ReorderArt）（AIArtHandle thisArt，ai :: int16 paintOrder，AIArtHandle prep）<br>   更改Art对象的绘制顺序，或将路径移入或移出复合路径或组。 </li><li>AIAPI AIErr（*     DuplicateArt）（AIArtHandle thisArt，ai :: int16 paintOrder，AIArtHandle prep，AIArtHandle * newArt）<br>   使用深层复制复制Art对象（组和复合路径的子项也是重复的）。 </li><li>AIAPI AIErr（*     GetFirstArtOfLayer）（AILayerHandle图层，AIArtHandle *Art）<br>   获得图层中的第一个Art对象，该图层包含该图层中的所有Art。 </li><li>AIAPI AIErr（*     GetLayerOfArt）（AIArtHandle art，AILayerHandle *layer）<br>   获得Art对象的父图层（如果有）。 </li><li>AIAPI AIErr（*     GetArtType）（AIArtHandle art，short * type）<br>   获得Art对象的类型。 </li><li>AIAPI AIErr（*     GetArtUserAttr）（AIArtHandle art，ai :: int32 whichAttr，ai :: int32 * attr）<br>   获得Art对象的用户属性; 也就是说，标志显示它是被选中，隐藏还是被锁定。 </li><li>AIAPI AIErr（*     SetArtUserAttr）（AIArtHandle art，ai :: int32 whichAttr，ai :: int32 attr）<br>   设置对象的用户属性; 也就是说，标志显示它是被选中，隐藏还是被锁定。 </li><li>AIAPI AIErr（*     GetArtParent）（AIArtHandle art，AIArtHandle *parent）<br>   获得Art对象的父组。 </li><li>AIAPI AIErr（*     GetArtFirstChild）（AIArtHandle art，AIArtHandle *child）<br>   获得组对象的第一个子对象。 </li><li>AIAPI AIErr（*     GetArtSibling）（AIArtHandle art，AIArtHandle *sibling）<br>   获得同一组中的下一个对象。 </li><li>AIAPI AIErr（*     GetArtPriorSibling）（AIArtHandle art，AIArtHandle *sibling）<br>   获得同一组中的上一个对象。 </li><li>AIAPI AIErr（*     GetArtBounds）（AIArtHandle art，AIRealRect * bounds）<br>   获得Art对象的包围矩形。 </li><li>AIAPI AIErr（*     SetArtBounds）（AIArtHandle art）<br>   更新Art对象的封闭矩形（边界框）的缓存信息。 </li><li>AIAPI AIErr（*     GetArtCenterPointVisible）（AIArtHandle art，AIBoolean *visible）<br>   检查Art品的中心点是否可见。 </li><li>AIAPI AIErr（*     SetArtCenterPointVisible）（AIArtHandle art，AIBoolean visible）<br>   选择对象时，可以使Art品的中心点可见或不可见。 </li><li>AIAPI AIErr（*     GetArtTransformBounds）（AIArtHandle art，AIRealMatrix * transform，ai :: int32 flags，AIRealRect * bounds）<br>   应用变换矩阵后，获得Art对象的几何边界。 </li><li>AIAPI AIErr（*     UpdateArtworkLink）（AIArtHandle art，AIBoolean force，AIBoolean *updated）<br>   检查给定容器的子树中包含的任何链接对象（链接图像或放置对象）是否需要更新，并在需要时更新它们。 </li><li>AIAPI AIBoolean（*     ValidArt）（AIArtHandle art，AIBoolean searchAllLayerLists）<br>   如果Art对象引用有效，则返回true。 </li><li>AIAPI AIErr（*     GetArtOrder）（AIArtHandle art1，AIArtHandle art2，short * order）<br>   获取两个Art品的绘画顺序或遏制关系。 </li><li>AIAPI AIErr（*     SelectNamedArtOfLayer）（AILayerHandle图层，const ai :: UnicodeString＆name，AIBoolean matchWholeWord，AIBoolean caseSensitive）<br>   通过将字符串与Art对象注释的内容进行匹配来选择图层的指定图稿。 </li><li>AIAPI AIErr（*     GetArtRotatedBounds）（AIArtHandle art，AIReal angle，ai :: int32 flags，AIRealRect * bounds）<br>   旋转后获得Art对象的包围矩形。 </li><li>AIAPI AIBoolean（*     ArtHasFill）（AIArtHandle art）<br>   如果Art对象或后代对象绘制应被视为填充的内容，则返回true。 </li><li>AIAPI AIBoolean（*     ArtHasStroke）（AIArtHandle art）<br>   如果Art对象或后代对象绘制应被视为笔划的内容，则返回true。 </li><li>AIAPI AIBoolean（*     ArtsHaveEqualPaths）（AIArtHandle art1，AIArtHandle art2）<br>   如果两个Art对象除了组，路径和复合路径之外只包含其他内容，并且它们具有相同的几何（控制点），则返回true。 </li><li>AIAPI AIErr（*     ArtCopyFillStyleIfEqualPaths）（AIArtHandle dstArt，AIArtHandle srcArt）<br>   未在AI11及更高版本中实施; 回报kNotImplementedErr。 </li><li>AIAPI AIErr（*     ArtCopyStrokeStyleIfEqualPaths）（AIArtHandle dstArt，AIArtHandle srcArt）<br>   未在AI11及更高版本中实施; 回报kNotImplementedErr。 </li><li>AIAPI AIErr（*     GetInsertionPoint）（AIArtHandle * art，short * paintorder，AIBoolean * editable）<br>   获得文档的插入点。 </li><li>AIAPI AIErr（*     SetInsertionPoint）（AIArtHandle art）<br>   设置文档的插入点。 </li><li>AIAPI AIErr（*     GetKeyArt）（AIArtHandle *Art）<br>   获得对象对齐的关键对象。 </li><li>AIAPI AIErr（*     CancelKeyArt）（无效）<br>   清除对象对齐的关键对象。 </li><li>AIAPI AIErr（*     GetDictionary）（AIArtHandle art，struct _AIDictionary ** dictionary）<br>   获得与Art对象关联的字典。 </li><li>AIAPI AIErr（*     SetArtName）（AIArtHandle art，const ai :: UnicodeString＆name）<br>   设置Art对象的名称。 </li><li>AIAPI AIErr（*     GetArtName）（AIArtHandle art，ai :: UnicodeString＆name，ASBoolean * isDefaultName）<br>   获得Art对象的名称。 </li><li>AIAPI AIErr（*     IsArtLayerGroup）（AIArtHandle art，ASBoolean * isLayerGroup）<br>   报告Art对象是否是与图层或子图层对应的组。 </li><li>AIAPI AIErr（*     ReleaseToLayers）（常量AIArtHandle技术中，ASBoolean版本）<br>   将图层，组或插件组的元素释放到单独的图层。 </li><li>AIAPI AIErr（*     ModifyTargetedArtSet）（AIArtHandle * list，ai :: int32 count，ai :: int32 action）<br>   使用指定的操作修改文档中的目标对象集。 </li><li>AIAPI AIBoolean（*     IsArtStyledArt）（AIArtHandle art）<br>   如果art是另一个对象的样式Art的一部分，则返回true。 </li><li>AIAPI AIBoolean（*     IsArtClipping）（AIArtHandle art）<br>   如果art添加到剪辑，则返回true 。 </li><li>AIAPI AIErr（*     TransferAttributes）（AIArtHandle srcart，AIArtHandle dstart，ai :: uint32 which）<br>   将源Art对象的属性传输到目标Art对象。 </li><li>AIAPI AIErr（*     GetArtLastChild）（AIArtHandle art，AIArtHandle *child）<br>   获得容器Art对象的最后一个子项。 </li><li>AIAPI AIErr（*     SetArtTextWrapProperty）（AIArtHandle art，AIReal offset，AIBoolean invert）<br>   设置影响文本环绕文本换行对象的方式的属性; 也就是说，kArtIsTextWrap设置属性的那个。 </li><li>AIAPI AIErr（*     GetArtTextWrapProperty）（AIArtHandle art，AIReal * offset，AIBoolean * invert）<br>   获得影响文本环绕文本换行对象的方式的属性; 也就是说，kArtIsTextWrap设置属性的那个。 </li><li>AIAPI AIErr（*     CreateCopyScope）（枚举AICopyScopeKind类，AICopyScopeHandle *范围）<br>   创建并设置复制范围。 </li><li>AIAPI AIErr（*     DestroyCopyScope）（AICopyScopeHandle范围）<br>   取消并销毁复制范围。 </li><li>AIAPI AIErr（*     InsertionPointBadForArtType）（ai :: int16 paintOrder，AIArtHandle prep，ai :: int16 artType）<br>   检查在给定插入点处创建或插入给定类型的Art对象是否可以。 </li><li>AIAPI AIErr（*     PreinsertionFlightCheck）（AIArtHandle candidateArt，ai :: int16 paintOrder，AIArtHandle prep）<br>   根据插入上下文和候选Art的属性，检查是否可以在指定的插入点处插入Art对象或其副本，而无需实际尝试插入。 </li><li>AIAPI AIErr（*     SetNote）（AIArtHandle art，const ai :: UnicodeString＆inNote）<br>   设置Art对象的音符属性，该属性通常包含用户输入的文本。 </li><li>AIAPI AIErr（*     GetNote）（AIArtHandle art，ai :: UnicodeString＆outNote）<br>   获得Art对象的注释属性文本，该文本通常包含用户输入的文本。 </li><li>AIAPI AIBoolean（*     HasNote）（AIArtHandle art）<br>   检查Art品是否附有说明。 </li><li>AIAPI无效（*     删除注意）（AIArtHandle art）<br>   删除附加到Art对象的注释（如果有）。 </li><li>AIAPI AIErr（*     GetArtXMPSize）（AIArtHandle art，size_t * size）<br>   获取与Art对象关联的XMP元数据的大小。 </li><li>AIAPI AIErr（*     GetArtXMP）（AIArtHandle art，char * xmp，size_t size）<br>   获得与Art对象的XMP元数据关联的XML数据包。 </li><li>AIAPI AIErr（*     SetArtXMP）（AIArtHandle art，const char * xmp）<br>   设置Art对象的XMP元数据，替换任何现有数据。 </li><li>AIAPI AIErr（*     GetPreciseArtTransformBounds）（AIArtHandle art，AIRealMatrix * transform，ai :: int32 flags，AIDoubleRect * bounds）<br>   应用变换矩阵后，获得Art对象的几何边界。 </li><li>AIAPI AIErr（*     UncheckedDisposeArt）（AIArtHandle art）<br>   从Art树中删除Art对象，对输入的有效性进行最低限度检查，以便最大限度地提高性能。 </li><li>AIAPI AIErr（*     ArtIsGraph）（AIArtHandle art，AIBoolean * artisgraph）<br>   报告Art对象是否为图形对象类型。 </li><li>AIAPI AIErr（*     SetKeyArt）（AIArtHandle art）<br>   将Art设置为对象对齐的KeyArt。关键对象是其他对象对齐的对象。 </li><li>AIAPI AIErr（*     GetDrawingMode）（ai :: int32 * mode）<br>   获得当前文档的绘图模式。 </li><li>AIAPI AIErr（*     SetDrawingMode）（ai :: int32模式）<br>   设置当前文档的绘图模式。 </li><li>AIAPI AIErr（*     GetInsertionPointForDrawingMode）（ai :: int32模式，AIArtHandle * art，short * paintorder，AIBoolean * editable）<br>   根据绘图模式获得当前文档的插入点。 </li><li>AIAPI AIErr（*     GetInsertionPointForCurrentDrawingMode）（AIArtHandle * art，short * paintorder，AIBoolean * editable）<br>   根据当前绘图模式获得当前文档的插入点。 </li><li>AIAPI AIErr（*     GetPathPolarity）（AIArtHandle art，ai :: int32 * polarity）<br>   获得Art对象的路径极性。 </li><li>AIAPI AIBoolean（*     IsPixelPerfect）（AIArtHandle art）<br>   报告Art品是否处于像素完美模式。 </li><li>AIAPI AIErr（*     SetPixelPerfect）（AIArtHandle art，AIBoolean isPixelPerfect）<br>   为Art品打开或关闭像素完美模式。 </li><li>AIAPI AIBoolean（*     ObjectsAreEquivalent）（AIArtHandle art1，AIArtHandle art2）<br>   比较两个Art对象以确定它们在几何，外观属性和字典内容中是否等效。通常，一个对象在当前文档中，另一个在另一个文档中。 </li><li>AIAPI AIErr（*     IsArtALayerInSymbol）（AIArtHandle art，AIBoolean * isLayerInSymbol）<br>   报告Art对象是否充当符号模式中的图层。 </li><li>AIAPI AIErr（*     GetArtTimeStamp）（AIArtHandle art，size_t * timeStamp）<br>   获得Art对象的修改时间戳。 <h2 id="paintOrder-枚举常量"><a href="#paintOrder-枚举常量" class="headerlink" title="paintOrder 枚举常量"></a>paintOrder 枚举常量</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">typedef enum AIPaintOrder &#123;</span><br><span class="line">/* Default value */</span><br><span class="line">kPlaceDefault = 0,</span><br><span class="line">/** Place above the prepositional object */</span><br><span class="line">kPlaceAbove = 1,</span><br><span class="line">/** Place below the prepositional object */</span><br><span class="line">kPlaceBelow,</span><br><span class="line">/** Place within and at the top of the prepositional container */</span><br><span class="line">kPlaceInsideOnTop,</span><br><span class="line">/** Place within and at the bottom of the prepositional container */</span><br><span class="line">kPlaceInsideOnBottom,</span><br><span class="line">/** Place at the top of the paint order, ignoring prepositional object */</span><br><span class="line">kPlaceAboveAll,</span><br><span class="line">/** Place at the bottom of the paint order, ignoring prepositional object */</span><br><span class="line">kPlaceBelowAll</span><br><span class="line">&#125; AIPaintOrder;</span><br></pre></td></tr></table></figure></li></ul><h2 id="AIArtHandle"><a href="#AIArtHandle" class="headerlink" title="AIArtHandle"></a>AIArtHandle</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">typedef struct ArtObject* AIArtHandle</span><br><span class="line">Opaque reference to an art object.</span><br><span class="line"></span><br><span class="line">Access using AIArtSuite.</span><br></pre></td></tr></table></figure><h2 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">AIArtHandle artGroup = NULL;</span><br><span class="line">sAIArt-&gt;GetFirstArtOfLayer(PolygonLayer, &amp;artGroup);</span><br><span class="line">AIArtHandle art = NULL;</span><br><span class="line">sAIArt-&gt;NewArt(kPathArt, kPlaceInsideOnTop, artGroup, &amp;art);</span><br><span class="line">//setNote</span><br><span class="line">sAIArt-&gt;SetNote(&quot;该属性通常包含用户输入的文本。需要记录保存的信息，一般，号分割的字符串，不过插件一般使用Dictionary&quot;);</span><br><span class="line">//HasNote,GetNote</span><br><span class="line">if (sAIArt-&gt;HasNote(artGroup))&#123;</span><br><span class="line">ai::UnicodeString infoNote;</span><br><span class="line">sAIArt-&gt;GetNote(artGroup, infoNote);</span><br><span class="line">&#125;</span><br><span class="line">//DisposeArt</span><br><span class="line">sAIArt-&gt;DisposeArt(artGroup);</span><br><span class="line"></span><br><span class="line">//设置隐藏图层内容不可见</span><br><span class="line">AILayerHandle FirstLayer;</span><br><span class="line">AILayerHandle NextLayer = NULL;</span><br><span class="line"></span><br><span class="line">sAILayer-&gt;GetLayerFirstChild(m_hideLayer,&amp;FirstLayer);</span><br><span class="line">while(FirstLayer)</span><br><span class="line">&#123;</span><br><span class="line">AIArtHandle ArtGroup;</span><br><span class="line">AIArtHandle Art;</span><br><span class="line">sAIArt-&gt;GetFirstArtOfLayer(FirstLayer,&amp;ArtGroup);</span><br><span class="line">sAIArt-&gt;GetArtFirstChild(ArtGroup,&amp;Art);</span><br><span class="line"></span><br><span class="line">AILayerHandle LayerTemp;</span><br><span class="line">LayerTemp =  FirstLayer;</span><br><span class="line">sAILayer-&gt;GetNextLayer(FirstLayer,&amp;FirstLayer);</span><br><span class="line">if(!Art)</span><br><span class="line">sAILayer-&gt;DeleteLayer(LayerTemp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sAILayer-&gt;SetLayerVisible(m_hideLayer, false);</span><br><span class="line"></span><br><span class="line">AIRealRect artRect;</span><br><span class="line">   sAIArt-&gt;GetArtBounds(m_pointArt, &amp;artRect);</span><br><span class="line">   sAIMathSuite-&gt;AIRealMatrixSetTranslate(&amp;maxtrix, ListIter-&gt;h - (artRect.right + artRect.left) / 2, ListIter-&gt;v - (artRect.top + artRect.bottom) / 2);</span><br><span class="line">   sAITransformArt-&gt;TransformArt(m_pointArt, &amp;maxtrix, 1, kTransformObjects);</span><br><span class="line">   sAIArt-&gt;SetArtName(m_pointArt, ai::UnicodeString(&quot;XXXX&quot;));</span><br><span class="line">   </span><br><span class="line">   AIArtHandle textPathPoly = NULL;</span><br><span class="line">   AIArtHandle textFrame;//已存在变量</span><br><span class="line">   sAIArt-&gt;DuplicateArt(textFrame, kPlaceBelow,textFrame, &amp;textPathPoly);</span><br><span class="line">   AIArtHandle textFrameBackgroud;//已存在变量</span><br><span class="line">   sAIArt-&gt;ReorderArt(textFrameBackgroud, kPlaceInsideOnTop, ArtGroup);</span><br><span class="line">   </span><br><span class="line">   AIArtHandle outlines=NULL;</span><br><span class="line">   sAITextFrame-&gt;CreateOutline(textFrame, &amp;outlines);</span><br><span class="line">   </span><br><span class="line">   AIArtHandle outlinef=NULL,outlinen=NULL;</span><br><span class="line">   sAIArt-&gt;GetArtFirstChild(outlines, &amp;outlinef);</span><br><span class="line">   </span><br><span class="line">   //描边属性</span><br><span class="line">   AIPathStyle pathstyle;</span><br><span class="line">   pathstyle.fillPaint = false;</span><br><span class="line">   pathstyle.strokePaint = true;</span><br><span class="line">   AIStrokeStyle strokestyle;</span><br><span class="line">   strokestyle.width = this-&gt;borderWidth;</span><br><span class="line">   strokestyle.cap = kAIRoundCap;</span><br><span class="line">   strokestyle.join = kAIRoundJoin;</span><br><span class="line">   strokestyle.color = borderColor;</span><br><span class="line">   pathstyle.stroke = strokestyle;</span><br><span class="line">   </span><br><span class="line">   sAIPathStyle-&gt;SetPathStyle(outlinef, &amp;pathstyle);</span><br><span class="line">   </span><br><span class="line">   sAIArt-&gt;GetArtSibling(outlinef, &amp;outlinen); </span><br><span class="line">   </span><br><span class="line">   while (outlinen)</span><br><span class="line">   &#123;</span><br><span class="line">   sAIPathStyle-&gt;SetPathStyle(outlinen, &amp;pathstyle);</span><br><span class="line">   sAIArt-&gt;GetArtSibling(outlinen, &amp;outlinen);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   sAIArt-&gt;DisposeArt(textFrame);</span><br><span class="line">   //使用GetArtPriorSibling</span><br><span class="line">   // get the previous art</span><br><span class="line">    error = sArt-&gt;GetArtPriorSibling(art, &amp;art);</span><br><span class="line">    if (error) return error;</span><br><span class="line">    if (!art)&#123;</span><br><span class="line">            // art was first in group</span><br><span class="line">            // see if parent has previous art</span><br><span class="line">            error = sArt-&gt;GetArtParent(art, &amp;art);</span><br><span class="line">            if (error) return error;</span><br><span class="line">            ...</span><br><span class="line">   //使用GetArtParent  ,GetArtSibling</span><br><span class="line">     ...</span><br><span class="line">     // see if parent has sibling</span><br><span class="line">     error = sArt-&gt;GetArtParent(nextart, &amp;nextart);</span><br><span class="line">     if (error) return error;</span><br><span class="line">     error = sArt-&gt;GetArtSibling(nextart, &amp;nextart);</span><br><span class="line">     if (error) return error;</span><br><span class="line">     if (nextart) &#123;    // parent has sibling</span><br><span class="line">     ...</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><h1 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h1><p><a href="/2019/03/14/ai-first-note">AI组件开发（一）–注记旋转矩阵</a><br><a href="/2019/03/18/ai-second-note">AI组件开发（二）–AIRealMathSuite</a><br><a href="/2019/03/24/ai-third-note">AI组件开发（三）–AIArtboardSuite</a><br><a href="/2019/03/24/ai-forth-document-note">AI组件开发（四）–AIDocumentSuite</a><br><a href="/2019/03/24/ai-fifth-ailayer-note">AI组件开发（五）–AILayerSuite</a><br><a href="/2019/03/24/ai-six-aiart-note">AI组件开发（六）–AIArtSuite</a><br><a href="/2019/03/25/ai-seven-path-note">AI组件开发（七）–AIPathSuite&amp;&amp;AIPathfinderSuite</a><br><a href="/2019/03/25/ai-eight-style-note">AI组件开发（八）–AIArtStyleSuite</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Adobe Illustrator 文档中绘制的所有图形均为Art，相关操作函数在AIArtSuite中定义&lt;br&gt;
    
    </summary>
    
      <category term="AI组件开发" scheme="http://11wy11.github.io/categories/AI%E7%BB%84%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="AI" scheme="http://11wy11.github.io/tags/AI/"/>
    
  </entry>
  
  <entry>
    <title>AI组件开发（五）--AILayerSuite</title>
    <link href="http://11wy11.github.io/2019/03/24/ai-fifth-ailayer-note/"/>
    <id>http://11wy11.github.io/2019/03/24/ai-fifth-ailayer-note/</id>
    <published>2019-03-24T13:09:15.000Z</published>
    <updated>2019-03-25T06:08:15.517Z</updated>
    
    <content type="html"><![CDATA[<p>文档中的图稿包含在图层中。AILayerSuite有一堆图层列表。堆栈中最顶层的层是当前正在编辑的层<br><a id="more"></a></p><h1 id="AILayerSuite"><a href="#AILayerSuite" class="headerlink" title="AILayerSuite"></a>AILayerSuite</h1><p>每个图层都包含一组对象，可以包含子图层。所有文档都至少以一个图层开头，用户或插件可以向其添加任意数量的新图层。图层是图稿树的容器; 用于AIArtSuite::GetFirstArtOfLayer()获取属于图层的Art对象组。</p><p>除了包含图稿之外，图层还有一个名称，一种颜色（用于表示选定的art），以及指示其是可见，可编辑还是已锁定，可打印以及是否将放置的Art显示为灰色的状态标志。图层引用是不透明的; 使用此套件中的函数来获取和设置图层属性。</p><p>多个图层属性会影响图层上的图稿是否可编辑。通常，不能选择不可编辑图层上的对象，因此无需检查对当前选择进行操作的插件。但是，在迭代图层或图稿时，请GetLayerEditable()在尝试对图稿进行任何更改之前调用每个图层。</p><p>可以将图层指定为模板图层，其中包含用于指导文档图稿构造的模板图稿。例如，模板可能包含正在跟踪的图像。永远不会打印模板图层或将其导出为最终格式的文件格式。</p><p>有四个与图层关联的通知程序：<br>kAICurrentLayerNotifier<br>kAILayerDeletionNotifier<br>kAILayerSetNotifier<br>kAILayerOptionsNotifier</p><p>使用SPBasicSuite::AcquireSuite()常量kAILayerSuite和使用获取此套件kAILayerVersion。</p><h2 id="注册声明"><a href="#注册声明" class="headerlink" title="注册声明"></a>注册声明</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//xxxSuites.h</span><br><span class="line">#include &lt;AILayer.h&gt;</span><br><span class="line">extern  &quot;C&quot; AILayerSuite\*                sAILayer;</span><br><span class="line"></span><br><span class="line">//xxxSuites.cpp</span><br><span class="line">extern &quot;C&quot;&#123;</span><br><span class="line">AILayerSuite\*               sAILayer = NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ImportSuite gImportSuites[] = &#123;</span><br><span class="line">    IMPORT_TEXT_SUITES</span><br><span class="line">    kAILayerSuite, kAILayerSuiteVersion, &amp;sAILayer,</span><br><span class="line">        nil, 0, nil</span><br><span class="line">      &#125;;</span><br></pre></td></tr></table></figure><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><ul><li>AIAPI AIErr（*     CountLayers）（ai :: int32 * count）<br>   获取当前文档图层列表中的顶级图层数。 </li><li>AIAPI AIErr（*     GetNthLayer）（ai :: int32 n，AILayerHandle *layer）<br>   从当前文档中按索引获得顶级图层。 </li><li>AIAPI AIErr（*     GetCurrentLayer）（AILayerHandle *layer）<br>   获得当前文档中当前图层的引用。 </li><li>AIAPI AIErr（*     SetCurrentLayer）（AILayerHandle layer）<br>   使图层最新。 </li><li>AIAPI AIErr（*     GetFirstLayer）（AILayerHandle * first）<br>   获得当前文档图层列表的最顶层。 </li><li>AIAPI AIErr（*     GetNextLayer）（AILayerHandle prev，AILayerHandle * next）<br>   在堆叠顺序中获得给定图层下方的下一层，位于图层列表堆栈的同一级别。 </li><li>AIAPI AIErr（*     InsertLayer）（AILayerHandle layer，ai :: int16 paintOrder，AILayerHandle * newLayer）<br>   向文档添加新图层，将其插入到相对于现有图层的绘制顺序的图层列表中。 </li><li>AIAPI AIErr（*     DeleteLayer）（AILayerHandle layer）<br>   从当前文档中删除图层及其包含的所有图稿。 </li><li>AIAPI AIErr（*     GetLayerTitle）（AILayerHandle layer，ai :: UnicodeString＆title）<br>   获得图层的名称。 </li><li>AIAPI AIErr（*     SetLayerTitle）（AILayerHandle layer，const ai :: UnicodeString＆newTitle）<br>   设置图层的名称。 </li><li>AIAPI AIErr（*     GetLayerColor）（AILayerHandle layer，AIRGBColor *color）<br>   获得在图层中勾画选定图稿时使用的颜色。 </li><li>AIAPI AIErr（*     SetLayerColor）（AILayerHandle layer，AIRGBColor color）<br>   设置在图层中勾画选定图稿时使用的颜色。 </li><li>AIAPI AIErr（*     GetLayerVisible）（AILayerHandle layer，AIBoolean *visible）<br>   报告图层的可见性状态，这会影响是否绘制图稿。 </li><li>AIAPI AIErr（*     SetLayerVisible）（AILayerHandle layer，AIBoolean visible）<br>   设置图层的可见性状态，这会影响是否绘制图稿。 </li><li>AIAPI AIErr（*     GetLayerPreview）（AILayerHandle layer，AIBoolean *preview）<br>   报告图层是指定预览模式还是轮廓模式。 </li><li>AIAPI AIErr（*     SetLayerPreview）（AILayerHandle layer，AIBoolean preview）<br>   将图层设置为预览模式或轮廓模式。 </li><li>AIAPI AIErr（*     GetLayerEditable）（AILayerHandle layer，AIBoolean *editable）<br>   报告图层是可编辑还是已锁定。 </li><li>AIAPI AIErr（*     SetLayerEditable）（AILayerHandle layer，AIBoolean editable）<br>   设置图层是可编辑还是锁定。 </li><li>AIAPI AIErr（*     GetLayerPrinted）（AILayerHandle layer，AIBoolean *printed）<br>   报告在打印文档时是否将此图层视为可打印。 </li><li>AIAPI AIErr（*     SetLayerPrinted）（AILayerHandle layer，AIBoolean printed）<br>   设置打印文档时是否将此图层视为可打印。 </li><li>AIAPI AIErr（*     GetLayerDimPlacedImages）（AILayerHandle layer，AIBoolean * dimmed）<br>   报告渲染时图层中的图像是否变暗（颜色向白色移动）。 </li><li>AIAPI AIErr（*     SetLayerDimPlacedImages）（AILayerHandle layer，AIBoolean dimmed）<br>   设置渲染时图层中的图像是否变暗（颜色向白色移动）。 </li><li>AIAPI AIErr（*     GetLayerSelected）（AILayerHandle layer，AIBoolean *selected）<br>   报告是否选择了图层。 </li><li>AIAPI AIErr（*     SetLayerSelected）（AILayerHandle layer，AIBoolean selected）<br>   设置是否选择图层。 </li><li>AIAPI AIErr（*     GetLayerByTitle）（AILayerHandle *layer，const ai :: UnicodeString＆title）<br>   按标题获得图层。 </li><li>AIAPI AIErr（*     LayerHasArt）（AILayerHandle layer，AIBoolean * hasArt）<br>   报告图层是否包含子图层以外的对象。 </li><li>AIAPI AIErr（*     LayerHasSelectedArt）（AILayerHandle layer，AIBoolean * hasSel）<br>   报告图层是否包含任何选定的图稿。 </li><li>AIAPI AIErr（*     取消选择ArtOnLayer）（AILayerHandle layer）<br>   取消选择图层上的所有对象。 </li><li>AIAPI AIErr（*     SelectArtOnLayer）（AILayerHandle layer）<br>   选择可以选择的图层上的所有对象。 </li><li>AIAPI AIErr（*     GetLayerIsTemplate）（AILayerHandle layer，AIBoolean * isTemplate）<br>   报告图层是否为模板图层。 </li><li>AIAPI AIErr（*     SetLayerIsTemplate）（AILayerHandle layer，AIBoolean isTemplate）<br>   设置图层是否为模板图层。 </li><li>AIAPI AIErr（*     GetPrevLayer）（AILayerHandle接下来，AILayerHandle *prev）<br>   在堆叠顺序中获得给定图层上方的图层。 </li><li>AIAPI AIErr（*     GetLayerDimmedPercent）（AILayerHandle layer，ai :: int32 *percent）<br>   当图层设置为灰色时，获得用于绘制图像的调光因子。 </li><li>AIAPI AIErr（*     SetLayerDimmedPercent）（AILayerHandle layer，ai :: int32 percent）<br>   设置图层设置为灰色时用于绘制图像的调光系数。 </li><li>AIAPI AIErr（*     GetLayerFirstChild）（const AILayerHandle layer，AILayerHandle *child）<br>   获得图层的第一个子子图层。 </li><li>AIAPI AIErr（*     GetLayerParent）（const AILayerHandle layer，AILayerHandle * parent）<br>   获得图层的父级。 </li><li>AIAPI AIErr（*     InsertLayerAtArt）（const AIArtHandle art，AIPaintOrder paintOrder，AILayerHandle * newLayer）<br>   在相对于艺术对象的绘制顺序位置处将新图层插入到文档中。 </li><li>AIAPI AIErr（*     ChangeLayerToGroup）（const AILayerHandle layer，const AIArtHandle group）<br>   将此图层的子图层转换为简单组。 </li><li>AIAPI AIErr（*     GetNextPreorderLayer）（AILayerHandle prev，AILayerHandle * next）<br>   在前序遍历中获得下一层，首先查找后代，然后是兄弟姐妹。 </li><li>AIAPI AIErr（*     GetNextNonChildPreorderLayer）（AILayerHandle prev，AILayerHandle * next）<br>   在前序遍历中获得下一层，跳过后代并仅返回兄弟层。 <h2 id="paintOrder-枚举常量"><a href="#paintOrder-枚举常量" class="headerlink" title="paintOrder 枚举常量"></a>paintOrder 枚举常量</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">typedef enum AIPaintOrder &#123;</span><br><span class="line">/** Default value */</span><br><span class="line">kPlaceDefault = 0,</span><br><span class="line">/** Place above the prepositional object */</span><br><span class="line">kPlaceAbove = 1,</span><br><span class="line">/** Place below the prepositional object */</span><br><span class="line">kPlaceBelow,</span><br><span class="line">/** Place within and at the top of the prepositional container */</span><br><span class="line">kPlaceInsideOnTop,</span><br><span class="line">/** Place within and at the bottom of the prepositional container */</span><br><span class="line">kPlaceInsideOnBottom,</span><br><span class="line">/** Place at the top of the paint order, ignoring prepositional object */</span><br><span class="line">kPlaceAboveAll,</span><br><span class="line">/** Place at the bottom of the paint order, ignoring prepositional object */</span><br><span class="line">kPlaceBelowAll</span><br><span class="line">&#125; AIPaintOrder;</span><br></pre></td></tr></table></figure></li></ul><h2 id="AILayerHandle"><a href="#AILayerHandle" class="headerlink" title="AILayerHandle"></a>AILayerHandle</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _t_AILayerOpaque* AILayerHandle</span><br><span class="line">Opaque reference to a layer.</span><br></pre></td></tr></table></figure><h2 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">//使用InsertLayer，SetLayerTitle，GetLayerByTitle，DeleteLayer</span><br><span class="line">AILayerHandle m_pointLinePolyLayer;</span><br><span class="line">AILayerHandle m_borderMarkLayer;</span><br><span class="line">sAILayer-&gt;InsertLayer(m_pointLinePolyLayer, kPlaceInsideOnTop, &amp;m_borderMarkLayer);//在点线面图层上添加色带图层</span><br><span class="line">sAILayer-&gt;SetLayerTitle(m_borderMarkLayer, ai::UnicodeString(&quot;色带图层&quot;));//设置新添加图层名称</span><br><span class="line">AILayerHandle polyAnnoLayers;</span><br><span class="line">sAILayer-&gt;GetLayerByTitle(&amp;polyAnnoLayers, ai::UnicodeString(L&quot;面注记图层&quot;));//找到名为面注记图层的layer</span><br><span class="line">sAILayer-&gt;DeleteLayer(polyAnnoLayers);//删除面注记图层layer</span><br><span class="line"></span><br><span class="line">//使用GetLayerFirstChild，GetNextLayer</span><br><span class="line">AILayerHandle m_hideLayer;</span><br><span class="line">AILayerHandle FirstLayer;</span><br><span class="line">AILayerHandle NextLayer = NULL;</span><br><span class="line">sAILayer-&gt;GetLayerFirstChild(m_hideLayer,&amp;FirstLayer);</span><br><span class="line">//遍历如果存在图稿，则删除该图层</span><br><span class="line">while(FirstLayer)</span><br><span class="line">&#123;</span><br><span class="line">AIArtHandle ArtGroup;</span><br><span class="line">AIArtHandle Art;</span><br><span class="line">sAIArt-&gt;GetFirstArtOfLayer(FirstLayer,&amp;ArtGroup);</span><br><span class="line">sAIArt-&gt;GetArtFirstChild(ArtGroup,&amp;Art);</span><br><span class="line"></span><br><span class="line">AILayerHandle LayerTemp;</span><br><span class="line">LayerTemp =  FirstLayer;</span><br><span class="line">sAILayer-&gt;GetNextLayer(FirstLayer,&amp;FirstLayer);</span><br><span class="line">if(!Art)</span><br><span class="line">sAILayer-&gt;DeleteLayer(LayerTemp);</span><br><span class="line">&#125;</span><br><span class="line">sAILayer-&gt;SetLayerVisible(m_hideLayer, false);</span><br><span class="line"></span><br><span class="line">//使用GetNthLayer获得最上面的图层</span><br><span class="line">AILayerHandle hideLayer = NULL;</span><br><span class="line">    sAILayer-&gt;GetNthLayer(0, &amp;hideLayer);</span><br><span class="line">    AILayerHandle childHideLayer = NULL;</span><br></pre></td></tr></table></figure><h1 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h1><p><a href="/2019/03/14/ai-first-note">AI组件开发（一）–注记旋转矩阵</a><br><a href="/2019/03/18/ai-second-note">AI组件开发（二）–AIRealMathSuite</a><br><a href="/2019/03/24/ai-third-note">AI组件开发（三）–AIArtboardSuite</a><br><a href="/2019/03/24/ai-forth-document-note">AI组件开发（四）–AIDocumentSuite</a><br><a href="/2019/03/24/ai-fifth-ailayer-note">AI组件开发（五）–AILayerSuite</a><br><a href="/2019/03/24/ai-six-aiart-note">AI组件开发（六）–AIArtSuite</a><br><a href="/2019/03/25/ai-seven-path-note">AI组件开发（七）–AIPathSuite&amp;&amp;AIPathfinderSuite</a><br><a href="/2019/03/25/ai-eight-style-note">AI组件开发（八）–AIArtStyleSuite</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;文档中的图稿包含在图层中。AILayerSuite有一堆图层列表。堆栈中最顶层的层是当前正在编辑的层&lt;br&gt;
    
    </summary>
    
      <category term="AI组件开发" scheme="http://11wy11.github.io/categories/AI%E7%BB%84%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="AI" scheme="http://11wy11.github.io/tags/AI/"/>
    
  </entry>
  
  <entry>
    <title>AI组件开发（四）--AIDocumentSuite</title>
    <link href="http://11wy11.github.io/2019/03/24/ai-forth-document-note/"/>
    <id>http://11wy11.github.io/2019/03/24/ai-forth-document-note/</id>
    <published>2019-03-24T12:19:52.000Z</published>
    <updated>2019-03-25T06:08:15.405Z</updated>
    
    <content type="html"><![CDATA[<p>获取和设置有关当前文档的信息。<br><a id="more"></a></p><h1 id="AIDocumentSuite"><a href="#AIDocumentSuite" class="headerlink" title="AIDocumentSuite"></a>AIDocumentSuite</h1><p>使用这些函数可以获取和设置有关当前文档的信息。<br>某些功能仅在读取文件格式时适用。有些是在文件格式写入期间使用，但可以随时使用。</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><ul><li>AIAPI AIErr（*     GetDocumentFileSpecification）（ai :: FilePath＆file）<br>   获得当前文档的文件规范。 </li><li>AIAPI AIErr（*     GetDocumentPageOrigin）（AIRealPoint * origin）<br>   获得相对于标尺原点指定的可成像页面左下角的坐标。 </li><li>AIAPI AIErr（*     SetDocumentPageOrigin）（AIRealPoint * origin）<br>   设置可成像页面左下角的坐标。 </li><li>AIAPI AIErr（*     SetDocumentRulerOrigin）（AIRealPoint * origin）<br>   设置当前文档的标尺原点。 </li><li>AIAPI AIErr（*     GetDocumentRulerUnits）（ai :: int16 *units）<br>   获得当前测量单位，显示在标尺中并显示在对话框中。 </li><li>AIAPI AIErr（*     SetDocumentRulerUnits）（ai :: int16 units）<br>   设置当前测量单位，显示在标尺中并显示在对话框中。 </li><li>AIAPI AIErr（*     GetDocumentCropStyle）（AICropMarkStyle * cropStyle）<br>   获得由“创建裁剪标记”命令和过滤器创建的裁剪标记的样式。 </li><li>AIAPI AIErr（*     SetDocumentCropStyle）（AICropMarkStyle cropStyle）<br>   设置“创建裁剪标记”命令和过滤器创建的裁剪标记的样式。 </li><li>AIAPI AIErr（*     GetDocumentSetup）（AIDocumentSetup * setup）<br>   获得有关通过文档“设置”对话框设置的当前文档的信息。 </li><li>AIAPI AIErr（*     SetDocumentSetup）（AIDocumentSetup * setup）<br>   设置文档设置信息，通过文档设置对话框设置。 </li><li>AIAPI AIErr（*     GetDocumentModified）（AIBoolean * modified）<br>   获得文档自上次保存以来是否已被编辑。 </li><li>AIAPI AIErr（*     SetDocumentModified）（AIBoolean修改）<br>   设置当前文档的修改状态。 </li><li>AIAPI AIErr（*     GetDocumentFileFormat）（AIFileFormatHandle * fileFormat）<br>   获得保存当前文档时要使用的文件格式。 </li><li>AIAPI AIErr（*     SetDocumentFileFormat）（AIFileFormatHandle fileFormat）<br>   设置保存当前文档时要使用的文件格式。 </li><li>AIAPI AIErr（*     GetDocumentFileFormatParameters）（AIDocumentFileFormatParameters *参数）<br>   获得与当前文档的关联文件格式关联的用户参数块。 </li><li>AIAPI AIErr（*     SetDocumentFileFormatParameters）（AIDocumentFileFormatParameters参数）<br>   设置与当前文档的关联文件格式关联的用户参数块。 </li><li>AIAPI AIErr（*     GetDocument）（AIDocumentHandle *文件）<br>   获得当前文档的不透明引用，以便与可以对当前文档以外的文档进行操作的函数一起使用。 </li><li>AIAPI AIErr（*     WriteDocument）（const ai :: FilePath＆file，const char * fileFormatName，AIBoolean askForParms）<br>   将当前文档写入文件而不修改文档或更改其修改状态。 </li><li>AIAPI AIErr（*     GetDocumentMiPrintRecord）（AIDocumentMiPrintRecordPtr打印）<br>   获得当前文档的打印记录。 </li><li>AIAPI AIErr（*     GetDocumentRulerOrigin）（AIRealPoint * origin）<br>   获得当前文档的标尺原点。 </li><li>AIAPI AIErr（*     UpdateLinks）（AIBoolean * updatedSomething）<br>   如果需要，更新当前文档中的链接对象。 </li><li>AIAPI AIErr（*     GetDocumentZoomLimit）（AIReal * min，AIReal * max）<br>   获得缩放的限制作为比例因子。 </li><li>AIAPI AIErr（*     GetDocumentMaxArtboardBounds）（AIRealRect * bounds）<br>   获得任何画板的最大有效范围，相对于当前文档的标尺原点表示，而不管文档画板的当前大小。 </li><li>AIAPI AIErr（*     DocumentExists）（AIDocumentHandle文档，AIBoolean *exists）<br>   报告文件是否存在; 也就是说，是一个打开的文档或剪贴板文档。 </li><li>AIAPI AIErr（*     GetDictionary）（struct _AIDictionary **Dictionary）<br>   获得与当前文档关联的录制Dictionary。 </li><li>AIAPI AIErr（*     GetDocumentColorModel）（ai :: int16 * colorModel）<br>   获得文档颜色模型。 </li><li>AIAPI AIErr（*     SetDocumentColorModel）（ai :: int16 colorModel）<br>   在加载时设置文档的预期颜色模型。 </li><li>AIAPI AIErr（*     GetDocumentProfiles）（AIColorProfile * rgbProfile，AIColorProfile * cmykProfile，AIColorProfile * grayProfile）<br>   获得当前文档的颜色校准配置文件。 </li><li>AIAPI AIErr（*     SetDocumentProfiles）（AIColorProfile rgbProfile，AIColorProfile cmykProfile，AIColorProfile grayProfile）<br>   设置当前文档的颜色校准配置文件。 </li><li>AIAPI AIErr（*     Copy）（）<br>   将当前选定的对象复制到剪贴板。 </li><li>AIAPI AIErr（*     Cut）（）<br>   将当前选定的对象剪切到剪贴板。 </li><li>AIAPI AIErr（*     Paste）（）<br>   将剪贴板的内容粘贴到文档中。 </li><li>AIAPI AIErr（* AIDocumentSuite :: SyncDocument）<br>更新缓存的图稿属性。<br>例如，组的选择状态被缓存，并根据其子项的状态确定。您通常不需要调用此函数。Illustrator会根据需要重新计算缓存的属性。</li><li>AIAPI AIErr（*     GetNonRecordedDictionary）（struct _AIDictionary **Dictionary）<br>   获得与当前文档关联的未记录Dictionary。 </li><li>AIAPI int（*     GetAIVersion）（）<br>   获得上次保存当前文档的Illustrator文件格式的版本。 </li><li>AIAPI AIErr（*     DocumentHasTransparency）（AIBoolean * hasTransparency，AIBoolean detectOverprint）<br>   报告是否根据当前视图设置渲染当前文档需要任何非不透明的绘制操作。 </li><li>AIAPI AIErr（*     DocumentHasSpotColorArt）（AIBoolean * hasSpotColorArt）<br>   报告是否根据当前视图设置渲染当前文档需要绘制任何专色。 </li><li>AIAPI AIErr（*     GetDocumentAssetMgmtInfo）（AIBoolean * managed，ai :: int32 * pNAlternates，AIBoolean * checkedOut，const char ** URL，AIBoolean * canEdit，char * fileType）<br>   获得资产管理信息。 </li><li>AIAPI AIErr（*     SetDocumentAssetMgmtInfo）（AIBoolean * managed，AIBoolean * checkedOut，const char * URL，AIBoolean * canEdit）<br>   设置资产管理信息。 </li><li>AIAPI AIErr（*     GetDocumentURL）（AIDocumentHandle文档，const char ** URL）<br>   获得与文档关联的URL。 </li><li>AIAPI AIErr（*     GetDocumentXAP）（const char ** xap）<br>   获得当前文档的XMP元数据。 </li><li>AIAPI AIErr（*     SetDocumentXAP）（const char * xap）<br>   设置当前文档的XMP元数据。 </li><li>AIAPI AIErr（*     SuspendTextReflow）（）<br>   暂停当前​​文档中所有文本对象的任何文本重排。 </li><li>AIAPI AIErr（*     ResumeTextReflow）（）<br>   恢复文本重排。 </li><li>AIAPI AIErr（*     GetTextSelection）（TextRangesRef * pTextSelection）<br>   获得当前文档的文本选择对象。 </li><li>AIAPI AIErr（*     HasTextFocus）（AIBoolean * focus）<br>   报告当前文档是否处于文本编辑模式。 </li><li>AIAPI AIErr（*     HasTextCaret）（AIBoolean * caret）<br>   报告当前文档是处于文本编辑模式还是插入符号闪烁（与选择的文本范围相反）。 </li><li>AIAPI AIErr（*     GetTextFocus）（StoryRef * pStory）<br>   获得处于编辑模式的当前故事。 </li><li>AIAPI AIErr（*     SetTextFocus）（StoryRef故事）<br>   将故事设置为处于编辑模式。 </li><li>AIAPI AIErr（*     LoseTextFocus）（）<br>   退出文本编辑模式。 </li><li>AIAPI AIErr（*     GetDocumentTextResources）（DocumentTextResourcesRef * pDocResources）<br>   获得当前文档的文本资源对象。 </li><li>AIAPI AIErr（*     WriteDocumentMacInformationResource）（const ai :: FilePath＆file）</li><li>AIAPI AIErr（*     WriteDocumentWithOptions）（const ai :: FilePath＆file，const char * fileFormatName，ai :: int32 options，AIBoolean askForParms）<br>   将当前文档写入具有指定写入选项的文件，而不修改文档或更改其修改状态。 </li><li>AIAPI AIErr（*     DocumentHasOverprint）（AIBoolean * hasOverprint）<br>   报告是否根据当前视图设置呈现当前文档需要绘制任何叠印对象。 </li><li>AIAPI AIErr（*     DocumentHasManagedLinks）（AIDocumentHandle文档，AIBoolean * hasManagedLinks）<br>   报告文档是否包含任何托管链接。 </li><li>AIAPI AIErr（*     GetDocumentSpotColorMode）（AIDocumentHandle文档，AISpotColorMode *模式）<br>   获得文档的专色模式，该模式控制添加到文档的新专色的外观定义。 </li><li>AIAPI AIErr（*     SetDocumentSpotColorMode）（AIDocumentHandle文档，AISpotColorMode模式，AIBoolean转换，AIBoolean *转换）<br>   设置文档的专色模式，该模式控制添加到文档的新专色的外观定义。 </li><li>AIAPI AIErr（*     撤消）（）<br>   撤消最近的可撤消事务。 </li><li>AIAPI AIErr（*     重做）（）<br>   重做最近的可重做事务。 </li><li>AIAPI AIErr（*     DocumentRasterAttributes）（AIBoolean * hasDeviceNRasters，AIBoolean * hasOverprint）<br>   报告当前文档是否包含任何DeviceN或叠印栅格。 </li><li>AIAPI AIErr（*     GetDocumentStartupProfile）（AIDocumentHandle文档，AIDocumentStartupProfile * startupProfile）<br>   获得文档启动配置文件。 </li><li>AIAPI AIErr（*     GetDocumentBleeds）（AIRealRect * bleedOffset）<br>   获得文档的bleedOffset。 </li><li>AIAPI AIErr（*     SetDocumentBleeds）（const AIRealRect＆bleedOffset）<br>   设置文档的bleedOffset。 </li><li>AIAPI AIErr（*     SetDocumentPixelPerfectStatus）（AIBoolean isPixelPerfect）<br>   打开或关闭文档的Pixel Perfect模式。 </li><li>AIAPI AIBoolean（*     GetDocumentPixelPerfectStatus）（）<br>   报告文档当前是否处于Pixel Perfect模式。 <h2 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h2></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//xxxSuites.h</span><br><span class="line">#include &lt;AIDocument.h&gt;</span><br><span class="line">extern&quot;C&quot; AIDocumentSuite*sAIDocument;</span><br><span class="line"></span><br><span class="line">//xxxSuites.cpp</span><br><span class="line">extern &quot;C&quot;&#123;</span><br><span class="line">AIDocumentSuite*sAIDocument = NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ImportSuite gImportSuites[] = &#123;</span><br><span class="line">    IMPORT_TEXT_SUITES</span><br><span class="line">    kAIDocumentSuite, kAIDocumentSuiteVersion, &amp;sAIDocument,</span><br><span class="line">        nil, 0, nil</span><br><span class="line">      &#125;;</span><br><span class="line">//XXXPlugin.cpp</span><br><span class="line">//绘制操作</span><br><span class="line">sAIDocument-&gt;SyncDocument();//更新图稿属性</span><br><span class="line">TextRangesRef rangesRef = NULL;</span><br><span class="line">sAIDocument-&gt;GetTextSelection(&amp;rangesRef);//获得当前文档的文本选择对象</span><br></pre></td></tr></table></figure><h1 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h1><p><a href="/2019/03/14/ai-first-note">AI组件开发（一）–注记旋转矩阵</a><br><a href="/2019/03/18/ai-second-note">AI组件开发（二）–AIRealMathSuite</a><br><a href="/2019/03/24/ai-third-note">AI组件开发（三）–AIArtboardSuite</a><br><a href="/2019/03/24/ai-forth-document-note">AI组件开发（四）–AIDocumentSuite</a><br><a href="/2019/03/24/ai-fifth-ailayer-note">AI组件开发（五）–AILayerSuite</a><br><a href="/2019/03/24/ai-six-aiart-note">AI组件开发（六）–AIArtSuite</a><br><a href="/2019/03/25/ai-seven-path-note">AI组件开发（七）–AIPathSuite&amp;&amp;AIPathfinderSuite</a><br><a href="/2019/03/25/ai-eight-style-note">AI组件开发（八）–AIArtStyleSuite</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;获取和设置有关当前文档的信息。&lt;br&gt;
    
    </summary>
    
      <category term="AI组件开发" scheme="http://11wy11.github.io/categories/AI%E7%BB%84%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="AI" scheme="http://11wy11.github.io/tags/AI/"/>
    
  </entry>
  
  <entry>
    <title>AI组件开发（三）--AIArtboardSuite</title>
    <link href="http://11wy11.github.io/2019/03/24/ai-third-note/"/>
    <id>http://11wy11.github.io/2019/03/24/ai-third-note/</id>
    <published>2019-03-24T08:53:24.000Z</published>
    <updated>2019-03-25T06:08:15.567Z</updated>
    
    <content type="html"><![CDATA[<p>AIArtboardSuite此套件提供的实用程序允许在文档中创建和操作Artboards。相关类ArtboardProperties和ArtboardList<br><a id="more"></a></p><h1 id="AIArtboardSuite"><a href="#AIArtboardSuite" class="headerlink" title="AIArtboardSuite"></a>AIArtboardSuite</h1><p>此套件提供的实用程序允许您在文档中创建和操作画板Artboards。文档与ArtboardList包含多个Artboard对象的对象相关联，每个ArtboardProperties对象与对象相关联。</p><p>建议您使用的包装类，ai::ArtboardProperties和ai::ArtboardList而不是直接调用这些功能。</p><p>使用SPBasicSuite::AcquireSuite()常量kAIArtboardSuite和使用获取此套件kAIArtboardSuiteVersion。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//xxxSuites.h</span><br><span class="line">#include &quot;AIArtboard.h&quot;</span><br><span class="line">extern&quot;C&quot; AIArtboardSuite*sAIArtboard;</span><br><span class="line"></span><br><span class="line">//xxxSuites.cpp</span><br><span class="line">extern &quot;C&quot;&#123;</span><br><span class="line">AIArtboardSuite*sAIArtboard = NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ImportSuite gImportSuites[] = &#123;</span><br><span class="line">    IMPORT_TEXT_SUITES</span><br><span class="line">    kAIArtboardSuite, kAIArtboardSuiteVersion, &amp;sAIArtboard,</span><br><span class="line">        nil, 0, nil</span><br><span class="line">      &#125;;</span><br></pre></td></tr></table></figure></p><!-- START doctoc generated TOC please keep comment here to allow auto update --><!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE --><p><strong>目录</strong>  <em>generated with <a href="https://github.com/thlorenz/doctoc" target="_blank" rel="noopener">DocToc</a></em></p><ul><li><a href="#addnew">AddNew</a></li><li><a href="#cloneartboard">CLoneArtboard</a></li><li><a href="#3delete">3.Delete</a></li><li><a href="#4dispose">4.Dispose</a></li><li><a href="#5getactive">5.GetActive</a></li><li><a href="#6getartboardproperties">6.GetArtboardProperties</a></li><li><a href="#7getcount">7.GetCount</a></li><li><a href="#8getname">8.GetName</a></li><li><a href="#9getpar">9.GetPAR</a></li><li><a href="#10getposition">10.GetPosition</a></li><li><a href="#11getrulerorigin">11.GetRulerOrigin</a></li><li><a href="#12getshowdisplaymark">12.GetShowDisplayMark</a></li><li><a href="#13init">13.Init</a></li><li><a href="#14insert">14.Insert</a></li><li><a href="#15isdefaultname">15.IsDefaultName</a></li><li><a href="#16releaseartboardlist">16.ReleaseArtboardList</a></li><li><a href="#17-setactive">17. SetActive</a></li><li><a href="#18setisdefaultname">18.SetIsDefaultName</a></li><li><a href="#19setname">19.SetName</a></li><li><a href="#20setpar">20.SetPAR</a></li><li><a href="#21setposition">21.SetPosition</a></li><li><a href="#22setrulerorigin">22.SetRulerOrigin</a></li><li><a href="#23setshowdisplaymark">23.SetShowDisplayMark</a></li><li><a href="#24update">24.Update</a></li></ul><!-- END doctoc generated TOC please keep comment here to allow auto update --><h2 id="AddNew"><a href="#AddNew" class="headerlink" title="AddNew"></a>AddNew</h2><p>AIAPI AIErr（* AIArtboardSuite :: AddNew）（ai :: ArtboardList＆artboardList，ai :: ArtboardProperties＆newArtboard，ai :: ArtboardID ＆index）<br>将新画板添加到当前文档并在画板列表中报告其索引位置。</p><ul><li>参数：<br>  artboardList     画板列表对象。<br>  newArtboard     新画板的属性对象。<br>  index     <strong>[out]</strong>一个缓冲区，用于返回新画板的从0开始的索引位置。  </li><li>返回：<br>  kAIExceededMaxArtboardLimitErr列表大小超过应用程序定义的限制时的错误。  </li></ul><p>参考ai :: ArtboardList :: AddNew（）</p><h2 id="CLoneArtboard"><a href="#CLoneArtboard" class="headerlink" title="CLoneArtboard"></a>CLoneArtboard</h2><p>AIAPI AIErr（* AIArtboardSuite :: CloneArtboard）（ai :: ArtboardProperties &amp;artboard，const ai :: ArtboardProperties &amp;newArtboard）<br>复制画板对象。</p><ul><li>参数：<br>  artboard     artboard属性要克隆。<br>  newArtboard     <strong>[out]</strong>用于返回新画图属性对象。 </li></ul><p>参考ai :: ArtboardProperties :: ArtboardProperties()</p><h2 id="3-Delete"><a href="#3-Delete" class="headerlink" title="3.Delete"></a>3.Delete</h2><p>AIAPI AIErr（* AIArtboardSuite ::Delete）（ai :: ArtboardList &amp;artboardList，ai :: ArtboardID &amp;index）<br>从画板列表中删除画板，并使列表中的下一个画板处于活动状态。</p><p>无法删除最后一个画板。</p><ul><li>参数：<br>  artboardList     画板列表对象。<br>  index     要从列表中删除的画板的从0开始的索引位置。  </li><li>返回：<br>  kAICantDeleteLastArtboardErr如果您尝试删除最后一个画板时出现错误。  </li></ul><p>参考ai::ArtboardList::Delete()。</p><h2 id="4-Dispose"><a href="#4-Dispose" class="headerlink" title="4.Dispose"></a>4.Dispose</h2><p>AIAPI AIErr(* AIArtboardSuite::Dispose)(ai::ArtboardProperties &amp;properties)<br>释放画板属性对象。</p><ul><li>参数：<br>properties     画板属性对象。    </li></ul><p>参考ai :: ArtboardProperties :: ~ArtboardProperties（）</p><h2 id="5-GetActive"><a href="#5-GetActive" class="headerlink" title="5.GetActive"></a>5.GetActive</h2><p>AIAPI AIErr（* AIArtboardSuite :: GetArtboardList）（ai :: ArtboardList ＆artboardList）<br>获得当前文档的画板列表。</p><ul><li>参数：<br> artboardList     <strong>[out]</strong>用于返回画板列表对象的引用。   </li></ul><p>参考ai :: ArtboardList :: ArtboardList（）。</p><h2 id="6-GetArtboardProperties"><a href="#6-GetArtboardProperties" class="headerlink" title="6.GetArtboardProperties"></a>6.GetArtboardProperties</h2><p>AIAPI AIErr（* AIArtboardSuite :: GetArtboardProperties）（ai :: ArtboardList &amp;artboardList，ai :: ArtboardID index，ai :: ArtboardProperties &amp;properties）<br>从画板列表中获得画板的属性。</p><p>使用GetCount()和Update()修改画板而不更改文档中哪个画板处于活动状态。</p><ul><li>参数：<br>  artboardList     画板列表对象。<br>  index     列表中画板的从0开始的索引位置。<br>  properties     <strong>[out]</strong>用于返回画板属性对象。出错时，返回无效对象</li><li>使用：    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ai::ArtboardProperties tempArtboardProperties;</span><br><span class="line">ai::ArtboardList tempoartboardList;</span><br><span class="line">sAIArtboard-&gt;GetArtboardList(tempoartboardList);</span><br><span class="line">sAIArtboard-&gt;GetArtboardProperties(tempoartboardList, 0, tempArtboardProperties);</span><br></pre></td></tr></table></figure></li></ul><h2 id="7-GetCount"><a href="#7-GetCount" class="headerlink" title="7.GetCount"></a>7.GetCount</h2><p>AIAPI AIErr（* AIArtboardSuite :: GetCount）（const ai :: ArtboardList &amp;artboardList，ai :: ArtboardID &amp;count）<br>获得画板列表中定义的画板数量。</p><ul><li>参数：<br>  artboardList     画板列表对象。<br>  count     <strong>[out]</strong>用于返回画板数量。</li></ul><p>参考ai :: ArtboardList :: GetCount（）。</p><h2 id="8-GetName"><a href="#8-GetName" class="headerlink" title="8.GetName"></a>8.GetName</h2><p>AIAPI AIErr(* AIArtboardSuite::GetName)(const ai::ArtboardProperties &amp; properties, ai::UnicodeString &amp;name)</p><h2 id="9-GetPAR"><a href="#9-GetPAR" class="headerlink" title="9.GetPAR"></a>9.GetPAR</h2><p>AIAPI AIErr(* AIArtboardSuite::GetPAR)(const ai::ArtboardProperties &amp;properties, AIReal &amp;par)<br>获得画板标尺的像素长宽比。</p><ul><li>参数：<br>  properties     画板属性对象。<br>  par     <strong>[out]</strong>用于返回像素宽高比。</li><li>实例：  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ai::ArtboardProperties tempArtboardProperties;</span><br><span class="line">ai::ArtboardList tempoartboardList;</span><br><span class="line">sAIArtboard-&gt;GetArtboardList(tempoartboardList);</span><br><span class="line">sAIArtboard-&gt;GetArtboardProperties(tempoartboardList, 0, tempArtboardProperties);</span><br><span class="line">AIReal artPar;</span><br><span class="line">sAIArtboard-&gt;GetPAR(tempArtboardProperties,artPar)</span><br></pre></td></tr></table></figure></li></ul><h2 id="10-GetPosition"><a href="#10-GetPosition" class="headerlink" title="10.GetPosition"></a>10.GetPosition</h2><p>AIAPI AIErr（* AIArtboardSuite :: GetPosition）（const ai :: ArtboardProperties＆properties，AIRealRect＆bounds）<br>获得画板的位置和边界。</p><ul><li>参数：<br>  properties     画板属性对象。<br>  bounds     <strong>[out]</strong>一个矩形对象，用于返回画板的位置和边界。</li><li>实例：  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ai::ArtboardProperties tempArtboardProperties;</span><br><span class="line">ai::ArtboardList tempoartboardList;</span><br><span class="line">sAIArtboard-&gt;GetArtboardList(tempoartboardList);</span><br><span class="line">sAIArtboard-&gt;GetArtboardProperties(tempoartboardList, 0, tempArtboardProperties);</span><br><span class="line">AIRealRect Bound;</span><br><span class="line">sAIArtboard-&gt;GetPosition(tempArtboardProperties, Bound);      </span><br><span class="line">ASReal bottom = Bound.bottom;</span><br><span class="line">ASReal top = Bound.top;</span><br><span class="line">ASReal right = Bound.right;</span><br><span class="line">ASReal left = Bound.left;</span><br></pre></td></tr></table></figure></li></ul><h2 id="11-GetRulerOrigin"><a href="#11-GetRulerOrigin" class="headerlink" title="11.GetRulerOrigin"></a>11.GetRulerOrigin</h2><p>AIAPI AIErr（* AIArtboardSuite :: GetRulerOrigin）（const ai :: ArtboardProperties＆properties，AIRealPoint＆rulerOrigin）<br>获得相对于左下角的画板的标尺原点。</p><ul><li>参数：<br>  properties     画板属性对象。<br>  rulerOrigin     <strong>[out]</strong>用于返回标尺原点。</li></ul><h2 id="12-GetShowDisplayMark"><a href="#12-GetShowDisplayMark" class="headerlink" title="12.GetShowDisplayMark"></a>12.GetShowDisplayMark</h2><p>AIAPI AIErr（* AIArtboardSuite :: GetShowDisplayMark）（const ai :: ArtboardProperties＆properties，ai :: ArtboardProperties :: DisplayMarkType type，AIBoolean＆show）<br>报告当前是否显示特定类型的画板注释。</p><ul><li>参数：<br>  properties     画板属性对象。<br>  type     注释类型。<br>  show     如果显示类型则返回true，如果隐藏则返回false。</li></ul><h2 id="13-Init"><a href="#13-Init" class="headerlink" title="13.Init"></a>13.Init</h2><p>AIAPI AIErr（* AIArtboardSuite :: Init）（ai :: ArtboardProperties＆artboard）<br>使用默认值初始化画板属性对象。</p><ul><li>参数：<br>artboard     画板属性对象。</li></ul><h2 id="14-Insert"><a href="#14-Insert" class="headerlink" title="14.Insert"></a>14.Insert</h2><p>AIAPI AIErr（* AIArtboardSuite :: Insert）（ai :: ArtboardList＆artboardList，ai :: ArtboardProperties＆artboard，ai :: ArtboardID＆index）<br>在指定位置插入新画板。</p><ul><li>参数：<br>  artboardList     ArtboardList对象。<br>  artboard     新画板的属性。<br>  index     基于0的新画板的索引位置。</li><li>返回：<br>  kAIExceededMaxArtboardLimitErr如果超出允许的最大画板数，则会出错。</li></ul><h2 id="15-IsDefaultName"><a href="#15-IsDefaultName" class="headerlink" title="15.IsDefaultName"></a>15.IsDefaultName</h2><p>AIAPI AIErr（* AIArtboardSuite :: IsDefaultName）（const ai :: ArtboardProperties＆properties，AIBoolean＆isDefault）<br>报告画板的当前名称是否是应用程序生成的。</p><p>在这种情况下，用户选择将画板内容导出为JPEG，并将画板保存为单独的文件时，文件只能通过编号来区分，而不是完整生成的名称; 例如，myArt-01.jpg。如果已明确设置画板名称，则会在导出的JPEG文件名中使用该名称。</p><ul><li>参数：<br>  properties     画板属性对象。<br>  isDefault     如果生成名称则返回true的缓冲区，如果已显式设置，则返回false。</li></ul><h2 id="16-ReleaseArtboardList"><a href="#16-ReleaseArtboardList" class="headerlink" title="16.ReleaseArtboardList"></a>16.ReleaseArtboardList</h2><p>AIAPI AIErr(* AIArtboardSuite::ReleaseArtboardList)(ai::ArtboardList &amp;artboardList)<br>释放画板列表对象。</p><ul><li>参数：<br>  artboardList     画板列表对象。</li></ul><h2 id="17-SetActive"><a href="#17-SetActive" class="headerlink" title="17. SetActive"></a>17. SetActive</h2><p>AIAPI AIErr（* AIArtboardSuite :: SetActive）（ai :: ArtboardList＆artboardList，ai :: ArtboardID index）<br>使特定画板处于活动状态，并使其按迭代顺序显示。</p><ul><li>参数：<br>  artboardList     画板列表对象。<br>  index     列表中画板的从0开始的索引位置。  </li></ul><h2 id="18-SetIsDefaultName"><a href="#18-SetIsDefaultName" class="headerlink" title="18.SetIsDefaultName"></a>18.SetIsDefaultName</h2><p>AIAPI AIErr（* AIArtboardSuite :: SetIsDefaultName）（ai :: ArtboardProperties＆properties，const AIBoolean＆isDefault）</p><h2 id="19-SetName"><a href="#19-SetName" class="headerlink" title="19.SetName"></a>19.SetName</h2><p>AIAPI AIErr(* AIArtboardSuite::SetName)(ai::ArtboardProperties &amp;properties, const ai::UnicodeString &amp;name)</p><h2 id="20-SetPAR"><a href="#20-SetPAR" class="headerlink" title="20.SetPAR"></a>20.SetPAR</h2><p>AIAPI AIErr（* AIArtboardSuite :: SetPAR）（ai :: ArtboardProperties＆properties，AIReal par）<br>修改画板标尺的像素长宽比。</p><p>AIArtboardSuite::Update()使用此对象调用进行更改。</p><ul><li>参数：<br>  properties     画板属性对象。<br>  par     新的像素长宽比。  </li></ul><h2 id="21-SetPosition"><a href="#21-SetPosition" class="headerlink" title="21.SetPosition"></a>21.SetPosition</h2><p>AIAPI AIErr（* AIArtboardSuite :: SetPosition）（ai :: ArtboardProperties＆properties，const AIRealRect＆bounds）<br>修改画板的位置和边界。</p><p>AIArtboardSuite::Update()使用此对象调用进行更改。</p><ul><li>参数：<br>  properties     画板属性对象<br>  bounds     新的位置和边界  </li></ul><h2 id="22-SetRulerOrigin"><a href="#22-SetRulerOrigin" class="headerlink" title="22.SetRulerOrigin"></a>22.SetRulerOrigin</h2><p>AIAPI AIErr（* AIArtboardSuite :: SetRulerOrigin）（ai :: ArtboardProperties＆properties，const AIRealPoint＆rulerOrigin）<br>设置画板的标尺原点，相对于左下角。</p><ul><li>参数：<br>properties     画板属性对象<br>rulerOrigin     标尺原点</li></ul><h2 id="23-SetShowDisplayMark"><a href="#23-SetShowDisplayMark" class="headerlink" title="23.SetShowDisplayMark"></a>23.SetShowDisplayMark</h2><p>AIAPI AIErr（* AIArtboardSuite :: SetShowDisplayMark）（ai :: ArtboardProperties＆properties，ai :: ArtboardProperties :: DisplayMarkType type，AIBoolean show）<br>设置当前是否显示特定类型的画板注释。</p><h2 id="24-Update"><a href="#24-Update" class="headerlink" title="24.Update"></a>24.Update</h2><p>AIAPI AIErr（* AIArtboardSuite :: Update）（ai :: ArtboardList＆artboardList，ai :: ArtboardID index，const ai :: ArtboardProperties＆properties）<br>更新画板的属性。</p><p>使用GetCount()和GetArtboardProperties()修改画板而不更改文档中哪个画板处于活动状态。</p><ul><li>参数：<br>  artboardList     画板列表对象。<br>  index     文档列表中画板的从0开始的索引位置。<br>  properties     包含新画板属性的对象。</li><li>实例： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">AIRealRect DateBound;</span><br><span class="line">AIRealPoint CenterPt;</span><br><span class="line">double m_scale=2000</span><br><span class="line">DateBound.top = (this-&gt;DateBound.top - this-&gt;m_center.v) * 1000 / m_scale * (72 / 25.4) - AIcenter.v;</span><br><span class="line">DateBound.bottom = (this-&gt;DateBound.bottom - this-&gt;m_center.v) * 1000 / m_scale * (72 / 25.4) - AIcenter.v;</span><br><span class="line">DateBound.left = (this-&gt;DateBound.left - this-&gt;m_center.h) * 1000 / m_scale * (72 / 25.4) - AIcenter.h;</span><br><span class="line">DateBound.right = (this-&gt;DateBound.right - this-&gt;m_center.h) * 1000 / m_scale * (72 / 25.4) - AIcenter.h;</span><br><span class="line">   </span><br><span class="line">CenterPt.h = (DateBound.left - DateBound.right) / 2;</span><br><span class="line">CenterPt.v = (DateBound.top - DateBound.bottom) / 2;</span><br><span class="line">   </span><br><span class="line">sAIArtboard-&gt;SetPosition(tempArtboardProperties, DateBound);//*******</span><br><span class="line">sAIArtboard-&gt;Update(tempoartboardList, 0, tempArtboardProperties);//*******</span><br></pre></td></tr></table></figure></li></ul><h1 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h1><p><a href="/2019/03/14/ai-first-note">AI组件开发（一）–注记旋转矩阵</a><br><a href="/2019/03/18/ai-second-note">AI组件开发（二）–AIRealMathSuite</a><br><a href="/2019/03/24/ai-third-note">AI组件开发（三）–AIArtboardSuite</a><br><a href="/2019/03/24/ai-forth-document-note">AI组件开发（四）–AIDocumentSuite</a><br><a href="/2019/03/24/ai-fifth-ailayer-note">AI组件开发（五）–AILayerSuite</a><br><a href="/2019/03/24/ai-six-aiart-note">AI组件开发（六）–AIArtSuite</a><br><a href="/2019/03/25/ai-seven-path-note">AI组件开发（七）–AIPathSuite&amp;&amp;AIPathfinderSuite</a><br><a href="/2019/03/25/ai-eight-style-note">AI组件开发（八）–AIArtStyleSuite</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;AIArtboardSuite此套件提供的实用程序允许在文档中创建和操作Artboards。相关类ArtboardProperties和ArtboardList&lt;br&gt;
    
    </summary>
    
      <category term="AI组件开发" scheme="http://11wy11.github.io/categories/AI%E7%BB%84%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="AI" scheme="http://11wy11.github.io/tags/AI/"/>
    
  </entry>
  
  <entry>
    <title>GDAL相关类及函数</title>
    <link href="http://11wy11.github.io/2019/03/24/cpp-gdal-function/"/>
    <id>http://11wy11.github.io/2019/03/24/cpp-gdal-function/</id>
    <published>2019-03-24T06:27:22.000Z</published>
    <updated>2019-03-24T06:38:53.288Z</updated>
    
    <content type="html"><![CDATA[<p>主要介绍GDAL基本类及OGR相关类<br><a id="more"></a></p><h1 id="GDAL-基本使用函数"><a href="#GDAL-基本使用函数" class="headerlink" title="GDAL 基本使用函数"></a>GDAL 基本使用函数</h1><h2 id="CPLSetConfigOption"><a href="#CPLSetConfigOption" class="headerlink" title="CPLSetConfigOption"></a>CPLSetConfigOption</h2><p>void CPLSetConfigOption    （    const char <em>     pszKey，<br>const char </em>     pszValue<br>）<br>为GDAL / OGR使用设置配置选项。</p><p>这些选项被定义为（键，值）对。稍后可以使用CPLGetConfigOption（）方法获取与密钥对应的值。</p><p>此机制类似于环境变量，但使用CPLSetConfigOption（）设置的选项会覆盖CPLGetConfigOption（）的观点，即环境中定义的值。</p><p>如果使用相同的密钥多次调用CPLSetConfigOption（），则将使用上次调用期间提供的值。</p><p>也可以使用带有’-config KEY VALUE’的大多数GDAL实用程序的命令行传递选项。例如，ogrinfo -config CPL_DEBUG ON~ / data / test / point.shp</p><p>此函数也可用于通过传递NULL作为值来清除设置（注意：传递NULL不会取消设置现有环境变量;它将取消设置先前由CPLSetConfigOption（）设置的值）。</p><p>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CPLSetConfigOption(&quot;MDB_DRIVER_TEMPLATE&quot;, &quot;DRIVER=Microsoft Access Driver (*.mdb, *.accdb);DBQ=%s&quot;);</span><br><span class="line">CPLSetConfigOption(&quot;PGEO_DRIVER_TEMPLATE&quot;, &quot;DRIVER=Microsoft Access Driver (*.mdb, *.accdb);DBQ=%s&quot;);</span><br></pre></td></tr></table></figure></p><h2 id="GDALAllRegister"><a href="#GDALAllRegister" class="headerlink" title="GDALAllRegister"></a>GDALAllRegister</h2><p>   最初需要注册所需的所有格式驱动程序。这通常通过调用GDALAllRegister（）来完成，该寄存器注册GDAL / OGR中内置的所有格式驱动程序。<br>    原型：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void GDALAllRegister(void)</span><br><span class="line">//Register all known configured GDAL drivers.</span><br><span class="line">//注册所有已知配置的GDAL驱动程序。</span><br><span class="line"> //This function will drive any of the following that are configured into GDAL. See raster list and vector full list       </span><br><span class="line">//此功能将驱动配置为GDAL的以下任何内容。请参阅栅格列表和矢量完整列表    </span><br><span class="line">//This function should generally be called once at the beginning of the application.</span><br><span class="line">//通常应在应用程序开始时调用此函数一次。 </span><br><span class="line">  </span><br><span class="line">//使用</span><br><span class="line">#include“ ogrsf_frmts.h ”</span><br><span class="line">    int main（）</span><br><span class="line">    &#123;</span><br><span class="line">        GDALAllRegister（）;</span><br></pre></td></tr></table></figure></p><h2 id="GDALOpenEx"><a href="#GDALOpenEx" class="headerlink" title="GDALOpenEx"></a>GDALOpenEx</h2><p>以GDALDataset打开栅格或矢量文件。</p><p>此函数将尝试依次调用每个已注册的GDALDriver的Open方法来打开传递的文件或虚拟数据集名称。第一次成功打开将导致返回的数据集。如果所有驱动程序都失败，则返回NULL并发出错误。</p><p>几条建议：</p><ul><li>如果打开具有GDAL_OF_UPDATE访问权限的数据集对象，则不建议在同一基础文件上打开新数据集。</li><li>返回的数据集一次只能由一个线程访问。如果要从不同的线程中使用它，则必须添加所有必需的代码（互斥锁等）以避免并发使用该对象。（某些驱动程序，如GeoTIFF，维护每次读取新块时更新的内部状态变量，从而防止并发使用。）</li></ul><p>原型：<br>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GDALDatasetH GDALOpenEx（const char * pszFilename，</span><br><span class="line">unsigned int nOpenFlags，</span><br><span class="line">const char * const * papszAllowedDrivers，</span><br><span class="line">const char * const * papszOpenOptions，</span><br><span class="line">const char * const * papszSiblingFiles </span><br><span class="line">）</span><br></pre></td></tr></table></figure></p><ul><li><p>参数  </p><ul><li><p><strong>pszFilename</strong>    要访问的文件的名称。在外来驱动程序的情况下，这可能不是指物理文件，而是包含驱动程序有关如何访问数据集的信息。它应该是UTF-8编码。</p></li><li><p><strong>nOpenFlags</strong> GDAL_OF_标志的组合，可以通过逻辑或运算符组合。  </p><ul><li>驱动程序类型：用于光栅驱动程序的GDAL_OF_RASTER，用于矢量驱动程序的GDAL_OF_VECTOR，用于地理网络模型驱动程序的GDAL_OF_GNM。如果未指定任何值，则隐含所有类型。</li><li>访问模式：GDAL_OF_READONLY（独占）或GDAL_OF_UPDATE。</li><li>共享模式：GDAL_OF_SHARED。如果设置，它允许与已设置GDAL_OF_SHARED的其他调用者共享数据集的GDALDataset句柄。特别是，GDALOpenEx（）将首先查询其当前打开和共享GDALDataset的列表，如果一个GetDescription（）名称与传递给GDALOpenEx（）的pszFilename完全匹配，则将引用并返回它，如果GDALOpenEx（）是从同一个线程调用。</li><li>详细错误：GDAL_OF_VERBOSE_ERROR。如果设置，则尝试打开文件失败将导致报告错误消息。</li></ul></li><li><p><strong>papszAllowedDrivers</strong>    NULL考虑所有候选驱动程序，或NULL终止的字符串列表，其中包含必须考虑的驱动程序短名称。</p></li><li><p><strong>papszOpenOptions</strong>    NULL或NULL终止的字符串列表，其中打开选项传递给候选驱动程序。所有驱动程序OVERVIEW_LEVEL = level都存在一个选项，用于选择数据集的特定概述级别。级别索引从0开始。级别编号可以以“仅”为后缀，以指定只有此概述级别必须可见，而不是子级别。默认情况下会验证打开选项，如果无法识别选项，则会发出警告。在某些情况下，可能不需要（例如，当不知道哪个驱动程序将打开文件时），因此可以将特殊打开选项VALIDATE_OPEN_OPTIONS设置为NO以避免此类警告。或者，从GDAL 2.1开始，选项名称前面可以加上@字符，表示如果驱动程序没有声明此选项，它可能不会引发警告。</p></li><li><p><strong>papszSiblingFiles</strong>    NULL或NULL终止的字符串列表，这些字符串是主文件名的辅助文件名。如果传递NULL，则将完成对文件系统的探测。</p></li></ul></li><li><p>返回<br>一个GDALDatasetH句柄或失败时为NULL。对于C ++应用程序，此句柄可以转换为GDALDataset *。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">GDALDataset       *poDS;</span><br><span class="line">poDS = (GDALDataset*) GDALOpenEx( &quot;point.shp&quot;, GDAL_OF_VECTOR, NULL, NULL, NULL );</span><br><span class="line">if( poDS == NULL )</span><br><span class="line">&#123;</span><br><span class="line">    printf( &quot;Open failed.\n&quot; );</span><br><span class="line">    exit( 1 );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>使用实例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">GDALDataset       *poDS;</span><br><span class="line">poDS = (GDALDataset*) GDALOpenEx( &quot;point.shp&quot;, GDAL_OF_VECTOR, NULL, NULL, NULL );</span><br><span class="line">if( poDS == NULL )</span><br><span class="line">&#123;</span><br><span class="line">    printf( &quot;Open failed.\n&quot; );</span><br><span class="line">    exit( 1 );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="GDALDataSet"><a href="#GDALDataSet" class="headerlink" title="GDALDataSet"></a>GDALDataSet</h2><p>帮助文档<a href="https://www.gdal.org/classGDALDataset.html" target="_blank" rel="noopener">https://www.gdal.org/classGDALDataset.html</a><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="cpp-gdal/pic2.png" alt="类图" title>                </div>                <div class="image-caption">类图</div>            </figure><br>部分函数介绍</p><ul><li><p>GetLayerByName<br>  Fetch a layer by name.</p><p>  The returned layer remains owned by the GDALDataset and should not be deleted by the application.</p><p>  This method is the same as the C function GDALDatasetGetLayerByName() and the deprecated OGR_DS_GetLayerByName().</p><p>  In GDAL 1.X, this method used to be in the OGRDataSource class.</p><p>  Parameters<br>  pszName    the layer name of the layer to fetch.<br>  Returns<br>  the layer, or NULL if Layer is not found or an error occurs.</p></li><li>GetLayerCount</li></ul><h1 id="OGR类或函数"><a href="#OGR类或函数" class="headerlink" title="OGR类或函数"></a>OGR类或函数</h1><h2 id="OGRLayer"><a href="#OGRLayer" class="headerlink" title="OGRLayer"></a>OGRLayer</h2><p>帮助文档<a href="https://www.gdal.org/classOGRLayer.html" target="_blank" rel="noopener">https://www.gdal.org/classOGRLayer.html</a><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="cpp-gdal/pic1.png" alt="类图" title>                </div>                <div class="image-caption">类图</div>            </figure>  </p><ul><li>GetLayerDefn</li><li>GetExtent</li><li>ResetReading</li><li>GetNextFeature</li><li>GetName                                                <h2 id="OGRFeature"><a href="#OGRFeature" class="headerlink" title="OGRFeature"></a>OGRFeature</h2> 包括geometry和attributes</li><li>GetDefRef</li><li>GetGeometryRef<br> 返回指向内部要素几何的指针。不应修改此对象</li><li>GetFieldAsString 将字段值作为字符串获取</li><li>OGRFeature::DestroyFeature<br><code>void OGRFeature :: DestroyFeature    （    OGRFeature *     poFeature    ）</code><br> poFeatur要删除的Feature。<h2 id="OGRGeometry"><a href="#OGRGeometry" class="headerlink" title="OGRGeometry"></a>OGRGeometry</h2>所有几何类的抽象基类。</li></ul><p>一些空间分析方法要求在GEOS库上构建OGR才能正常工作。描述几何之间空间关系的方法的精确含义在SFCOM或其他简单特征接口规范中描述，例如“OpenGIS®地理信息实现规范 - 简单特征访问 - 第1部分：通用体系结构”：&lt;a href =“ <a href="http://www.opengeospatial.org/standards/sfa" target="_blank" rel="noopener">http://www.opengeospatial.org/standards/sfa</a> “&gt; OGC 06-103r4</p><p>在GDAL 2.0中，类的层次结构已经扩展为（工作草案）ISO SQL / MM第3部分（ISO / IEC 13249-3）曲线几何：CIRCULARSTRING（OGRCircularString），COMPOUNDCURVE（OGRCompoundCurve），CURVEPOLYGON（OGRCurvePolygon），MULTICURVE（OGRMultiCurve）和MULTISURFACE（OGRMultiSurface）。</p><h3 id="OGRPoint"><a href="#OGRPoint" class="headerlink" title="OGRPoint"></a>OGRPoint</h3><h3 id="OGRLineString"><a href="#OGRLineString" class="headerlink" title="OGRLineString"></a>OGRLineString</h3><p>多顶点线的具体表示。继承OGRSimpleCurve</p><ul><li>getPoints<br><code>void OGRSimpleCurve::getPoints    (    OGRRawPoint *     paoPointsOut,double *     padfZOut = nullptr )</code></li><li>getPoint<br><code>void OGRSimpleCurve::getPoint    (    int     i,OGRPoint *     poPoint )</code><br>获取行字符串中的一个点。<br>i:要获取的顶点，从0到getNumPoints（） - 1<br>poPoint    用获取的点初始化的点。</li><li>getNumPoints<br>获得线上点的个数<h3 id="OGRMultiLineString"><a href="#OGRMultiLineString" class="headerlink" title="OGRMultiLineString"></a>OGRMultiLineString</h3></li><li>getNumGeometries<br>获得几何要素格个数<h3 id="OGRPolygon"><a href="#OGRPolygon" class="headerlink" title="OGRPolygon"></a>OGRPolygon</h3></li><li>getExteriorRing<br> 获取对外部多边形环的引用   </li><li>getNumInteriorRings<br>获取指示内部环的数量</li><li>getInteriorRing<br>获取指示内部环的引用<h2 id="OGRFeatureDefn"><a href="#OGRFeatureDefn" class="headerlink" title="OGRFeatureDefn"></a>OGRFeatureDefn</h2> 要素类或要素图层的定义。<ul><li>GetFieldCount 获取字段数</li><li>GetFieldDefn 获得字段 参数：字段索引<h2 id="OGRFieldDefn"><a href="#OGRFieldDefn" class="headerlink" title="OGRFieldDefn"></a>OGRFieldDefn</h2></li><li>GetNameRef 字段名称</li></ul></li></ul><h2 id="OGREnvelope"><a href="#OGREnvelope" class="headerlink" title="OGREnvelope"></a>OGREnvelope</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">class CPL_DLL OGREnvelope</span><br><span class="line">&#123;</span><br><span class="line">  public:</span><br><span class="line">        OGREnvelope() : MinX(std::numeric_limits&lt;double&gt;::infinity()),</span><br><span class="line">                        MaxX(-std::numeric_limits&lt;double&gt;::infinity()),</span><br><span class="line">                        MinY(std::numeric_limits&lt;double&gt;::infinity()),</span><br><span class="line">                        MaxY(-std::numeric_limits&lt;double&gt;::infinity())</span><br><span class="line">        &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        OGREnvelope(const OGREnvelope&amp; oOther) :</span><br><span class="line">            MinX(oOther.MinX),MaxX(oOther.MaxX), MinY(oOther.MinY), MaxY(oOther.MaxY)</span><br><span class="line">        &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    double      MinX;</span><br><span class="line">    double      MaxX;</span><br><span class="line">    double      MinY;</span><br><span class="line">    double      MaxY;</span><br><span class="line"></span><br><span class="line">#ifdef HAVE_GCC_DIAGNOSTIC_PUSH</span><br><span class="line">#pragma GCC diagnostic push</span><br><span class="line">#pragma GCC diagnostic ignored &quot;-Wfloat-equal&quot;</span><br><span class="line">#endif</span><br><span class="line">    int  IsInit() const &#123; return MinX != std::numeric_limits&lt;double&gt;::infinity(); &#125;</span><br><span class="line"></span><br><span class="line">#ifdef HAVE_GCC_DIAGNOSTIC_PUSH</span><br><span class="line">#pragma GCC diagnostic pop</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    void Merge( OGREnvelope const&amp; sOther ) &#123;</span><br><span class="line">        MinX = MIN(MinX,sOther.MinX);</span><br><span class="line">        MaxX = MAX(MaxX,sOther.MaxX);</span><br><span class="line">        MinY = MIN(MinY,sOther.MinY);</span><br><span class="line">        MaxY = MAX(MaxY,sOther.MaxY);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void Merge( double dfX, double dfY ) &#123;</span><br><span class="line">        MinX = MIN(MinX,dfX);</span><br><span class="line">        MaxX = MAX(MaxX,dfX);</span><br><span class="line">        MinY = MIN(MinY,dfY);</span><br><span class="line">        MaxY = MAX(MaxY,dfY);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void Intersect( OGREnvelope const&amp; sOther ) &#123;</span><br><span class="line">        if(Intersects(sOther))</span><br><span class="line">        &#123;</span><br><span class="line">            if( IsInit() )</span><br><span class="line">            &#123;</span><br><span class="line">                MinX = MAX(MinX,sOther.MinX);</span><br><span class="line">                MaxX = MIN(MaxX,sOther.MaxX);</span><br><span class="line">                MinY = MAX(MinY,sOther.MinY);</span><br><span class="line">                MaxY = MIN(MaxY,sOther.MaxY);</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                MinX = sOther.MinX;</span><br><span class="line">                MaxX = sOther.MaxX;</span><br><span class="line">                MinY = sOther.MinY;</span><br><span class="line">                MaxY = sOther.MaxY;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            *this = OGREnvelope();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int Intersects(OGREnvelope const&amp; other) const</span><br><span class="line">    &#123;</span><br><span class="line">        return MinX &lt;= other.MaxX &amp;&amp; MaxX &gt;= other.MinX &amp;&amp;</span><br><span class="line">               MinY &lt;= other.MaxY &amp;&amp; MaxY &gt;= other.MinY;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int Contains(OGREnvelope const&amp; other) const</span><br><span class="line">    &#123;</span><br><span class="line">        return MinX &lt;= other.MinX &amp;&amp; MinY &lt;= other.MinY &amp;&amp;</span><br><span class="line">               MaxX &gt;= other.MaxX &amp;&amp; MaxY &gt;= other.MaxY;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="OGRwkbGeometryType"><a href="#OGRwkbGeometryType" class="headerlink" title="OGRwkbGeometryType"></a>OGRwkbGeometryType</h2><p>几何类型代码。<br>在下面这类中实现：<br> OGRMultiLineString, OGRMultiCurve, OGRMultiPoint, OGRTriangulatedSurface, OGRPolyhedralSurface, OGRMultiPolygon, OGRMultiSurface, OGRGeometryCollection, OGRTriangle, OGRPolygon, OGRCurvePolygon, OGRCompoundCurve, OGRCircularString, OGRLineString, and OGRPoint.  </p><p> 常亮值如：wkbPoint，wkbMultiPoint，wkbLineString,wkbMultiLineString，wkbPolygon，wkbCurvePolygon，wkbMultiPolygon</p><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><ol><li>百度百科：<a href="https://baike.baidu.com/item/GDAL/4004525?fr=aladdin" target="_blank" rel="noopener">https://baike.baidu.com/item/GDAL/4004525?fr=aladdin</a></li><li>官方网站：<a href="https://www.gdal.org/" target="_blank" rel="noopener">https://www.gdal.org/</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;主要介绍GDAL基本类及OGR相关类&lt;br&gt;
    
    </summary>
    
      <category term="C++" scheme="http://11wy11.github.io/categories/C/"/>
    
    
      <category term="GDAL" scheme="http://11wy11.github.io/tags/GDAL/"/>
    
  </entry>
  
  <entry>
    <title>VS2013打包C#项目</title>
    <link href="http://11wy11.github.io/2019/03/22/winform-release/"/>
    <id>http://11wy11.github.io/2019/03/22/winform-release/</id>
    <published>2019-03-22T13:54:22.000Z</published>
    <updated>2019-03-26T13:23:34.500Z</updated>
    
    <content type="html"><![CDATA[<p>在VS2013中安装InstallShield打包程序，<br><a id="more"></a></p><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>vs2010打包时，在其他项目类型中找到安装和部署的模板，即可新建安装项目，而在vs2013中需要先在线搜索InstallShield，然后按照网页提示一步步下载，之后添加安装项目，配置打包设置完成打包<br> 在vs2010 选择“新建项目”→“ 其他项目类型”→“ Visual Studio Installer→“安装项目”：</p><h1 id="1-打包前的准备"><a href="#1-打包前的准备" class="headerlink" title="1. 打包前的准备"></a>1. 打包前的准备</h1><h2 id="InstallShield安装"><a href="#InstallShield安装" class="headerlink" title="InstallShield安装"></a>InstallShield安装</h2><p>在我们准备好的项目中右击“解决方案”，在弹出的菜单中选择添加 - 新建项目：</p><p>在弹出的新建对话框中依次选择 其他项目 - 安装和部署 - 安装项目，你可以改名字，也可以使用默认的名字setup1</p><p>新建一个打包部署项目，点OK，如果是第一次使用的话，会打开一个网页，按照提示的步骤来做，</p><p>点击<strong>Go to the download web site</strong>,进入下载网站，填写完信息，点击“download ”即会收到一封邮件，里面有下载地址和激活码。</p><p>之后会下载一个<strong>InstallShield2015LimitedEdition.exe</strong>的安装包,用管理员权限运行安装完后。重新启动VS2013</p><p>重新新建一个这样的项目：</p><p>点OK，这时候不再是打开网页，这时打开会提示激活或者是试用，选第一项，下一步</p><p>输入收到的邮件里的激活码，激活,待激活完成</p><p>卸载功能：找到C:\Windows\System32目录下的msiexec.exe文件，右击 选择 “msiexec.exe 的快捷方式”，然后改名为：你想叫名称（卸载、uninstall都可以），移动到你需要打包的程序菜单的文件夹下面。</p><h2 id="winform设置项目图标"><a href="#winform设置项目图标" class="headerlink" title="winform设置项目图标"></a>winform设置项目图标</h2><ul><li>首先可以在你的窗体属性中找到icon选择你准备好的图标；</li><li>右键项目点击属性，找到应用程序中的<strong>图标和清单</strong></li></ul><h1 id="2-开始部署"><a href="#2-开始部署" class="headerlink" title="2. 开始部署"></a>2. 开始部署</h1><h2 id="2-1-基本配置Application-Information"><a href="#2-1-基本配置Application-Information" class="headerlink" title="2.1 基本配置Application Information"></a>2.1 基本配置Application Information</h2><p>   可以设置公司名称，点击右侧General Information 可以设置语言为中文，可以设置应用名称</p><h2 id="2-2-Installation-Requirements"><a href="#2-2-Installation-Requirements" class="headerlink" title="2.2 Installation Requirements"></a>2.2 Installation Requirements</h2><p>   一般可以默认设置，如果需要,选择安装如.NET Framework 4.5等依赖同时打包，勾选所需依赖</p><h2 id="2-3-Installation-Architecture"><a href="#2-3-Installation-Architecture" class="headerlink" title="2.3 Installation Architecture"></a>2.3 Installation Architecture</h2><p>   默认即可</p><h2 id="2-4-Application-Files"><a href="#2-4-Application-Files" class="headerlink" title="2.4 Application Files"></a>2.4 Application Files</h2><p>   添加程序所需文件，这里有两种方式经过测试均可实现</p><h3 id="2-4-1方式一"><a href="#2-4-1方式一" class="headerlink" title="2.4.1方式一"></a>2.4.1方式一</h3><p>   点击到ProgramFilesFolder&gt;Microsoft&gt; &lt;你的工程名&gt;[INSRALLDIR]，点击<strong>Add Folders</strong>，选择工程bin目录下的Debug或Release文件夹，一般选择Release</p><h3 id="2-4-2-方式二"><a href="#2-4-2-方式二" class="headerlink" title="2.4.2 方式二"></a>2.4.2 方式二</h3><p>   点击到ProgramFilesFolder&gt;Microsoft&gt; &lt;你的工程名&gt;[INSRALLDIR]，点击<strong>Add Project Outputs</strong>,选择主输出</p><p>   点击Ok后，选中主输出，右键Resolve Project OutPut</p><p>   点击OK后，在左边菜单CatcheScreen下新建目录source，然后同上步骤添加源文件，然后选中资源，右键Resolve Project OutPut</p><p>   在创建一个文件命名“uninstall”，然后同上步骤添加源文件，然后选中资源，右键Resolve Project OutPut</p><h2 id="2-5-Application-Shortcuts"><a href="#2-5-Application-Shortcuts" class="headerlink" title="2.5 Application Shortcuts"></a>2.5 Application Shortcuts</h2><ul><li>2.4如果选择方式一，这是默认后有两个Launch xxx.exe,Launch xxx.vshost.exe,可以将第二个删掉，然后重命名第一个<br> 勾选use alternate shortcut icon可以选择自定义的程序图标<br> 然后创建卸载程序的快捷方式<br> 点击Create an unistallation shortcut，选择uninstall</li><li><p>2.4如果选择方式二，<br>  点击左侧的new,弹出对话框后点击最后一项，一直点到最后,点击Open，重命名Built（这里的重命名实际上就是你的程序在桌面上的名称) 选择在桌面上创建快捷方式：<br> 勾选use alternate shortcut icon可以选择自定义的程序图标</p><pre><code>然后创建卸载程序的快捷方式</code></pre><h2 id="2-6-Application-Registry"><a href="#2-6-Application-Registry" class="headerlink" title="2.6  Application Registry"></a>2.6  Application Registry</h2><p>配置是否允许用户修改安装地址等</p><h2 id="2-7-在右侧找到第六步Prepare-for-Release，双击下面的Releases"><a href="#2-7-在右侧找到第六步Prepare-for-Release，双击下面的Releases" class="headerlink" title="2.7 在右侧找到第六步Prepare for Release，双击下面的Releases"></a>2.7 在右侧找到第六步Prepare for Release，双击下面的Releases</h2><p>点击选中“SingleImage”–选项卡点击“Setup.exe”–找到 “InstallShield PrerequisitesLocation”，把它设置为“Extract From Setup.exe”   </p><h1 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h1><p>生成解决方案后会在安装程序集下面生成一个名为Setup（当时添加安装部署项目的项目名）的文件夹，安装文件就保存在下面的目录中。Install在生成安装文件后会有Setup.exe和.msi两中安装文件，exe文件是安装的引导文件，核心文件是msi文件，里面封存了程序的组件。在里面找到Setup.exe文件及msi文件即可进行安装。</p><p>点击Setup.exe，进行安装，如果想卸载，点击Uninstall卸载</p><h1 id="更换用installshield打包生成exe文件的图标"><a href="#更换用installshield打包生成exe文件的图标" class="headerlink" title="更换用installshield打包生成exe文件的图标"></a>更换用installshield打包生成exe文件的图标</h1><ul><li>打开Visio studio,选择文件方式打开你生成的exe文件</li><li>在Icon下右键添加资源》点击导入选择准备好的项目图标等</li><li>删除原来的100资源</li><li>设置你导入的资源ID为100</li><li>保存<h1 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h1></li></ul><ol><li>有时打包之后，项目更新之后，重新再生成解决方案来打包,遇到exe文件找不到时<br>【解决方案】<ul><li>清理，重新生成解决方案</li><li>如果还是不行，运行一次，然后点击生成解决方案</li></ul></li><li>重新打包遇到DVD5无法覆盖<br>【解决方案】原因是通过打开了相关文件夹，关闭文件资源管理器即可</li><li>设置了应用的ico图标后，生成解决方案提示 error : -3204: Cannot extract icon with index 0 from file…<br>【解决方案】把图标添加进工程。</li></ol></li></ul><p>参考：<a href="https://blog.csdn.net/qq_38122230/article/details/80470699" target="_blank" rel="noopener">https://blog.csdn.net/qq_38122230/article/details/80470699</a><br><a href="https://blog.csdn.net/u010872301/article/details/80509405" target="_blank" rel="noopener">https://blog.csdn.net/u010872301/article/details/80509405</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在VS2013中安装InstallShield打包程序，&lt;br&gt;
    
    </summary>
    
      <category term="应用" scheme="http://11wy11.github.io/categories/%E5%BA%94%E7%94%A8/"/>
    
    
      <category term="VS" scheme="http://11wy11.github.io/tags/VS/"/>
    
      <category term="打包" scheme="http://11wy11.github.io/tags/%E6%89%93%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>krpano快速入门教程（四）之菜单栏</title>
    <link href="http://11wy11.github.io/2019/03/21/krpano-forth-note/"/>
    <id>http://11wy11.github.io/2019/03/21/krpano-forth-note/</id>
    <published>2019-03-21T15:37:50.000Z</published>
    <updated>2019-03-24T01:30:49.265Z</updated>
    
    <content type="html"><![CDATA[<p>主要通过自定义plugin插件实现krpano下拉框<br><a id="more"></a></p><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>有时当有多个场景，用户想要直观的查看和定位指定的菜单栏，因此，最简单的方式是在页面中添加下拉框，能够支持用户选择场景进行跳转 </p><h1 id="下拉式菜单栏"><a href="#下拉式菜单栏" class="headerlink" title="下拉式菜单栏"></a>下拉式菜单栏</h1><p>主要通过自定义plugin插件实现下拉框<br>tour.xml代码如下：</p><ul><li>plugin<br>  plugin定义插件，其中使用了krpano中提供的combox插件，align属性可以设置下拉框相对对齐位置，onloaded定义在加载时调用的函数或动作action    </li><li>action fill_with_scenes<br>  主要读取当前所有的场景，依次设置添加到combox的item中，可以看到采用了部分krpano的语法，首先定义了item点击事件itemcall，调用loadscene加载场景，然后将场景名称和场景title作为项的属性添加</li><li>action select_box_item<br>  下拉框选中动作，如果该插件加载，则调用选中函数，否则，延时执行选中<br>combox.js<a href="/krpano-forth-note/combobox.js">下载</a><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">krpano</span> <span class="attr">version</span>=<span class="string">"1.19"</span> <span class="attr">title</span>=<span class="string">"Virtual Tour"</span> <span class="attr">onstart</span>=<span class="string">"startup();"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- combobox plugin --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugin</span> <span class="attr">name</span>=<span class="string">"box"</span> <span class="attr">keep</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">url</span>=<span class="string">"%SWFPATH%/plugins/combobox.swf"</span> <span class="attr">width</span>=<span class="string">"230"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">alturl</span>=<span class="string">"%SWFPATH%/plugins/combobox.js"</span> <span class="attr">native</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">align</span>=<span class="string">"righttop"</span> <span class="attr">x</span>=<span class="string">"10"</span> <span class="attr">y</span>=<span class="string">"10"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">onloaded</span>=<span class="string">"fill_with_scenes();"</span></span></span><br><span class="line"><span class="tag">        /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- an action for automatically fill the combobox with all scenes --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">action</span> <span class="attr">name</span>=<span class="string">"fill_with_scenes"</span>&gt;</span></span><br><span class="line">for(set(i,0), i LT scene.count, inc(i),</span><br><span class="line">txtadd(itemcall, 'loadscene(',get(scene[get(i)].name),',null,MERGE,BLEND(1));');</span><br><span class="line">addIdItem(get(scene[get(i)].name), get(scene[get(i)].title), get(itemcall));</span><br><span class="line">);</span><br><span class="line"><span class="tag">&lt;/<span class="name">action</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- an action for updating the combobox when the scene was changed --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">action</span> <span class="attr">name</span>=<span class="string">"select_box_item"</span>&gt;</span></span><br><span class="line">if(plugin[box].loaded,</span><br><span class="line">plugin[box].selectIdItem(%1);</span><br><span class="line">  ,</span><br><span class="line">delayedcall(0.1, select_box_item(%1));</span><br><span class="line">  );</span><br><span class="line"><span class="tag">&lt;/<span class="name">action</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="tag">&lt;<span class="name">action</span> <span class="attr">name</span>=<span class="string">"floorvisible"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> set(layer[map_container_mask].oy,5);</span><br><span class="line">set(layer[map_container_mask].height,100%);</span><br><span class="line">  for(set(i,1);txtadd(floorname, 'floor', '_', get(i)),  layer[get(floorname)],  inc(i); txtadd(floorname, 'floor', '_', get(i)),</span><br><span class="line">  set(layer[get(floorname)].visible, false);</span><br><span class="line">  </span><br><span class="line">    );  </span><br><span class="line"><span class="tag">&lt;/<span class="name">action</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- set skin settings: bingmaps? gyro? thumbnail controlling? tooltips? --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">skin_settings</span> <span class="attr">bingmaps</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">bingmaps_key</span>=<span class="string">""</span></span></span><br><span class="line"><span class="tag">               <span class="attr">bingmaps_zoombuttons</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">gyro</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">thumbs_width</span>=<span class="string">"120"</span> <span class="attr">thumbs_height</span>=<span class="string">"80"</span> <span class="attr">thumbs_padding</span>=<span class="string">"10"</span> <span class="attr">thumbs_crop</span>=<span class="string">"0|40|240|160"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">thumbs_opened</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">thumbs_text</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">thumbs_dragging</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">thumbs_onhoverscrolling</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">thumbs_scrollbuttons</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">thumbs_scrollindicator</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">tooltips_thumbs</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">tooltips_hotspots</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">tooltips_mapspots</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">controlbar_offset</span>=<span class="string">"20"</span></span></span><br><span class="line"><span class="tag">               /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- set optional skin logo url --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">layer</span> <span class="attr">name</span>=<span class="string">"skin_logo"</span> <span class="attr">url</span>=<span class="string">""</span> <span class="attr">scale</span>=<span class="string">"0.25"</span> <span class="attr">opened_onclick</span>=<span class="string">"openurl('...',_blank);"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">action</span> <span class="attr">name</span>=<span class="string">"startup"</span>&gt;</span></span><br><span class="line">if(startscene === null, copy(startscene,scene[0].name));</span><br><span class="line">loadscene(get(startscene), null, MERGE);</span><br><span class="line"><span class="tag">&lt;/<span class="name">action</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">scene</span> <span class="attr">name</span>=<span class="string">"scene_1"</span> <span class="attr">title</span>=<span class="string">"场景1"</span> <span class="attr">onstart</span>=<span class="string">""</span> <span class="attr">thumburl</span>=<span class="string">"panos/3.tiles/thumb.jpg"</span> <span class="attr">lat</span>=<span class="string">""</span> <span class="attr">lng</span>=<span class="string">""</span> <span class="attr">heading</span>=<span class="string">""</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">hlookat</span>=<span class="string">"0"</span> <span class="attr">vlookat</span>=<span class="string">"0"</span> <span class="attr">fovtype</span>=<span class="string">"MFOV"</span> <span class="attr">fov</span>=<span class="string">"120"</span> <span class="attr">maxpixelzoom</span>=<span class="string">"2.0"</span> <span class="attr">fovmin</span>=<span class="string">"70"</span> <span class="attr">fovmax</span>=<span class="string">"140"</span> <span class="attr">limitview</span>=<span class="string">"auto"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">preview</span> <span class="attr">url</span>=<span class="string">"panos/3.tiles/preview.jpg"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">image</span> <span class="attr">type</span>=<span class="string">"CUBE"</span> <span class="attr">multires</span>=<span class="string">"true"</span> <span class="attr">tilesize</span>=<span class="string">"512"</span> <span class="attr">progressive</span>=<span class="string">"false"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">level</span> <span class="attr">tiledimagewidth</span>=<span class="string">"1910"</span> <span class="attr">tiledimageheight</span>=<span class="string">"1910"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">cube</span> <span class="attr">url</span>=<span class="string">"panos/3.tiles/%s/l3/%v/l3_%s_%v_%h.jpg"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">level</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">level</span> <span class="attr">tiledimagewidth</span>=<span class="string">"955"</span> <span class="attr">tiledimageheight</span>=<span class="string">"955"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">cube</span> <span class="attr">url</span>=<span class="string">"panos/3.tiles/%s/l2/%v/l2_%s_%v_%h.jpg"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">level</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">level</span> <span class="attr">tiledimagewidth</span>=<span class="string">"512"</span> <span class="attr">tiledimageheight</span>=<span class="string">"512"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">cube</span> <span class="attr">url</span>=<span class="string">"panos/3.tiles/%s/l1/%v/l1_%s_%v_%h.jpg"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">level</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mobile</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">cube</span> <span class="attr">url</span>=<span class="string">"panos/3.tiles/mobile_%s.jpg"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mobile</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">image</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- place your scene hotspots here --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">scene</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">scene</span> <span class="attr">name</span>=<span class="string">"scene_2"</span> <span class="attr">title</span>=<span class="string">"场景2"</span> <span class="attr">onstart</span>=<span class="string">""</span> <span class="attr">thumburl</span>=<span class="string">"panos/1.tiles/thumb.jpg"</span> <span class="attr">lat</span>=<span class="string">""</span> <span class="attr">lng</span>=<span class="string">""</span> <span class="attr">heading</span>=<span class="string">""</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">hlookat</span>=<span class="string">"0"</span> <span class="attr">vlookat</span>=<span class="string">"0"</span> <span class="attr">fovtype</span>=<span class="string">"MFOV"</span> <span class="attr">fov</span>=<span class="string">"120"</span> <span class="attr">maxpixelzoom</span>=<span class="string">"2.0"</span> <span class="attr">fovmin</span>=<span class="string">"70"</span> <span class="attr">fovmax</span>=<span class="string">"140"</span> <span class="attr">limitview</span>=<span class="string">"auto"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">preview</span> <span class="attr">url</span>=<span class="string">"panos/1.tiles/preview.jpg"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">image</span> <span class="attr">type</span>=<span class="string">"CUBE"</span> <span class="attr">multires</span>=<span class="string">"true"</span> <span class="attr">tilesize</span>=<span class="string">"512"</span> <span class="attr">progressive</span>=<span class="string">"false"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">level</span> <span class="attr">tiledimagewidth</span>=<span class="string">"955"</span> <span class="attr">tiledimageheight</span>=<span class="string">"955"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">cube</span> <span class="attr">url</span>=<span class="string">"panos/1.tiles/%s/l2/%v/l2_%s_%v_%h.jpg"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">level</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">level</span> <span class="attr">tiledimagewidth</span>=<span class="string">"512"</span> <span class="attr">tiledimageheight</span>=<span class="string">"512"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">cube</span> <span class="attr">url</span>=<span class="string">"panos/1.tiles/%s/l1/%v/l1_%s_%v_%h.jpg"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">level</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mobile</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">cube</span> <span class="attr">url</span>=<span class="string">"panos/1.tiles/mobile_%s.jpg"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mobile</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">image</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- place your scene hotspots here --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">scene</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">krpano</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="历史文章"><a href="#历史文章" class="headerlink" title="历史文章"></a>历史文章</h3><p><a href="/2019/03/14/krpano-first-note">krpano快速入门教程（一) 使用krpano工具构建即用型panos</a><br><a href="/2019/03/15/krpano-second-note">krpano快速入门教程（二) vtour全景漫游及vtour文件夹介绍</a><br><a href="/2019/03/16/krpano-third-note">krpano快速入门教程（三）之热点Hotspot</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;主要通过自定义plugin插件实现krpano下拉框&lt;br&gt;
    
    </summary>
    
      <category term="全景" scheme="http://11wy11.github.io/categories/%E5%85%A8%E6%99%AF/"/>
    
    
      <category term="krpano" scheme="http://11wy11.github.io/tags/krpano/"/>
    
  </entry>
  
  <entry>
    <title>AE开发问题总结(一)</title>
    <link href="http://11wy11.github.io/2019/03/20/arcengine-second/"/>
    <id>http://11wy11.github.io/2019/03/20/arcengine-second/</id>
    <published>2019-03-20T04:55:36.000Z</published>
    <updated>2019-03-24T01:26:35.880Z</updated>
    
    <content type="html"><![CDATA[<p>今天本地运行项目，莫名其妙地报了个 尝试读取或写入受保护的内存，这通常指示其他内存已损坏！提供解决方案<br><a id="more"></a></p><h1 id="AE-读Shp文件及查属性表等"><a href="#AE-读Shp文件及查属性表等" class="headerlink" title="AE 读Shp文件及查属性表等"></a>AE 读Shp文件及查属性表等</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"> try</span><br><span class="line">&#123;</span><br><span class="line">    bool flag = true;</span><br><span class="line">     IWorkspaceFactory pWsFactory = new ShapefileWorkspaceFactoryClass();</span><br><span class="line">     IFeatureWorkspace pWorkSpace = pWsFactory.OpenFromFile(path, 0) as IFeatureWorkspace;//path为shp文件所在目录路径</span><br><span class="line">     IFeatureClass pFeatureClass = pWorkSpace.OpenFeatureClass(System.IO.Path.GetFileNameWithoutExtension(path));//OpenFeatureClass的参数为不带后缀的shp文件名</span><br><span class="line">     //检查属性                               </span><br><span class="line">     IFeatureLayer pFeatureLayer = new FeatureLayerClass();</span><br><span class="line">     pFeatureLayer.Name = pFeatureClass.AliasName;</span><br><span class="line">     pFeatureLayer.FeatureClass = pFeatureClass;</span><br><span class="line">    </span><br><span class="line">     //查询 ,search的参数第一个为过滤条件，第二个为是否重复执行</span><br><span class="line">     IFeatureCursor pFeatureCursor = pFeatureLayer.Search(null, false);</span><br><span class="line">     //获取查询到的要素 </span><br><span class="line">     IFeature pFeature = pFeatureCursor.NextFeature();</span><br><span class="line">     string strFeatureClassName = (pFeatureClass as IDataset).Name;</span><br><span class="line">     int fieldCount = pFeatureClass.Fields.FieldCount;</span><br><span class="line">     </span><br><span class="line">     else</span><br><span class="line">     &#123;</span><br><span class="line">         for (int i = 0; i &lt; fieldCount; ++i)</span><br><span class="line">         &#123;</span><br><span class="line">             //这段当时的需求是判断shp文件中是否有规定要求的字段，</span><br><span class="line">             string fieldName = ConstantInfo.shpFields[i];</span><br><span class="line">             if (pFeatureClass.Fields.FindField(fieldName) == -1)</span><br><span class="line">             &#123;</span><br><span class="line">                 //自定义函数，按照需要修改</span><br><span class="line">                 flag = false;</span><br><span class="line">             &#125;</span><br><span class="line">    </span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     IFeature pTempFeature = pFeatureCursor.NextFeature();</span><br><span class="line">     int rowid = 0;</span><br><span class="line">     while (null != pTempFeature)</span><br><span class="line">     &#123;</span><br><span class="line">         rowid++;</span><br><span class="line">         for (int i = 0; i &lt; fieldCount; ++i)</span><br><span class="line">         &#123;</span><br><span class="line">             string str = Convert.ToString(pTempFeature.get_Value(i));</span><br><span class="line">             //空值检查</span><br><span class="line">             if (str == &quot;&quot;)</span><br><span class="line">             &#123;</span><br><span class="line">                 /自定义函数，按照需要修改</span><br><span class="line">                 flag = false;</span><br><span class="line">             &#125;</span><br><span class="line">    </span><br><span class="line">         &#125;</span><br><span class="line">         pTempFeature = pFeatureCursor.NextFeature();</span><br><span class="line">     &#125;</span><br><span class="line">     Marshal.ReleaseComObject(pFeatureCursor);</span><br><span class="line">     if (!flag)</span><br><span class="line">     &#123;</span><br><span class="line">         MainForm.isPassed = false;</span><br><span class="line">         logger.Error(&quot;Error:&quot; + childNode.InnerText.Replace(&quot;%%&quot;, this.strPac) + &quot;shp文件属性等检查未通过\n&quot;);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">catch (Exception e)</span><br><span class="line">&#123;</span><br><span class="line"> //自定义函数，按照需要修改</span><br><span class="line">&#125;</span><br><span class="line">break;</span><br></pre></td></tr></table></figure><h1 id="尝试读取或写入受保护的内存，这通常指示其他内存已损坏【解决方法】"><a href="#尝试读取或写入受保护的内存，这通常指示其他内存已损坏【解决方法】" class="headerlink" title="尝试读取或写入受保护的内存，这通常指示其他内存已损坏【解决方法】"></a>尝试读取或写入受保护的内存，这通常指示其他内存已损坏【解决方法】</h1><p>以<strong>管理员的身份</strong>运行CMD   执行netsh winsock reset    然后提示你重新启动计算机   重启后错误就没有了</p><p>但这样太过复杂，没有从程序自身角度解决这个问题，继续查阅资料，最终找到了有效的方法，释放程序锁</p><h1 id="最佳解决方法"><a href="#最佳解决方法" class="headerlink" title="最佳解决方法"></a>最佳解决方法</h1><p>使用IWorkspaceFactoryLockControl接口的SchemaLockingEnabled和DisableSchemaLocking，分别获得工作空间锁状态，并关闭，具体代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">IWorkspaceFactory pWsFactory = new ShapefileWorkspaceFactory();</span><br><span class="line">//关闭资源锁定   </span><br><span class="line">IWorkspaceFactoryLockControl ipWsFactoryLock = (IWorkspaceFactoryLockControl)pWsFactory;</span><br><span class="line">if (ipWsFactoryLock.SchemaLockingEnabled)</span><br><span class="line">&#123;</span><br><span class="line">  ipWsFactoryLock.DisableSchemaLocking();</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure></p><h1 id="错误原因分析"><a href="#错误原因分析" class="headerlink" title="错误原因分析"></a>错误原因分析</h1><p>   AE中非托管变量未释放，这些有Icursor，IFeatureCursor，IEnumStyleGalleryItem，IEnumBSTR，IStyleGallery；AGS里面有IServerContext等，释放方法System.Runtime.InteropServices.Marshal.ReleaseComObject(o);或者使用ESRI.ArcGIS.ADF.COMSupport.AOUninitialize.Shutdown()  </p><p>参考：[1] <a href="https://blog.csdn.net/mattran/article/details/47149077" target="_blank" rel="noopener">https://blog.csdn.net/mattran/article/details/47149077</a><br>      [2] <a href="https://blog.csdn.net/u011116642/article/details/17960135" target="_blank" rel="noopener">https://blog.csdn.net/u011116642/article/details/17960135</a>  </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天本地运行项目，莫名其妙地报了个 尝试读取或写入受保护的内存，这通常指示其他内存已损坏！提供解决方案&lt;br&gt;
    
    </summary>
    
      <category term="ArcGIS" scheme="http://11wy11.github.io/categories/ArcGIS/"/>
    
    
      <category term="ArcEngine" scheme="http://11wy11.github.io/tags/ArcEngine/"/>
    
      <category term="VS" scheme="http://11wy11.github.io/tags/VS/"/>
    
  </entry>
  
  <entry>
    <title>krpano学习笔记--干货</title>
    <link href="http://11wy11.github.io/2019/03/20/krpano-learn-note/"/>
    <id>http://11wy11.github.io/2019/03/20/krpano-learn-note/</id>
    <published>2019-03-19T16:46:27.000Z</published>
    <updated>2019-03-24T01:32:04.334Z</updated>
    
    <content type="html"><![CDATA[<p>介绍krpano开发中的一些注意事项和重要属性等<br><a id="more"></a></p><h1 id="1-Krpano-xml"><a href="#1-Krpano-xml" class="headerlink" title="1.Krpano xml"></a>1.Krpano xml</h1><ol><li>Onstart<br>onstart事件将在xml加载和解析之后直接调用。</li><li>Basedir<br>basedir设置为所有下面的loadpano（）动作调用定义了基本目录。这可以是相对路径或绝对路径，也可以在这里使用 url占位符。默认值是％FIRSTXML％，这意味着所有下面的loadpano（）动作调用的所有相对xml路径都是相对于第一个加载的xml文件。</li><li>关于vars和initvars区别<br>vars在加载xml后加载图像前赋值，而initvars在加载xml前赋值，一般用于构建url。由于get:variable或calc:variable中的变量值需要在加载xml中定义，所以使用vars不能在开始加载时控制krpano的某些设置，但是可以在之后动态的修改其显示状态。</li><li>Action: 参数/参数传递/解析<br>当调用一个动作时，可以将参数/参数传递给它。<br>为了访问参数/参数，有两种可能性：</li></ol><ul><li>通过占位符替换：（ 旧版本的方法）<br>  可以使用从％0到％99形式的操作代码中的数字占位符来获取给定的参数。<br>  其中％0是操作本身的名称， ％1表示第一个参数， ％2表示第二个参数，依此类推。<br>  这些占位符可以在代码中的任何地方使用。<br>  在实际的操作代码将被解析并执行之前，所有的占位符将被其参数值替换。<br>  当给定的占位符不会有参数时，将使用值’null’。<br>  要在动作中使用％字符，需要使用%%</li><li>通过参数到变量映射:( 推荐，新的）<br>  对于具有本地作用域的操作，可以将args属性添加到&lt;action>元素。例如：<br>  <code>&lt;action ... args =“var1，var2，var3”&gt;</code><br>  在那里可以定义给定动作参数/参数的args属性变量名称（用逗号分隔）。<br>  每个动作参数将被映射到本地作用域中的一个新变量，其名称是在args属性中设置的。<br>  这些变量可以像操作代码中的任何其他变量一样正常使用（例如，通过get / calc / copy读取）。<br>  当给定变量没有动作参数时，将使用值’null’。<br>  处理包含引号或逗号字符的值时，使用变量映射非常有用。在这种情况下，正常的占位符替换可能会产生问题<br>  注意 - 建议尽可能使用参数变量映射。没有％N占位符的动作可以在内部进行缓存，这使得进一步调用的执行速度更快。</li></ul><h1 id="值得注意的属性"><a href="#值得注意的属性" class="headerlink" title="值得注意的属性"></a>值得注意的属性</h1><ol><li>Name属性：每个名字都需要以字母字符开头！这意味着不允许使用数字作为名字！当名称仍然以数字字符开头时，名称将被解释为数组索引。这对于动作内部基于动态索引的访问没有问题，但不能用于定义元素！所有名称将自动转换为小写字母，以便直接区分大小写访问！</li><li>URL属性：<br>当一个相对路径被用作url值时，路径将被自动调整为相对于定义了url属性的xml文件。这意味着xml中的相对路径总是相对于xml本身，但是请注意 - 当动态设置/更改url属性时，则不再有与xml的自动关系！要使路径相对于某些特定的预定义路径，可以 在url路径中使用这些占位符中的一些：<br>％FIRSTXML％ - 第一个加载的xml文件的路径。<br>％CURRENTXML％ - 当前加载的主要xml文件的路径（不是包含的）。<br>％SWFPATH％ - krpano查看器文件的路径。<br>％HTMLPATH％ - html文件的路径。<br>％BASEDIR％ - 使用basedir路径。<br>％$ VARIABLE％ - 使用给定’VARIABLE’的值 - 这可以是任何krpano变量，但必须在加载当前xml或场景之前定义它，例如，在嵌入过程中（通过initvars）或在loadpano（），loadscene（）调用之前。</li><li>Style属性<br>&lt;style>元素是任何类型属性的集合/存储元素。<br>每个其他具有name属性的xml元素也可以有一个style属性。当xml元素首次被创建时，在&lt;style>元素处定义的所有属性将被复制到元素本身。这将在xml元素本身定义的属性被应用之前完成。<br>这意味着可以在&lt;style>元素中预先定义一些设置，然后使用直接在元素上定义的属性稍后覆盖它们。</li><li>Get:|Calc方法<br>当xml属性的值以get：或calc：开头时：<br>在这种情况下，xml属性的值将从其他变量获取或使用表达式计算。<br>在get：或calc：中使用的变量需要在当前xml元素之前（=上方）定义。此外，这里有一个特殊情况 - 在&lt;include>元素上使用它时，那么在那里使用的变量需要在当前xml加载之前定义。这可以在嵌入期间通过使用initvars设置或在xml中进行loadpano（）调用之前在html文件中完成。</li></ol><h1 id="Javascript-krpano操作-（仅限HTML5）"><a href="#Javascript-krpano操作-（仅限HTML5）" class="headerlink" title="Javascript krpano操作 （仅限HTML5）"></a>Javascript krpano操作 （仅限HTML5）</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;action name =“...” type =“ Javascript ” &gt; &lt;！[CDATA [     ... autorun =“”</span><br><span class="line"></span><br><span class="line">    Javascript代码</span><br><span class="line">    ... </span><br><span class="line">]]&gt; &lt;/ action&gt;</span><br></pre></td></tr></table></figure><p>Action type krpano操作的类型：<br>type =“”（默认） - 正常krpano操作 - 适用于Flash和HTML5<br>type =“Javascript” - JavaScript krpano操作 - 仅限HTML5</p><p>Action scope<br>在操作中为新生成的变量定义范围：<br>全局或未设置（默认）<br>新变量将被添加到全局变量作用域中。<br>其他任何行为或代码也可以使用它们。<br>这在再使用变量名称时可能会有问题，特别是当变量类型在用法之间会有所不同时。<br>本地<br>新变量将被添加到仅存在于当前操作调用中的局部变量作用域中。<br>当动作完成或调用其他动作时，局部作用域和其中定义的所有变量将不再可用。<br>动作越复杂，它使用的临时变量越多，使用本地作用域进行此操作越有意义，以避免干扰其他动作的问题。<br>设置LocalOnly<br>有些作为scope = local，但区别在于，默认情况下，所有访问仅引用本地作用域本身。<br>全局范围的访问只能由全局对象来实现。<br>亲<br>使用调用者的范围。<br>当调用当前动作的动作具有局部范围时，则可以在当前动作中使用/访问该动作。<br>私人：NAME<br>为该操作定义一个私有本地范围。<br>范围将由自定义的唯一名称进行参考。<br>该范围在多个操作调用之间保持活动状态，并可以在多个操作中共享。<br>有些作为范围= localonly所有访问只涉及本地范围本身。</p><h1 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h1><p>全局范围访问 - 搜索变量时，首先搜索本地范围，然后搜索全局范围。为了能够将变量添加到全局范围，即使在使用本地范围或直接访问全局范围内的变量时，也存在全局对象。<br>本地范围访问 - 为了能够确保访问本地范围（例如，当可能已经存在具有相同名称的全局变量时定义本地变量），当前本地范围也可用作 操作代码中的本地对象。例如使用def（local.i，integer，0）; 定义一个名为’i’的局部整型变量。为了稍后访问动作代码，只需使用’i’来解决该变量就足够了。<br>延期代码 - 稍后调用其他代码的操作（例如delayedcall，tween，asyncloop等）将使用与该代码中当前操作相同的范围。<br>调用者范围 - 从插件/图层/热点事件调用的代码<br>对于非localscope动作：<br>当一个动作（或任何代码）将从plugin / layer / hotspot事件中被调用时，plugin / layer / hotspot对象本身也将作为搜索变量的范围。但仅限于访问现有的变量！新生成的变量将始终添加到全局范围中。<br>对于localscope动作：<br>在localscope动作中总是有预定义的局部变量调用者。当动作将从插件/图层/热点事件（或通过使用callwith）被调用时，那么该 调用者变量将引用该元素。否则，调用者变量将为空。</p><p>本地作用域操作中的 预定义变量：<br>actionname - 当前操作的名称。<br>args - 参数的值数组。<br>访问者：args [index]。<br>通过以下方式获取数字或参数：args.length。<br>调用者 - 从那里调用插件/图层/热点对象，否则为null。<br>全球 - 参考全球范围。<br>本地 - 对当前本地范围本身的引用。<br>parentscope - 父行为的范围引用，当没有父范围时，这指的是全局范围。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;介绍krpano开发中的一些注意事项和重要属性等&lt;br&gt;
    
    </summary>
    
      <category term="全景" scheme="http://11wy11.github.io/categories/%E5%85%A8%E6%99%AF/"/>
    
    
      <category term="krpano" scheme="http://11wy11.github.io/tags/krpano/"/>
    
  </entry>
  
  <entry>
    <title>VS2013/VS2015/VS2017下使用ArcEngine10.1/10.2（一）</title>
    <link href="http://11wy11.github.io/2019/03/19/arcengine-first/"/>
    <id>http://11wy11.github.io/2019/03/19/arcengine-first/</id>
    <published>2019-03-19T07:51:40.000Z</published>
    <updated>2019-03-20T02:32:42.182Z</updated>
    
    <content type="html"><![CDATA[<p>ArcObjects SDK for Microsoft .Net Framework 10.1或10.2在安装时，会检测VS2010或VS2012的安装路径，而有时因为其他项目使用限制而且不愿同时安装多个版本的VS,通过修改注册表方式实现安装<br><a id="more"></a></p><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>ArcObjects SDK for Microsoft .Net Framework 10.1或10.2在安装时，会检测VS2010或VS2012的安装路径，而有时因为其他项目使用限制而且不愿同时安装多个版本的VS,通过修改注册表方式实现安装</p><h1 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h1><h2 id="1-修改注册表"><a href="#1-修改注册表" class="headerlink" title="1.修改注册表"></a>1.修改注册表</h2><p>首先打开注册表，window系统可以通过win+R，输入regedit后，回车打开注册表</p><p>找到<strong>计算机\HKEY_LOCAL_MACHINE\SOFTWARE\WOW6432Node\Microsoft\VisualStudio\10.0</strong>，点击10.0文件夹，此时是没有InstallDir和ShellFolder两个字符串值</p><p>找到<strong>计算机\HKEY_LOCAL_MACHINE\SOFTWARE\WOW6432Node\Microsoft\VisualStudio\12.0</strong>,点击12.0文件夹，查看InstallDir值，并复制</p><p>回到10.0目录，右键新建->字符串值，新建InstallDir值，双击编辑值，将刚复制的粘贴</p><p>同样的处理，添加ShellFolder</p><h2 id="2-安装ArcObjects-SDK-for-Microsoft-Net-Framework"><a href="#2-安装ArcObjects-SDK-for-Microsoft-Net-Framework" class="headerlink" title="2.安装ArcObjects SDK for Microsoft .Net Framework"></a>2.安装ArcObjects SDK for Microsoft .Net Framework</h2><p>打开ArcGIS Desktop 或ArcEngine安装程序，找到ArcObjects SDK for Microsoft .Net Framework，点击安装，此时就不会提示要求VS2010或VS2012安装环境了，下面以ArcGIS Desktop 为例：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="arcengine-first/pic1.png" alt="图1-安装" title>                </div>                <div class="image-caption">图1-安装</div>            </figure></p><h2 id="3-在工具箱中添加ArcGIS相关组件"><a href="#3-在工具箱中添加ArcGIS相关组件" class="headerlink" title="3. 在工具箱中添加ArcGIS相关组件"></a>3. 在工具箱中添加ArcGIS相关组件</h2><p>由于通过修改注册表的方式安装的ArcObjects SDK for Microsoft .Net Framework，因此，可能会导致VS中没有ArcGIS相关工具，需要手动添加</p><p>打开VS2013,任意打开一个窗体，打开工具箱，会发现没有ArcGIS选项卡，因此，首先右键<strong>新建选项卡</strong>，然后右键，点击<strong>选择项</strong>,在.NET Framework组件下，找到下图所示的ArcGIS组件<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="arcengine-first/pic2.png" alt="图2-添加ArcGIS组件" title>                </div>                <div class="image-caption">图2-添加ArcGIS组件</div>            </figure></p><h3 id="方案1"><a href="#方案1" class="headerlink" title="方案1"></a>方案1</h3><p>注意，如果在.NET Framework下找不到相关组件，可以点击<strong>浏览</strong>,找到ArcObjects SDK for Microsoft .Net Framework的安装目录下的DotNet，一般路径为<code>D:\Program Files (x86)\ArcGIS\DeveloperKit10.2\DotNet</code>如下图所示，可以按需添加，或者按住<strong>Shift</strong>全选添加。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="arcengine-first/pic3.png" alt="图3-浏览组件dll" title>                </div>                <div class="image-caption">图3-浏览组件dll</div>            </figure></p><p>勾选需要的组件，点击确定后，在新建的选项卡下出现组件<br>    <center><br>    <img src="arcengine-first/pic4.png" alt="图4-组件"><br>    </center><br>红色框为新添加的.NET组件，上面两个是COM组件，暂时不需要使用，下节介绍.NET组件和COM组件的区别  </p><h3 id="方案2"><a href="#方案2" class="headerlink" title="方案2"></a>方案2</h3><p>在Desktop安装目录的bin下找到需要的控件，以.ocx为后缀，选中后拖入工具箱</p><h2 id="添加引用"><a href="#添加引用" class="headerlink" title="添加引用"></a>添加引用</h2><p>在不做任何手动操作时，安装了ArcGIS Desktop之后，可以在COM下的类型库中找到ArcGIS 相关的COM组件，如下图所示<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="arcengine-first/pic5.png" alt="图5-COM类型库中的ArcGIS相关组件" title>                </div>                <div class="image-caption">图5-COM类型库中的ArcGIS相关组件</div>            </figure></p><p>注意点击引用这些组件时，引用呈现下图所示结果：</p><center><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="arcengine-first/pic6.png" alt="图6-添加COM组件引用后" title>                </div>                <div class="image-caption">图6-添加COM组件引用后</div>            </figure><br></center><p>但会发现找不到Esri.ArcGIS.Version的库，而这个库必须在主函数入口处使用获得授权许可，之后才能使用ArcEngine中相关的类或接口。</p><p>因此，<strong>这里在添加引用是选择.NET组件</strong>，点击<strong>浏览</strong>找到ArcObjects SDK for Microsoft .Net Framework的安装目录下的DotNet，一般路径为<code>D:\Program Files (x86)\ArcGIS\DeveloperKit10.2\DotNet</code>如下图所示，选择Esri.ArcGIS.Version.dll，其他库VS会根据需要自动引用。如上图图3所示.<br>注意点击引用这些组件时，引用呈现下图所示结果：</p><center><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="arcengine-first/pic7.png" alt="图7-添加NET组件引用后" title>                </div>                <div class="image-caption">图7-添加NET组件引用后</div>            </figure><br></center><h1 id="Program-cs中授权"><a href="#Program-cs中授权" class="headerlink" title="Program.cs中授权"></a>Program.cs中授权</h1><p>在Main函数中添加 <code>ESRI.ArcGIS.RuntimeManager.Bind(ESRI.ArcGIS.ProductCode.EngineOrDesktop);</code>,如下图所示<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="arcengine-first/pic8.png" alt="图8-添加授权" title>                </div>                <div class="image-caption">图8-添加授权</div>            </figure></p><p>直至就可以在一个应用程序中使用ArcEngine的功能了。</p><p>当然如果你想使用VS创建ArcGIS模板应用程序，此时你会发现Visual C#下没有ArcGIS选项，这时又需要我们手动添加了<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="arcengine-first/pic9.png" alt="图9-手动安装之前" title>                </div>                <div class="image-caption">图9-手动安装之前</div>            </figure></p><h1 id="手动添加ArcGIS项目模板"><a href="#手动添加ArcGIS项目模板" class="headerlink" title="手动添加ArcGIS项目模板"></a>手动添加ArcGIS项目模板</h1><p>由于我们最开始安装SDK时，采用了修改注册表的方式骗过ArcObject检测，因此，模板默认安装在了但是设置的VS2013安装路径Microsoft Visio Studio 12.0下了</p><ol><li>将模板拷贝至vs模板库中<br>找到D:\Program Files (x86)\Microsoft Visual Studio 12.0\Microsoft Visual Studio 10.0，在Common7/IDE下有两个文件夹<strong>ItemTemplates/CSharp/ArcGIS</strong>,<strong>ProjectTemplates/CSharp/ArcGIS</strong>,<br>分别拷贝在vs2013模板文件位置，如：<br>D:\Program Files (x86)\Microsoft Visual Studio 12.0\Common7\IDE\<strong>ItemTemplates</strong>\CSharp和<br>I:\Program Files (x86)\Microsoft Visual Studio 12.0\Common7\IDE\<strong>ProjectTemplates</strong>\CSharp</li><li>右键，以管理员权限运行vs2013,也就是启动vs2013</li><li><p>重新安装一次模板</p><ul><li>打开vs2013/2015的命令行工具<br> 2013：<br>  开始–&gt; 所有应用 –&gt; Microsoft Visual Studio 2013 –&gt; Visual Studio Tools,打开后 vs2013开发人员命令提示<br>  <img src="arcengine-first/pic10.png" alt="图10-vs2013开发人员命令提示"><br> 2015或更高：<br> 开始–&gt; 所有应用 –&gt; Microsoft Visual Studio 2015 –&gt; vs2015开发人员命令提示（可能会叫Visual Studio 2015 Command Prompt ）</li><li><p>执行如下命令<br><code>devenv.exe/InstallVSTemplates</code><br>需要注意的事情是，这个命令执行后，不会马上出现项目或项模板，需要重新打开vs2017，新建时会重新初始化模板。 </p><p>如果第三步有问题，换成用管理员权限运行。</p></li></ul></li><li>效果<br>C#下出现ArcGIS相关模板<br> <img src="arcengine-first/pic11.png" alt="图11-成功添加ArcGIS模板"></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ArcObjects SDK for Microsoft .Net Framework 10.1或10.2在安装时，会检测VS2010或VS2012的安装路径，而有时因为其他项目使用限制而且不愿同时安装多个版本的VS,通过修改注册表方式实现安装&lt;br&gt;
    
    </summary>
    
      <category term="ArcGIS" scheme="http://11wy11.github.io/categories/ArcGIS/"/>
    
    
      <category term="ArcEngine" scheme="http://11wy11.github.io/tags/ArcEngine/"/>
    
      <category term="VS" scheme="http://11wy11.github.io/tags/VS/"/>
    
  </entry>
  
  <entry>
    <title>GDAL简介</title>
    <link href="http://11wy11.github.io/2019/03/18/cpp-gdal/"/>
    <id>http://11wy11.github.io/2019/03/18/cpp-gdal/</id>
    <published>2019-03-18T07:26:26.000Z</published>
    <updated>2019-03-24T06:30:30.855Z</updated>
    
    <content type="html"><![CDATA[<p>GDAL(Geospatial Data Abstraction Library)是一个在X/MIT许可协议下的开源栅格空间数据转换库<br><strong>持续更新中</strong><br><a id="more"></a><br><!-- START doctoc generated TOC please keep comment here to allow auto update --><br><!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE --><br><strong>Table of Contents</strong>  <em>generated with <a href="https://github.com/thlorenz/doctoc" target="_blank" rel="noopener">DocToc</a></em></p><ul><li><a href="#%E7%AE%80%E4%BB%8B">简介</a></li><li><a href="#%E5%8A%9F%E8%83%BD%E7%89%B9%E5%BE%81">功能特征</a></li><li><a href="#ogr%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%BC%96%E8%BE%91">OGR体系结构编辑</a></li><li><a href="#gdal%E4%B8%ADogr%E7%9A%84%E4%BD%BF%E7%94%A8">GDAL中OGR的使用</a><ul><li><a href="#%E8%AF%BB%E6%95%B0%E6%8D%AE">读数据</a></li><li><a href="#%E5%86%99%E6%95%B0%E6%8D%AE">写数据</a></li></ul></li><li><a href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料：</a></li></ul><!-- END doctoc generated TOC please keep comment here to allow auto update --><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>它利用抽象数据模型来表达所支持的各种文件格式。它还有一系列命令行工具来进行数据转换和处理。</p><p>OGR是GDAL项目的一个分支，功能与GDAL类似，只不过它提供对矢量数据的支持。</p><p>有很多著名的GIS类产品都使用了GDAL/OGR库，包括ESRI的ARCGIS 9.3，Google Earth和跨平台的GRASS GIS系统。利用GDAL/OGR库，可以使基于Linux的地理空间数据管理系统提供对矢量和栅格文件数据的支持。</p><h1 id="功能特征"><a href="#功能特征" class="headerlink" title="功能特征"></a>功能特征</h1><p>GDAL提供对多种栅格数据的支持，包括Arc/Info ASCII Grid(asc)，GeoTiff (tiff)，Erdas Imagine Images(img)，ASCII DEM(dem) 等格式。</p><p>GDAL使用抽象数据模型(abstract data model)来解析它所支持的数据格式，抽象数据模型包括数据集(dataset)，坐标系统，仿射地理坐标转换(Affine Geo Transform)， 大地控制点(GCPs)， 元数据(Metadata)，栅格波段(Raster Band)，颜色表(Color Table)，子数据集域(Subdatasets Domain)，图像结构域(Image_Structure Domain)，XML域(XML:Domains)。</p><p>GDALMajorObject类：带有元数据的对象。</p><p>GDALDdataset类：通常是从一个栅格文件中提取的相关联的栅格波段集合和这些波段的元数据;GDALDdataset也负责所有栅格波段的地理坐标转换(georeferencing transform)和坐标系定义。</p><p>GDALDriver类：文件格式驱动类，GDAL会为每一个所支持的文件格式创建一个该类的实体，来管理该文件格式。</p><p>GDALDriverManager类：文件格式驱动管理类，用来管理GDALDriver类。</p><h1 id="OGR体系结构编辑"><a href="#OGR体系结构编辑" class="headerlink" title="OGR体系结构编辑"></a>OGR体系结构编辑</h1><p>Geometry类：Geometry (包括OGRGeometry等类)封装了OpenGIS的矢量数据模型，并提供了一些几何操作，WKB(Well Knows Binary)和WKT(Well Known Text)格式之间的相互转换，以及空间参考系统(投影)。</p><p>Spatial Reference类：OGRSpatialReference封装了投影和基准面的定义。</p><p>Feature类：OGRFeature封装了一个完整feature的定义，一个完整的feature包括一个geometry和geometry的一系列属性。</p><p>Feature Definition类：OGRFeatureDefn里面封装了feature的属性，类型、名称及其默认的空间参考系统等。一个OGRFeatureDefn对象通常与一个层(layer)对应。</p><p>Layer类：OGRLayer是一个抽象基类，表示数据源类OGRDataSource里面的一层要素(feature)。</p><p>Data Source类：OGRDataSource是一个抽象基类，表示含有OGRLayer对象的一个文件或一个数据库。</p><p>Drivers类：OGRSFDriver对应于每一个所支持的矢量文件格式。类OGRSFDriver由类OGRSFDriverRegistrar来注册和管理。</p><h1 id="GDAL中OGR的使用"><a href="#GDAL中OGR的使用" class="headerlink" title="GDAL中OGR的使用"></a>GDAL中OGR的使用</h1><h2 id="读数据"><a href="#读数据" class="headerlink" title="读数据"></a>读数据</h2><ol><li><p>在工程的Library files中和Include files中分别添加GDAL的LIB文件目录和头文件目录</p></li><li><p>最初需要注册所需的所有格式驱动程序。这通常通过调用GDALAllRegister（）来完成，该寄存器注册GDAL / OGR中内置的所有格式驱动程序。 </p></li><li><p>接下来我们需要打开输入OGR数据源。数据源可以是文件，RDBMS，充满文件的目录，甚至是远程Web服务，具体取决于所使用的驱动程序。但是，数据源名称始终是单个字符串。在这种情况下，我们硬编码打开一个特定的shapefile。第二个参数（GDAL_OF_VECTOR）告诉OGROpen（）方法我们想要使用向量驱动程序并且不需要更新访问。失败时返回NULL，我们报告错误。</p></li><li><p>GDALDataset可以潜在地具有与它相关联的许多层。可以使用GDALDataset :: GetLayerCount（）查询可用的图层数，并使用GDALDataset :: GetLayer（）通过索引获取各个图层。但是，我们只是按名称获取图层。<br> OGRLayer   * poLayer;<br> poLayer = poDS-&gt; GetLayerByName（“point”）;  </p></li><li><p>现在我们要开始从图层中读取要素。在我们开始之前，我们可以为图层指定属性或空间过滤器以限制我们获取的功能集，但是现在我们有兴趣获取所有功能。</p></li><li><p>我们使用OGRLayer :: GetNextFeature（）遍历图层中的所有要素。当我们用完功能时它会返回NULL。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">OGRFeature *poFeature;</span><br><span class="line">poLayer-&gt;ResetReading();</span><br><span class="line">while( (poFeature = poLayer-&gt;GetNextFeature()) != NULL )</span><br><span class="line">&#123;</span><br></pre></td></tr></table></figure></li><li><p>为了转储该功能的所有属性字段，获取OGRFeatureDefn会很有帮助。这是与图层关联的对象，包含所有字段的定义。我们遍历所有字段，并根据其类型获取和报告属性。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">for( auto&amp;&amp; oField: *poFeature )</span><br><span class="line">&#123;</span><br><span class="line">    switch( oField.GetType() )</span><br><span class="line">    &#123;</span><br><span class="line">        case OFTInteger:</span><br><span class="line">            printf( &quot;%d,&quot;, oField.GetInteger() );</span><br><span class="line">            break;</span><br><span class="line">        case OFTInteger64:</span><br><span class="line">            printf( CPL_FRMT_GIB &quot;,&quot;, oField.GetInteger64() );</span><br><span class="line">            break;</span><br><span class="line">        case OFTReal:</span><br><span class="line">            printf( &quot;%.3f,&quot;, oField.GetDouble() );</span><br><span class="line">            break;</span><br><span class="line">        case OFTString:</span><br><span class="line">            printf( &quot;%s,&quot;, oField.GetString() );</span><br><span class="line">            break;</span><br><span class="line">        default:</span><br><span class="line">            printf( &quot;%s,&quot;, oField.GetAsString() );</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 除了上面显式处理的字段类型之外，还有一些字段类型，但可以使用OGRFeature :: GetFieldAsString（）方法获取它们的合理表示。事实上，我们可以通过对所有类型使用OGRFeature :: GetFieldAsString（）来缩短上述内容。   </p></li><li><p>接下来，我们要从要素中提取几何体，并写出点几何体x和y。几何图形作为通用OGRGeometry指针返回。然后我们确定特定的几何类型，如果它是一个点，我们将其转换为点并对其进行操作。如果它是别的东西我们写占位符。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">    OGRGeometry *poGeometry;</span><br><span class="line">    poGeometry = poFeature-&gt;GetGeometryRef();</span><br><span class="line">    if( poGeometry != NULL</span><br><span class="line">            &amp;&amp; wkbFlatten(poGeometry-&gt;getGeometryType()) == wkbPoint )</span><br><span class="line">    &#123;</span><br><span class="line">#if GDAL_VERSION_NUM &gt;= GDAL_COMPUTE_VERSION(2,3,0)</span><br><span class="line">        OGRPoint *poPoint = poGeometry-&gt;toPoint();</span><br><span class="line">#else</span><br><span class="line">        OGRPoint *poPoint = (OGRPoint *) poGeometry;</span><br><span class="line">#endif</span><br><span class="line">        printf( &quot;%.3f,%3.f\n&quot;, poPoint-&gt;getX(), poPoint-&gt;getY() );</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        printf( &quot;no point geometry\n&quot; );</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p> 所述wkbFlatten（）宏上述用于将类型转换为一个wkbPoint25D（带z坐标的点）到2D的类型代码（wkbPoint）。对于每个2D几何类型，都有相应的2.5D类型代码。2D和2.5D几何案例由相同的C ++类处理，因此我们的代码将正确处理2D或3D案例。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">OGRGeometry *poGeometry;</span><br><span class="line">   int iGeomField;</span><br><span class="line">   int nGeomFieldCount;</span><br><span class="line">   nGeomFieldCount = poFeature-&gt;GetGeomFieldCount();</span><br><span class="line">   for(iGeomField = 0; iGeomField &lt; nGeomFieldCount; iGeomField ++ )</span><br><span class="line">   &#123;</span><br><span class="line">       poGeometry = poFeature-&gt;GetGeomFieldRef(iGeomField);</span><br><span class="line">       if( poGeometry != NULL</span><br><span class="line">               &amp;&amp; wkbFlatten(poGeometry-&gt;getGeometryType()) == wkbPoint )</span><br><span class="line">       &#123;</span><br><span class="line">       #if GDAL_VERSION_NUM &gt;= GDAL_COMPUTE_VERSION(2,3,0)</span><br><span class="line">                   OGRPoint *poPoint = poGeometry-&gt;toPoint();</span><br><span class="line">       #else</span><br><span class="line">                   OGRPoint *poPoint = (OGRPoint *) poGeometry;</span><br><span class="line">       #endif</span><br><span class="line">                   printf( &quot;%.3f,%3.f\n&quot;, poPoint-&gt;getX(), poPoint-&gt;getY() );</span><br><span class="line">               &#125;</span><br><span class="line">       else</span><br><span class="line">       &#123;</span><br><span class="line">           printf( &quot;no point geometry\n&quot; );</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p> 请注意，OGRFeature :: GetGeometryRef（）和OGRFeature :: GetGeomFieldRef（）返回指向OGRFeature所拥有的内部几何的指针。实际上没有删除返回几何。  </p></li><li>对于GDAL &lt;2.3，因为OGRLayer :: GetNextFeature（）方法返回现在由我们拥有的功能的副本。因此，在使用结束时，我们必须释放该功能。我们可以“删除”它，但这可能会导致Windows版本中的问题，其中GDAL DLL与主程序具有不同的“堆”。为了安全起见，我们使用GDAL功能删除该功能。<br> <code>OGRFeature :: DestroyFeature（poFeature）;}</code></li><li>该OGRLayer通过返回的GDALDataset :: GetLayerByName（）也是由拥有一个内部层参考的GDALDataset所以我们并不需要将其删除。但我们确实需要删除数据源才能关闭输入文件。我们再一次使用自定义删除方法来避免特殊的win32堆问题。<br> <code>GDALClose（poDS）; }</code></li><li>完整模板 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;ogrsf_frmts.h&quot;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    GDALAllRegister();</span><br><span class="line">    GDALDataset *poDS = static_cast&lt;GDALDataset*&gt;(</span><br><span class="line">        GDALOpenEx( &quot;point.shp&quot;, GDAL_OF_VECTOR, NULL, NULL, NULL ));</span><br><span class="line">    if( poDS == NULL )</span><br><span class="line">    &#123;</span><br><span class="line">        printf( &quot;Open failed.\n&quot; );</span><br><span class="line">        exit( 1 );</span><br><span class="line">    &#125;</span><br><span class="line">    OGRLayer  *poLayer = poDS-&gt;GetLayerByName( &quot;point&quot; );</span><br><span class="line">    OGRFeatureDefn *poFDefn = poLayer-&gt;GetLayerDefn();</span><br><span class="line">    poLayer-&gt;ResetReading();</span><br><span class="line">    OGRFeature *poFeature;</span><br><span class="line">    while( (poFeature = poLayer-&gt;GetNextFeature()) != NULL )</span><br><span class="line">    &#123;</span><br><span class="line">        for( int iField = 0; iField &lt; poFDefn-&gt;GetFieldCount(); iField++ )</span><br><span class="line">        &#123;</span><br><span class="line">            OGRFieldDefn *poFieldDefn = poFDefn-&gt;GetFieldDefn( iField );</span><br><span class="line">            switch( poFieldDefn-&gt;GetType() )</span><br><span class="line">            &#123;</span><br><span class="line">                case OFTInteger:</span><br><span class="line">                    printf( &quot;%d,&quot;, poFeature-&gt;GetFieldAsInteger( iField ) );</span><br><span class="line">                    break;</span><br><span class="line">                case OFTInteger64:</span><br><span class="line">                    printf( CPL_FRMT_GIB &quot;,&quot;, poFeature-&gt;GetFieldAsInteger64( iField ) );</span><br><span class="line">                    break;</span><br><span class="line">                case OFTReal:</span><br><span class="line">                    printf( &quot;%.3f,&quot;, poFeature-&gt;GetFieldAsDouble(iField) );</span><br><span class="line">                    break;</span><br><span class="line">                case OFTString:</span><br><span class="line">                    printf( &quot;%s,&quot;, poFeature-&gt;GetFieldAsString(iField) );</span><br><span class="line">                    break;</span><br><span class="line">                default:</span><br><span class="line">                    printf( &quot;%s,&quot;, poFeature-&gt;GetFieldAsString(iField) );</span><br><span class="line">                    break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        OGRGeometry *poGeometry = poFeature-&gt;GetGeometryRef();</span><br><span class="line">        if( poGeometry != NULL</span><br><span class="line">                &amp;&amp; wkbFlatten(poGeometry-&gt;getGeometryType()) == wkbPoint )</span><br><span class="line">        &#123;</span><br><span class="line">            OGRPoint *poPoint = (OGRPoint *) poGeometry;</span><br><span class="line">            printf( &quot;%.3f,%3.f\n&quot;, poPoint-&gt;getX(), poPoint-&gt;getY() );</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            printf( &quot;no point geometry\n&quot; );</span><br><span class="line">        &#125;</span><br><span class="line">        OGRFeature::DestroyFeature( poFeature );</span><br><span class="line">    &#125;</span><br><span class="line">    GDALClose( poDS );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="写数据"><a href="#写数据" class="headerlink" title="写数据"></a>写数据</h2><p> 作为通过OGR写作的一个例子，我们将大致与上述相反。从输入文本中读取逗号分隔值的短程序将通过OGR写入点shapefile。  </p><pre><code>1. 像往常一样，我们首先注册所有驱动程序，然后获取Shapefile驱动程序，因为我们需要它来创建输出文件。    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;ogrsf_frmts.h&quot;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    const char *pszDriverName = &quot;ESRI Shapefile&quot;;</span><br><span class="line">    GDALDriver *poDriver;</span><br><span class="line">    GDALAllRegister();</span><br><span class="line">    poDriver = GetGDALDriverManager()-&gt;GetDriverByName(pszDriverName );</span><br><span class="line">    if( poDriver == NULL )</span><br><span class="line">    &#123;</span><br><span class="line">        printf( &quot;%s driver not available.\n&quot;, pszDriverName );</span><br><span class="line">        exit( 1 );</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>2. 接下来我们创建数据源。ESRI Shapefile驱动程序允许我们创建一个完整的shapefile目录，或一个shapefile作为数据源。在这种情况下，我们将通过在名称中包含扩展名来显式创建单个文件。其他驱动程序表现不同。第二个，第三个，第四个和第五个参数与栅格尺寸相关（如果驱动程序具有栅格功能）。调用的最后一个参数是选项值列表，但在这种情况下我们将只使用默认值。支持的选项的详细信息也是特定于格式的。    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">GDALDataset *poDS;</span><br><span class="line">poDS = poDriver-&gt;Create( &quot;point_out.shp&quot;, 0, 0, 0, GDT_Unknown, NULL );</span><br><span class="line">if( poDS == NULL )</span><br><span class="line">&#123;</span><br><span class="line">    printf( &quot;Creation of output file failed.\n&quot; );</span><br><span class="line">    exit( 1 );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>3. 现在我们创建输出层。在这种情况下，由于数据源是单个文件，因此我们只能有一个图层。我们传递wkbPoint来指定该层支持的几何类型。在这种情况下，我们不传递任何坐标系信息或其他特殊图层创建选项。    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">OGRLayer *poLayer;</span><br><span class="line">poLayer = poDS-&gt;CreateLayer( &quot;point_out&quot;, NULL, wkbPoint, NULL );</span><br><span class="line">if( poLayer == NULL )</span><br><span class="line">&#123;</span><br><span class="line">    printf( &quot;Layer creation failed.\n&quot; );</span><br><span class="line">    exit( 1 );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>4. 现在该图层已存在，我们需要创建应出现在图层上的任何属性字段。必须在写入任何要素之前将字段添加到图层。要创建字段，我们使用有关字段的信息初始化OGRField对象。在Shapefiles的情况下，字段宽度和精度在创建输出.dbf文件时很重要，所以我们专门设置它，尽管通常默认值是OK。对于此示例，我们将只有一个属性，一个与x，y点关联的名称字符串。   请注意，我们传递给CreateField（）的模板OGRField是在内部复制的。我们保留对象的所有权。   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">OGRFieldDefn oField（“Name”，OFTString）;</span><br><span class="line">oField.SetWidth（32）;</span><br><span class="line">if（poLayer-&gt; CreateField（＆oField）！= OGRERR_NONE）</span><br><span class="line">&#123;</span><br><span class="line">    printf（“创建名称字段失败。\ n”）;</span><br><span class="line">    退出（1）;</span><br><span class="line">&#125;</span><br><span class="line">//通过读数据中的x,y,name，写入</span><br><span class="line">double x, y;</span><br><span class="line"> char szName[33];</span><br><span class="line"> while( !feof(stdin)</span><br><span class="line">        &amp;&amp; fscanf( stdin, &quot;%lf,%lf,%32s&quot;, &amp;x, &amp;y, szName ) == 3 )</span><br><span class="line"> &#123;</span><br></pre></td></tr></table></figure>5. 要将功能写入磁盘，我们必须创建本地OGRFeature，设置属性并附加几何体，然后再尝试将其写入图层。必须从与要写入的层关联的OGRFeatureDefn实例化此功能。    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">OGRFeature * poFeature;</span><br><span class="line">poFeature = OGRFeature :: CreateFeature（poLayer-&gt; GetLayerDefn（））;</span><br><span class="line">poFeature-&gt; SetField（“Name”，szName）;</span><br></pre></td></tr></table></figure>6. 我们创建一个本地几何对象，并将其副本（间接）分配给该功能。的和OGRFeature :: SetGeometryDirectly（）不同于和OGRFeature :: SetGeometry（）在该直接方法给出了几何形状的特征的所有权。这通常更有效，因为它避免了几何体的额外深层对象副本。    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">OGRPoint pt;</span><br><span class="line">pt.setX( x );</span><br><span class="line">pt.setY( y );</span><br><span class="line">poFeature-&gt;SetGeometry( &amp;pt );</span><br></pre></td></tr></table></figure>7. 现在我们在文件中创建一个功能。该OGRLayer :: CreateFeature（）不走我们的特点的所有权，所以我们在用它做清理。    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> if( poLayer-&gt;CreateFeature( poFeature ) != OGRERR_NONE )</span><br><span class="line">     &#123;</span><br><span class="line">         printf( &quot;Failed to create feature in shapefile.\n&quot; );</span><br><span class="line">        exit( 1 );</span><br><span class="line">     &#125;</span><br><span class="line">     OGRFeature::DestroyFeature( poFeature );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>8. 最后，我们需要关闭数据源，以确保以有序的方式写出标头，并恢复所有资源。`GDALClose（poDS）;}`9. 模板    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;ogrsf_frmts.h&quot;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    const char *pszDriverName = &quot;ESRI Shapefile&quot;;</span><br><span class="line">    GDALDriver *poDriver;</span><br><span class="line">    GDALAllRegister();</span><br><span class="line">    poDriver = GetGDALDriverManager()-&gt;GetDriverByName(pszDriverName );</span><br><span class="line">    if( poDriver == NULL )</span><br><span class="line">    &#123;</span><br><span class="line">        printf( &quot;%s driver not available.\n&quot;, pszDriverName );</span><br><span class="line">        exit( 1 );</span><br><span class="line">    &#125;</span><br><span class="line">    GDALDataset *poDS;</span><br><span class="line">    poDS = poDriver-&gt;Create( &quot;point_out.shp&quot;, 0, 0, 0, GDT_Unknown, NULL );</span><br><span class="line">    if( poDS == NULL )</span><br><span class="line">    &#123;</span><br><span class="line">        printf( &quot;Creation of output file failed.\n&quot; );</span><br><span class="line">        exit( 1 );</span><br><span class="line">    &#125;</span><br><span class="line">    OGRLayer *poLayer;</span><br><span class="line">    poLayer = poDS-&gt;CreateLayer( &quot;point_out&quot;, NULL, wkbPoint, NULL );</span><br><span class="line">    if( poLayer == NULL )</span><br><span class="line">    &#123;</span><br><span class="line">        printf( &quot;Layer creation failed.\n&quot; );</span><br><span class="line">        exit( 1 );</span><br><span class="line">    &#125;</span><br><span class="line">    OGRFieldDefn oField( &quot;Name&quot;, OFTString );</span><br><span class="line">    oField.SetWidth(32);</span><br><span class="line">    if( poLayer-&gt;CreateField( &amp;oField ) != OGRERR_NONE )</span><br><span class="line">    &#123;</span><br><span class="line">        printf( &quot;Creating Name field failed.\n&quot; );</span><br><span class="line">        exit( 1 );</span><br><span class="line">    &#125;</span><br><span class="line">    double x, y;</span><br><span class="line">    char szName[33];</span><br><span class="line">    while( !feof(stdin)</span><br><span class="line">           &amp;&amp; fscanf( stdin, &quot;%lf,%lf,%32s&quot;, &amp;x, &amp;y, szName ) == 3 )</span><br><span class="line">    &#123;</span><br><span class="line">        OGRFeature *poFeature;</span><br><span class="line">        poFeature = OGRFeature::CreateFeature( poLayer-&gt;GetLayerDefn() );</span><br><span class="line">        poFeature-&gt;SetField( &quot;Name&quot;, szName );</span><br><span class="line">        OGRPoint pt;</span><br><span class="line">        pt.setX( x );</span><br><span class="line">        pt.setY( y );</span><br><span class="line">        poFeature-&gt;SetGeometry( &amp;pt );</span><br><span class="line">        if( poLayer-&gt;CreateFeature( poFeature ) != OGRERR_NONE )</span><br><span class="line">        &#123;</span><br><span class="line">            printf( &quot;Failed to create feature in shapefile.\n&quot; );</span><br><span class="line">            exit( 1 );</span><br><span class="line">        &#125;</span><br><span class="line">        OGRFeature::DestroyFeature( poFeature );</span><br><span class="line">    &#125;</span><br><span class="line">    GDALClose( poDS );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><ol><li>百度百科：<a href="https://baike.baidu.com/item/GDAL/4004525?fr=aladdin" target="_blank" rel="noopener">https://baike.baidu.com/item/GDAL/4004525?fr=aladdin</a></li><li>官方网站：<a href="https://www.gdal.org/" target="_blank" rel="noopener">https://www.gdal.org/</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;GDAL(Geospatial Data Abstraction Library)是一个在X/MIT许可协议下的开源栅格空间数据转换库&lt;br&gt;&lt;strong&gt;持续更新中&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
      <category term="C++" scheme="http://11wy11.github.io/categories/C/"/>
    
    
      <category term="GDAL" scheme="http://11wy11.github.io/tags/GDAL/"/>
    
  </entry>
  
  <entry>
    <title>常用工具</title>
    <link href="http://11wy11.github.io/2019/03/18/tools/"/>
    <id>http://11wy11.github.io/2019/03/18/tools/</id>
    <published>2019-03-18T04:46:05.000Z</published>
    <updated>2019-03-24T01:35:38.507Z</updated>
    
    <content type="html"><![CDATA[<p>主要介绍doctoc插件自动生成文章目录<br><a id="more"></a></p><h1 id="markdown相关"><a href="#markdown相关" class="headerlink" title="markdown相关"></a>markdown相关</h1><h2 id="doctoc-markdown目录自动生成"><a href="#doctoc-markdown目录自动生成" class="headerlink" title="doctoc(markdown目录自动生成)"></a>doctoc(markdown目录自动生成)</h2><p>GitHub中的markdown文件直接写[TOC]是无法生成目录的，可以使用工具doctoc<br>npm install -g doctoc<br>使用方式</p><ul><li><p>对当前文件夹中所有文件生成目录<br>e.g.</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    cd D:\Develop\Documents\Notes\CSDN笔记\temp</span><br><span class="line">    doctoc .</span><br><span class="line">    ``` </span><br><span class="line"></span><br><span class="line">+ 对文件夹中单个文件生成目录（文件名中间不能有空格）  </span><br><span class="line">`doctoc /path/to/file [...]`  </span><br><span class="line">  如：</span><br></pre></td></tr></table></figure><p>  doctoc README.md<br>  doctoc CONTRIBUTING.md LICENSE.md<br>  doctoc D:\Develop\Documents\Notes\CSDN笔记\JAVARxJava.md<br> <code>`</code></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;主要介绍doctoc插件自动生成文章目录&lt;br&gt;
    
    </summary>
    
      <category term="工具" scheme="http://11wy11.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="tools" scheme="http://11wy11.github.io/tags/tools/"/>
    
  </entry>
  
  <entry>
    <title>AI组件开发（二）--AIRealMathSuite</title>
    <link href="http://11wy11.github.io/2019/03/18/ai-second-note/"/>
    <id>http://11wy11.github.io/2019/03/18/ai-second-note/</id>
    <published>2019-03-18T02:50:27.000Z</published>
    <updated>2019-03-25T08:38:49.151Z</updated>
    
    <content type="html"><![CDATA[<p>主要介绍AIRealMathSuite中使用到的函数，以及部分应用场景，持续更新中<br><a id="more"></a></p><h1 id="AIRealRectOverlap"><a href="#AIRealRectOverlap" class="headerlink" title="AIRealRectOverlap"></a>AIRealRectOverlap</h1><p>AIAPI AIBoolean(* AIRealMathSuite::AIRealRectOverlap)(const AIRealRect *a, const AIRealRect *b)<br>Tests whether two rectangles overlap (have any points in common).<br>测试两个矩形是否重叠（有任何共同点）  </p><ul><li>参数:<ul><li>a<br>The first rectangle.</li><li>b<br>The second rectangle.  </li></ul></li><li>返回值：<br>如果矩形重叠，则为真。</li></ul><h1 id="AIRealRectInAIRealRect"><a href="#AIRealRectInAIRealRect" class="headerlink" title="AIRealRectInAIRealRect"></a>AIRealRectInAIRealRect</h1><p>AIAPI AIBoolean(* AIRealMathSuite::AIRealRectInAIRealRect)(const AIRealRect *a, const AIRealRect *b)<br>Tests whether one rectangle is inside (entirely contained in) another rectangle.<br>测试一个矩形是否在另一个矩形内（完全包含在内）。  </p><p>Both must be open or both closed.<br>两者都必须是开放的或都是封闭的。</p><ul><li>参数:<ul><li>a<br>The first rectangle.  </li><li>b<br>The second rectangle.</li></ul></li><li>返回值：<br>True if the set of points contained by a is also contained by b.<br>如果a包含的点集也包含在b内，则为真。</li></ul><h1 id="AIRealRectSet"><a href="#AIRealRectSet" class="headerlink" title="AIRealRectSet"></a>AIRealRectSet</h1><p>AIAPI void(* AIRealMathSuite::AIRealRectSet)(AIRealRect *a, AIReal left, AIReal top, AIReal right, AIReal bottom)<br>Sets the coordinate values in a rectangle. 设置矩形中的坐标值<br>(In the Illustrator art coordinate system, the origin, (0, 0), is at the bottom left corner of a page. X and Y values increase upward and to the right.) </p><ul><li>参数:<ul><li>a<br>The rectangle object. ///AI的矩形对象指针</li><li>left<br>The left side location.///xmin</li><li>top<br>The top side location. ///ymax</li><li>right<br>The right side location.///xmax</li><li>bottom<br>The bottom side location.///ymin</li></ul></li></ul><p>注意：Illustrator的坐标系原点位于页面左下角，X和Y值向上和向右增加。</p><h1 id="AIRealPointInterpolate"><a href="#AIRealPointInterpolate" class="headerlink" title="AIRealPointInterpolate"></a>AIRealPointInterpolate</h1><p>AIAPI void（* AIRealMathSuite :: AIRealPointInterpolate）（const AIRealPoint * a，const AIRealPoint * b，AIReal t，AIRealPoint * result）<br>通过在点的相应坐标之间插入新坐标值来计算两点之间的点的位置。<br>原理就是向量<br>结果是 a <em> t + b </em> (1-t)</p><p>参数：<br>a 第一点。<br>b 第二点。<br>t（b-a）的百分比，表示为0到1之间的数字。<br>result     [out]用于返回结果的缓冲区。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>  Adobe Illustrator SDK，下载地址：<a href="https://www.adobe.com/devnet/illustrator/sdk.html" target="_blank" rel="noopener">https://www.adobe.com/devnet/illustrator/sdk.html</a></p><h1 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h1><p><a href="/2019/03/14/ai-first-note">AI组件开发（一）–注记旋转矩阵</a><br><a href="/2019/03/18/ai-second-note">AI组件开发（二）–AIRealMathSuite</a><br><a href="/2019/03/24/ai-third-note">AI组件开发（三）–AIArtboardSuite</a><br><a href="/2019/03/24/ai-forth-document-note">AI组件开发（四）–AIDocumentSuite</a><br><a href="/2019/03/24/ai-fifth-ailayer-note">AI组件开发（五）–AILayerSuite</a><br><a href="/2019/03/24/ai-six-aiart-note">AI组件开发（六）–AIArtSuite</a><br><a href="/2019/03/25/ai-seven-path-note">AI组件开发（七）–AIPathSuite&amp;&amp;AIPathfinderSuite</a><br><a href="/2019/03/25/ai-eight-style-note">AI组件开发（八）–AIArtStyleSuite</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;主要介绍AIRealMathSuite中使用到的函数，以及部分应用场景，持续更新中&lt;br&gt;
    
    </summary>
    
      <category term="AI组件开发" scheme="http://11wy11.github.io/categories/AI%E7%BB%84%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="AI" scheme="http://11wy11.github.io/tags/AI/"/>
    
  </entry>
  
  <entry>
    <title>markdown编写技巧</title>
    <link href="http://11wy11.github.io/2019/03/17/markdown-first-skill/"/>
    <id>http://11wy11.github.io/2019/03/17/markdown-first-skill/</id>
    <published>2019-03-17T13:33:53.000Z</published>
    <updated>2019-03-24T01:33:15.202Z</updated>
    
    <content type="html"><![CDATA[<p>markdown编写技巧,转义字符及部分基本语法<br><a id="more"></a></p><h1 id="常用转义字符"><a href="#常用转义字符" class="headerlink" title="常用转义字符"></a>常用转义字符</h1><ul><li>\\ 反斜杠  </li><li>\` 反引号  </li><li>\* 星号  </li><li>\_ 下划线  </li><li>\{\} 大括号  </li><li>\[\] 中括号  </li><li>\(\) 小括号  </li><li>\# 井号  </li><li>\+ 加号  </li><li>\- 减号  </li><li>\. 英文句号  </li><li>\! 感叹号<br>也可以用ASCII码代替<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="markdown-first-skill/pic1.png" alt="1" title>                </div>                <div class="image-caption">1</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="markdown-first-skill/pic2.png" alt="2" title>                </div>                <div class="image-caption">2</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="markdown-first-skill/pic3.png" alt="3" title>                </div>                <div class="image-caption">3</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="markdown-first-skill/pic4.png" alt="4" title>                </div>                <div class="image-caption">4</div>            </figure><h1 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h1></li></ul><ol><li><p>标题设置（让字体变大，和word的标题意思一样）<br>在Markdown当中设置标题，有两种方式：<br>第一种：通过在文字下方添加“=”和“-”，他们分别表示一级标题和二级标题。<br>第二种：在文字开头加上 “#”，通过“#”数量表示几级标题。（一共只有1~6级标题，1级标题字体最大）</p></li><li><p>块注释（blockquote）<br>通过在文字开头添加“&gt;”表示块注释。（当&gt;和文字之间添加五个blank时，块注释的文字会有变化。）</p></li><li><p>斜体<br>将需要设置为斜体的文字两端使用1个“*”或者“_”夹起来</p></li><li><p>粗体<br>将需要设置为斜体的文字两端使用2个“*”或者“_”夹起来</p></li><li><p>无序列表<br>在文字开头添加(*, +, and -)实现无序列表。但是要注意在(*, +, and -)和文字之间需要添加空格。（建议：一个文档中只是用一种无序列表的表示方式）</p></li><li><p>有序列表<br>使用数字后面跟上句号。（还要有空格）</p></li><li><p>链接（Links）<br>Markdown中有两种方式，实现链接，分别为内联方式和引用方式。<br>内联方式：This is an [example link](<a href="http://example.com/)" target="_blank" rel="noopener">http://example.com/)</a>.<br>引用方式：<br>I get 10 times more traffic from [Google][1] than from [Yahoo][2] or [MSN][3].  </p><p>[1]: <a href="http://google.com/" target="_blank" rel="noopener">http://google.com/</a>        “Google”<br>[2]: <a href="http://search.yahoo.com/" target="_blank" rel="noopener">http://search.yahoo.com/</a>  “Yahoo Search”<br>[3]: <a href="http://search.msn.com/" target="_blank" rel="noopener">http://search.msn.com/</a>    “MSN Search”</p></li></ol><ol start="8"><li>图片（Images）<br>图片的处理方式和链接的处理方式，非常的类似。<br>内联方式：![alt text](/path/to/img.jpg “Title”)<br>引用方式：<br>![alt text][id] </li></ol><p>[id]: /path/to/img.jpg “Title”</p><ol start="9"><li><p>代码（HTML中所谓的Code）<br>实现方式有两种：<br>第一种：简单文字出现一个代码框。使用<code>&lt;blockquote&gt;</code>。（<code>不是单引号而是左上角的ESC下面~中的</code>）<br>第二种：大片文字需要实现代码框。使用Tab和四个空格。</p></li><li><p>脚注（footnote）<br>实现方式如下：<br>hello[^hello]</p></li></ol><ol start="11"><li>下划线<br>在空白行下方添加三条“-”横线。（前面讲过在文字下方添加“-”，实现的2级标题）<br>参考<br>官方文档<a href="http://daringfireball.net/projects/markdown/basics" target="_blank" rel="noopener">http://daringfireball.net/projects/markdown/basics</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;markdown编写技巧,转义字符及部分基本语法&lt;br&gt;
    
    </summary>
    
      <category term="语言" scheme="http://11wy11.github.io/categories/%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="markdown" scheme="http://11wy11.github.io/tags/markdown/"/>
    
  </entry>
  
  <entry>
    <title>sqlite数据库查询 C++函数</title>
    <link href="http://11wy11.github.io/2019/03/17/sqlite-first-note/"/>
    <id>http://11wy11.github.io/2019/03/17/sqlite-first-note/</id>
    <published>2019-03-17T13:17:22.000Z</published>
    <updated>2019-03-17T13:36:37.631Z</updated>
    
    <content type="html"><![CDATA[<h2 id="sqlite部分函数简介"><a href="#sqlite部分函数简介" class="headerlink" title="sqlite部分函数简介"></a>sqlite部分函数简介</h2><p>主要有打开数据库连接，执行数据库查询语句，关闭连接等函数<br><a id="more"></a></p><h3 id="sqlite3-open用法"><a href="#sqlite3-open用法" class="headerlink" title="sqlite3_open用法"></a>sqlite3_open用法</h3><p>打开数据库链接<br>sqlite3_open用法<br>原型：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int sqlite3_open(</span><br><span class="line">  const char *filename,   /* Database filename (UTF-8) */</span><br><span class="line">  sqlite3 **ppDb          /* OUT: SQLite db handle */</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p><p>用这个函数开始数据库操作。需要传入两个参数，一是数据库文件名，比如：E:/test.db。文件名不需要一定存在，如果此文件不存在，sqlite会自动建立它。如果它存在，就尝试把它当数据库文件来打开。<br>二是sqlite3**，即前面提到的关键数据结构。<br>函数返回值表示操作是否正确，如果是SQLITE_OK则表示操作正常。相关的返回值sqlite定义了一些宏。具体这些宏的含义可以参考sqlite3.h 文件。里面有详细定义。</p><h3 id="sqlite3-close用法"><a href="#sqlite3-close用法" class="headerlink" title="sqlite3_close用法"></a>sqlite3_close用法</h3><p>关闭数据库链接<br>原型：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int sqlite3_close(sqlite3 *ppDb);</span><br></pre></td></tr></table></figure></p><p>ppDb为刚才使用sqlite3_open打开的数据库链接  </p><h3 id="sqlite3-exec用法"><a href="#sqlite3-exec用法" class="headerlink" title="sqlite3_exec用法"></a>sqlite3_exec用法</h3><p>执行sql操作<br>原型：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int sqlite3_exec(</span><br><span class="line">  sqlite3* ppDb,                             /* An open database */</span><br><span class="line">  const char *sql,                           /* SQL to be evaluated */</span><br><span class="line">  int (*callback)(void*,int,char**,char**),  /* Callback function */</span><br><span class="line">  void *,                                    /* 1st argument to callback */</span><br><span class="line">  char **errmsg                              /* Error msg written here */</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p><p>这就是执行一条sql 语句的函数。<br>第1个参数不再说了，是前面open函数得到的指针。<br>第2个参数constchar*sql是一条sql 语句，以\0结尾。<br>第3个参数sqlite3_callback 是回调，当这条语句执行之后，sqlite3会去调用你提供的这个函数。<br>第4个参数void*是你所提供的指针，你可以传递任何一个指针参数到这里，这个参数最终会传到回调函数里面，如果不需要传递指针给回调函数，可以填NULL。回调函数的写法，以及这个参数的使用在之后介绍。<br>第5个参数char** errmsg 是错误信息。注意是指针的指针。sqlite3里面有很多固定的错误信息。执行sqlite3_exec 之后，执行失败时可以查阅这个指针（直接cout&lt;&lt;errmsg得到一串字符串信息，这串信息告诉你错在什么地方。sqlite3_exec函数通过修改你传入的指针的指针，把你提供的指针指向错误提示信息，这样sqlite3_exec函数外面就可以通过这个char*得到具体错误提示。<br>说明：通常，sqlite3_callback 和它后面的void*这两个位置都可以填NULL。填NULL表示你不需要回调。比如你做insert 操作，做delete操作，就没有必要使用回调。而当你做select 时，就要使用回调，因为sqlite3 把数据查出来，得通过回调告诉你查出了什么数据。<br>exec 的回调<br><code>typedef int(*sqlite3_callback)(void*,int,char**,char**);</code><br>你的回调函数必须定义成上面这个函数的类型。下面给个简单的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//sqlite3的回调函数</span><br><span class="line">//sqlite 每查到一条记录，就调用一次这个回调</span><br><span class="line">int LoadMyInfo(void* para,intn_column,char** column_value,char** column_name);</span><br><span class="line">//para是你在sqlite3_exec 里传入的void*参数通过para参数，你可以传入一些特殊的指针（比如类指针、结构指针），</span><br><span class="line">//然后在这里面强制转换成对应的类型（这里面是void*类型，必须强制转换成你的类型才可用）。然后操作这些数据</span><br><span class="line">//n_column是这一条记录有多少个字段(即这条记录有多少列)</span><br><span class="line">//char** column_value 是个关键值，查出来的数据都保存在这里，它实际上是个1维数组（不要以为是2维数组），</span><br><span class="line">//每一个元素都是一个char*值，是一个字段内容（用字符串来表示，以\0结尾）</span><br><span class="line">//char** column_name 跟column_value是对应的，表示这个字段的字段名称</span><br></pre></td></tr></table></figure></p><p>实例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#include &quot;sqlite/sqlite3.h&quot;</span><br><span class="line">int callback(void*,int,char**,char**);</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    sqlite3* db;</span><br><span class="line">    int nResult = sqlite3_open(&quot;test.db&quot;,&amp;db);</span><br><span class="line">    if (nResult != SQLITE_OK)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;&quot;打开数据库失败：&quot;&lt;&lt;sqlite3_errmsg(db)&lt;&lt;endl;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;&quot;数据库打开成功&quot;&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    char* errmsg;</span><br><span class="line"></span><br><span class="line">    nResult = sqlite3_exec(db,&quot;create table fuck(id integer primary key autoincrement,name varchar(100))&quot;,NULL,NULL,&amp;errmsg);</span><br><span class="line">     if (nResult != SQLITE_OK)</span><br><span class="line">     &#123;</span><br><span class="line">         sqlite3_close(db);</span><br><span class="line">         cout&lt;&lt;errmsg;</span><br><span class="line">         sqlite3_free(errmsg);</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    string strSql;</span><br><span class="line">    strSql+=&quot;begin;\n&quot;;</span><br><span class="line">    for (int i=0;i&lt;100;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        strSql+=&quot;insert into fuck values(null,&apos;heh&apos;);\n&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    strSql+=&quot;commit;&quot;;</span><br><span class="line">    //cout&lt;&lt;strSql&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    nResult = sqlite3_exec(db,strSql.c_str(),NULL,NULL,&amp;errmsg);</span><br><span class="line"></span><br><span class="line">    if (nResult != SQLITE_OK)</span><br><span class="line">    &#123;</span><br><span class="line">        sqlite3_close(db);</span><br><span class="line">        cout&lt;&lt;errmsg&lt;&lt;endl;</span><br><span class="line">        sqlite3_free(errmsg);</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    strSql = &quot;select * from fuck&quot;;</span><br><span class="line">    nResult = sqlite3_exec(db,strSql.c_str(),callback,NULL,&amp;errmsg);</span><br><span class="line">      if (nResult != SQLITE_OK)</span><br><span class="line">    &#123;</span><br><span class="line">        sqlite3_close(db);</span><br><span class="line">        cout&lt;&lt;errmsg&lt;&lt;endl;</span><br><span class="line">        sqlite3_free(errmsg);</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sqlite3_close(db);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int callback(void* ,int nCount,char** pValue,char** pName)</span><br><span class="line">&#123;</span><br><span class="line">    string s;</span><br><span class="line">    for(int i=0;i&lt;nCount;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        s+=pName[i];</span><br><span class="line">        s+=&quot;:&quot;;</span><br><span class="line">        s+=pValue[i];</span><br><span class="line">        s+=&quot;\n&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;s&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;sqlite部分函数简介&quot;&gt;&lt;a href=&quot;#sqlite部分函数简介&quot; class=&quot;headerlink&quot; title=&quot;sqlite部分函数简介&quot;&gt;&lt;/a&gt;sqlite部分函数简介&lt;/h2&gt;&lt;p&gt;主要有打开数据库连接，执行数据库查询语句，关闭连接等函数&lt;br&gt;
    
    </summary>
    
      <category term="其他" scheme="http://11wy11.github.io/categories/%E5%85%B6%E4%BB%96/"/>
    
    
      <category term="sqlite" scheme="http://11wy11.github.io/tags/sqlite/"/>
    
      <category term="C++" scheme="http://11wy11.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++部分基础知识</title>
    <link href="http://11wy11.github.io/2019/03/17/cpp-function/"/>
    <id>http://11wy11.github.io/2019/03/17/cpp-function/</id>
    <published>2019-03-17T06:09:53.000Z</published>
    <updated>2019-03-25T07:15:46.340Z</updated>
    
    <content type="html"><![CDATA[<p>介绍项目中用到的一些常用函数和关键字的使用<br><a id="more"></a><br><!-- START doctoc generated TOC please keep comment here to allow auto update --><br><!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE --><br><strong>Table of Contents</strong>  <em>generated with <a href="https://github.com/thlorenz/doctoc" target="_blank" rel="noopener">DocToc</a></em></p><ul><li><a href="#%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0">常用函数</a><ul><li><a href="#1-strtok">1. strtok</a></li><li><a href="#2strcmp">2.strcmp</a></li><li><a href="#3-erase">3. Erase</a></li><li><a href="#4-list">4. List</a></li><li><a href="#5-strcpy">5. strcpy</a></li><li><a href="#6%E8%BD%AC%E6%8D%A2%E5%87%BD%E6%95%B0">6.转换函数</a><ul><li><a href="#61-atoi">6.1 Atoi</a></li></ul></li></ul></li><li><a href="#%E5%85%B3%E9%94%AE%E5%AD%97">关键字</a><ul><li><a href="#extern">extern</a><ul><li><a href="#%E5%8F%98%E9%87%8F">变量</a></li><li><a href="#%E5%87%BD%E6%95%B0">函数</a></li><li><a href="#%E7%BC%96%E8%AF%91%E9%93%BE%E6%8E%A5">编译链接</a><ul><li><a href="#%E5%A3%B0%E6%98%8E%E5%A4%96%E9%83%A8%E5%8F%98%E9%87%8F">声明外部变量</a></li></ul></li><li><a href="#c%E4%B8%ADextern-c%E7%9A%84%E6%B7%B1%E5%B1%82%E6%8E%A2%E7%B4%A2">C++中extern c的深层探索</a></li></ul></li></ul></li></ul><!-- END doctoc generated TOC please keep comment here to allow auto update --><hr><h1 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h1><h2 id="1-strtok"><a href="#1-strtok" class="headerlink" title="1. strtok"></a>1. strtok</h2><p>  分解字符串为一组字符串。s为要分解的字符，delim为分隔符字符（如果传入字符串，则传入的字符串中每个字符均为分割符）。首次调用时，s指向要分解的字符串，之后再次调用要把s设成NULL。<br>  例如：strtok(“abc,def,ghi”,”,”)，最后可以分割成为abc def ghi.尤其在点分十进制的IP中提取应用较多。<br>strtok的函数原型为char <em>strtok(char </em>s, char *delim)，功能为“Parse S into tokens separated by characters in DELIM.If S is NULL, the saved pointer in SAVE_PTR is used as the next starting point. ” 翻译成汉语就是：作用于字符串s，以包含在delim中的字符为分界符，将s切分成一个个子串；如果，s为空值NULL，则函数保存的指针SAVE_PTR在下一次调用中将作为起始位置。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    char sentence[]=&quot;This is a sentence with 7 tokens&quot;;</span><br><span class="line">    cout &lt;&lt; &quot;The string to be tokenized is:\n&quot; &lt;&lt; sentence &lt;&lt; &quot;\n\nThe tokens are:\n\n&quot;;</span><br><span class="line">    char *tokenPtr=strtok(sentence,&quot; &quot;);</span><br><span class="line">    while(tokenPtr!=NULL)　&#123;</span><br><span class="line">        cout&lt;&lt;tokenPtr&lt;&lt;endl;</span><br><span class="line">        tokenPtr=strtok(NULL,&quot; &quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    //cout &lt;&lt; &quot;After strtok,sentence=&quot; &lt;&lt; tokenPtr&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>函数第一次调用需设置两个参数。第一次分割的结果，返回串中第一个 ‘,’ 之前的字符串,也就是上面的程序第一次输出abc。<br>第二次调用该函数strtok(NULL,”,”),第一个参数设置为NULL。结果返回分割依据后面的字串，即第二次输出d。<br>strtok是一个线程不安全的函数，因为它使用了静态分配的空间来存储被分割的字符串位置<br>线程安全的函数叫strtok_r,ca<br>运用strtok来判断ip或者mac的时候务必要先用其他的方法判断’.’或’:’的个数，因为用strtok截断的话，比</p><h2 id="2-strcmp"><a href="#2-strcmp" class="headerlink" title="2.strcmp"></a>2.strcmp</h2><p>C/C++函数，比较两个字符串<br>设这两个字符串为str1，str2，<br>若str1=str2，则返回零；<br>若str1&lt;str2，则返回负数；<br>若str1&gt;str2，则返回正数。<br>matlab中函数，strcmp(s1，s2) 判断两个字符串s1和s2是否相同，相同返回true ,不同返回false<br>源码：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">strcmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str1,<span class="keyword">const</span> <span class="keyword">char</span> *str2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*不可用while(*str1++==*str2++)来比较，当不相等时仍会执行一次++，</span></span><br><span class="line"><span class="comment">    return返回的比较值实际上是下一个字符。应将++放到循环体中进行。*/</span></span><br><span class="line">    <span class="keyword">while</span>(*str1 == *str2)</span><br><span class="line">    &#123;</span><br><span class="line">                assert((str1 != <span class="literal">NULL</span>) &amp;&amp; (str2 != <span class="literal">NULL</span>));</span><br><span class="line">                 </span><br><span class="line">        <span class="keyword">if</span>(*str1 == <span class="string">'\0'</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">         </span><br><span class="line">        str1++;</span><br><span class="line">        str2++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *str1 - *str2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="3-Erase"><a href="#3-Erase" class="headerlink" title="3. Erase"></a>3. Erase</h2><ul><li>c.erase(k)<br>从c中删除元素k，返回一个size_type值，指出删除的元素的数量</li><li>c.erase(p)<br>从c中删除迭代器p指定的元素，p必须指向c中的一个真实元素，不能等于c.end()</li><li>c.erase(b,e)<br>从c中删除迭代器对b和e所表示的范围中的元素，返回e<h2 id="4-List"><a href="#4-List" class="headerlink" title="4. List"></a>4. List</h2>List 反向迭代器<br>begin和end成员<br>begin和end操作产生指向容器内第一个元素和最后一个元素的下一个位置的迭代器，如下所示。这两个迭代器通常用于标记包含容器中所有元素的迭代范围。<br>c.begin() 返回一个迭代器，它指向容器c的第一个元素<br>c.end() 返回一个迭代器，它指向容器c的最后一个元素的下一个位置<br>c.rbegin() 返回一个逆序迭代器，它指向容器c的最后一个元素<br>c.rend() 返回一个逆序迭代器，它指向容器c的第一个元素前面的位置<br>上述每个操作都有两个不同的版本：一个是const成员，另一个是非const成员。这些操作返回什么类型取决于容器是否为const。如果容器不是const，则这些操作返回iterator或reverse_iterator类型。如果容器是const，则其返回类型要加上const_前缀，也就是const_iterator和const_reverse_iterator类型。  <h2 id="5-strcpy"><a href="#5-strcpy" class="headerlink" title="5. strcpy"></a>5. strcpy</h2>描述<br>C 库函数 char <em>strcpy(char </em>dest, const char *src) 把 src 所指向的字符串复制到 dest。</li></ul><p>声明<br>下面是 strcpy() 函数的声明。<br><code>char *strcpy(char *dest, const char *src)</code><br>参数<br>dest – 指向用于存储复制内容的目标数组。<br>src – 要复制的字符串。<br>返回值<br>该函数返回一个指向最终的目标字符串 dest 的指针。<br>实例<br>下面的实例演示了 strcpy() 函数的用法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">   char src[40];</span><br><span class="line">   char dest[100];</span><br><span class="line">  </span><br><span class="line">   memset(dest, &apos;\0&apos;, sizeof(dest));</span><br><span class="line">   strcpy(src, &quot;This is runoob.com&quot;);</span><br><span class="line">   strcpy(dest, src);</span><br><span class="line"></span><br><span class="line">   printf(&quot;最终的目标字符串： %s\n&quot;, dest);</span><br><span class="line">   </span><br><span class="line">   return(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="6-转换函数"><a href="#6-转换函数" class="headerlink" title="6.转换函数"></a>6.转换函数</h2><h3 id="6-1-Atoi"><a href="#6-1-Atoi" class="headerlink" title="6.1 Atoi"></a>6.1 Atoi</h3><p>字符串转整型</p><h3 id="6-2-Atof"><a href="#6-2-Atof" class="headerlink" title="6.2 Atof"></a>6.2 Atof</h3><p>字符串转浮点型</p><h2 id="7-malloc动态内存分配"><a href="#7-malloc动态内存分配" class="headerlink" title="7. malloc动态内存分配"></a>7. malloc动态内存分配</h2><p>用于申请一块连续的指定大小的内存块区域以void<em>类型返回分配的内存区域地址，当无法知道内存具体位置的时候，想要绑定真正的内存空间，就需要用到动态的分配内存。<br>void \</em>malloc(size_t size);<br>如果分配成功则返回指向被分配内存的指针(此存储区中的初始值不确定)，否则返回空指针NULL。当内存不再使用时，应使用free()函数将内存块释放。函数返回的指针一定要适当对齐，使其可以用于任何数据对象。<br>例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int *p;</span><br><span class="line">p = (int*)malloc(sizeof(int) * 128);</span><br><span class="line">//分配128个（可根据实际需要替换该数值）整型存储单元，</span><br><span class="line">//并将这128个连续的整型存储单元的首地址存储到指针变量p中</span><br><span class="line">double *pd = (double*)malloc(sizeof(double) * 12);</span><br><span class="line">//分配12个double型存储单元，</span><br><span class="line">//并将首地址存储到指针变量pd中</span><br></pre></td></tr></table></figure></p><h2 id="math库中的函数"><a href="#math库中的函数" class="headerlink" title="math库中的函数"></a>math库中的函数</h2><h3 id="hypot"><a href="#hypot" class="headerlink" title="hypot"></a>hypot</h3><p> 计算直角三角形的斜边长</p><h1 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h1><h2 id="extern"><a href="#extern" class="headerlink" title="extern"></a>extern</h2><p>extern是计算机语言中的一个关键字，可置于变量或者函数前，以表示变量或者函数的定义在别的文件中。提示编译器遇到此变量或函数时，在其它模块中寻找其定义，另外，extern也可用来进行链接指定。  </p><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>在一个源文件里定义了一个数组：char a[6];<br>在另外一个文件里用下列语句进行了声明：extern char *a；<br>    请问，这样可以吗？<br>    答案与分析：<br>    1)、不可以，程序运行时会告诉你非法访问。原因在于，指向类型T的指针并不等价于类型T的数组。extern char *a声明的是一个指针变量而不是字符数组，因此与实际的定义不同，从而造成运行时非法访问。应该将声明改为extern char a[ ]。<br>    2)、例子分析如下，如果a[] = “abcd”,则外部变量a=0x12345678 (数组的起始地址)，而*a是重新定义了一个指针变量，a指向的地址可能是0x87654321,直接使用*a是错误的.<br>    3)、这提示我们，在使用extern时候要严格对应声明时的格式，在实际编程中，这样的错误屡见不鲜。<br>    4)、extern用在变量声明中常常有这样一个作用：你要在*.c文件中引用另一个文件中的一个全局的变量，那就应该放在*.h中用extern来声明这个全局变量。<br>    extern用于变量的用法：<br>    extern int a;//声明一个全局变量a<br>    int a; //定义一个全局变量a<br>    extern int a =0 ;//定义一个全局变量a 并给初值。一旦给予赋值，一定是定义，定义才会分配存储空间。（注意：经过测试在GCC中，这样定义变量是不能通过编译的，而在VS2013可以）<br>    int a =0;//定义一个全局变量a,并给初值，<br>    声明之后你不能直接使用这个变量，需要定义之后才能使用。<br>    第四个等于第三个，都是定义一个可以被外部使用的全局变量，并给初值。<br>    糊涂了吧，他们看上去可真像。但是定义只能出现在一处。也就是说，不管是int a;还是int a=0;都只能出现一次，而那个extern int a可以出现很多次。<br>    当你要引用一个全局变量的时候，你就要声明extern int a;这时候extern不能省略，因为省略了，就变成int a;这是一个定义，不是声明。  </p><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>实际上函数的声明和定义都不需要添加extern关键字，在实际使用的时候也最好不要添加关键字。<br>如果一个函数是不会被其它文件调用的，那么这个函数应该被声明成static的。<br>如：<code>extern int func(void){return 0;}</code>跟<code>int func(void){return 0;}</code>    是等价的<br>另外  <code>extern int func(void);</code> 跟<code>int func(void);</code>是等价的。  </p><h3 id="编译链接"><a href="#编译链接" class="headerlink" title="编译链接"></a>编译链接</h3><h4 id="声明外部变量"><a href="#声明外部变量" class="headerlink" title="声明外部变量"></a>声明外部变量</h4><p>现代编译器一般采用按文件编译的方式，因此在编译时，各个文件中定义的全局变量是互相不透明的。也就是说，在编译时，全局变量的可见域限制在文件内部。  </p><p>下面举一个简单的例子：</p><p>创建一个工程，里面含有A.cpp和B.cpp两个简单的C++源文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//A.cpp</span><br><span class="line">int i;</span><br><span class="line">int main()&#123;</span><br><span class="line">&#125;</span><br><span class="line">//B.cpp</span><br><span class="line">int i;</span><br></pre></td></tr></table></figure></p><p>这两个文件极为简单，在A.cpp中我们定义了一个全局变量i，在B中我们也定义了一个全局变量i。 </p><p>我们对A和B分别编译，都可以正常通过编译，但是进行链接的时候，却出现了错误，错误提示如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Linking...</span><br><span class="line">B.obj:error LNK2005:&quot;inti&quot;(?i@@3HA)already defined in A.obj</span><br><span class="line">Debug/A.exe:fatal error LNK1169:one or more multiply defined symbols found</span><br><span class="line">Error executing link.exe.</span><br><span class="line">A.exe-2 error(s),0 warning(s)</span><br></pre></td></tr></table></figure></p><p>这就是说，在编译阶段，各个文件中定义的全局变量相互是不透明的，编译A时觉察不到B中也定义了i，同样，编译B时觉察不到A中也定义了i。  </p><p>但是到了链接阶段，要将各个文件的内容“合为一体”，因此，如果某些文件中定义的全局变量名相同的话，在这个时候就会出现错误，也就是上面提示的重复定义的错误。 </p><p>因此，各个文件中定义的全局变量名不可相同。 </p><p>在链接阶段，各个文件的内容（实际是编译产生的obj文件）是被合并到一起的，因而，定义于某文件内的全局变量，在链接完成后，它的可见范围被扩大到了整个程序。  </p><p>这样一来，按道理说，一个文件中定义的全局变量，可以在整个程序的任何地方被使用，举例说，如果A文件中定义了某全局变量，那么B文件中应可以使用该变量。修改我们的程序，加以验证：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//A.cpp</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    i = 100;//试图使用B中定义的全局变量</span><br><span class="line">&#125;</span><br><span class="line">//B.cpp</span><br><span class="line">int i;</span><br></pre></td></tr></table></figure><p>编译结果如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Compiling...</span><br><span class="line">A.cpp</span><br><span class="line">C:\Documents and Settings\桌面\try extern\A.cpp(5):error C2065:&apos;i&apos;:undeclared identifier</span><br><span class="line">Error executing cl.exe.</span><br><span class="line">A.obj-1 error(s),0 warning(s)</span><br></pre></td></tr></table></figure></p><p>编译错误。 </p><p>其实出现这个错误是意料之中的，因为文件中定义的全局变量的可见性扩展到整个程序是在链接完成之后，而在编译阶段，他们的可见性仍局限于各自的文件。  </p><p>编译器的目光不够长远，编译器没有能够意识到，某个变量符号虽然不是本文件定义的，但是它可能是在其它的文件中定义的。  </p><p>虽然编译器不够有远见，但是我们可以给它提示，帮助它来解决上面出现的问题。这就是extern的作用了。</p><p>extern的原理很简单，就是告诉编译器：“你现在编译的文件中，有一个标识符虽然没有在本文件中定义，但是它是在别的文件中定义的全局变量，你要放行！” </p><p>我们为上面的错误程序加上extern关键字：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//A.cpp</span><br><span class="line">extern int i;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    i=100;//试图使用B中定义的全局变量</span><br><span class="line">&#125;</span><br><span class="line">//B.cpp</span><br><span class="line">int i;</span><br></pre></td></tr></table></figure></p><p>顺利通过编译，链接。</p><h3 id="C-中extern-c的深层探索"><a href="#C-中extern-c的深层探索" class="headerlink" title="C++中extern c的深层探索"></a>C++中extern c的深层探索</h3><ol><li>简介<br>C++语言的创建初衷是“a better C”，但是这并不意味着C++中类似C语言的全局变量和函数所采用的编译和连接方式与C语言完全相同。作为一种欲与C兼容的语言，C++保留了一部分过程式语言的特点（被世人称为“不彻底地面向对象”），因而它可以定义不属于任何类的全局变量和函数。但是，C++毕竟是一种面向对象的程序设计语言，为了支持函数的重载，C++对全局函数的处理方式与C有明显的不同。 </li><li><p>从标准头文件说起<br>某企业曾经给出如下的一道面试题：<br>为什么标准头文件都有类似以下的结构？</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#ifndef __INCvxWorksh</span><br><span class="line">#define __INCvxWorksh</span><br><span class="line">#ifdef __cplusplus</span><br><span class="line">extern &quot;C&quot; &#123;</span><br><span class="line">#endif</span><br><span class="line">/*...*/</span><br><span class="line">#ifdef __cplusplus</span><br><span class="line">&#125;</span><br><span class="line">#endif</span><br><span class="line">#endif /* __INCvxWorksh */</span><br></pre></td></tr></table></figure><p> 分析<br> 显然，头文件中的编译宏“#ifndef <strong>INCvxWorksh、#define </strong>INCvxWorksh、#endif” 的作用是防止该头文件被重复引用。<br> 那么    </p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#ifdef __cplusplus</span><br><span class="line">extern &quot;C&quot; &#123;</span><br><span class="line">#endif</span><br><span class="line">#ifdef __cplusplus</span><br><span class="line">&#125;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p> 的作用又是什么呢？我们将在下文一一道</p></li><li><p>深层揭密extern “C”<br> extern “C” 包含双重含义，从字面上即可得到：首先，被它修饰的目标是“extern”的；其次，被它修饰的目标是“C”的。让我们来详细解读这两重含义。  </p><p> 被extern “C”限定的函数或变量是extern类型的；</p><p> extern是C/C++语言中表明函数和全局变量作用范围（可见性）的关键字，该关键字告诉编译器，其声明的函数和变量可以在本模块或其它模块中使用，记住，下列语句：<br> extern int a;<br> 仅仅是一个变量的声明，其并不是在定义变量a，并未为a分配内存空间。变量a在所有模块中作为一种全局变量只能被定义一次，否则会出现连接错误。</p><p> 引用一个定义在其它模块的全局变量或函数（如，全局函数或变量定义在A模块，B欲引用）有两种方法，<br> 一、B模块中include模块A的头文件。<br> 二、模块B中对欲引用的模块A的变量或函数重新声明一遍，并前加extern关键字。  </p><p> 通常，在模块的头文件中对本模块提供给其它模块引用的函数和全局变量以关键字extern声明。<br> 例如，如果模块B欲引用该模块A中定义的全局变量和函数时只需包含模块A的头文件即可。这样，模块B中调用模块A中的函数时，在编译阶段，模块B虽然找不到该函数，但是并不会报错；它会在连接阶段中从模块A编译生成的目标代码中找到此函数。</p><p> 与extern对应的关键字是static，被它修饰的全局变量和函数只能在本模块中使用。因此，一个函数或变量只可能被本模块使用时，其不可能被extern “C”修饰。</p><p> 被extern “C”修饰的变量和函数是按照C语言方式编译和连接的；<br> 未加extern “C”声明时的编译方式 </p><p> 首先看看C++中对类似C的函数是怎样编译的。  </p><p> 作为一种面向对象的语言，C++支持函数重载，而过程式语言C则不支持。函数被C++编译后在符号库中的名字与C语言的不同。例如，假设某个函数的原型为：<br> <code>void foo( int x, int y );</code><br> 该函数被C编译器编译后在符号库中的名字为_foo，而C++编译器则会产生像_foo_int_int之类的名字（不同的编译器可能生成的名字不同，但是都采用了相同的机制，生成的新名字称为“mangled name”）。<br> _foo_int_int这样的名字包含了函数名、函数参数数量及类型信息，C++就是靠这种机制来实现函数重载的。例如，在C++中，函数<code>void foo( int x, int y )</code>与<code>void foo( int x, float y )</code>编译生成的符号是不相同的，后者为_foo_int_float。  </p><p> 同样地，C++中的变量除支持局部变量外，还支持类成员变量和全局变量。用户所编写程序的类成员变量可能与全局变量同名，我们以”.”来区分。而本质上，编译器在进行编译时，与函数的处理相似，也为类中的变量取了一个独一无二的名字，这个名字与用户程序中同名的全局变量名字不同。</p><p> 未加extern “C”声明时的连接方式</p><p> 假设在C++中，模块A的头文件如下：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 模块A头文件　moduleA.h</span><br><span class="line">#ifndef MODULE_A_H</span><br><span class="line">#define MODULE_A_H</span><br><span class="line">int foo( int x, int y );</span><br><span class="line">#endif</span><br><span class="line">在模块B中引用该函数：</span><br><span class="line">// 模块B实现文件　moduleB.cpp</span><br><span class="line">#include &quot;moduleA.h&quot;</span><br><span class="line">foo(2,3);</span><br></pre></td></tr></table></figure><p> 实际上，在连接阶段，连接器会从模块A生成的目标文件moduleA.obj中寻找_foo_int_int这样的符号！</p><p> 加extern “C”声明后的编译和连接方式<br> 加extern “C”声明后，模块A的头文件变为：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 模块A头文件　moduleA.h</span><br><span class="line">#ifndef MODULE_A_H</span><br><span class="line">#define MODULE_A_H</span><br><span class="line">extern &quot;C&quot; int foo( int x, int y );</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p> 在模块B的实现文件中仍然调用foo( 2,3 )，其结果是：<br> （1）模块A编译生成foo的目标代码时，没有对其名字进行特殊处理，采用了C语言的方式；<br> （2）连接器在为模块B的目标代码寻找foo(2,3)调用时，寻找的是未经修改的符号名_foo。<br> 如果在模块A中函数声明了foo为extern “C”类型，而模块B中包含的是extern int foo( int x, int y ) ，则模块B找不到模块A中的函数；反之亦然。<br> 所以，可以用一句话概括extern “C”这个声明的真实目的（任何语言中的任何语法特性的诞生都不是随意而为的，来源于真实世界的需求驱动。我们在思考问题时，不能只停留在这个语言是怎么做的，还要问一问它为什么要这么做，动机是什么，这样我们可以更深入地理解许多问题）：<br> 实现C++与C及其它语言的混合编程。<br> 明白了C++中extern “C”的设立动机，我们下面来具体分析extern “C”通常的使用技巧。<br> extern “C”的惯用法<br> （1）在C++中引用C语言中的函数和变量，在包含C语言头文件（假设为cExample.h）时，需进行下列处理：   </p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">extern &quot;C&quot;</span><br><span class="line">&#123;</span><br><span class="line">#include &quot;cExample.h&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 而在C语言的头文件中，对其外部函数只能指定为extern类型，C语言中不支持extern “C”声明，在.c文件中包含了extern “C”时会出现编译语法错误。<br> 笔者编写的C++引用C函数例子工程中包含的三个文件的源代码如下：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/*c语言头文件：cExample.h */</span><br><span class="line">#ifndef C_EXAMPLE_H</span><br><span class="line">#define C_EXAMPLE_H</span><br><span class="line">extern int add(int x,int y);</span><br><span class="line">#endif</span><br><span class="line">/*c语言实现文件：cExample.c */</span><br><span class="line">#include &quot;cExample.h&quot;</span><br><span class="line">int add( int x, int y )</span><br><span class="line">&#123;</span><br><span class="line">return x + y;</span><br><span class="line">&#125;</span><br><span class="line">//c++实现文件，调用add：cppFile.cpp</span><br><span class="line">extern &quot;C&quot;</span><br><span class="line">&#123;</span><br><span class="line">#include &quot;cExample.h&quot;</span><br><span class="line">&#125;</span><br><span class="line">int main(int argc, char* argv[])</span><br><span class="line">&#123;</span><br><span class="line">add(2,3);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 如果C++调用一个C语言编写的.DLL时，当包括.DLL的头文件或声明接口函数时，应加extern “C” {　}。<br> （2）在C++引用C语言中的函数和变量时，C++的头文件需添加extern “C”，但是在C语言中不能直接引用声明了extern “C”的该头文件，应该仅将C文件中将C++中定义的extern “C”函数声明为extern类型。<br> 笔者编写的C引用C++函数例子工程中包含的三个文件的源代码如下：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//C++头文件 cppExample.h</span><br><span class="line">#ifndef CPP_EXAMPLE_H</span><br><span class="line">#define CPP_EXAMPLE_H</span><br><span class="line">extern &quot;C&quot; int add( int x, int y );</span><br><span class="line">#endif</span><br><span class="line">//C++实现文件 cppExample.cpp</span><br><span class="line">#include &quot;cppExample.h&quot;</span><br><span class="line">int add( int x, int y )</span><br><span class="line">&#123;</span><br><span class="line">return x + y;</span><br><span class="line">&#125;</span><br><span class="line">/* C实现文件 cFile.c</span><br><span class="line">/* 这样会编译出错：#include &quot;cppExample.h&quot; */</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">extern int add (int x,int y);</span><br><span class="line">int main (int argc,char*argv[])</span><br><span class="line">&#123;</span><br><span class="line">  add(2,3);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>参考：百度百科<a href="https://baike.baidu.com/item/extern/4443005?fr=aladdin" target="_blank" rel="noopener">https://baike.baidu.com/item/extern/4443005?fr=aladdin</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;介绍项目中用到的一些常用函数和关键字的使用&lt;br&gt;
    
    </summary>
    
      <category term="C++" scheme="http://11wy11.github.io/categories/C/"/>
    
    
      <category term="C++" scheme="http://11wy11.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>krpano快速入门教程（三）</title>
    <link href="http://11wy11.github.io/2019/03/16/krpano-third-note/"/>
    <id>http://11wy11.github.io/2019/03/16/krpano-third-note/</id>
    <published>2019-03-16T14:54:57.000Z</published>
    <updated>2019-03-24T01:32:04.249Z</updated>
    
    <content type="html"><![CDATA[<p>使用编辑器热点，添加自定义热点，动态热点等<br><a id="more"></a></p><h2 id="添加热点及相关内容"><a href="#添加热点及相关内容" class="headerlink" title="添加热点及相关内容"></a>添加热点及相关内容</h2><p>使用编辑器热点，添加自定义热点，动态热点等<br><!--more--></p><h3 id="使用tour-editor添加热点及设定起始角度"><a href="#使用tour-editor添加热点及设定起始角度" class="headerlink" title="使用tour_editor添加热点及设定起始角度"></a>使用tour_editor添加热点及设定起始角度</h3><p>通过<strong>Load tour.xml</strong>导入要编辑的配置文件<br>点击<strong>set as startup view</strong>设置初始角度，可以旋转到合适的角度，点击按钮设置全景图默认展示角度。<br>点击<strong>Add hotspot</strong>按钮，画面中出现一个箭头，将其拖放置你想放置的地方，点击<strong>save</strong>按钮保存热点编辑。也可以通过编辑按钮设置热点链接场景。<br>点击<strong>Save tour.xml</strong>按钮保存文件。</p><h3 id="编辑-tour-xml添加热点"><a href="#编辑-tour-xml添加热点" class="headerlink" title="编辑 tour.xml添加热点"></a>编辑 tour.xml添加热点</h3><p>在实际生产中，通常直接编辑xml文件，在相应的场景中添加热点<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">&lt;hotspot name=&quot;...&quot;              定义热点名称    </span><br><span class="line">         type=&quot;image&quot;            定义热点类型，只能是image    </span><br><span class="line">         url=&quot;...&quot;               热点图像路径，支持SWF, JPG, PNG, GIF    </span><br><span class="line">         alturl=&quot;...&quot;            html5状态下显示的图像路径    </span><br><span class="line">         keep=&quot;false&quot;            是否在下一场景跳转后保持显示    </span><br><span class="line">         devices=&quot;all&quot;           支持设备类型    </span><br><span class="line">         visible=&quot;true&quot;          是否可见    </span><br><span class="line">         enabled=&quot;true&quot;          设置热点是否接收鼠标事件    </span><br><span class="line">         handcursor=&quot;true&quot;       设置是否鼠标移到上面显示小手    </span><br><span class="line">         maskchildren=&quot;false&quot;    设置是否将子控件变成蒙板    </span><br><span class="line">         zorder=&quot;&quot;               插入元素的次序索引，可以是字符也可以是数字，html5输出必须是0-100整数    </span><br><span class="line">         zorder2=&quot;0.0&quot;           设置为0.0和1.0，分别对应当前热点在扭曲控件之下和之上    </span><br><span class="line">         capture=&quot;true&quot;          与enabled配合使用，都为true只对热点传递动作，capture=&quot;false&quot;可对子控件传递动作 </span><br><span class="line">         children=&quot;true&quot;         设置子控件是否接收热点鼠标事件    </span><br><span class="line">         blendmode=&quot;normal&quot;      设置混合模式，可选：normal, layer, screen, add, subtract, difference, multiply, overlay, lighten, darken, hardlight, invert.    </span><br><span class="line">    </span><br><span class="line">         style=&quot;&quot;                读入已设置好的style名称    </span><br><span class="line">         ath=&quot;0.0&quot; atv=&quot;0.0&quot;     设定将场景缩略图为球形热点    </span><br><span class="line">         edge=&quot;center&quot;           热点的边界对齐点    </span><br><span class="line">         ox=&quot;0&quot;                  边界到对齐点的偏移量    </span><br><span class="line">         oy=&quot;0&quot;                      </span><br><span class="line">         zoom=&quot;false&quot;            设置是否场景缩放时，热点跟随缩放    </span><br><span class="line">         distorted=&quot;false&quot; rx=&quot;0.0&quot; ry=&quot;0.0&quot; rz=&quot;0.0&quot;    设置热点是否跟随场景进行3D扭曲    </span><br><span class="line">         details=&quot;8&quot;              热点显示的细节数量，默认为8    </span><br><span class="line">         inverserotation=&quot;false&quot;  设置是否逆向旋转3D扭曲    </span><br><span class="line">         flying=&quot;0.0&quot;             设置ath/atv/scale的插值     </span><br><span class="line">         width=&quot;&quot; height=&quot;&quot;       设置热点宽高    </span><br><span class="line">         scale=&quot;1.0&quot;              设置热点缩放    </span><br><span class="line">         rotate=&quot;0.0&quot;             设置热点旋转角度    </span><br><span class="line">         pixelhittest=&quot;false&quot;     是否启动精确像素测试    </span><br><span class="line">         smoothing=&quot;true&quot;         设置缩放时，是否平滑化处理    </span><br><span class="line">         accuracy=&quot;0&quot;             设置像素渲染值（flash下）    </span><br><span class="line">         accuracy2=&quot;1&quot;            设置精度控制（html5下）    </span><br><span class="line">         alpha=&quot;1.0&quot;              设置透明度    </span><br><span class="line">         autoalpha=&quot;false&quot;        设置是否自动变更透明度    </span><br><span class="line">         usecontentsize=&quot;false&quot;   是否使用用户指定flash大小，默认false原始大小    </span><br><span class="line">         scale9grid=&quot;&quot;            定义是否支持矢量缩放，scale9grid=&quot;x-position|y-position|width|height|prescale*&quot;    </span><br><span class="line">         crop=&quot;&quot;                  定义元素坐标及宽高  crop=&quot;x-position|y-position|width|height&quot;    </span><br><span class="line">         onovercrop=&quot;&quot;          设置元素鼠标移到上方后的坐标及宽高    </span><br><span class="line">         ondowncrop=&quot;&quot;          设置元素鼠标按下状态后的坐标及宽高    </span><br><span class="line">         scalechildren=&quot;false&quot;   子元素是否跟随缩放    </span><br><span class="line">         mask=&quot;&quot;                 mask=&quot;name&quot;  mask=&quot;layer[name]&quot;  mask=&quot;hotspot[name]&quot;    </span><br><span class="line">         effect=&quot;&quot;                热点位图效果3种：glow(color,alpha,range,strength);    </span><br><span class="line">                                  dropshadow(depth,angle,color,range,strength);    </span><br><span class="line">                                  blur(radius);        </span><br><span class="line">         onover=&quot;&quot;               鼠标在经过上方时执行动作    </span><br><span class="line">         onhover=&quot;&quot;              鼠标停在上方时执行动作    </span><br><span class="line">         onout=&quot;&quot;                鼠标停移出范围时时执行动作    </span><br><span class="line">         onclick=&quot;&quot;              鼠标停点击时执行动作    </span><br><span class="line">         ondown=&quot;&quot;               鼠标按下时执行动作    </span><br><span class="line">         onup=&quot;&quot;                 鼠标按键松开时执行动作    </span><br><span class="line">         onloaded=&quot;&quot;             加载元素完成后执行动作    </span><br><span class="line">         /&gt;    </span><br><span class="line">           </span><br><span class="line">多边形热点    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&lt;hotspot name=&quot;...&quot;    </span><br><span class="line">         keep=&quot;false&quot;    </span><br><span class="line">         visible=&quot;true&quot;    </span><br><span class="line">         enabled=&quot;true&quot;    </span><br><span class="line">         handcursor=&quot;true&quot;    </span><br><span class="line">         zorder=&quot;&quot;    </span><br><span class="line">         capture=&quot;true&quot;    </span><br><span class="line">         blendmode=&quot;normal&quot;    </span><br><span class="line">         style=&quot;&quot;    </span><br><span class="line">         alpha=&quot;1.0&quot;    </span><br><span class="line">         autoalpha=&quot;false&quot;    </span><br><span class="line">         fillcolor=&quot;0xFFFFFF&quot; fillcolorhover=&quot;0xFFFFFF&quot;   填充颜色及鼠标移上后颜色    </span><br><span class="line">         fillalpha=&quot;0.0&quot; fillalphahover=&quot;0.1&quot;             填充颜色透明度及鼠标移上后颜色透明度    </span><br><span class="line">         borderwidth=&quot;0.0&quot; borderwidthhover=&quot;4.0&quot;         边界宽度及鼠标移上后边界宽度    </span><br><span class="line">         bordercolor=&quot;0xFFFFFF&quot; bordercolorhover=&quot;0xFFFFFF&quot;  边界颜色及边界鼠标移上后颜色    </span><br><span class="line">         borderalpha=&quot;0.0&quot; borderalphahover=&quot;0.8&quot;           边界透明度及鼠标移上后边界透明度    </span><br><span class="line">         fadeintime=&quot;0.15&quot; fadeincurve=&quot;1.1&quot;               悬停状态变化时间及形式    </span><br><span class="line">         fadeouttime=&quot;0.3&quot; fadeoutcurve=&quot;0.7&quot;    </span><br><span class="line">         onover=&quot;&quot;    </span><br><span class="line">         onhover=&quot;&quot;    </span><br><span class="line">         onout=&quot;&quot;    </span><br><span class="line">         onclick=&quot;&quot;    </span><br><span class="line">         ondown=&quot;&quot;    </span><br><span class="line">         onup=&quot;&quot;    </span><br><span class="line">&gt;    </span><br><span class="line">    &lt;point ath=&quot;...&quot; atv=&quot;...&quot; /&gt;            多边形热点坐标    </span><br><span class="line">    &lt;point ath=&quot;...&quot; atv=&quot;...&quot; /&gt;    </span><br><span class="line">    &lt;point ath=&quot;...&quot; atv=&quot;...&quot; /&gt;    </span><br><span class="line">    ...    </span><br><span class="line">&lt;/hotspot&gt;</span><br></pre></td></tr></table></figure></p><h3 id="历史文章"><a href="#历史文章" class="headerlink" title="历史文章"></a>历史文章</h3><p><a href="/2019/03/14/krpano-first-note">krpano快速入门教程（一) 使用krpano工具构建即用型panos</a><br><a href="/2019/03/15/krpano-second-note">krpano快速入门教程（二) vtour全景漫游及vtour文件夹介绍</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用编辑器热点，添加自定义热点，动态热点等&lt;br&gt;
    
    </summary>
    
      <category term="全景" scheme="http://11wy11.github.io/categories/%E5%85%A8%E6%99%AF/"/>
    
    
      <category term="krpano" scheme="http://11wy11.github.io/tags/krpano/"/>
    
  </entry>
  
  <entry>
    <title>C++之QT的信号和槽的详解</title>
    <link href="http://11wy11.github.io/2019/03/16/qt-note/"/>
    <id>http://11wy11.github.io/2019/03/16/qt-note/</id>
    <published>2019-03-16T12:24:56.000Z</published>
    <updated>2019-03-24T01:34:40.382Z</updated>
    
    <content type="html"><![CDATA[<p>QT的信号和槽的详解，包括简介，信号和槽分析以及一个实例<br><a id="more"></a></p><h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1 简介"></a>1 简介</h1><p> 信号和槽是Qt特有的信息传输机制，是Qt设计程序的重要基础，它可以让互不干扰的对象建立一种联系。<br><!--more--><br>  在GUI编程中，当我们改变一个部件时，经常想要其他部件被通知。更一般化，我们希望任何一类的对象可以和其它对象进行通讯。例如，如果我们点击一个关闭按钮，我们可能想要窗口的close()函数被调用。</p><p>  其他工具包通过回调实现了这种通信。回调是一个函数指针，所以如果你希望一个处理函数通知你一些事件，你可以把另一个函数（回调）的指针传递给处理函数。处理函数在适当的时候调用回调。尽管一些成功的框架使用了这个方法，但是回调可能是不直观的，并可能在确保回调参数类型正确性上存在问题。<br>信号槽是 Qt 框架引以为豪的机制之一。所谓信号槽，实际就是观察者模式。当某个事件发生之后，比如，按钮检测到自己被点击了一下，它就会发出一个信号（signal）。这种发出是没有目的的，类似广播。如果有对象对这个信号感兴趣，它就会使用连接（connect）函数，意思是，将想要处理的信号和自己的一个函数（称为槽（slot））绑定来处理这个信号。也就是说，当信号发出时，被连接的槽函数会自动被回调。这就类似观察者模式：当发生了感兴趣的事件，某一个操作就会被自动触发。（这里提一句，Qt 的信号槽使用了额外的处理来实现，并不是 GoF 经典的观察者模式的实现方式。）</p><p>  信号和槽是Qt特有的信息传输机制，是Qt设计程序的重要基础，它可以让互不干扰的对象建立一种联系。</p><p>  槽的本质是类的成员函数，其参数可以是任意类型的。和普通C++成员函数几乎没有区别，它可以是虚函数；也可以被重载；可以是公有的、保护的、私有的、也可以被其他C++成员函数调用。唯一区别的是：槽可以与信号连接在一起，每当和槽连接的信号被发射的时候，就会调用这个槽。<br>  Qt的小部件有很多预定义的信号，但是我们总是可以通过继承来加入我们自己的信号。槽就是一个对应于特定信号的被调用的函数。Qt的部件有很多预定义的槽，但同样可以通过子类化加入自己的槽来处理感兴趣的信号。</p><h2 id="1-1-对象树-子对象动态分配空间不需要释放"><a href="#1-1-对象树-子对象动态分配空间不需要释放" class="headerlink" title="1.1 对象树(子对象动态分配空间不需要释放)"></a>1.1 对象树(子对象动态分配空间不需要释放)</h2><p>  <img src="qt-note/pic1.png" alt="对象树"><br>   比如说当应用程序创建了一个具有父窗口部件的对象时，该对象将被加入父窗口部件的孩子列表。当应用程序销毁父窗口部件时，其下的孩子列表中的对象将被一一删除。这让我们在编程时，能够将主要精力放在系统的业务上，提高编程效率，同时也保证了系统的稳健性。</p><h1 id="2-信号和槽"><a href="#2-信号和槽" class="headerlink" title="2 信号和槽"></a>2 信号和槽</h1><p>  在Qt中我们有一种可以替代回调的技术：我们使用信号和槽。当一个特定事件发生的时候，一个信号被发射。Qt的小部件有很多预定义的信号，但是我们总是可以通过继承来加入我们自己的信号。槽就是一个对应于特定信号的被调用的函数。Qt的部件有很多预定义的槽，但同样可以通过子类化加入自己的槽来处理感兴趣的信号。<br>  信号和槽机制是类型安全的：一个信号的签名(参数类型)必须与它的接收槽的签名相匹配。（实际上，一个槽的签名可能比它接收到的信号短，因为它可以忽略额外的参数。）因为签名是兼容的，当使用基于函数指针的语法时，编译器就可以帮助我们检测类型不匹配。基于字符串的信号和槽语法将在运行时检测类型不匹配。信号和插槽是松散耦合的：一个发射信号的类不用知道也不用关心哪个槽要接收这个信号。Qt的信号和槽的机制可以保证如果你把一个信号和一个槽连接起来，槽会在正确的时间使用信号的参数被调用。信号和槽可以使用任何数量、任何类型的参数。它们是完全类型安全的：不会再有回调核心转储(core dump)。</p><p>  从QObject类或者它的子类（如QWidget类）继承的所有类可以包含信号和槽。当改变它们的状态的时候，信号被发送。从某种意义上说，即它们对其他对象感兴趣。这就是所有的对象通讯时所做的一切。它不知道也不关心是否有其他对象接收到了它发射的信号。这就是真正的信息封装，并且确保对象可以用作一个软件组件使用。</p><p>  槽可以用来接收信号，但它们也是普通的成员函数。正如一个对象不知道有其他对象收到它的信号一样，一个槽也不知道它是否被任意信号连接。因此，这种方式保证了Qt创建组件的完全独立。</p><p>  你可以连接多个信号到一个槽，同样一个信号可以被你需要的多个槽连接。甚至可以一个信号连接到另一个信号。（该情况下，只要第一个信 号被发射时，第二个信号立即被发射。）</p><p>  总体来看，信号和槽构成了一个强有力的组件编程机制。</p><h2 id="2-1-信号"><a href="#2-1-信号" class="headerlink" title="2.1 信号"></a>2.1 信号</h2><p>  当一个对象内部状态发生改变时发射信号，信号就被发射，在某些方面对象的客户端和所有者可能感兴趣。信号是一个public访问函数并可以在任何地方发射，但是我们建议仅在定义了信号的类及他们的子类中发射。</p><p>  当一个信号被发射，它所连接的槽会被立即执行，类似于一个普通函数的调用。在该情况下，信号/槽机制在任何GUI事件循环中是完全独立的。一旦所有的槽返回了，emit语句随后的代码将会执行。这与queued connections方式有些许不同，queued connections方式下emit关键字随后的代码会立即继续执行，槽在随后执行（相当于异步，参考信号与槽的连接类型）。</p><p>  如果几个槽被连接到一个信号，当信号被发射时，这些槽就会按它们连接的顺序挨个执行。</p><p>  信号会由moc自动生成并一定不要在.cpp文件中实现。它们也不能有任何返回类型（也就是 只能使用void）。</p><h2 id="2-2-槽"><a href="#2-2-槽" class="headerlink" title="2.2 槽"></a>2.2 槽</h2><p>  当与槽连接的信号被发射时，该槽被调用。槽是普通的C++函数可以正常调用；它们唯一的特点就是可以被信号连接。</p><p>  因为槽是普通成员函数，所以被直接调用时遵循一般的C++规则。然而，作为槽，它们能被任何组件调用，通过信号槽连接，无需考虑访问级别。这意味着从一个任意类的实例发出的一个信号可以在一个不相关的类的实例中调用一个私有槽。</p><p>  同样还可以定义虚拟槽，我们在实践中发现它非常有用。</p><p>  与回调相比，信号和插槽的速度稍慢，因为它们增加了灵活性，尽管在实际应用程序中的差异是微不足道的。</p><p>  信号和槽的机制是非常有效的，但是它不像“真正的”回调那样快。信号和槽稍微有些慢，这是因为它们所提供的灵活性造成，尽管在实际应用中这些性能可以被忽略。通常，发射一个和槽相连的信号，大约比直接调接收器非虚函数的调用慢十倍。这是定位连接对象所需的开销，为了安全地遍历所有连接（e.g检查随后的接收器在发射过程中没有被销毁），并以通用的方式安排任意参数。虽然10个非虚函数调用听起来可能很多，但开销比任意new或delete 操作少得多。当执行一个字符串时，vector或list操作在后面的场景中需要new或delete, 但信号和槽在完成函数调用的开销中只占很小的一部分。在一个槽中进行系统调用或者间接地调用超过10个函数，情况也是相同的;。信号/插槽机制的简单和灵活性对于时间的开销是值得，用户甚至不会注意到这点。</p><p>  注意，与基于qt的应用程序一起编译时，定义变量的其他库调用信号和槽可能会造成编译器警告和错误。要解决这个问题，#undef这些预处理器的冲突符号即可。</p><h2 id="2-3-一个Qt-Creator的例子"><a href="#2-3-一个Qt-Creator的例子" class="headerlink" title="2.3 一个Qt Creator的例子"></a>2.3 一个Qt Creator的例子</h2>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;QApplication&gt;</span><br><span class="line">#include &lt;QPushButton&gt;</span><br><span class="line">   int main(int argc, char *argv[])</span><br><span class="line">   &#123;</span><br><span class="line">       QApplication app(argc, argv);</span><br><span class="line">       QPushButton button(&quot;Quit&quot;);</span><br><span class="line">       QObject::connect(&amp;button, &amp;QPushButton::clicked,</span><br><span class="line">       &amp;app, &amp;QApplication::quit);</span><br><span class="line">       button.show();</span><br><span class="line">       return app.exec();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>  在 Qt Creator 中创建工程的方法创建好工程，然后将main()函数修改为上面的代码。点击运行，我们会看到一个按钮，上面有“Quit”字样。点击按钮，程序退出。<br>  connect()函数最常用的一般形式：<br>  <strong>connect(sender, signal, receiver, slot);</strong><br>  参数：<br>   sender：发出信号的对象<br>   signal：发送对象发出的信号<br>   receiver：接收信号的对象<br>   slot：接收对象在接收到信号之后所需要调用的函数<br>  信号槽要求信号和槽的参数一致，所谓一致，是参数类型一致。如果不一致，允许的情况是，槽函数的参数可以比信号的少，即便如此，槽函数存在的那些参数的顺序也必须和信号的前面几个一致起来。这是因为，你可以在槽函数中选择忽略信号传来的数据（也就是槽函数的参数比信号的少），但是不能说信号根本没有这个数据，你就要在槽函数中使用（就是槽函数的参数比信号的多，这是不允许的）。</p><h2 id="2-4-一个普通C-程序的例子"><a href="#2-4-一个普通C-程序的例子" class="headerlink" title="2.4 一个普通C++程序的例子"></a>2.4 一个普通C++程序的例子</h2><p>  一个小的C++类声明如下：<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Counter</span><br><span class="line"> &#123;</span><br><span class="line">     public:</span><br><span class="line">         Counter() &#123; m_value = 0; &#125;</span><br><span class="line">   </span><br><span class="line">         int value() const &#123; return m_value; &#125;</span><br><span class="line">         void setValue(int value);</span><br><span class="line">     private:</span><br><span class="line">         int m_value;</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure></p><p>  一个小的基于QObject类如下：<br>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;QObject&gt;</span><br><span class="line"></span><br><span class="line">  class Counter : public QObject</span><br><span class="line">  &#123;</span><br><span class="line">      Q_OBJECT   </span><br><span class="line">      public:</span><br><span class="line">          Counter() &#123; m_value = 0; &#125;       </span><br><span class="line">          int value() const &#123; return m_value; &#125;       </span><br><span class="line">      public slots:</span><br><span class="line">          void setValue(int value);       </span><br><span class="line">      signals:</span><br><span class="line">          void valueChanged(int newValue);      </span><br><span class="line">      private:</span><br><span class="line">          int m_value;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure></p><p>   这个基于QObject的类有同样的内部状态，并提供公有方法来访问状态。除此之外，这个类可以通过发射一个valueChanged()信号来告诉外部世界关于它的状态改变，并且它有一个槽，其它对象可以发送信号给这个槽。<br>   所有包含信号和/或者槽的类必须在它们的声明中提到Q_OBJECT。它们也必须从QObject继承(直接或间接)。<br>   槽由应用程序的编写者来实现。这里是Counter::setValue()可能的一个槽实现：<br>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void Counter::setValue(int value)</span><br><span class="line">  &#123;</span><br><span class="line">      if (value != m_value) &#123;</span><br><span class="line">          m_value = value;</span><br><span class="line">          emit valueChanged(value);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>   emit这一行从对象中发射valueChanged()信号，以一个新值作为参数。<br>   在下面的小片断中，我们创建了两个Counter对象，并使用QObject::connect()将第一个对象的valueChanget()信号连接到第二个对象的setValue槽。<br>   下面是把两个对象连接在一起的一种方法：<br>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Counter a, b;</span><br><span class="line">    QObject::connect(&amp;a, &amp;Counter::valueChanged,</span><br><span class="line">                     &amp;b, &amp;Counter::setValue);</span><br><span class="line">   </span><br><span class="line">    a.setValue(12);     // a.value() == 12, b.value() == 12</span><br><span class="line">    b.setValue(48);     // a.value() == 12, b.value() == 48</span><br></pre></td></tr></table></figure></p><p>  调用a.setValue(12)会使a发射一个valueChanged(12) 信号，b将会在它的setValue()槽中接收这个信号，也就是b.setValue(12) 被调用。接下来b会发射同样的valueChanged()信号，但是因为没有槽被连接到b的valueChanged()信号，所以该信号被忽略。</p><p>  注意只有当value!= m_value的时候setValue()函数才会设置这个值并发射信号。这样就避免了存在环connections的情况下无限循环。（比如b.valueChanged() 和a.setValue()连接在一起）。</p><p>  默认情况下，对于你做出的每一个连接，一个信号被发射;重复连接下两个信号被发射。你可以调用disconnect()中断所有连接。如果传递了Qt::UniqueConnection类型，连接只有在不重复的情况下才建立。如果已经存在重复连接（同一个对象上确定的信号到确定的槽），则连接将会失败，connect返回fase。</p><p>  这个例子说明了对象可以协同工作而不需要知道彼此的任何信息。为达到这种效果，对像仅需要相互连接，并用一个简单的QObject::connect()函数调用实现，或者使用uic的自动连接特性。</p><h2 id="2-5-带有默认参数的信号和槽"><a href="#2-5-带有默认参数的信号和槽" class="headerlink" title="2.5 带有默认参数的信号和槽"></a>2.5 带有默认参数的信号和槽</h2><p>   信号和槽的签名可能包含参数，参数可以有默认值。考虑QObject::destroyed()函数。<br>   <code>void destroyed(QObject* = 0);</code><br>   当一个QObject对象被删除，它发射QObject::destroyed()信号。我们想捕获此信号，无论在我们可能有一个悬空的引用指向删除的QObject对象的情况下，因此我们可以把它清理干净。一个合适的槽签名可能是这样的:<br>    <code>void objectDestroyed(QObject* obj = 0);</code><br>   为连接一个信号到此槽，我们使用QObject::connect。这里有几个方式连接。第一种方式是使用函数指针：<br>    <code>connect(sender,&amp;QObject::destroyed,this,&amp;MyObject::objectDestroyed);</code><br>   连接信号到槽的另一种方法是使用QObject::connect()，SIGNAL和SLOT宏。关于是否在SIGNAL()和SLOT()宏中包含参数的规则，如果参数有默认值，传递给SIGNAL()宏的签名必须不能少于传递给SLOT()宏签名的参数。<br>   下述这些都会生效：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">connect(sender,SIGNAL(destroyed(QObject*)),this,</span><br><span class="line">SLOT(objectDestroyed(Qbject*)));</span><br><span class="line"></span><br><span class="line">connect(sender,SIGNAL(destroyed(QObject*)),this,</span><br><span class="line">SLOT(objectDestroyed()));</span><br><span class="line"></span><br><span class="line">connect(sender, SIGNAL(destroyed()),this,</span><br><span class="line">SLOT(objectDestroyed()));</span><br></pre></td></tr></table></figure></p><h2 id="2-6-信号和槽的进一步使用"><a href="#2-6-信号和槽的进一步使用" class="headerlink" title="2.6 信号和槽的进一步使用"></a>2.6 信号和槽的进一步使用</h2><p>   对于可能需要信号发送者信息的情况, Qt提供了QObject::sender()函数，它返回一个指向发送信号的对象的指针。</p><p>   QSignalMapper类为一种情形提供，该情况下多个信号连接到同一个槽，而槽需要以不同的方式处理每个信号。</p><p>   假设有三个按钮来决定将打开哪个文件: “Tax File”, “Accounts File”, “Report File”.</p><p>   为了打开正确的文件,使用QSignalMapper:setMapping()来映射所有QPushButton:clicked()到QSignalMapper对象。然后将文件的QPushButton::clicked()信号连接到QSignalMapper::map()槽。<br>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">signalMapper = new QSignalMapper(this);</span><br><span class="line">       </span><br><span class="line">       signalMapper-&gt;setMapping(taxFileButton,   QString(&quot;taxfile.txt&quot;));</span><br><span class="line">       </span><br><span class="line">       signalMapper-&gt;setMapping(accountFileButton,</span><br><span class="line">                               QString(&quot;accountsfile.txt&quot;));</span><br><span class="line">       </span><br><span class="line">       signalMapper-&gt;setMapping(reportFileButton,</span><br><span class="line">                               QString(&quot;reportfile.txt&quot;));</span><br><span class="line">       </span><br><span class="line">       connect(taxFileButton, &amp;QPushButton::clicked,</span><br><span class="line">                 signalMapper, &amp;QSignalMapper::map);</span><br><span class="line">       </span><br><span class="line">       connect(accountFileButton, &amp;QPushButton::clicked,</span><br><span class="line">                 signalMapper, &amp;QSignalMapper::map);</span><br><span class="line">       </span><br><span class="line">       connect(reportFileButton, &amp;QPushButton::clicked,</span><br><span class="line">                 signalMapper, &amp;QSignalMapper::map);</span><br></pre></td></tr></table></figure></p><p>   然后，将mapped()信号连接到readFile()，根据按下的按钮，readFile()打开不同的文件。<code>connect(signalMapper, SIGNAL(mapped(QString)),this, SLOT(readFile(QString)));</code>  </p><h2 id="2-7-自定义信号槽"><a href="#2-7-自定义信号槽" class="headerlink" title="2.7 自定义信号槽"></a>2.7 自定义信号槽</h2><ul><li>发送者和接收者都需要是QObject的子类（当然，槽函数是全局函数、Lambda 表达式等无需接收者的时候除外）； </li><li>使用 signals 标记信号函数，信号是一个函数声明，返回 void，不需要实现函数代码；</li><li>槽函数是普通的成员函数，作为成员函数，会受到 public、private、protected 的影响；</li><li>使用 emit 在恰当的位置发送信号；</li><li>使用QObject::connect()函数连接信号和槽。</li><li>任何成员函数、static 函数、全局函数和 Lambda 表达式都可以作为槽函数 <h2 id="2-8-信号槽的更多用法"><a href="#2-8-信号槽的更多用法" class="headerlink" title="2.8 信号槽的更多用法"></a>2.8 信号槽的更多用法</h2></li><li>一个信号可以和多个槽相连<br>　　如果是这种情况，这些槽会一个接一个的被调用，但是它们的调用顺序是不确定的。</li><li>多个信号可以连接到一个槽<br>　　只要任意一个信号发出，这个槽就会被调用。</li><li>一个信号可以连接到另外的一个信号<br>　　当第一个信号发出时，第二个信号被发出。除此之外，这种信号-信号的形式和信号-槽的形式没有什么区别。</li><li>槽可以被取消链接<br>　　这种情况并不经常出现，因为当一个对象delete之后，Qt自动取消所有连接到这个对象上面的槽。</li><li>使用Lambda 表达式<br>　　在使用 Qt 5 的时候，能够支持 Qt 5 的编译器都是支持 Lambda 表达式的。<br>　　我们的代码可以写成下面这样：  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">QObject::connect(&amp;newspaper, static_cast&lt;void (Newspaper:: *)</span><br><span class="line">(const QString &amp;)&gt;(&amp;Newspaper::newPaper),</span><br><span class="line">[=](const QString &amp;name) </span><br><span class="line">&#123; /* Your code here. */ &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li></ul><p>在连接信号和槽的时候，槽函数可以使用Lambda表达式的方式进行处理。</p><h1 id="3-案例"><a href="#3-案例" class="headerlink" title="3 案例"></a>3 案例</h1><p>mainwidget.h<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#ifndef MAINWIDGET_H</span><br><span class="line">#define MAINWIDGET_H</span><br><span class="line"></span><br><span class="line">#include &lt;QWidget&gt;</span><br><span class="line">#include &lt;QPushButton&gt;</span><br><span class="line">#include &quot;subwidget.h&quot; //子窗口头文件</span><br><span class="line"></span><br><span class="line">class MainWidget : public QWidget</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    MainWidget(QWidget *parent = 0);</span><br><span class="line">    ~MainWidget();</span><br><span class="line"></span><br><span class="line">public slots:</span><br><span class="line">    void mySlot();</span><br><span class="line">    void changeWin();</span><br><span class="line">    void dealSub();</span><br><span class="line">    void dealSlot(int, QString);</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    QPushButton b1;</span><br><span class="line">    QPushButton *b2;</span><br><span class="line">    QPushButton b3;</span><br><span class="line"></span><br><span class="line">    SubWidget subWin;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">#endif // MAINWIDGET_H</span><br></pre></td></tr></table></figure></p><p>subwidget.h<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#ifndef SUBWIDGET_H</span><br><span class="line">#define SUBWIDGET_H</span><br><span class="line"></span><br><span class="line">#include &lt;QWidget&gt;</span><br><span class="line">#include &lt;QPushButton&gt;</span><br><span class="line"></span><br><span class="line">class SubWidget : public QWidget</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line">public:</span><br><span class="line">    explicit SubWidget(QWidget *parent = 0);</span><br><span class="line"></span><br><span class="line">    void sendSlot();</span><br><span class="line"></span><br><span class="line">signals:</span><br><span class="line">     /* 信号必须有signals关键字来声明</span><br><span class="line">      * 信号没有返回值，但可以有参数</span><br><span class="line">      * 信号就是函数的声明，只需声明，无需定义</span><br><span class="line">      * 使用：emit mySignal();</span><br><span class="line">      * 信号可以重载</span><br><span class="line">     */</span><br><span class="line"></span><br><span class="line">    void mySignal();</span><br><span class="line">    void mySignal(int, QString);</span><br><span class="line"></span><br><span class="line">public slots:</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    QPushButton b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">#endif // SUBWIDGET_H</span><br></pre></td></tr></table></figure></p><p>main.cpp<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;mainwidget.h&quot;</span><br><span class="line">#include &lt;QApplication&gt;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    QApplication a(argc, argv);</span><br><span class="line">    MainWidget w;//执行MainWidget的构造函数</span><br><span class="line">    w.show();</span><br><span class="line"></span><br><span class="line">    return a.exec();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>mainvidget.cpp<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;mainwidget.h&quot;</span><br><span class="line">#include &lt;QPushButton&gt;</span><br><span class="line">#include &lt;QDebug&gt; //打印</span><br><span class="line"></span><br><span class="line">MainWidget::MainWidget(QWidget *parent)</span><br><span class="line">    : QWidget(parent)</span><br><span class="line">&#123;</span><br><span class="line">    b1.setParent(this);</span><br><span class="line">    b1.setText(&quot;close&quot;);</span><br><span class="line">    b1.move(100, 100);</span><br><span class="line"></span><br><span class="line">    b2 = new QPushButton(this);</span><br><span class="line">    b2-&gt;setText(&quot;abc&quot;);</span><br><span class="line"></span><br><span class="line">    connect(&amp;b1, &amp;QPushButton::pressed, this, &amp;MainWidget::close);</span><br><span class="line">    /* &amp;b1: 信号发出者，指针类型</span><br><span class="line">     * &amp;QPushButton::pressed：处理的信号，  &amp;发送者的类名::信号名字</span><br><span class="line">     * this: 信号接收者</span><br><span class="line">     * &amp;MainWidget::close： 槽函数，信号处理函数  &amp;接收的类名::槽函数名字</span><br><span class="line">     * 发送-处理-接收-处理</span><br><span class="line">    */</span><br><span class="line"></span><br><span class="line">    /* 自定义槽，普通函数的用法</span><br><span class="line">     * Qt5：任意的成员函数，普通全局函数，静态函数</span><br><span class="line">     * 槽函数需要和信号一致（参数，返回值）</span><br><span class="line">     * 由于信号都是没有返回值，所以，槽函数一定没有返回值</span><br><span class="line">     */</span><br><span class="line">    connect(b2, &amp;QPushButton::released, this, &amp;MainWidget::mySlot);</span><br><span class="line"></span><br><span class="line">    connect(b2, &amp;QPushButton::released, &amp;b1, &amp;QPushButton::hide);</span><br><span class="line"></span><br><span class="line">    /* 信号：短信</span><br><span class="line">     * 槽函数：接收短信的手机</span><br><span class="line">     */</span><br><span class="line"></span><br><span class="line">    setWindowTitle(&quot;老大&quot;);</span><br><span class="line">    //this-&gt;setWindowTitle(&quot;老大&quot;);//等价同上</span><br><span class="line"></span><br><span class="line">    b3.setParent(this);</span><br><span class="line">    b3.setText(&quot;切换到子窗口&quot;);</span><br><span class="line">    b3.move(50, 50);</span><br><span class="line"></span><br><span class="line">    //显示子窗口</span><br><span class="line">    //subWin.show();</span><br><span class="line"></span><br><span class="line">    connect(&amp;b3, &amp;QPushButton::released, this, &amp;MainWidget::changeWin);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //处理子窗口的信号</span><br><span class="line">//    void (SubWidget::*funSignal)() = &amp;SubWidget::mySignal;</span><br><span class="line">//    connect(&amp;subWin, funSignal, this, &amp;MainWidget::dealSub);</span><br><span class="line"></span><br><span class="line">//     void (SubWidget::*testSignal)(int, QString) = &amp;SubWidget::mySignal;</span><br><span class="line">//    connect(&amp;subWin, testSignal, this, &amp;MainWidget::dealSlot);</span><br><span class="line"></span><br><span class="line">    //Qt4信号连接</span><br><span class="line">    //Qt4槽函数必须有slots关键字来修饰</span><br><span class="line">    connect(&amp;subWin, SIGNAL(mySignal()), this, SLOT(dealSub()) );</span><br><span class="line"></span><br><span class="line">    connect(&amp;subWin, SIGNAL(mySignal(int,QString)),</span><br><span class="line">            this, SLOT(dealSlot(int,QString)) );</span><br><span class="line">    //缺点： SIGNAL SLOT 将函数名字 -&gt; 字符串  不进行错误检查</span><br><span class="line"></span><br><span class="line">    //Lambda表达式, 匿名函数对象</span><br><span class="line">    //C++11增加的新特性， 项目文件： CONFIG += C++11</span><br><span class="line">    //Qt配合信号一起使用，非常方便</span><br><span class="line"></span><br><span class="line">    QPushButton *b4 = new QPushButton(this);</span><br><span class="line">    b4-&gt;setText(&quot;Lambda表达式&quot;);</span><br><span class="line">    b4-&gt;move(150, 150);</span><br><span class="line">    int a = 10, b = 100;</span><br><span class="line">    connect(b4, &amp;QPushButton::clicked,</span><br><span class="line">            // = :把外部所有局部变量、类中所有成员以值传递方式</span><br><span class="line">            // this: 类中所有成员以值传递方式</span><br><span class="line">            // &amp; : 把外部所有局部变量， 引用符号</span><br><span class="line">            [=](bool isCheck)</span><br><span class="line">            &#123;</span><br><span class="line">                qDebug() &lt;&lt; isCheck;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    resize(400, 300);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void MainWidget::dealSlot(int a, QString str)</span><br><span class="line">&#123;</span><br><span class="line">    // str.toUtf8() -&gt; 字节数组QByteArray</span><br><span class="line">    // ……data()  -&gt; QByteArray -&gt; char *</span><br><span class="line">    qDebug() &lt;&lt; a &lt;&lt; str.toUtf8().data();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void MainWidget::mySlot()</span><br><span class="line">&#123;</span><br><span class="line">    b2-&gt;setText(&quot;123&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void MainWidget::changeWin()</span><br><span class="line">&#123;</span><br><span class="line">    //子窗口显示</span><br><span class="line">    subWin.show();</span><br><span class="line">    //本窗口隐藏</span><br><span class="line">    this-&gt;hide();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void MainWidget::dealSub()</span><br><span class="line">&#123;</span><br><span class="line">    //子窗口隐藏</span><br><span class="line">    subWin.hide();</span><br><span class="line">    //本窗口显示</span><br><span class="line">    show();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MainWidget::~MainWidget()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>subwidget.cpp<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;subwidget.h&quot;</span><br><span class="line"></span><br><span class="line">SubWidget::SubWidget(QWidget *parent) : QWidget(parent)</span><br><span class="line">&#123;</span><br><span class="line">    this-&gt;setWindowTitle(&quot;小弟&quot;);</span><br><span class="line">    b.setParent(this);</span><br><span class="line">    b.setText(&quot;切换到主窗口&quot;);</span><br><span class="line"></span><br><span class="line">    connect(&amp;b, &amp;QPushButton::clicked, this, &amp;SubWidget::sendSlot);</span><br><span class="line"></span><br><span class="line">    resize(400, 300);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void SubWidget::sendSlot()</span><br><span class="line">&#123;</span><br><span class="line">    emit mySignal();</span><br><span class="line">    emit mySignal(250, &quot;我是子窗口&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>SingnalAndSlot.pro<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">QT       += core gui</span><br><span class="line"></span><br><span class="line">greaterThan(QT_MAJOR_VERSION, 4): QT += widgets</span><br><span class="line"></span><br><span class="line">TARGET = 03_SignalAndSlot</span><br><span class="line">TEMPLATE = app</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SOURCES += main.cpp\</span><br><span class="line">        mainwidget.cpp \</span><br><span class="line">    subwidget.cpp</span><br><span class="line"></span><br><span class="line">HEADERS  += mainwidget.h \</span><br><span class="line">    subwidget.h</span><br><span class="line"></span><br><span class="line">CONFIG += C++11</span><br></pre></td></tr></table></figure></p><h1 id="4-总结"><a href="#4-总结" class="headerlink" title="4 总结"></a>4 总结</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="qt-note/pic2.png" alt="结构图" title>                </div>                <div class="image-caption">结构图</div>            </figure><h1 id="5-参考博文"><a href="#5-参考博文" class="headerlink" title="5 参考博文"></a>5 参考博文</h1><ol><li>C++_之Qt的信号和槽的详解 <a href="https://www.cnblogs.com/wanghui1234/p/8964968.html" target="_blank" rel="noopener">https://www.cnblogs.com/wanghui1234/p/8964968.html</a>  </li><li>Qt信号和槽机制 <a href="https://blog.csdn.net/lsfreeing/article/details/78575246" target="_blank" rel="noopener">https://blog.csdn.net/lsfreeing/article/details/78575246</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;QT的信号和槽的详解，包括简介，信号和槽分析以及一个实例&lt;br&gt;
    
    </summary>
    
      <category term="AI组件开发" scheme="http://11wy11.github.io/categories/AI%E7%BB%84%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    
      <category term="C++" scheme="http://11wy11.github.io/categories/C/"/>
    
    
      <category term="C++" scheme="http://11wy11.github.io/tags/C/"/>
    
      <category term="QT" scheme="http://11wy11.github.io/tags/QT/"/>
    
  </entry>
  
  <entry>
    <title>krpano快速入门教程（二）</title>
    <link href="http://11wy11.github.io/2019/03/15/krpano-second-note/"/>
    <id>http://11wy11.github.io/2019/03/15/krpano-second-note/</id>
    <published>2019-03-15T15:19:51.000Z</published>
    <updated>2019-03-24T01:32:04.216Z</updated>
    
    <content type="html"><![CDATA[<p>主要介绍全景漫游及vtour文件夹介绍<br><a id="more"></a></p><h3 id="vtour全景漫游及vtour文件夹介绍"><a href="#vtour全景漫游及vtour文件夹介绍" class="headerlink" title="vtour全景漫游及vtour文件夹介绍"></a>vtour全景漫游及vtour文件夹介绍</h3><p>使用MAKE VTOUR (MULTIRES) droplet工具生成全景漫游<br><!--more--></p><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>在初始学习krpano时，可以借助krpano的工具生成全景漫游文件，之后可以根据需要修改tour.xml,定制skin等；<br>上节简单介绍了krpano使用Make pano的工具创建单场景应用，但大多数应用中场景数量不只一个，彼此之间可以跳转，这就需要借助MAKE VTOUR droplet工具了。而具体选择三种中的哪一种，根据应用场景需要选择，multires支持将全景切片分级，能够达到更好的展示效果，但会使全景文件大小增加，normal生成普通的pano_f.jpg,pano_b.jpg,pano_l.jpg，pano_r.jpg，pano_u.jpg，pano_d.jpg,preview.jpg，分别为全景图的前后左右上下，以及菜单中的预览图。</p><h3 id="生成vtour"><a href="#生成vtour" class="headerlink" title="生成vtour"></a>生成vtour</h3><p>使用MAKE VTOUR (MULTIRES) droplet工具生成的全景漫游场景，场景彼此之间相互连接，能够从一个场景跳转到另一个场景。<br>可以同时选择多张全景图片拖放在该工具上，输入全景图类型，和全景角度，执行切片，等待完成。显示<strong>done</strong>之后，在全景图文件夹中生成vtour文件夹。</p><h3 id="vtour文件夹内容介绍"><a href="#vtour文件夹内容介绍" class="headerlink" title="vtour文件夹内容介绍"></a>vtour文件夹内容介绍</h3><pre><code>1. tour.html文件--嵌入全景的网页2. tour.swf文件--krpano的flash viewer3. tour.js文件--基于swfkrpano.js的一个viewer，即HTML5的viewer及嵌入HTML的js文件的合体4. tour.xml文件--是krpano xml配置文件，定义全景图配置及皮肤配置5. panos文件夹--存放处理后的全景图切片6. plugins文件夹--主要存放使用到的插件</code></pre><h3 id="场景Scene"><a href="#场景Scene" class="headerlink" title="场景Scene"></a>场景Scene</h3><p>它们可用于在当前xml文件中再次定义完整krpano xml文件的内容。它就像一个外部的xml，但只是内联/嵌入到当前的xml中。 在调用具有场景名称的loadscene（）</p><p>典型的用法是在一个xml文件中定义几个panos。</p><p>使用loadpano（）动作加载新的外部xml文件时，将删除所有当前定义的场景元素。</p><p>可以在&lt;scene>元素中存储任何自定义属性 - 查看器本身将忽略它们，但它们可用于自定义操作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;scene name=&quot;scene_20171106193359&quot; title=&quot;20171106193359&quot; onstart=&quot;&quot; thumburl=&quot;panos/20171106193359.tiles/thumb.jpg&quot; lat=&quot;51.51500000&quot; lng=&quot;-0.08050000&quot; heading=&quot;0.0&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;view hlookat=&quot;0.0&quot; vlookat=&quot;0.0&quot; fovtype=&quot;MFOV&quot; fov=&quot;120&quot; maxpixelzoom=&quot;2.0&quot; fovmin=&quot;70&quot; fovmax=&quot;140&quot; limitview=&quot;range&quot; vlookatmin=&quot;-56.055&quot; vlookatmax=&quot;56.055&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;preview url=&quot;panos/20171106193359.tiles/preview.jpg&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;image prealign=&quot;0|0.0|0&quot;&gt;</span><br><span class="line">&lt;cube url=&quot;panos/20171106193359.tiles/pano_%s.jpg&quot; /&gt;</span><br><span class="line">&lt;/image&gt;</span><br><span class="line"></span><br><span class="line">&lt;/scene&gt;</span><br></pre></td></tr></table></figure></p><p>说明：      </p><ol><li>name<br>场景名称，命名规则：每个名字都需要以字母字符开头！这意味着不允许使用数字作为名字！当名称仍然以数字字符开头时，名称将被解释为数组索引。这对于动作内部基于动态索引的访问没有问题，但不能用于定义元素！所有名称将自动转换为小写字母，以便直接区分大小写访问！也是loadscene时设置的参数</li><li>title<br>主要显示在缩略图上或者菜单栏名称</li><li>onstart<br>此处可以定义将在“开始时”调用全景/场景观看的任何动作/功能。<br>场景启动时调用，可以执行定义好的action</li><li>thumburl<br>默认视角的展示图路径，使用相对路径，以xml所在位置开始计算相对路径</li><li>lat&amp;lon<br>场景所在经纬度，可以用于小地图插件，定位场景</li><li>heading<br>仰角度数</li></ol><h3 id="视图view"><a href="#视图view" class="headerlink" title="视图view"></a>视图view</h3><p>view元素包含有关当前视图的信息。<br>在xml中，它可用于设置启动视图设置。</p><p>查找方向将由hlookat / vlookat属性（=水平/垂直lookat）和fov属性中的当前视野定义。要查看部分全景图的限制，可以使用limitview属性。</p><ol><li>hlookat&amp;vlookat<br>设置初始视角，分别为水平方向和垂直方向<ul><li>hlookat:球面坐标的水平方向，以度为单位。<pre><code>典型范围为-180°至+ 180°。该值不会环绕360°，但视图本身会。值0.0指向全景图像的中心。</code></pre></li><li>vlookat:球面坐标的垂直方向，以度为单位。<pre><code>典型范围为-90°至+90°。但视图本身会。值0.0指向全景图像的中心。</code></pre></li></ul></li><li>fov<br>以度为单位的当前视野 - 从近似0.0到179.0。,默认为90 </li><li>fovmin&amp;fovmax<br>主要设置视角放大和缩小的最大和最小视角</li><li>maxpixelzoom<br>全景图像的最大像素缩放系数。<br>这将根据全景分辨率和当前观察窗口自动限制fov，例如1.0 =限制为100％缩放，不会看到源图像的像素缩放。</li></ol><h3 id="预览preview"><a href="#预览preview" class="headerlink" title="预览preview"></a>预览preview</h3><pre><code>url:设置预览图路径</code></pre><h3 id="全景图image"><a href="#全景图image" class="headerlink" title="全景图image"></a>全景图image</h3><pre><code>使用&lt;image&gt;元素将定义全景图像。</code></pre><p>在此处设置图像/图块的类型，大小和URL路径。</p><ol><li>type<br>定义全景图像的类型。</li></ol><p>可能的值：</p><ul><li>CUBE<br>方全景图像 - 六个图像，每个立方体一个图像。</li><li>CUBESTRIP<br>在一张图像中作为“图像条”的立方体全景图像。支持的多维数据集格式为6x1,1x6,3x2或2x3。立方体侧对齐本身始终需要：L，F，R，B，U，D（默认为krpano）。</li><li>SPHERE<br>球形/ equirectangular全景图像。<br>通过设置自定义hfov， vfov和 voffset设置可以实现部分panos。</li><li>CYLINDER<br>一个圆柱形全景图像。<br>通过设置自定义hfov， vfov和 voffset设置可以实现部分panos。</li><li>…未设置时：<br>如果未设置类型，则查看器会尝试通过&lt;image>标记内的标记自动检测类型（仅适用于非多图像）。</li></ul><ol start="2"><li>hfov<br>以度为单位定义全景图像的水平视野（hfov）。<br>这是在全景图像上捕获的可见范围。<br>默认值为360，表示全方位视图。使用较小的值进行部分全景。对于平坦全景（或普通图像），应使用值“1.0”。</li><li><p>multies<br>启用平铺的多分辨率图像。<br>设置为true时，&lt;image>元素需要包含多个&lt;level>元素，其中包含每个多分辨率级别的图像定义。多分辨切片时定义使用</p></li><li><p>tilesize<br>当全景图为切片时，设置每一级切片大小</p></li><li>level[..].tiledimagewidth level[..].tiledimageheight<br>某一级切片大小</li><li><p>stereo&amp;stereolabels&amp;stereoformat    </p><p> 允许使用立体图像（仅限HTML5和WebGL）。</p><p> 使用立方体图像时，图像URL应包含％t占位符。此占位符将替换为stereolabels设置中的值。对于左图像，将使用第一个值，对于右图像，将使用第二个值。</p><p> 对于球形或圆柱形图像或视频，可以使用“帧封装”立体图像。该stereoformat设置定义的打包顺序：<br> stereoformat =“TB” - 上/下<br> stereoformat =“SBS” - Side-By-Side<br> 示例 - 立体立方体图像：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;image stereo =“true”stereolabels =“1 | 2” &gt; </span><br><span class="line">  &lt;cube url =“pano_％s_ ％t .jpg”/&gt; </span><br><span class="line">&lt;/ image&gt;</span><br><span class="line">示例 - 立体全景视频：</span><br><span class="line">&lt;image stereo =“true”stereoformat =“TB” &gt; </span><br><span class="line">  &lt;sphere url =“ plugin：video ”/&gt; </span><br><span class="line">&lt;/ image&gt;</span><br></pre></td></tr></table></figure><p> 注意 - 根据全景图像或视频的像素大小（和侧面），可能需要手动设置hfov，vfov和voffset设置。</p></li><li><p>fisheye.fov fisheye.align fisheye.crop fisheye.lenscp<br> 鱼眼图像支持（仅限HTML5和WebGL）。</p><p> 通过鱼眼设置，可以在krpano中使用鱼眼照片和视频。</p><p> 为了正确地拉直和对齐鱼眼图像，有必要了解一些有关它的参数。获取这些参数的一个好工具是PTGUI。</p><p> 鱼眼设置：</p><ul><li>fov = “180.0”<ul><li>鱼眼图像的视野（以度为单位）。</li><li>与crop大小有关。</li><li>来源：可以直接从PTGUI fov图像参数中获取。</li></ul></li><li>align = “yaw|pitch|roll”<ul><li>图像的对齐/旋转/调平（以度为单位）。</li><li>来源：可以直接从PTGUI图像参数中获取。<br>（例如，使用垂直线控制点来对齐/调整图像）</li></ul></li><li>crop=“left|right|top|bottom”<ul><li>鱼眼fov裁剪圆的边缘（以像素为单位）。</li><li>圆与fov大小有关。</li><li>来源：可以直接从PTGUI裁剪设置中获取。</li></ul></li><li>lenscp = “a| b | c | d | e” 的<ul><li>镜头校正参数。</li><li>来源：可以直接从PTGUI镜头设置中获取。</li></ul></li></ul></li></ol><h3 id="image中URL占位符等"><a href="#image中URL占位符等" class="headerlink" title="image中URL占位符等"></a>image中URL占位符等</h3><p>根据图像类型和相关设置，图像的URL应包含多个占位符，以允许寻址正确的图像文件。</p><p>这些网址占位符可用：</p><ul><li>对于立方体的各个面：％s⇒cubelabels的占位符</li><li>对于水平图块索引：％h，％x，％u或％c （都相同）</li><li>对于垂直图块索引： ％v，％y或％r （都相同）</li><li>对于立体图像：％t⇒stereolabels的占位符<br>为当前图像帧：％f ⇒ image.frame （仅限Flash）</li><li>每个占位符可以在url中多次使用 - 例如，作为文件名的一部分，也作为foldername的一部分。</li><li>平铺索引填充：<br>通过在％字符和tile-index占位符的字符之间插入一个或多个0个字符，可以为数字定义自定义填充。<br>比如:<br>％H  ⇒  1,2,3，…，9,10,11<br>％0H  ⇒  01,02,03，…，09,10,11<br>％00H  ⇒  001,002,003，……，009010011</li></ul><h3 id="预览效果"><a href="#预览效果" class="headerlink" title="预览效果"></a>预览效果</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="krpano-second-note/pic1.png" alt="效果图" title>                </div>                <div class="image-caption">效果图</div>            </figure><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p>之后的主要工作为：定制skin，定制plugins，定制xml，一些动态操作全景图配置使编辑js文件，能够实现动态配置全景图程序，能够更好的融入到Web应用程序中，作为其中一个子功能模块。后续结合实际案例介绍具体实现方式。历史文章</p><h3 id="历史文章"><a href="#历史文章" class="headerlink" title="历史文章"></a>历史文章</h3><p><a href="/2019/03/14/krpano-first-note">krpano快速入门教程（一) 使用krpano工具构建即用型panos</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;主要介绍全景漫游及vtour文件夹介绍&lt;br&gt;
    
    </summary>
    
      <category term="全景" scheme="http://11wy11.github.io/categories/%E5%85%A8%E6%99%AF/"/>
    
    
      <category term="krpano" scheme="http://11wy11.github.io/tags/krpano/"/>
    
  </entry>
  
  <entry>
    <title>krpano快速入门教程（一）之构建panos应用</title>
    <link href="http://11wy11.github.io/2019/03/14/krpano-first-note/"/>
    <id>http://11wy11.github.io/2019/03/14/krpano-first-note/</id>
    <published>2019-03-14T07:54:54.000Z</published>
    <updated>2019-03-24T01:17:55.061Z</updated>
    
    <content type="html"><![CDATA[<h2 id="使用krpano工具构建即用型panos"><a href="#使用krpano工具构建即用型panos" class="headerlink" title="使用krpano工具构建即用型panos"></a>使用krpano工具构建即用型panos</h2><p>简单使用krpano工具快速生成可执行的pano文件，后续介绍如何自定义编写配置文件切图等<br><a id="more"></a></p><h2 id="krpano简介"><a href="#krpano简介" class="headerlink" title="krpano简介"></a>krpano简介</h2><p>Krpano是一款全景漫游制作软件和工具。用krpano所生成的全景，在兼容性、功能性、互动性方面的表现都很不错，而且可以二次开发并拥有自己的编程语言，比如使用专用的krpano xml代码编写全景漫游，可开发出高度定制化的项目。因此，目前主流的全景网站均是在krpano全景的基础上进行开发，并不断进行更新迭代，形成自己独有的全景内容服务。</p><h2 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h2><ol><li>从<a href="https://krpano.com/download/" target="_blank" rel="noopener">krpano下载页面下载</a>适合于自己系统的krpano Tools软件包</li><li>将下载的krpano Tools zip文件解压到一个不含中文路径的文件夹下（为了所有稳定使用，推荐）</li><li>如果您已拥有krpano许可文件 - 则立即将其复制或移动到krpano Tools文件夹中。如果您没有任何一个，那么只需跳过此步骤即可。之后可以通过注册码注册，具体破解方法请自行百度，注册后能够去掉切片中的krpano水印。</li><li>要构建单个全景图 - 打开包含全景图像的文件夹，选择其中一个或全部，拖放到MAKE PANO droplet批处理工具上。<br><img src="krpano-first-note/pic1.png" alt="拖动全景图到工具上"><br>等待切片完成，会在全景图像所在文件夹中生成一个以全景图命名的文件夹，里面自动生成一个即用型pano,点击tour_testingsever运行测试服务器，打开index.html查看效果。<br><img src="krpano-first-note/pic2.png" alt="生成结果"><br>需要说明的是，这里如果没有注册，运行之后全景图是有krpano水印的。可以运行krpano tools选择 register now 输入序列号完成注册。注册完在按照第4步操作，得到没有水印的全景图<br><img src="krpano-first-note/pic3.png" alt="注册前"><center>注册前</center><br><img src="krpano-first-note/pic4.png" alt="注册后"><br><center> 注册后</center></li><li>要构建虚拟游览 - 打开包含全景虚拟游览图像的文件夹，选择所有这些图像拖放到MAKE VTOURdroplet批处理工具上。 </li><li>其他工具使用类似，主要功能简介如下：  <ul><li>MAKE PANO (NORMAL) droplet<br>针对标准全景图（360度），最大值。cubeize默认限制为2200像素（可以在’templates / normal.config’文件中更改），没有皮肤 - 只需pano，HTML5 iPhone / iPad就绪</li><li>MAKE PANO（MULTIRES）droplet<br>用于渐进多分辨率的panos，没有尺寸/分辨率限制，快速动态加载，带按钮的默认皮肤，HTML5 iPhone / iPad就绪</li><li>MAKE PANO（FLAT）droplet<br>用于平面/ 2D平移/图像，平铺多分辨率，无尺寸/分辨率限制，平坦全景/图像的皮肤/控制，仅限闪光</li><li>MAKE PANO（SINGLESWF）droplet<br>只生成一个Flash swf文件，对于标准全景图，完整的pano将立即加载，最大值。cubesize限制为2200像素（可在’templates / singleswf.config’文件中更改），默认皮肤带按钮，仅限Flash</li><li>MAKE OBJECT droplet<br>用于平铺多分辨率对象影片，一次删除所有对象图像，没有大小/分辨率限制，快速和动态加载，具有按钮和对象旋转控件的对象外观，仅限Flash</li><li>MAKE VTOUR (NORMAL) droplet / MAKE VTOUR (MULTIRES) droplet<br> 用于自动构建虚拟游览，将所有全景图像放在此工具上，通过自动缩略图生成，准备好HTML5 iPhone / iPad </li></ul></li><li>处理完成后关闭dos / terminal窗口。在源图像的文件夹中会有新文件：典型的.html文件 - 这是嵌入pano的示例网页，.swf文件 - 这是krpano Flash查看器，.js文件 - 这是Javascript Flash到HTML嵌入代码（基于swfkrpano.js）和可选的krpano HTML5 / Javascript iPhone / iPad查看器，一个.xml文件 - 这是krpano xml文件，有pano和皮肤定义，最后有.tiles文件夹 - 有处理过的全景图像。全景图像本身不是观看全景图像所必需的。 6.2。当您使用MAKE VTOUR Droplet时，这些文件将位于’vtour’文件夹中，而pano图像位于其中的’panos’文件夹中。</li><li>编辑全景设置打开并在任何文本编辑器中编辑生成的xml文件（带有xml-syntax-highlighting的文本编辑器可能会有帮助）： 在在线文档中查找krpano xml定义：</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;使用krpano工具构建即用型panos&quot;&gt;&lt;a href=&quot;#使用krpano工具构建即用型panos&quot; class=&quot;headerlink&quot; title=&quot;使用krpano工具构建即用型panos&quot;&gt;&lt;/a&gt;使用krpano工具构建即用型panos&lt;/h2&gt;&lt;p&gt;简单使用krpano工具快速生成可执行的pano文件，后续介绍如何自定义编写配置文件切图等&lt;br&gt;
    
    </summary>
    
      <category term="全景" scheme="http://11wy11.github.io/categories/%E5%85%A8%E6%99%AF/"/>
    
    
      <category term="krpano" scheme="http://11wy11.github.io/tags/krpano/"/>
    
  </entry>
  
  <entry>
    <title>AI组件开发（一）--注记旋转矩阵</title>
    <link href="http://11wy11.github.io/2019/03/14/ai-first-note/"/>
    <id>http://11wy11.github.io/2019/03/14/ai-first-note/</id>
    <published>2019-03-14T02:56:02.000Z</published>
    <updated>2019-03-25T06:05:00.276Z</updated>
    
    <content type="html"><![CDATA[<p>Adobe Illustrator 组件开发 AIRealMatrixSet介绍及使用方法，参数及原理分析<br><a id="more"></a></p><h2 id="SDK官方帮助文档"><a href="#SDK官方帮助文档" class="headerlink" title="SDK官方帮助文档"></a>SDK官方帮助文档</h2><p>AIAPI void(<em> AIRealMathSuite::AIRealMatrixSet)(AIRealMatrix </em>m, AIReal a, AIReal b, AIReal c, AIReal d, AIReal tx, AIReal ty)<br>Sets the scale, rotation, and translation values of a transformation matrix.<br>Parameters:<br>m The matrix object.<br>a New a value.<br>b New b value.<br>c New c value.<br>d New d value.<br>tx New horizontal translation value.<br>ty New vertical translation value.  </p><h2 id="参数及原理分析"><a href="#参数及原理分析" class="headerlink" title="参数及原理分析"></a>参数及原理分析</h2><p>ad缩放bc旋转tx,ty位移，基础的2D矩阵<br> 公式</p><pre><code>x=ax+cy+txy=bx+dy+ty</code></pre><p>为了把二维图形的变化统一在一个坐标系里，引入了齐次坐标的概念，即把一个图形用一个三维矩阵表示，其中第三列总是(0,0,1)，用来作为坐标系的标准。所以所有的变化都由前两列完成<br>以上参数在矩阵中的表示为：</p><p> |a    b    0|</p><p> |c    d    0|</p><p> |tx   ty   1|</p><p>运算原理：原坐标设为（X,Y,1）;</p><pre><code>                     |a    b    0|[X，Y,  1]           |c    d    0|     =     [aX + cY + tx   bX + dY + ty  1] ;                     |tx    ty  1|</code></pre><p>通过矩阵运算后的坐标[aX + cY + tx   bX + dY + ty  1]，我们对比一下可知：</p><ol><li>第一种：设a=d=1, b=c=0.  平移</li></ol><p>[aX + cY + tx   bX + dY + ty  1] = [X  + tx  Y + ty  1];</p><p>可见，这个时候，坐标是按照向量（tx，ty）进行平移</p><ol start="2"><li>第二种：设b=c=tx=ty=0.  缩放</li></ol><p>[aX + cY + tx   bX + dY + ty  1] = [aX    dY   1];</p><p>可见，这个时候，坐标X按照a进行缩放，Y按照d进行缩放，a，d就是X，Y的比例系数</p><ol start="3"><li>第三种：设tx=ty=0，a=cosɵ，b=sinɵ，c=-sinɵ，d=cosɵ。旋转</li></ol><p>[aX + cY + tx   bX + dY + ty  1] = [Xcosɵ - Ysinɵ    Xsinɵ + Ycosɵ  1] ;</p><pre><code>|cosɵ    -sinɵ   0||sinɵ    cosɵ    0|    | 0       0      1 |</code></pre><p>可见，这个时候，ɵ就是旋转的角度，逆时针为正，顺时针为负</p><ol start="4"><li><p>第四种：设tx=ty=0，a=1，b=0，c=-sinɵ，d=cosɵ。倾斜<br>[aX + cY + tx   bX + dY + ty  1] = [ - Ysinɵ    Ycosɵ  1] ;</p><pre><code>|1        0       0||-sinɵ    cosɵ    0|    | 0       0       1 |</code></pre></li></ol><p>可见，这个时候，ɵ就是倾斜的角度，逆时针为正，顺时针为负</p><h1 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h1><p><a href="/2019/03/14/ai-first-note">AI组件开发（一）–注记旋转矩阵</a><br><a href="/2019/03/18/ai-second-note">AI组件开发（二）–AIRealMathSuite</a><br><a href="/2019/03/24/ai-third-note">AI组件开发（三）–AIArtboardSuite</a><br><a href="/2019/03/24/ai-forth-document-note">AI组件开发（四）–AIDocumentSuite</a><br><a href="/2019/03/24/ai-fifth-ailayer-note">AI组件开发（五）–AILayerSuite</a><br><a href="/2019/03/24/ai-six-aiart-note">AI组件开发（六）–AIArtSuite</a><br><a href="/2019/03/25/ai-seven-path-note">AI组件开发（七）–AIPathSuite&amp;&amp;AIPathfinderSuite</a><br><a href="/2019/03/25/ai-eight-style-note">AI组件开发（八）–AIArtStyleSuite</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Adobe Illustrator 组件开发 AIRealMatrixSet介绍及使用方法，参数及原理分析&lt;br&gt;
    
    </summary>
    
      <category term="AI组件开发" scheme="http://11wy11.github.io/categories/AI%E7%BB%84%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="AI" scheme="http://11wy11.github.io/tags/AI/"/>
    
  </entry>
  
  <entry>
    <title>csdn-markdown编辑器语法</title>
    <link href="http://11wy11.github.io/2019/03/14/csdn-markdown-grammar/"/>
    <id>http://11wy11.github.io/2019/03/14/csdn-markdown-grammar/</id>
    <published>2019-03-13T16:03:21.000Z</published>
    <updated>2019-03-24T01:28:54.796Z</updated>
    
    <content type="html"><![CDATA[<p>记录CSDN 的markdown语法，备查<br><a id="more"></a><br>@<a href="这里写自定义目录标题">TOC</a></p><h1 id="欢迎使用Markdown编辑器"><a href="#欢迎使用Markdown编辑器" class="headerlink" title="欢迎使用Markdown编辑器"></a>欢迎使用Markdown编辑器</h1><p>你好！ 这是你第一次使用 <strong>Markdown编辑器</strong> 所展示的欢迎页。如果你想学习如何使用Markdown编辑器, 可以仔细阅读这篇文章，了解一下Markdown的基本语法知识。</p><h2 id="功能快捷键"><a href="#功能快捷键" class="headerlink" title="功能快捷键"></a>功能快捷键</h2><p>撤销：<kbd>Ctrl/Command</kbd> + <kbd>Z</kbd><br>重做：<kbd>Ctrl/Command</kbd> + <kbd>Y</kbd><br>加粗：<kbd>Ctrl/Command</kbd> + <kbd>B</kbd><br>斜体：<kbd>Ctrl/Command</kbd> + <kbd>I</kbd><br>标题：<kbd>Ctrl/Command</kbd> + <kbd>Shift</kbd> + <kbd>H</kbd><br>无序列表：<kbd>Ctrl/Command</kbd> + <kbd>Shift</kbd> + <kbd>U</kbd><br>有序列表：<kbd>Ctrl/Command</kbd> + <kbd>Shift</kbd> + <kbd>O</kbd><br>检查列表：<kbd>Ctrl/Command</kbd> + <kbd>Shift</kbd> + <kbd>C</kbd><br>插入代码：<kbd>Ctrl/Command</kbd> + <kbd>Shift</kbd> + <kbd>K</kbd><br>插入链接：<kbd>Ctrl/Command</kbd> + <kbd>Shift</kbd> + <kbd>L</kbd><br>插入图片：<kbd>Ctrl/Command</kbd> + <kbd>Shift</kbd> + <kbd>G</kbd></p><h2 id="合理的创建标题，有助于目录的生成"><a href="#合理的创建标题，有助于目录的生成" class="headerlink" title="合理的创建标题，有助于目录的生成"></a>合理的创建标题，有助于目录的生成</h2><p>直接输入1次<kbd>#</kbd>，并按下<kbd>space</kbd>后，将生成1级标题。<br>输入2次<kbd>#</kbd>，并按下<kbd>space</kbd>后，将生成2级标题。<br>以此类推，我们支持6级标题。有助于使用<code>TOC</code>语法后生成一个完美的目录。</p><h2 id="如何改变文本的样式"><a href="#如何改变文本的样式" class="headerlink" title="如何改变文本的样式"></a>如何改变文本的样式</h2><p><em>强调文本</em> <em>强调文本</em></p><p><strong>加粗文本</strong> <strong>加粗文本</strong></p><p>==标记文本==</p><p><del>删除文本</del></p><blockquote><p>引用文本</p></blockquote><p>H~2~O is是液体。</p><p>2^10^ 运算结果是 1024.</p><h2 id="插入链接与图片"><a href="#插入链接与图片" class="headerlink" title="插入链接与图片"></a>插入链接与图片</h2><p>链接: <a href="https://mp.csdn.net" target="_blank" rel="noopener">link</a>.</p><p>图片: <figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://avatar.csdn.net/7/7/B/1_ralf_hx163com.jpg" alt="Alt" title>                </div>                <div class="image-caption">Alt</div>            </figure></p><p>带尺寸的图片: <figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://avatar.csdn.net/7/7/B/1_ralf_hx163com.jpg" alt="Alt" title="=30x30">                </div>                <div class="image-caption">=30x30</div>            </figure></p><p>居中的图片: <figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://avatar.csdn.net/7/7/B/1_ralf_hx163com.jpg#pic_center" alt="Alt" title>                </div>                <div class="image-caption">Alt</div>            </figure></p><p>居中并且带尺寸的图片: <figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://avatar.csdn.net/7/7/B/1_ralf_hx163com.jpg#pic_center" alt="Alt" title="=30x30">                </div>                <div class="image-caption">=30x30</div>            </figure></p><p>当然，我们为了让用户更加便捷，我们增加了图片拖拽功能。</p><h2 id="如何插入一段漂亮的代码片"><a href="#如何插入一段漂亮的代码片" class="headerlink" title="如何插入一段漂亮的代码片"></a>如何插入一段漂亮的代码片</h2><p>去<a href="https://mp.csdn.net/configure" target="_blank" rel="noopener">博客设置</a>页面，选择一款你喜欢的代码片高亮样式，下面展示同样高亮的 <code>代码片</code>.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// An highlighted block</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="string">'bar'</span>;</span><br></pre></td></tr></table></figure></p><h2 id="生成一个适合你的列表"><a href="#生成一个适合你的列表" class="headerlink" title="生成一个适合你的列表"></a>生成一个适合你的列表</h2><ul><li>项目<ul><li>项目<ul><li>项目</li></ul></li></ul></li></ul><ol><li>项目1</li><li>项目2</li><li>项目3</li></ol><ul><li style="list-style: none"><input type="checkbox"> 计划任务</li><li style="list-style: none"><input type="checkbox" checked> 完成任务</li></ul><h2 id="创建一个表格"><a href="#创建一个表格" class="headerlink" title="创建一个表格"></a>创建一个表格</h2><p>一个简单的表格是这么创建的：<br>项目     | Value<br>——– | —–<br>电脑  | $1600<br>手机  | $12<br>导管  | $1</p><h3 id="设定内容居中、居左、居右"><a href="#设定内容居中、居左、居右" class="headerlink" title="设定内容居中、居左、居右"></a>设定内容居中、居左、居右</h3><p>使用<code>:---------:</code>居中<br>使用<code>:----------</code>居左<br>使用<code>----------:</code>居右<br>| 第一列       | 第二列         | 第三列        |<br>|:———–:| ————-:|:————-|<br>| 第一列文本居中 | 第二列文本居右  | 第三列文本居左 | </p><h3 id="SmartyPants"><a href="#SmartyPants" class="headerlink" title="SmartyPants"></a>SmartyPants</h3><p>SmartyPants将ASCII标点字符转换为“智能”印刷标点HTML实体。例如：<br>|    TYPE   |ASCII                          |HTML<br>|—————-|——————————-|—————————–|<br>|Single backticks|<code>&#39;Isn&#39;t this fun?&#39;</code>            |’Isn’t this fun?’            |<br>|Quotes          |<code>&quot;Isn&#39;t this fun?&quot;</code>            |”Isn’t this fun?”            |<br>|Dashes          |<code>-- is en-dash, --- is em-dash</code>|– is en-dash, — is em-dash|</p><h2 id="创建一个自定义列表"><a href="#创建一个自定义列表" class="headerlink" title="创建一个自定义列表"></a>创建一个自定义列表</h2><p>Markdown<br>:  Text-to-HTML conversion tool</p><p>Authors<br>:  John<br>:  Luke</p><h2 id="如何创建一个注脚"><a href="#如何创建一个注脚" class="headerlink" title="如何创建一个注脚"></a>如何创建一个注脚</h2><p>一个具有注脚的文本。<a href="注脚的解释">^2</a></p><h2 id="注释也是必不可少的"><a href="#注释也是必不可少的" class="headerlink" title="注释也是必不可少的"></a>注释也是必不可少的</h2><p>Markdown将文本转换为 HTML。</p><p>*[HTML]:   超文本标记语言</p><h2 id="KaTeX数学公式"><a href="#KaTeX数学公式" class="headerlink" title="KaTeX数学公式"></a>KaTeX数学公式</h2><p>您可以使用渲染LaTeX数学表达式 <a href="https://khan.github.io/KaTeX/" target="_blank" rel="noopener">KaTeX</a>:</p><p>Gamma公式展示 $\Gamma(n) = (n-1)!\quad\forall<br>n\in\mathbb N$ 是通过欧拉积分</p><p>$$<br>\Gamma(z) = \int_0^\infty t^{z-1}e^{-t}dt\,.<br>$$</p><blockquote><p>你可以找到更多关于的信息 <strong>LaTeX</strong> 数学表达式<a href="http://meta.math.stackexchange.com/questions/5020/mathjax-basic-tutorial-and-quick-reference" target="_blank" rel="noopener">here</a>.</p></blockquote><h2 id="新的甘特图功能，丰富你的文章"><a href="#新的甘特图功能，丰富你的文章" class="headerlink" title="新的甘特图功能，丰富你的文章"></a>新的甘特图功能，丰富你的文章</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">gantt</span><br><span class="line">        dateFormat  YYYY-MM-DD</span><br><span class="line">        title Adding GANTT diagram functionality to mermaid</span><br><span class="line">        section 现有任务</span><br><span class="line">        已完成               :done,    des1, 2014-01-06,2014-01-08</span><br><span class="line">        进行中               :active,  des2, 2014-01-09, 3d</span><br><span class="line">        计划一               :         des3, after des2, 5d</span><br><span class="line">        计划二               :         des4, after des3, 5d</span><br></pre></td></tr></table></figure><ul><li>关于 <strong>甘特图</strong> 语法，参考 <a href="https://mermaidjs.github.io/" target="_blank" rel="noopener">这儿</a>,</li></ul><h2 id="UML-图表"><a href="#UML-图表" class="headerlink" title="UML 图表"></a>UML 图表</h2><p>可以使用UML图表进行渲染。 <a href="https://mermaidjs.github.io/" target="_blank" rel="noopener">Mermaid</a>. 例如下面产生的一个序列图：:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">张三 -&gt;&gt; 李四: 你好！李四, 最近怎么样?</span><br><span class="line">李四--&gt;&gt;王五: 你最近怎么样，王五？</span><br><span class="line">李四--x 张三: 我很好，谢谢!</span><br><span class="line">李四-x 王五: 我很好，谢谢!</span><br><span class="line">Note right of 王五: 李四想了很长时间, 文字太长了&lt;br/&gt;不适合放在一行.</span><br><span class="line"></span><br><span class="line">李四--&gt;&gt;张三: 打量着王五...</span><br><span class="line">张三-&gt;&gt;王五: 很好... 王五, 你怎么样?</span><br></pre></td></tr></table></figure><p>这将产生一个流程图。:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">A[长方形] -- 链接 --&gt; B((圆))</span><br><span class="line">A --&gt; C(圆角长方形)</span><br><span class="line">B --&gt; D&#123;菱形&#125;</span><br><span class="line">C --&gt; D</span><br></pre></td></tr></table></figure><ul><li>关于 <strong>Mermaid</strong> 语法，参考 <a href="https://mermaidjs.github.io/" target="_blank" rel="noopener">这儿</a>,</li></ul><h2 id="FLowchart流程图"><a href="#FLowchart流程图" class="headerlink" title="FLowchart流程图"></a>FLowchart流程图</h2><p>我们依旧会支持flowchart的流程图：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">flowchat</span><br><span class="line">st=&gt;start: 开始</span><br><span class="line">e=&gt;end: 结束</span><br><span class="line">op=&gt;operation: 我的操作</span><br><span class="line">cond=&gt;condition: 确认？</span><br><span class="line"></span><br><span class="line">st-&gt;op-&gt;cond</span><br><span class="line">cond(yes)-&gt;e</span><br><span class="line">cond(no)-&gt;op</span><br></pre></td></tr></table></figure></p><ul><li>关于 <strong>Flowchart流程图</strong> 语法，参考 <a href="http://adrai.github.io/flowchart.js/" target="_blank" rel="noopener">这儿</a>.</li></ul><h2 id="导出与导入"><a href="#导出与导入" class="headerlink" title="导出与导入"></a>导出与导入</h2><h3 id="导出"><a href="#导出" class="headerlink" title="导出"></a>导出</h3><p>如果你想尝试使用此编辑器, 你可以在此篇文章任意编辑。当你完成了一篇文章的写作, 在上方工具栏找到 <strong>文章导出</strong> ，生成一个.md文件或者.html文件进行本地保存。</p><h3 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h3><p>如果你想加载一篇你写过的.md文件或者.html文件，在上方工具栏可以选择导入功能进行对应扩展名的文件导入，<br>继续你的创作。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录CSDN 的markdown语法，备查&lt;br&gt;
    
    </summary>
    
      <category term="语言" scheme="http://11wy11.github.io/categories/%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="markdown" scheme="http://11wy11.github.io/tags/markdown/"/>
    
  </entry>
  
  <entry>
    <title>git常用命令</title>
    <link href="http://11wy11.github.io/2019/03/13/git-command/"/>
    <id>http://11wy11.github.io/2019/03/13/git-command/</id>
    <published>2019-03-13T12:41:15.000Z</published>
    <updated>2019-03-24T01:30:11.348Z</updated>
    
    <content type="html"><![CDATA[<p>记录一些常用的git命令，目前理解还不是很深，有点进一步查阅资料<br><a id="more"></a></p><ol><li><p>强制本地覆盖远程分支   </p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    git push origin *** --force  </span><br><span class="line">    ```  </span><br><span class="line">2. 放弃本地分支，远程分支强制覆盖本地</span><br><span class="line">  </span><br><span class="line">git fetch --all    //只是下载代码到本地，不进行合并操作</span><br><span class="line">git reset --hard origin/分支名如master    //把HEAD指向最新下载的版本</span><br><span class="line">3. 删除远程分支和本地分支</span><br></pre></td></tr></table></figure><p>git branch -a//查看分支<br>git push origin –delete <strong><em>// 删除远程分支<br>git branch -d </em></strong>//删除本地分支</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">4. git diff</span><br><span class="line">    检查文件更改内容</span><br><span class="line">5. 撤销未提交的修改git checkout</span><br></pre></td></tr></table></figure><p>  git checkout app/src/main/../MainActivity </p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">6、git reset</span><br></pre></td></tr></table></figure><p>git log #找到需要退回的commit版本号，可以只复制前几位<br>git reset &lt;刚查找到的版本号&gt;<br><code>`</code><br>7、git log</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录一些常用的git命令，目前理解还不是很深，有点进一步查阅资料&lt;br&gt;
    
    </summary>
    
      <category term="使用技巧" scheme="http://11wy11.github.io/categories/%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
    
    
      <category term="git" scheme="http://11wy11.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>使用hexo+github创建个人博客并备份源码</title>
    <link href="http://11wy11.github.io/2019/03/09/create-blog-process/"/>
    <id>http://11wy11.github.io/2019/03/09/create-blog-process/</id>
    <published>2019-03-09T13:52:06.000Z</published>
    <updated>2019-03-24T01:28:25.066Z</updated>
    
    <content type="html"><![CDATA[<p>最基础的hexo+github搭建个人博客的教程<br><a id="more"></a></p><h3 id="一、准备"><a href="#一、准备" class="headerlink" title="一、准备"></a>一、准备</h3><ol><li>安装<a href="https://nodejs.org/en/" target="_blank" rel="noopener">node.js</a></li><li>安装<a href="https://gitforwindows.org/" target="_blank" rel="noopener">git-windows</a></li><li><p>安装hexo-cli</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$npm install hexo-cli -g</span><br></pre></td></tr></table></figure></li><li><p>在GitHub上创建&lt;username&gt;.github.io的仓库</p><pre><code>e.g. 11wy11.github.io</code></pre></li><li><p>配置SSH key<br>打开本机的控制台，以windows系统为例，可以执行win+R 输入cmd打开，执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -keygen -t rsa -C &apos;D:/id.txt&apos;</span><br></pre></td></tr></table></figure><p>然后连续按3次回车，最终会在用户目录下生成一个文件，找到<strong>目录.ssh/id_rsa.pub</strong>文件，用记事本打开全选复制。<br>在你的github上点击头像&gt;设置进入设置页面，选择SSH and GPG keys, 点击<strong>New SSH key</strong>按钮，名称随意填写，将刚复制的内容粘贴到key,添加<br><img src="create-blog-process/res2.png" alt="添加ssh key"></p><h3 id="二、搭建流程"><a href="#二、搭建流程" class="headerlink" title="二、搭建流程"></a>二、搭建流程</h3></li><li>本地创建&lt;username&gt;.github.io</li><li><p>在本地&lt;username&gt;.github.io文件夹下初始化hexo项目并安装依赖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo init //初始化工程</span><br><span class="line">npm install //安装依赖</span><br><span class="line">hexo server //启动本地调试器在localhost:4000预览</span><br></pre></td></tr></table></figure></li><li><p>修改默认主题，可以在github上clone其他的主题，如<a href="https://github.com/litten/hexo-theme-yilia" target="_blank" rel="noopener">yilia</a>,<a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">icarus</a>,<a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank" rel="noopener">indigo</a>等</p><ul><li><p>以indigo为例，在本地&lt;username&gt;.github.io文件夹下执行以下命令安装主题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone git@github.com:yscoder/hexo-theme-indigo.git themes/indigo</span><br></pre></td></tr></table></figure></li><li><p>修改工程中的_config.yml配置文件，将themes: landscope改为themes: indigo<br><img src="create-blog-process/res1.png" alt="修改配置"></p></li><li><p>依赖安装分别安装Less,Feed,Json-content依赖，执行如下命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-renderer-less --save</span><br><span class="line">$ npm install hexo-generator-feed --save</span><br><span class="line">$ npm install hexo-generator-json-content --save</span><br></pre></td></tr></table></figure></li><li><p>执行<code>hexo s</code>命令启动服务器在localhost:4000查看效果</p></li></ul></li><li>新建文章，使用hexo new  “my-first blog”，会在source/_posts下创建my-first-blog.md的页面文件<br>进行编写</li><li><p>发布博客<br>首先修改工程中的_config.yml配置文件，在最后三行添加以下代码，将username换成自己的git用户名</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: git@github.com:&lt;username&gt;/&lt;username&gt;.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><p> 其次安装hexo-deployer-git 执行 <code>npm install hexo-deployer-git --save</code><br> 在工程文件夹内右键git bash进入命令行 输入hexo g，编译为静态文件，生成public文件夹，使用 hexo d 部署，此时可以访问https://&lt;username&gt;.github.io查看你的博客</p></li><li>备份源码<br> 在工程文件夹内右键git bash进入命令行 输入 touch .gitignore ，生成“.gitignore”文件。<br> 在”.gitignore” 文件里输入你要忽略的文件夹及其文件就可以了。（注意格式）<br> 我的 .gitignore：<pre><code>node_modules/.deploy_gitpublic/.DS_Store Thumbs.dbdb.json  *.log.deploy*/</code></pre>  执行以下命令<pre><code class="git">#git初始化git init#创建hexo分支，用来存放源码git checkout -b hexo#git 文件添加git add .#git 提交git commit -m &quot;init&quot;#添加远程仓库git remote add origin git@github.com:&lt;username&gt;/&lt;username&gt;.github.io.git#push到hexo分支git push origin hexo</code></pre> 执行hexo g -d生成网站并部署到GitHub上<br> 这样一来，在GitHub上的<a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>:&lt;username&gt;/&lt;username&gt;.github.io.git仓库就有两个分支，一个hexo分支用来存放网站的原始文件，一个master分支用来存放生成的静态网页。</li><li>其他设备更新博客步骤：<br> 1、先安装hexo<br> $ npm install -g hexo-cli<br> 2、存在github上的git clone下来<br> git clone -b hexo <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>:&lt;username&gt;/&lt;username&gt;.github.io.git<br> 3、项目文件夹下<br> $ npm install<br> $ npm install hexo-deployer-git<br> 4、重新配置github和coding的公钥<br> 5、编写博客push 到远程分支   <h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3></li><li>有时会出现下载的主题无法上传，首先删除themes/主题文件夹下的<code>.git</code>,使用<code>git rm --cached themes/indigo</code>命令清空后重新上传`</li><li>如果最开始.gitignore文件没有配置正确，可以使用<code>git rm -r --cached .</code>命令清楚缓存文件，重新add,commit,push上传</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最基础的hexo+github搭建个人博客的教程&lt;br&gt;
    
    </summary>
    
      <category term="工具" scheme="http://11wy11.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="hexo" scheme="http://11wy11.github.io/tags/hexo/"/>
    
      <category term="git" scheme="http://11wy11.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>Vue全局添加组件</title>
    <link href="http://11wy11.github.io/2019/03/09/Vue-global-component/"/>
    <id>http://11wy11.github.io/2019/03/09/Vue-global-component/</id>
    <published>2019-03-09T02:39:22.000Z</published>
    <updated>2019-03-24T01:36:27.024Z</updated>
    
    <content type="html"><![CDATA[<p>Vue全局添加组件，方便重复使用的功能一次性定义<br><a id="more"></a></p><h3 id="一-背景"><a href="#一-背景" class="headerlink" title="一. 背景"></a>一. 背景</h3><p>在项目中有时需要反复用到如区域选择器等组件，每次使用时都需要在对应的vue中添加import,并在component中注册，为了避免多次书写引用代码，可以自定义全局组件，只需要在main.js中一次性注册在vue项目中，可以自定义组件像vue-resource一样使用Vue.use（）方法来使用。</p><h3 id="二-具体实现方法"><a href="#二-具体实现方法" class="headerlink" title="二. 具体实现方法"></a>二. 具体实现方法</h3><p>1、首先建一个自定义组件的文件夹，比如叫loading，在该文件夹下新建一个index.js，一个自定义组件loading.vue,在这个loading.vue里面就是这个组件的具体的内容，</p><p>2、在index.js中，规定使用这个组件的名字，以及使用方法，如：</p><pre><code>import loadingComponent from &apos;./loading.vue&apos;const loading={    install:function(Vue){        Vue.component(&apos;Loading&apos;,loadingComponent)    }  //&apos;Loading&apos;这就是后面可以使用的组件的名字，install是默认的一个方法};export default loading;</code></pre><p>3、只要在main.js中规定了install方法，就可以像一些公共的插件一样使用Vue.use()来使用：</p><pre><code>import loading from &apos;./loading&apos;Vue.use(loading）</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Vue全局添加组件，方便重复使用的功能一次性定义&lt;br&gt;
    
    </summary>
    
      <category term="前端" scheme="http://11wy11.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Vue" scheme="http://11wy11.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Oracle配置SDE支持空间查询</title>
    <link href="http://11wy11.github.io/2019/03/09/oracle-st-geometry/"/>
    <id>http://11wy11.github.io/2019/03/09/oracle-st-geometry/</id>
    <published>2019-03-09T01:56:40.000Z</published>
    <updated>2019-03-24T01:33:52.010Z</updated>
    
    <content type="html"><![CDATA[<p> Oracle配置SDE支持空间查询,配置oracle外部链接库<br><a id="more"></a></p><h3 id="配置oracle外部链接库"><a href="#配置oracle外部链接库" class="headerlink" title="配置oracle外部链接库"></a>配置oracle外部链接库</h3><ol><li>将ArcGIS Desktop安装目录下DatabaseSupport文件夹下的st_shapelib.dll拷贝到装有oracle的服务器上，可以放置在任意地方，这里推荐放在Oracle安装目录下的bin文件夹下。<br> 例如：st_shapelib.dll所在文件夹路径：<br> C:\ProgramFiles(x86)\ArcGIS\Desktop10.2\DatabaseSupport\Oracle\Windows64\st_shapelib.dll<br> 拷贝放置位置：E:\app\503\product\11.2.0\dbhome_1\BIN\ st_shapelib.dll</li><li><p>修改oracle安装目录下的network/admin文件夹下的listener.ora,将步骤1中的st_shapelib.dll路径添加到<br>ENVS”EXTPROC_DLLS=ONLY:E:\app\503\product\11.2.0\dbhome_1\bin\oraclr11.dll;后面</p><pre><code>例如：linstener文件，添加红色字部分</code></pre> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># listener.ora Network Configuration File: D:\app\Administrator\product\11.2.0\dbhome_1\NETWORK\ADMIN\listener.ora</span><br><span class="line"># Generated by Oracle configuration tools.</span><br><span class="line">SID_LIST_LISTENER =</span><br><span class="line">  (SID_LIST =</span><br><span class="line">    (SID_DESC =</span><br><span class="line">      (SID_NAME = CLRExtProc)</span><br><span class="line">      (ORACLE_HOME = E:\app\503\product\11.2.0\dbhome_1)</span><br><span class="line">      (PROGRAM = extproc)</span><br><span class="line">      (ENVS= &quot;EXTPROC_DLLS=ONLY:E:\app\503\product\11.2.0\dbhome_1\bin\oraclr11.dll;E:\app\503\product\11.2.0\dbhome_1\bin\st_shapelib.dll&quot;) # interesting</span><br><span class="line">    )</span><br><span class="line">  )   </span><br><span class="line">LISTENER =</span><br><span class="line">  (DESCRIPTION_LIST =</span><br><span class="line">    (DESCRIPTION =</span><br><span class="line">      (ADDRESS = (PROTOCOL = TCP)(HOST = 503-PC)(PORT = 1521))</span><br><span class="line">  (ADDRESS = (PROTOCOL = IPC)(KEY = EXTPROC1521))</span><br><span class="line">    )</span><br><span class="line">    (DESCRIPTION =</span><br><span class="line">      (ADDRESS = (PROTOCOL = TCP)(HOST = 192.168.1.164)(PORT = 1521))</span><br><span class="line">    )</span><br><span class="line">  )</span><br><span class="line"> </span><br><span class="line">ADR_BASE_LISTENER = E:\app\503</span><br></pre></td></tr></table></figure></li><li><p>修改oracle安装home目录下的hs/admin文件夹下的extproc.ora，具体路径示例：E:\app\503\product\11.2.0\dbhome_1\hs\admin\extproc.ora，将最后一行的SET EXTPROC_DLLS=  设为ANY<br><img src="oracle-st-geometry/res1.png" alt="extproc.ora设置"></p></li><li>通过任何一个数据库管理软件，这里以sql-plus为例，使用sde用户登录首先执行：<code>select * from user_libraries</code><br> 查看是否有ST_SHAPELIB并检查路径是否与步骤1中的一致，通常默认为c盘第一次安装Arcgis时的相关路径。结果如下：<br>  <img src="oracle-st-geometry/res2.png" alt="extproc.ora设置"><br>  如果路径与步骤1中st_shapelib的路径不一致，执行以下两条命令：<ul><li>Create or replace library st_SHAPELIB  as &lt;步骤1中的st_shapelib路径&gt;<br><img src="oracle-st-geometry/res3.png" alt="extproc.ora设置"></li><li>Alter package sde.st_geometry_shapelib_pkg compile reuse settings<br><img src="oracle-st-geometry/res4.png" alt="extproc.ora设置"></li></ul></li><li>重启监听器OracleOraDB11g_home1TNSListener，有时也需要重启服务OracleServiceORCL。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt; Oracle配置SDE支持空间查询,配置oracle外部链接库&lt;br&gt;
    
    </summary>
    
      <category term="ArcGIS" scheme="http://11wy11.github.io/categories/ArcGIS/"/>
    
    
      <category term="ArcGIS" scheme="http://11wy11.github.io/tags/ArcGIS/"/>
    
      <category term="Oracle" scheme="http://11wy11.github.io/tags/Oracle/"/>
    
  </entry>
  
</feed>
