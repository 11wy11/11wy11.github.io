<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>WeiYuan&#39;s Blog</title>
  
  <subtitle>学习随记</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://11wy11.github.io/"/>
  <updated>2019-03-16T14:09:19.017Z</updated>
  <id>http://11wy11.github.io/</id>
  
  <author>
    <name>11wy11</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>C++之QT的信号和槽的详解</title>
    <link href="http://11wy11.github.io/2019/03/16/qt-note/"/>
    <id>http://11wy11.github.io/2019/03/16/qt-note/</id>
    <published>2019-03-16T12:24:56.000Z</published>
    <updated>2019-03-16T14:09:19.017Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1 简介"></a>1 简介</h1><p> 信号和槽是Qt特有的信息传输机制，是Qt设计程序的重要基础，它可以让互不干扰的对象建立一种联系。<br><a id="more"></a><br>  在GUI编程中，当我们改变一个部件时，经常想要其他部件被通知。更一般化，我们希望任何一类的对象可以和其它对象进行通讯。例如，如果我们点击一个关闭按钮，我们可能想要窗口的close()函数被调用。</p><p>  其他工具包通过回调实现了这种通信。回调是一个函数指针，所以如果你希望一个处理函数通知你一些事件，你可以把另一个函数（回调）的指针传递给处理函数。处理函数在适当的时候调用回调。尽管一些成功的框架使用了这个方法，但是回调可能是不直观的，并可能在确保回调参数类型正确性上存在问题。<br>信号槽是 Qt 框架引以为豪的机制之一。所谓信号槽，实际就是观察者模式。当某个事件发生之后，比如，按钮检测到自己被点击了一下，它就会发出一个信号（signal）。这种发出是没有目的的，类似广播。如果有对象对这个信号感兴趣，它就会使用连接（connect）函数，意思是，将想要处理的信号和自己的一个函数（称为槽（slot））绑定来处理这个信号。也就是说，当信号发出时，被连接的槽函数会自动被回调。这就类似观察者模式：当发生了感兴趣的事件，某一个操作就会被自动触发。（这里提一句，Qt 的信号槽使用了额外的处理来实现，并不是 GoF 经典的观察者模式的实现方式。）</p><p>  信号和槽是Qt特有的信息传输机制，是Qt设计程序的重要基础，它可以让互不干扰的对象建立一种联系。</p><p>  槽的本质是类的成员函数，其参数可以是任意类型的。和普通C++成员函数几乎没有区别，它可以是虚函数；也可以被重载；可以是公有的、保护的、私有的、也可以被其他C++成员函数调用。唯一区别的是：槽可以与信号连接在一起，每当和槽连接的信号被发射的时候，就会调用这个槽。<br>  Qt的小部件有很多预定义的信号，但是我们总是可以通过继承来加入我们自己的信号。槽就是一个对应于特定信号的被调用的函数。Qt的部件有很多预定义的槽，但同样可以通过子类化加入自己的槽来处理感兴趣的信号。</p><h2 id="1-1-对象树-子对象动态分配空间不需要释放"><a href="#1-1-对象树-子对象动态分配空间不需要释放" class="headerlink" title="1.1 对象树(子对象动态分配空间不需要释放)"></a>1.1 对象树(子对象动态分配空间不需要释放)</h2><p>  <img src="/2019/03/16/qt-note/pic1.png" alt="对象树"><br>   比如说当应用程序创建了一个具有父窗口部件的对象时，该对象将被加入父窗口部件的孩子列表。当应用程序销毁父窗口部件时，其下的孩子列表中的对象将被一一删除。这让我们在编程时，能够将主要精力放在系统的业务上，提高编程效率，同时也保证了系统的稳健性。</p><h1 id="2-信号和槽"><a href="#2-信号和槽" class="headerlink" title="2 信号和槽"></a>2 信号和槽</h1><p>  在Qt中我们有一种可以替代回调的技术：我们使用信号和槽。当一个特定事件发生的时候，一个信号被发射。Qt的小部件有很多预定义的信号，但是我们总是可以通过继承来加入我们自己的信号。槽就是一个对应于特定信号的被调用的函数。Qt的部件有很多预定义的槽，但同样可以通过子类化加入自己的槽来处理感兴趣的信号。<br>  信号和槽机制是类型安全的：一个信号的签名(参数类型)必须与它的接收槽的签名相匹配。（实际上，一个槽的签名可能比它接收到的信号短，因为它可以忽略额外的参数。）因为签名是兼容的，当使用基于函数指针的语法时，编译器就可以帮助我们检测类型不匹配。基于字符串的信号和槽语法将在运行时检测类型不匹配。信号和插槽是松散耦合的：一个发射信号的类不用知道也不用关心哪个槽要接收这个信号。Qt的信号和槽的机制可以保证如果你把一个信号和一个槽连接起来，槽会在正确的时间使用信号的参数被调用。信号和槽可以使用任何数量、任何类型的参数。它们是完全类型安全的：不会再有回调核心转储(core dump)。</p><p>  从QObject类或者它的子类（如QWidget类）继承的所有类可以包含信号和槽。当改变它们的状态的时候，信号被发送。从某种意义上说，即它们对其他对象感兴趣。这就是所有的对象通讯时所做的一切。它不知道也不关心是否有其他对象接收到了它发射的信号。这就是真正的信息封装，并且确保对象可以用作一个软件组件使用。</p><p>  槽可以用来接收信号，但它们也是普通的成员函数。正如一个对象不知道有其他对象收到它的信号一样，一个槽也不知道它是否被任意信号连接。因此，这种方式保证了Qt创建组件的完全独立。</p><p>  你可以连接多个信号到一个槽，同样一个信号可以被你需要的多个槽连接。甚至可以一个信号连接到另一个信号。（该情况下，只要第一个信 号被发射时，第二个信号立即被发射。）</p><p>  总体来看，信号和槽构成了一个强有力的组件编程机制。</p><h2 id="2-1-信号"><a href="#2-1-信号" class="headerlink" title="2.1 信号"></a>2.1 信号</h2><p>  当一个对象内部状态发生改变时发射信号，信号就被发射，在某些方面对象的客户端和所有者可能感兴趣。信号是一个public访问函数并可以在任何地方发射，但是我们建议仅在定义了信号的类及他们的子类中发射。</p><p>  当一个信号被发射，它所连接的槽会被立即执行，类似于一个普通函数的调用。在该情况下，信号/槽机制在任何GUI事件循环中是完全独立的。一旦所有的槽返回了，emit语句随后的代码将会执行。这与queued connections方式有些许不同，queued connections方式下emit关键字随后的代码会立即继续执行，槽在随后执行（相当于异步，参考信号与槽的连接类型）。</p><p>  如果几个槽被连接到一个信号，当信号被发射时，这些槽就会按它们连接的顺序挨个执行。</p><p>  信号会由moc自动生成并一定不要在.cpp文件中实现。它们也不能有任何返回类型（也就是 只能使用void）。</p><h2 id="2-2-槽"><a href="#2-2-槽" class="headerlink" title="2.2 槽"></a>2.2 槽</h2><p>  当与槽连接的信号被发射时，该槽被调用。槽是普通的C++函数可以正常调用；它们唯一的特点就是可以被信号连接。</p><p>  因为槽是普通成员函数，所以被直接调用时遵循一般的C++规则。然而，作为槽，它们能被任何组件调用，通过信号槽连接，无需考虑访问级别。这意味着从一个任意类的实例发出的一个信号可以在一个不相关的类的实例中调用一个私有槽。</p><p>  同样还可以定义虚拟槽，我们在实践中发现它非常有用。</p><p>  与回调相比，信号和插槽的速度稍慢，因为它们增加了灵活性，尽管在实际应用程序中的差异是微不足道的。</p><p>  信号和槽的机制是非常有效的，但是它不像“真正的”回调那样快。信号和槽稍微有些慢，这是因为它们所提供的灵活性造成，尽管在实际应用中这些性能可以被忽略。通常，发射一个和槽相连的信号，大约比直接调接收器非虚函数的调用慢十倍。这是定位连接对象所需的开销，为了安全地遍历所有连接（e.g检查随后的接收器在发射过程中没有被销毁），并以通用的方式安排任意参数。虽然10个非虚函数调用听起来可能很多，但开销比任意new或delete 操作少得多。当执行一个字符串时，vector或list操作在后面的场景中需要new或delete, 但信号和槽在完成函数调用的开销中只占很小的一部分。在一个槽中进行系统调用或者间接地调用超过10个函数，情况也是相同的;。信号/插槽机制的简单和灵活性对于时间的开销是值得，用户甚至不会注意到这点。</p><p>  注意，与基于qt的应用程序一起编译时，定义变量的其他库调用信号和槽可能会造成编译器警告和错误。要解决这个问题，#undef这些预处理器的冲突符号即可。</p><h2 id="2-3-一个Qt-Creator的例子"><a href="#2-3-一个Qt-Creator的例子" class="headerlink" title="2.3 一个Qt Creator的例子"></a>2.3 一个Qt Creator的例子</h2>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;QApplication&gt;</span><br><span class="line">#include &lt;QPushButton&gt;</span><br><span class="line">   int main(int argc, char *argv[])</span><br><span class="line">   &#123;</span><br><span class="line">       QApplication app(argc, argv);</span><br><span class="line">       QPushButton button(&quot;Quit&quot;);</span><br><span class="line">       QObject::connect(&amp;button, &amp;QPushButton::clicked,</span><br><span class="line">       &amp;app, &amp;QApplication::quit);</span><br><span class="line">       button.show();</span><br><span class="line">       return app.exec();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>  在 Qt Creator 中创建工程的方法创建好工程，然后将main()函数修改为上面的代码。点击运行，我们会看到一个按钮，上面有“Quit”字样。点击按钮，程序退出。<br>  connect()函数最常用的一般形式：<br>  <strong>connect(sender, signal, receiver, slot);</strong><br>  参数：<br>   sender：发出信号的对象<br>   signal：发送对象发出的信号<br>   receiver：接收信号的对象<br>   slot：接收对象在接收到信号之后所需要调用的函数<br>  信号槽要求信号和槽的参数一致，所谓一致，是参数类型一致。如果不一致，允许的情况是，槽函数的参数可以比信号的少，即便如此，槽函数存在的那些参数的顺序也必须和信号的前面几个一致起来。这是因为，你可以在槽函数中选择忽略信号传来的数据（也就是槽函数的参数比信号的少），但是不能说信号根本没有这个数据，你就要在槽函数中使用（就是槽函数的参数比信号的多，这是不允许的）。</p><h2 id="2-4-一个普通C-程序的例子"><a href="#2-4-一个普通C-程序的例子" class="headerlink" title="2.4 一个普通C++程序的例子"></a>2.4 一个普通C++程序的例子</h2><p>  一个小的C++类声明如下：<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Counter</span><br><span class="line"> &#123;</span><br><span class="line">     public:</span><br><span class="line">         Counter() &#123; m_value = 0; &#125;</span><br><span class="line">   </span><br><span class="line">         int value() const &#123; return m_value; &#125;</span><br><span class="line">         void setValue(int value);</span><br><span class="line">     private:</span><br><span class="line">         int m_value;</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure></p><p>  一个小的基于QObject类如下：<br>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;QObject&gt;</span><br><span class="line"></span><br><span class="line">  class Counter : public QObject</span><br><span class="line">  &#123;</span><br><span class="line">      Q_OBJECT   </span><br><span class="line">      public:</span><br><span class="line">          Counter() &#123; m_value = 0; &#125;       </span><br><span class="line">          int value() const &#123; return m_value; &#125;       </span><br><span class="line">      public slots:</span><br><span class="line">          void setValue(int value);       </span><br><span class="line">      signals:</span><br><span class="line">          void valueChanged(int newValue);      </span><br><span class="line">      private:</span><br><span class="line">          int m_value;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure></p><p>   这个基于QObject的类有同样的内部状态，并提供公有方法来访问状态。除此之外，这个类可以通过发射一个valueChanged()信号来告诉外部世界关于它的状态改变，并且它有一个槽，其它对象可以发送信号给这个槽。<br>   所有包含信号和/或者槽的类必须在它们的声明中提到Q_OBJECT。它们也必须从QObject继承(直接或间接)。<br>   槽由应用程序的编写者来实现。这里是Counter::setValue()可能的一个槽实现：<br>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void Counter::setValue(int value)</span><br><span class="line">  &#123;</span><br><span class="line">      if (value != m_value) &#123;</span><br><span class="line">          m_value = value;</span><br><span class="line">          emit valueChanged(value);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>   emit这一行从对象中发射valueChanged()信号，以一个新值作为参数。<br>   在下面的小片断中，我们创建了两个Counter对象，并使用QObject::connect()将第一个对象的valueChanget()信号连接到第二个对象的setValue槽。<br>   下面是把两个对象连接在一起的一种方法：<br>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Counter a, b;</span><br><span class="line">    QObject::connect(&amp;a, &amp;Counter::valueChanged,</span><br><span class="line">                     &amp;b, &amp;Counter::setValue);</span><br><span class="line">   </span><br><span class="line">    a.setValue(12);     // a.value() == 12, b.value() == 12</span><br><span class="line">    b.setValue(48);     // a.value() == 12, b.value() == 48</span><br></pre></td></tr></table></figure></p><p>  调用a.setValue(12)会使a发射一个valueChanged(12) 信号，b将会在它的setValue()槽中接收这个信号，也就是b.setValue(12) 被调用。接下来b会发射同样的valueChanged()信号，但是因为没有槽被连接到b的valueChanged()信号，所以该信号被忽略。</p><p>  注意只有当value!= m_value的时候setValue()函数才会设置这个值并发射信号。这样就避免了存在环connections的情况下无限循环。（比如b.valueChanged() 和a.setValue()连接在一起）。</p><p>  默认情况下，对于你做出的每一个连接，一个信号被发射;重复连接下两个信号被发射。你可以调用disconnect()中断所有连接。如果传递了Qt::UniqueConnection类型，连接只有在不重复的情况下才建立。如果已经存在重复连接（同一个对象上确定的信号到确定的槽），则连接将会失败，connect返回fase。</p><p>  这个例子说明了对象可以协同工作而不需要知道彼此的任何信息。为达到这种效果，对像仅需要相互连接，并用一个简单的QObject::connect()函数调用实现，或者使用uic的自动连接特性。</p><h2 id="2-5-带有默认参数的信号和槽"><a href="#2-5-带有默认参数的信号和槽" class="headerlink" title="2.5 带有默认参数的信号和槽"></a>2.5 带有默认参数的信号和槽</h2><p>   信号和槽的签名可能包含参数，参数可以有默认值。考虑QObject::destroyed()函数。<br>   <code>void destroyed(QObject* = 0);</code><br>   当一个QObject对象被删除，它发射QObject::destroyed()信号。我们想捕获此信号，无论在我们可能有一个悬空的引用指向删除的QObject对象的情况下，因此我们可以把它清理干净。一个合适的槽签名可能是这样的:<br>    <code>void objectDestroyed(QObject* obj = 0);</code><br>   为连接一个信号到此槽，我们使用QObject::connect。这里有几个方式连接。第一种方式是使用函数指针：<br>    <code>connect(sender,&amp;QObject::destroyed,this,&amp;MyObject::objectDestroyed);</code><br>   连接信号到槽的另一种方法是使用QObject::connect()，SIGNAL和SLOT宏。关于是否在SIGNAL()和SLOT()宏中包含参数的规则，如果参数有默认值，传递给SIGNAL()宏的签名必须不能少于传递给SLOT()宏签名的参数。<br>   下述这些都会生效：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">connect(sender,SIGNAL(destroyed(QObject*)),this,</span><br><span class="line">SLOT(objectDestroyed(Qbject*)));</span><br><span class="line"></span><br><span class="line">connect(sender,SIGNAL(destroyed(QObject*)),this,</span><br><span class="line">SLOT(objectDestroyed()));</span><br><span class="line"></span><br><span class="line">connect(sender, SIGNAL(destroyed()),this,</span><br><span class="line">SLOT(objectDestroyed()));</span><br></pre></td></tr></table></figure></p><h2 id="2-6-信号和槽的进一步使用"><a href="#2-6-信号和槽的进一步使用" class="headerlink" title="2.6 信号和槽的进一步使用"></a>2.6 信号和槽的进一步使用</h2><p>   对于可能需要信号发送者信息的情况, Qt提供了QObject::sender()函数，它返回一个指向发送信号的对象的指针。</p><p>   QSignalMapper类为一种情形提供，该情况下多个信号连接到同一个槽，而槽需要以不同的方式处理每个信号。</p><p>   假设有三个按钮来决定将打开哪个文件: “Tax File”, “Accounts File”, “Report File”.</p><p>   为了打开正确的文件,使用QSignalMapper:setMapping()来映射所有QPushButton:clicked()到QSignalMapper对象。然后将文件的QPushButton::clicked()信号连接到QSignalMapper::map()槽。<br>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">signalMapper = new QSignalMapper(this);</span><br><span class="line">       </span><br><span class="line">       signalMapper-&gt;setMapping(taxFileButton,   QString(&quot;taxfile.txt&quot;));</span><br><span class="line">       </span><br><span class="line">       signalMapper-&gt;setMapping(accountFileButton,</span><br><span class="line">                               QString(&quot;accountsfile.txt&quot;));</span><br><span class="line">       </span><br><span class="line">       signalMapper-&gt;setMapping(reportFileButton,</span><br><span class="line">                               QString(&quot;reportfile.txt&quot;));</span><br><span class="line">       </span><br><span class="line">       connect(taxFileButton, &amp;QPushButton::clicked,</span><br><span class="line">                 signalMapper, &amp;QSignalMapper::map);</span><br><span class="line">       </span><br><span class="line">       connect(accountFileButton, &amp;QPushButton::clicked,</span><br><span class="line">                 signalMapper, &amp;QSignalMapper::map);</span><br><span class="line">       </span><br><span class="line">       connect(reportFileButton, &amp;QPushButton::clicked,</span><br><span class="line">                 signalMapper, &amp;QSignalMapper::map);</span><br></pre></td></tr></table></figure></p><p>   然后，将mapped()信号连接到readFile()，根据按下的按钮，readFile()打开不同的文件。<code>connect(signalMapper, SIGNAL(mapped(QString)),this, SLOT(readFile(QString)));</code>  </p><h2 id="2-7-自定义信号槽"><a href="#2-7-自定义信号槽" class="headerlink" title="2.7 自定义信号槽"></a>2.7 自定义信号槽</h2><ul><li>发送者和接收者都需要是QObject的子类（当然，槽函数是全局函数、Lambda 表达式等无需接收者的时候除外）； </li><li>使用 signals 标记信号函数，信号是一个函数声明，返回 void，不需要实现函数代码；</li><li>槽函数是普通的成员函数，作为成员函数，会受到 public、private、protected 的影响；</li><li>使用 emit 在恰当的位置发送信号；</li><li>使用QObject::connect()函数连接信号和槽。</li><li>任何成员函数、static 函数、全局函数和 Lambda 表达式都可以作为槽函数 <h2 id="2-8-信号槽的更多用法"><a href="#2-8-信号槽的更多用法" class="headerlink" title="2.8 信号槽的更多用法"></a>2.8 信号槽的更多用法</h2></li><li>一个信号可以和多个槽相连<br>　　如果是这种情况，这些槽会一个接一个的被调用，但是它们的调用顺序是不确定的。</li><li>多个信号可以连接到一个槽<br>　　只要任意一个信号发出，这个槽就会被调用。</li><li>一个信号可以连接到另外的一个信号<br>　　当第一个信号发出时，第二个信号被发出。除此之外，这种信号-信号的形式和信号-槽的形式没有什么区别。</li><li>槽可以被取消链接<br>　　这种情况并不经常出现，因为当一个对象delete之后，Qt自动取消所有连接到这个对象上面的槽。</li><li>使用Lambda 表达式<br>　　在使用 Qt 5 的时候，能够支持 Qt 5 的编译器都是支持 Lambda 表达式的。<br>　　我们的代码可以写成下面这样：  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">QObject::connect(&amp;newspaper, static_cast&lt;void (Newspaper:: *)</span><br><span class="line">(const QString &amp;)&gt;(&amp;Newspaper::newPaper),</span><br><span class="line">[=](const QString &amp;name) </span><br><span class="line">&#123; /* Your code here. */ &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li></ul><p>在连接信号和槽的时候，槽函数可以使用Lambda表达式的方式进行处理。</p><h1 id="3-案例"><a href="#3-案例" class="headerlink" title="3 案例"></a>3 案例</h1><p>mainwidget.h<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#ifndef MAINWIDGET_H</span><br><span class="line">#define MAINWIDGET_H</span><br><span class="line"></span><br><span class="line">#include &lt;QWidget&gt;</span><br><span class="line">#include &lt;QPushButton&gt;</span><br><span class="line">#include &quot;subwidget.h&quot; //子窗口头文件</span><br><span class="line"></span><br><span class="line">class MainWidget : public QWidget</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    MainWidget(QWidget *parent = 0);</span><br><span class="line">    ~MainWidget();</span><br><span class="line"></span><br><span class="line">public slots:</span><br><span class="line">    void mySlot();</span><br><span class="line">    void changeWin();</span><br><span class="line">    void dealSub();</span><br><span class="line">    void dealSlot(int, QString);</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    QPushButton b1;</span><br><span class="line">    QPushButton *b2;</span><br><span class="line">    QPushButton b3;</span><br><span class="line"></span><br><span class="line">    SubWidget subWin;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">#endif // MAINWIDGET_H</span><br></pre></td></tr></table></figure></p><p>subwidget.h<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#ifndef SUBWIDGET_H</span><br><span class="line">#define SUBWIDGET_H</span><br><span class="line"></span><br><span class="line">#include &lt;QWidget&gt;</span><br><span class="line">#include &lt;QPushButton&gt;</span><br><span class="line"></span><br><span class="line">class SubWidget : public QWidget</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line">public:</span><br><span class="line">    explicit SubWidget(QWidget *parent = 0);</span><br><span class="line"></span><br><span class="line">    void sendSlot();</span><br><span class="line"></span><br><span class="line">signals:</span><br><span class="line">     /* 信号必须有signals关键字来声明</span><br><span class="line">      * 信号没有返回值，但可以有参数</span><br><span class="line">      * 信号就是函数的声明，只需声明，无需定义</span><br><span class="line">      * 使用：emit mySignal();</span><br><span class="line">      * 信号可以重载</span><br><span class="line">     */</span><br><span class="line"></span><br><span class="line">    void mySignal();</span><br><span class="line">    void mySignal(int, QString);</span><br><span class="line"></span><br><span class="line">public slots:</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    QPushButton b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">#endif // SUBWIDGET_H</span><br></pre></td></tr></table></figure></p><p>main.cpp<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;mainwidget.h&quot;</span><br><span class="line">#include &lt;QApplication&gt;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    QApplication a(argc, argv);</span><br><span class="line">    MainWidget w;//执行MainWidget的构造函数</span><br><span class="line">    w.show();</span><br><span class="line"></span><br><span class="line">    return a.exec();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>mainvidget.cpp<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;mainwidget.h&quot;</span><br><span class="line">#include &lt;QPushButton&gt;</span><br><span class="line">#include &lt;QDebug&gt; //打印</span><br><span class="line"></span><br><span class="line">MainWidget::MainWidget(QWidget *parent)</span><br><span class="line">    : QWidget(parent)</span><br><span class="line">&#123;</span><br><span class="line">    b1.setParent(this);</span><br><span class="line">    b1.setText(&quot;close&quot;);</span><br><span class="line">    b1.move(100, 100);</span><br><span class="line"></span><br><span class="line">    b2 = new QPushButton(this);</span><br><span class="line">    b2-&gt;setText(&quot;abc&quot;);</span><br><span class="line"></span><br><span class="line">    connect(&amp;b1, &amp;QPushButton::pressed, this, &amp;MainWidget::close);</span><br><span class="line">    /* &amp;b1: 信号发出者，指针类型</span><br><span class="line">     * &amp;QPushButton::pressed：处理的信号，  &amp;发送者的类名::信号名字</span><br><span class="line">     * this: 信号接收者</span><br><span class="line">     * &amp;MainWidget::close： 槽函数，信号处理函数  &amp;接收的类名::槽函数名字</span><br><span class="line">     * 发送-处理-接收-处理</span><br><span class="line">    */</span><br><span class="line"></span><br><span class="line">    /* 自定义槽，普通函数的用法</span><br><span class="line">     * Qt5：任意的成员函数，普通全局函数，静态函数</span><br><span class="line">     * 槽函数需要和信号一致（参数，返回值）</span><br><span class="line">     * 由于信号都是没有返回值，所以，槽函数一定没有返回值</span><br><span class="line">     */</span><br><span class="line">    connect(b2, &amp;QPushButton::released, this, &amp;MainWidget::mySlot);</span><br><span class="line"></span><br><span class="line">    connect(b2, &amp;QPushButton::released, &amp;b1, &amp;QPushButton::hide);</span><br><span class="line"></span><br><span class="line">    /* 信号：短信</span><br><span class="line">     * 槽函数：接收短信的手机</span><br><span class="line">     */</span><br><span class="line"></span><br><span class="line">    setWindowTitle(&quot;老大&quot;);</span><br><span class="line">    //this-&gt;setWindowTitle(&quot;老大&quot;);//等价同上</span><br><span class="line"></span><br><span class="line">    b3.setParent(this);</span><br><span class="line">    b3.setText(&quot;切换到子窗口&quot;);</span><br><span class="line">    b3.move(50, 50);</span><br><span class="line"></span><br><span class="line">    //显示子窗口</span><br><span class="line">    //subWin.show();</span><br><span class="line"></span><br><span class="line">    connect(&amp;b3, &amp;QPushButton::released, this, &amp;MainWidget::changeWin);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //处理子窗口的信号</span><br><span class="line">//    void (SubWidget::*funSignal)() = &amp;SubWidget::mySignal;</span><br><span class="line">//    connect(&amp;subWin, funSignal, this, &amp;MainWidget::dealSub);</span><br><span class="line"></span><br><span class="line">//     void (SubWidget::*testSignal)(int, QString) = &amp;SubWidget::mySignal;</span><br><span class="line">//    connect(&amp;subWin, testSignal, this, &amp;MainWidget::dealSlot);</span><br><span class="line"></span><br><span class="line">    //Qt4信号连接</span><br><span class="line">    //Qt4槽函数必须有slots关键字来修饰</span><br><span class="line">    connect(&amp;subWin, SIGNAL(mySignal()), this, SLOT(dealSub()) );</span><br><span class="line"></span><br><span class="line">    connect(&amp;subWin, SIGNAL(mySignal(int,QString)),</span><br><span class="line">            this, SLOT(dealSlot(int,QString)) );</span><br><span class="line">    //缺点： SIGNAL SLOT 将函数名字 -&gt; 字符串  不进行错误检查</span><br><span class="line"></span><br><span class="line">    //Lambda表达式, 匿名函数对象</span><br><span class="line">    //C++11增加的新特性， 项目文件： CONFIG += C++11</span><br><span class="line">    //Qt配合信号一起使用，非常方便</span><br><span class="line"></span><br><span class="line">    QPushButton *b4 = new QPushButton(this);</span><br><span class="line">    b4-&gt;setText(&quot;Lambda表达式&quot;);</span><br><span class="line">    b4-&gt;move(150, 150);</span><br><span class="line">    int a = 10, b = 100;</span><br><span class="line">    connect(b4, &amp;QPushButton::clicked,</span><br><span class="line">            // = :把外部所有局部变量、类中所有成员以值传递方式</span><br><span class="line">            // this: 类中所有成员以值传递方式</span><br><span class="line">            // &amp; : 把外部所有局部变量， 引用符号</span><br><span class="line">            [=](bool isCheck)</span><br><span class="line">            &#123;</span><br><span class="line">                qDebug() &lt;&lt; isCheck;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    resize(400, 300);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void MainWidget::dealSlot(int a, QString str)</span><br><span class="line">&#123;</span><br><span class="line">    // str.toUtf8() -&gt; 字节数组QByteArray</span><br><span class="line">    // ……data()  -&gt; QByteArray -&gt; char *</span><br><span class="line">    qDebug() &lt;&lt; a &lt;&lt; str.toUtf8().data();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void MainWidget::mySlot()</span><br><span class="line">&#123;</span><br><span class="line">    b2-&gt;setText(&quot;123&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void MainWidget::changeWin()</span><br><span class="line">&#123;</span><br><span class="line">    //子窗口显示</span><br><span class="line">    subWin.show();</span><br><span class="line">    //本窗口隐藏</span><br><span class="line">    this-&gt;hide();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void MainWidget::dealSub()</span><br><span class="line">&#123;</span><br><span class="line">    //子窗口隐藏</span><br><span class="line">    subWin.hide();</span><br><span class="line">    //本窗口显示</span><br><span class="line">    show();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MainWidget::~MainWidget()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>subwidget.cpp<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;subwidget.h&quot;</span><br><span class="line"></span><br><span class="line">SubWidget::SubWidget(QWidget *parent) : QWidget(parent)</span><br><span class="line">&#123;</span><br><span class="line">    this-&gt;setWindowTitle(&quot;小弟&quot;);</span><br><span class="line">    b.setParent(this);</span><br><span class="line">    b.setText(&quot;切换到主窗口&quot;);</span><br><span class="line"></span><br><span class="line">    connect(&amp;b, &amp;QPushButton::clicked, this, &amp;SubWidget::sendSlot);</span><br><span class="line"></span><br><span class="line">    resize(400, 300);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void SubWidget::sendSlot()</span><br><span class="line">&#123;</span><br><span class="line">    emit mySignal();</span><br><span class="line">    emit mySignal(250, &quot;我是子窗口&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>SingnalAndSlot.pro<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">QT       += core gui</span><br><span class="line"></span><br><span class="line">greaterThan(QT_MAJOR_VERSION, 4): QT += widgets</span><br><span class="line"></span><br><span class="line">TARGET = 03_SignalAndSlot</span><br><span class="line">TEMPLATE = app</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SOURCES += main.cpp\</span><br><span class="line">        mainwidget.cpp \</span><br><span class="line">    subwidget.cpp</span><br><span class="line"></span><br><span class="line">HEADERS  += mainwidget.h \</span><br><span class="line">    subwidget.h</span><br><span class="line"></span><br><span class="line">CONFIG += C++11</span><br></pre></td></tr></table></figure></p><h1 id="4-总结"><a href="#4-总结" class="headerlink" title="4 总结"></a>4 总结</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2019/03/16/qt-note/pic2.png" alt="结构图" title>                </div>                <div class="image-caption">结构图</div>            </figure><h1 id="5-参考博文"><a href="#5-参考博文" class="headerlink" title="5 参考博文"></a>5 参考博文</h1><ol><li>C++_之Qt的信号和槽的详解 <a href="https://www.cnblogs.com/wanghui1234/p/8964968.html" target="_blank" rel="noopener">https://www.cnblogs.com/wanghui1234/p/8964968.html</a>  </li><li>Qt信号和槽机制 <a href="https://blog.csdn.net/lsfreeing/article/details/78575246" target="_blank" rel="noopener">https://blog.csdn.net/lsfreeing/article/details/78575246</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-简介&quot;&gt;&lt;a href=&quot;#1-简介&quot; class=&quot;headerlink&quot; title=&quot;1 简介&quot;&gt;&lt;/a&gt;1 简介&lt;/h1&gt;&lt;p&gt; 信号和槽是Qt特有的信息传输机制，是Qt设计程序的重要基础，它可以让互不干扰的对象建立一种联系。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="AI组件开发" scheme="http://11wy11.github.io/categories/AI%E7%BB%84%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    
      <category term="C++" scheme="http://11wy11.github.io/categories/C/"/>
    
    
      <category term="C++" scheme="http://11wy11.github.io/tags/C/"/>
    
      <category term="QT" scheme="http://11wy11.github.io/tags/QT/"/>
    
  </entry>
  
  <entry>
    <title>krpano快速入门教程（二）</title>
    <link href="http://11wy11.github.io/2019/03/15/krpano-second-note/"/>
    <id>http://11wy11.github.io/2019/03/15/krpano-second-note/</id>
    <published>2019-03-15T15:19:51.000Z</published>
    <updated>2019-03-16T05:46:36.064Z</updated>
    
    <content type="html"><![CDATA[<h3 id="vtour全景漫游及vtour文件夹介绍"><a href="#vtour全景漫游及vtour文件夹介绍" class="headerlink" title="vtour全景漫游及vtour文件夹介绍"></a>vtour全景漫游及vtour文件夹介绍</h3><p>使用MAKE VTOUR (MULTIRES) droplet工具生成全景漫游<br><a id="more"></a></p><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>在初始学习krpano时，可以借助krpano的工具生成全景漫游文件，之后可以根据需要修改tour.xml,定制skin等；<br>上节简单介绍了krpano使用Make pano的工具创建单场景应用，但大多数应用中场景数量不只一个，彼此之间可以跳转，这就需要借助MAKE VTOUR droplet工具了。而具体选择三种中的哪一种，根据应用场景需要选择，multires支持将全景切片分级，能够达到更好的展示效果，但会使全景文件大小增加，normal生成普通的pano_f.jpg,pano_b.jpg,pano_l.jpg，pano_r.jpg，pano_u.jpg，pano_d.jpg,preview.jpg，分别为全景图的前后左右上下，以及菜单中的预览图。</p><h3 id="生成vtour"><a href="#生成vtour" class="headerlink" title="生成vtour"></a>生成vtour</h3><p>使用MAKE VTOUR (MULTIRES) droplet工具生成的全景漫游场景，场景彼此之间相互连接，能够从一个场景跳转到另一个场景。<br>可以同时选择多张全景图片拖放在该工具上，输入全景图类型，和全景角度，执行切片，等待完成。显示<strong>done</strong>之后，在全景图文件夹中生成vtour文件夹。</p><h3 id="vtour文件夹内容介绍"><a href="#vtour文件夹内容介绍" class="headerlink" title="vtour文件夹内容介绍"></a>vtour文件夹内容介绍</h3><ol><li>tour.html文件–嵌入全景的网页</li><li>tour.swf文件–krpano的flash viewer</li><li>tour.js文件–基于swfkrpano.js的一个viewer，即HTML5的viewer及嵌入HTML的js文件的合体</li><li>tour.xml文件–是krpano xml配置文件，定义全景图配置及皮肤配置</li><li>panos文件夹–存放处理后的全景图切片</li><li>plugins文件夹–主要存放使用到的插件</li></ol><h3 id="预览效果"><a href="#预览效果" class="headerlink" title="预览效果"></a>预览效果</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2019/03/15/krpano-second-note/pic1.png" alt="效果图" title>                </div>                <div class="image-caption">效果图</div>            </figure><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p>之后的主要工作为：定制skin，定制plugins，定制xml，一些动态操作全景图配置使编辑js文件，能够实现动态配置全景图程序，能够更好的融入到Web应用程序中，作为其中一个子功能模块。后续结合实际案例介绍具体实现方式。历史文章</p><h3 id="历史文章"><a href="#历史文章" class="headerlink" title="历史文章"></a>历史文章</h3><p><a href="/2019/03/14/krpano-first-note">krpano快速入门教程（一)</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;vtour全景漫游及vtour文件夹介绍&quot;&gt;&lt;a href=&quot;#vtour全景漫游及vtour文件夹介绍&quot; class=&quot;headerlink&quot; title=&quot;vtour全景漫游及vtour文件夹介绍&quot;&gt;&lt;/a&gt;vtour全景漫游及vtour文件夹介绍&lt;/h3&gt;&lt;p&gt;使用MAKE VTOUR (MULTIRES) droplet工具生成全景漫游&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="全景" scheme="http://11wy11.github.io/categories/%E5%85%A8%E6%99%AF/"/>
    
    
      <category term="krpano" scheme="http://11wy11.github.io/tags/krpano/"/>
    
  </entry>
  
  <entry>
    <title>krpano快速入门教程（一）</title>
    <link href="http://11wy11.github.io/2019/03/14/krpano-first-note/"/>
    <id>http://11wy11.github.io/2019/03/14/krpano-first-note/</id>
    <published>2019-03-14T07:54:54.000Z</published>
    <updated>2019-03-16T05:46:36.064Z</updated>
    
    <content type="html"><![CDATA[<h2 id="使用krpano工具构建即用型panos"><a href="#使用krpano工具构建即用型panos" class="headerlink" title="使用krpano工具构建即用型panos"></a>使用krpano工具构建即用型panos</h2><p>简单使用krpano工具快速生成可执行的pano文件，后续介绍如何自定义编写配置文件切图等<br><a id="more"></a></p><h2 id="krpano简介"><a href="#krpano简介" class="headerlink" title="krpano简介"></a>krpano简介</h2><p>Krpano是一款全景漫游制作软件和工具。用krpano所生成的全景，在兼容性、功能性、互动性方面的表现都很不错，而且可以二次开发并拥有自己的编程语言，比如使用专用的krpano xml代码编写全景漫游，可开发出高度定制化的项目。因此，目前主流的全景网站均是在krpano全景的基础上进行开发，并不断进行更新迭代，形成自己独有的全景内容服务。</p><h2 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h2><ol><li>从<a href="https://krpano.com/download/" target="_blank" rel="noopener">krpano下载页面下载</a>适合于自己系统的krpano Tools软件包</li><li>将下载的krpano Tools zip文件解压到一个不含中文路径的文件夹下（为了所有稳定使用，推荐）</li><li>如果您已拥有krpano许可文件 - 则立即将其复制或移动到krpano Tools文件夹中。如果您没有任何一个，那么只需跳过此步骤即可。之后可以通过注册码注册，具体破解方法请自行百度，注册后能够去掉切片中的krpano水印。</li><li>要构建单个全景图 - 打开包含全景图像的文件夹，选择其中一个或全部，拖放到MAKE PANO droplet批处理工具上。<br><img src="/2019/03/14/krpano-first-note/pic1.png" alt="拖动全景图到工具上"><br>等待切片完成，会在全景图像所在文件夹中生成一个以全景图命名的文件夹，里面自动生成一个即用型pano,点击tour_testingsever运行测试服务器，打开index.html查看效果。<br><img src="/2019/03/14/krpano-first-note/pic2.png" alt="生成结果"><br>需要说明的是，这里如果没有注册，运行之后全景图是有krpano水印的。可以运行krpano tools选择 register now 输入序列号完成注册。注册完在按照第4步操作，得到没有水印的全景图<br><img src="/2019/03/14/krpano-first-note/pic3.png" alt="注册前"><center>注册前</center><br><img src="/2019/03/14/krpano-first-note/pic4.png" alt="注册后"><br><center> 注册后</center></li><li>要构建虚拟游览 - 打开包含全景虚拟游览图像的文件夹，选择所有这些图像拖放到MAKE VTOURdroplet批处理工具上。 </li><li>其他工具使用类似，主要功能简介如下：  <ul><li>MAKE PANO (NORMAL) droplet<br>针对标准全景图（360度），最大值。cubeize默认限制为2200像素（可以在’templates / normal.config’文件中更改），没有皮肤 - 只需pano，HTML5 iPhone / iPad就绪</li><li>MAKE PANO（MULTIRES）droplet<br>用于渐进多分辨率的panos，没有尺寸/分辨率限制，快速动态加载，带按钮的默认皮肤，HTML5 iPhone / iPad就绪</li><li>MAKE PANO（FLAT）droplet<br>用于平面/ 2D平移/图像，平铺多分辨率，无尺寸/分辨率限制，平坦全景/图像的皮肤/控制，仅限闪光</li><li>MAKE PANO（SINGLESWF）droplet<br>只生成一个Flash swf文件，对于标准全景图，完整的pano将立即加载，最大值。cubesize限制为2200像素（可在’templates / singleswf.config’文件中更改），默认皮肤带按钮，仅限Flash</li><li>MAKE OBJECT droplet<br>用于平铺多分辨率对象影片，一次删除所有对象图像，没有大小/分辨率限制，快速和动态加载，具有按钮和对象旋转控件的对象外观，仅限Flash</li><li>MAKE VTOUR (NORMAL) droplet / MAKE VTOUR (MULTIRES) droplet<br> 用于自动构建虚拟游览，将所有全景图像放在此工具上，通过自动缩略图生成，准备好HTML5 iPhone / iPad </li></ul></li><li>处理完成后关闭dos / terminal窗口。在源图像的文件夹中会有新文件：典型的.html文件 - 这是嵌入pano的示例网页，.swf文件 - 这是krpano Flash查看器，.js文件 - 这是Javascript Flash到HTML嵌入代码（基于swfkrpano.js）和可选的krpano HTML5 / Javascript iPhone / iPad查看器，一个.xml文件 - 这是krpano xml文件，有pano和皮肤定义，最后有.tiles文件夹 - 有处理过的全景图像。全景图像本身不是观看全景图像所必需的。 6.2。当您使用MAKE VTOUR Droplet时，这些文件将位于’vtour’文件夹中，而pano图像位于其中的’panos’文件夹中。</li><li>编辑全景设置打开并在任何文本编辑器中编辑生成的xml文件（带有xml-syntax-highlighting的文本编辑器可能会有帮助）： 在在线文档中查找krpano xml定义：</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;使用krpano工具构建即用型panos&quot;&gt;&lt;a href=&quot;#使用krpano工具构建即用型panos&quot; class=&quot;headerlink&quot; title=&quot;使用krpano工具构建即用型panos&quot;&gt;&lt;/a&gt;使用krpano工具构建即用型panos&lt;/h2&gt;&lt;p&gt;简单使用krpano工具快速生成可执行的pano文件，后续介绍如何自定义编写配置文件切图等&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="全景" scheme="http://11wy11.github.io/categories/%E5%85%A8%E6%99%AF/"/>
    
    
      <category term="krpano" scheme="http://11wy11.github.io/tags/krpano/"/>
    
  </entry>
  
  <entry>
    <title>AI组件开发（一）--注记旋转矩阵</title>
    <link href="http://11wy11.github.io/2019/03/14/ai-first-note/"/>
    <id>http://11wy11.github.io/2019/03/14/ai-first-note/</id>
    <published>2019-03-14T02:56:02.000Z</published>
    <updated>2019-03-16T05:46:36.062Z</updated>
    
    <content type="html"><![CDATA[<h2 id="SDK官方帮助文档"><a href="#SDK官方帮助文档" class="headerlink" title="SDK官方帮助文档"></a>SDK官方帮助文档</h2><p>AIAPI void(<em> AIRealMathSuite::AIRealMatrixSet)(AIRealMatrix </em>m, AIReal a, AIReal b, AIReal c, AIReal d, AIReal tx, AIReal ty)<br>Sets the scale, rotation, and translation values of a transformation matrix.<br>Parameters:<br>m The matrix object.<br>a New a value.<br>b New b value.<br>c New c value.<br>d New d value.<br>tx New horizontal translation value.<br>ty New vertical translation value.  </p><h2 id="参数及原理分析"><a href="#参数及原理分析" class="headerlink" title="参数及原理分析"></a>参数及原理分析</h2><p>ad缩放bc旋转tx,ty位移，基础的2D矩阵<br> 公式</p><pre><code>x=ax+cy+txy=bx+dy+ty</code></pre><p>为了把二维图形的变化统一在一个坐标系里，引入了齐次坐标的概念，即把一个图形用一个三维矩阵表示，其中第三列总是(0,0,1)，用来作为坐标系的标准。所以所有的变化都由前两列完成<br>以上参数在矩阵中的表示为：</p><p> |a    b    0|</p><p> |c    d    0|</p><p> |tx   ty   1|</p><p>运算原理：原坐标设为（X,Y,1）;</p><pre><code>                     |a    b    0|[X，Y,  1]           |c    d    0|     =     [aX + cY + tx   bX + dY + ty  1] ;                     |tx    ty  1|</code></pre><p>通过矩阵运算后的坐标[aX + cY + tx   bX + dY + ty  1]，我们对比一下可知：</p><ol><li>第一种：设a=d=1, b=c=0.  </li></ol><p>[aX + cY + tx   bX + dY + ty  1] = [X  + tx  Y + ty  1];</p><p>可见，这个时候，坐标是按照向量（tx，ty）进行平移，其实这也就是函数</p><ol start="2"><li>第二种：设b=c=tx=ty=0.  </li></ol><p>[aX + cY + tx   bX + dY + ty  1] = [aX    dY   1];</p><p>可见，这个时候，坐标X按照a进行缩放，Y按照d进行缩放，a，d就是X，Y的比例系数，其实这也就是函数</p><ol start="3"><li>第三种：设tx=ty=0，a=cosɵ，b=sinɵ，c=-sinɵ，d=cosɵ。</li></ol><p>[aX + cY + tx   bX + dY + ty  1] = [Xcosɵ - Ysinɵ    Xsinɵ + Ycosɵ  1] ;</p><p>可见，这个时候，ɵ就是旋转的角度，逆时针为正，顺时针为负。其实这也就是函数</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;SDK官方帮助文档&quot;&gt;&lt;a href=&quot;#SDK官方帮助文档&quot; class=&quot;headerlink&quot; title=&quot;SDK官方帮助文档&quot;&gt;&lt;/a&gt;SDK官方帮助文档&lt;/h2&gt;&lt;p&gt;AIAPI void(&lt;em&gt; AIRealMathSuite::AIRealMat
      
    
    </summary>
    
      <category term="AI组件开发" scheme="http://11wy11.github.io/categories/AI%E7%BB%84%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="AI" scheme="http://11wy11.github.io/tags/AI/"/>
    
  </entry>
  
  <entry>
    <title>csdn-markdown编辑器语法</title>
    <link href="http://11wy11.github.io/2019/03/14/csdn-markdown-grammar/"/>
    <id>http://11wy11.github.io/2019/03/14/csdn-markdown-grammar/</id>
    <published>2019-03-13T16:03:21.000Z</published>
    <updated>2019-03-14T02:18:56.851Z</updated>
    
    <content type="html"><![CDATA[<p>@<a href="这里写自定义目录标题">TOC</a></p><h1 id="欢迎使用Markdown编辑器"><a href="#欢迎使用Markdown编辑器" class="headerlink" title="欢迎使用Markdown编辑器"></a>欢迎使用Markdown编辑器</h1><p>你好！ 这是你第一次使用 <strong>Markdown编辑器</strong> 所展示的欢迎页。如果你想学习如何使用Markdown编辑器, 可以仔细阅读这篇文章，了解一下Markdown的基本语法知识。</p><h2 id="功能快捷键"><a href="#功能快捷键" class="headerlink" title="功能快捷键"></a>功能快捷键</h2><p>撤销：<kbd>Ctrl/Command</kbd> + <kbd>Z</kbd><br>重做：<kbd>Ctrl/Command</kbd> + <kbd>Y</kbd><br>加粗：<kbd>Ctrl/Command</kbd> + <kbd>B</kbd><br>斜体：<kbd>Ctrl/Command</kbd> + <kbd>I</kbd><br>标题：<kbd>Ctrl/Command</kbd> + <kbd>Shift</kbd> + <kbd>H</kbd><br>无序列表：<kbd>Ctrl/Command</kbd> + <kbd>Shift</kbd> + <kbd>U</kbd><br>有序列表：<kbd>Ctrl/Command</kbd> + <kbd>Shift</kbd> + <kbd>O</kbd><br>检查列表：<kbd>Ctrl/Command</kbd> + <kbd>Shift</kbd> + <kbd>C</kbd><br>插入代码：<kbd>Ctrl/Command</kbd> + <kbd>Shift</kbd> + <kbd>K</kbd><br>插入链接：<kbd>Ctrl/Command</kbd> + <kbd>Shift</kbd> + <kbd>L</kbd><br>插入图片：<kbd>Ctrl/Command</kbd> + <kbd>Shift</kbd> + <kbd>G</kbd></p><h2 id="合理的创建标题，有助于目录的生成"><a href="#合理的创建标题，有助于目录的生成" class="headerlink" title="合理的创建标题，有助于目录的生成"></a>合理的创建标题，有助于目录的生成</h2><p>直接输入1次<kbd>#</kbd>，并按下<kbd>space</kbd>后，将生成1级标题。<br>输入2次<kbd>#</kbd>，并按下<kbd>space</kbd>后，将生成2级标题。<br>以此类推，我们支持6级标题。有助于使用<code>TOC</code>语法后生成一个完美的目录。</p><h2 id="如何改变文本的样式"><a href="#如何改变文本的样式" class="headerlink" title="如何改变文本的样式"></a>如何改变文本的样式</h2><p><em>强调文本</em> <em>强调文本</em></p><p><strong>加粗文本</strong> <strong>加粗文本</strong></p><p>==标记文本==</p><p><del>删除文本</del></p><blockquote><p>引用文本</p></blockquote><p>H~2~O is是液体。</p><p>2^10^ 运算结果是 1024.</p><h2 id="插入链接与图片"><a href="#插入链接与图片" class="headerlink" title="插入链接与图片"></a>插入链接与图片</h2><p>链接: <a href="https://mp.csdn.net" target="_blank" rel="noopener">link</a>.</p><p>图片: <figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://avatar.csdn.net/7/7/B/1_ralf_hx163com.jpg" alt="Alt" title>                </div>                <div class="image-caption">Alt</div>            </figure></p><p>带尺寸的图片: <figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://avatar.csdn.net/7/7/B/1_ralf_hx163com.jpg" alt="Alt" title="=30x30">                </div>                <div class="image-caption">=30x30</div>            </figure></p><p>居中的图片: <figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://avatar.csdn.net/7/7/B/1_ralf_hx163com.jpg#pic_center" alt="Alt" title>                </div>                <div class="image-caption">Alt</div>            </figure></p><p>居中并且带尺寸的图片: <figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://avatar.csdn.net/7/7/B/1_ralf_hx163com.jpg#pic_center" alt="Alt" title="=30x30">                </div>                <div class="image-caption">=30x30</div>            </figure></p><p>当然，我们为了让用户更加便捷，我们增加了图片拖拽功能。</p><h2 id="如何插入一段漂亮的代码片"><a href="#如何插入一段漂亮的代码片" class="headerlink" title="如何插入一段漂亮的代码片"></a>如何插入一段漂亮的代码片</h2><p>去<a href="https://mp.csdn.net/configure" target="_blank" rel="noopener">博客设置</a>页面，选择一款你喜欢的代码片高亮样式，下面展示同样高亮的 <code>代码片</code>.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// An highlighted block</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="string">'bar'</span>;</span><br></pre></td></tr></table></figure></p><h2 id="生成一个适合你的列表"><a href="#生成一个适合你的列表" class="headerlink" title="生成一个适合你的列表"></a>生成一个适合你的列表</h2><ul><li>项目<ul><li>项目<ul><li>项目</li></ul></li></ul></li></ul><ol><li>项目1</li><li>项目2</li><li>项目3</li></ol><ul><li style="list-style: none"><input type="checkbox"> 计划任务</li><li style="list-style: none"><input type="checkbox" checked> 完成任务</li></ul><h2 id="创建一个表格"><a href="#创建一个表格" class="headerlink" title="创建一个表格"></a>创建一个表格</h2><p>一个简单的表格是这么创建的：<br>项目     | Value<br>——– | —–<br>电脑  | $1600<br>手机  | $12<br>导管  | $1</p><h3 id="设定内容居中、居左、居右"><a href="#设定内容居中、居左、居右" class="headerlink" title="设定内容居中、居左、居右"></a>设定内容居中、居左、居右</h3><p>使用<code>:---------:</code>居中<br>使用<code>:----------</code>居左<br>使用<code>----------:</code>居右<br>| 第一列       | 第二列         | 第三列        |<br>|:———–:| ————-:|:————-|<br>| 第一列文本居中 | 第二列文本居右  | 第三列文本居左 | </p><h3 id="SmartyPants"><a href="#SmartyPants" class="headerlink" title="SmartyPants"></a>SmartyPants</h3><p>SmartyPants将ASCII标点字符转换为“智能”印刷标点HTML实体。例如：<br>|    TYPE   |ASCII                          |HTML<br>|—————-|——————————-|—————————–|<br>|Single backticks|<code>&#39;Isn&#39;t this fun?&#39;</code>            |’Isn’t this fun?’            |<br>|Quotes          |<code>&quot;Isn&#39;t this fun?&quot;</code>            |”Isn’t this fun?”            |<br>|Dashes          |<code>-- is en-dash, --- is em-dash</code>|– is en-dash, — is em-dash|</p><h2 id="创建一个自定义列表"><a href="#创建一个自定义列表" class="headerlink" title="创建一个自定义列表"></a>创建一个自定义列表</h2><p>Markdown<br>:  Text-to-HTML conversion tool</p><p>Authors<br>:  John<br>:  Luke</p><h2 id="如何创建一个注脚"><a href="#如何创建一个注脚" class="headerlink" title="如何创建一个注脚"></a>如何创建一个注脚</h2><p>一个具有注脚的文本。<a href="注脚的解释">^2</a></p><h2 id="注释也是必不可少的"><a href="#注释也是必不可少的" class="headerlink" title="注释也是必不可少的"></a>注释也是必不可少的</h2><p>Markdown将文本转换为 HTML。</p><p>*[HTML]:   超文本标记语言</p><h2 id="KaTeX数学公式"><a href="#KaTeX数学公式" class="headerlink" title="KaTeX数学公式"></a>KaTeX数学公式</h2><p>您可以使用渲染LaTeX数学表达式 <a href="https://khan.github.io/KaTeX/" target="_blank" rel="noopener">KaTeX</a>:</p><p>Gamma公式展示 $\Gamma(n) = (n-1)!\quad\forall<br>n\in\mathbb N$ 是通过欧拉积分</p><p>$$<br>\Gamma(z) = \int_0^\infty t^{z-1}e^{-t}dt\,.<br>$$</p><blockquote><p>你可以找到更多关于的信息 <strong>LaTeX</strong> 数学表达式<a href="http://meta.math.stackexchange.com/questions/5020/mathjax-basic-tutorial-and-quick-reference" target="_blank" rel="noopener">here</a>.</p></blockquote><h2 id="新的甘特图功能，丰富你的文章"><a href="#新的甘特图功能，丰富你的文章" class="headerlink" title="新的甘特图功能，丰富你的文章"></a>新的甘特图功能，丰富你的文章</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">gantt</span><br><span class="line">        dateFormat  YYYY-MM-DD</span><br><span class="line">        title Adding GANTT diagram functionality to mermaid</span><br><span class="line">        section 现有任务</span><br><span class="line">        已完成               :done,    des1, 2014-01-06,2014-01-08</span><br><span class="line">        进行中               :active,  des2, 2014-01-09, 3d</span><br><span class="line">        计划一               :         des3, after des2, 5d</span><br><span class="line">        计划二               :         des4, after des3, 5d</span><br></pre></td></tr></table></figure><ul><li>关于 <strong>甘特图</strong> 语法，参考 <a href="https://mermaidjs.github.io/" target="_blank" rel="noopener">这儿</a>,</li></ul><h2 id="UML-图表"><a href="#UML-图表" class="headerlink" title="UML 图表"></a>UML 图表</h2><p>可以使用UML图表进行渲染。 <a href="https://mermaidjs.github.io/" target="_blank" rel="noopener">Mermaid</a>. 例如下面产生的一个序列图：:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">张三 -&gt;&gt; 李四: 你好！李四, 最近怎么样?</span><br><span class="line">李四--&gt;&gt;王五: 你最近怎么样，王五？</span><br><span class="line">李四--x 张三: 我很好，谢谢!</span><br><span class="line">李四-x 王五: 我很好，谢谢!</span><br><span class="line">Note right of 王五: 李四想了很长时间, 文字太长了&lt;br/&gt;不适合放在一行.</span><br><span class="line"></span><br><span class="line">李四--&gt;&gt;张三: 打量着王五...</span><br><span class="line">张三-&gt;&gt;王五: 很好... 王五, 你怎么样?</span><br></pre></td></tr></table></figure><p>这将产生一个流程图。:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">A[长方形] -- 链接 --&gt; B((圆))</span><br><span class="line">A --&gt; C(圆角长方形)</span><br><span class="line">B --&gt; D&#123;菱形&#125;</span><br><span class="line">C --&gt; D</span><br></pre></td></tr></table></figure><ul><li>关于 <strong>Mermaid</strong> 语法，参考 <a href="https://mermaidjs.github.io/" target="_blank" rel="noopener">这儿</a>,</li></ul><h2 id="FLowchart流程图"><a href="#FLowchart流程图" class="headerlink" title="FLowchart流程图"></a>FLowchart流程图</h2><p>我们依旧会支持flowchart的流程图：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">flowchat</span><br><span class="line">st=&gt;start: 开始</span><br><span class="line">e=&gt;end: 结束</span><br><span class="line">op=&gt;operation: 我的操作</span><br><span class="line">cond=&gt;condition: 确认？</span><br><span class="line"></span><br><span class="line">st-&gt;op-&gt;cond</span><br><span class="line">cond(yes)-&gt;e</span><br><span class="line">cond(no)-&gt;op</span><br></pre></td></tr></table></figure></p><ul><li>关于 <strong>Flowchart流程图</strong> 语法，参考 <a href="http://adrai.github.io/flowchart.js/" target="_blank" rel="noopener">这儿</a>.</li></ul><h2 id="导出与导入"><a href="#导出与导入" class="headerlink" title="导出与导入"></a>导出与导入</h2><h3 id="导出"><a href="#导出" class="headerlink" title="导出"></a>导出</h3><p>如果你想尝试使用此编辑器, 你可以在此篇文章任意编辑。当你完成了一篇文章的写作, 在上方工具栏找到 <strong>文章导出</strong> ，生成一个.md文件或者.html文件进行本地保存。</p><h3 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h3><p>如果你想加载一篇你写过的.md文件或者.html文件，在上方工具栏可以选择导入功能进行对应扩展名的文件导入，<br>继续你的创作。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;@&lt;a href=&quot;这里写自定义目录标题&quot;&gt;TOC&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;欢迎使用Markdown编辑器&quot;&gt;&lt;a href=&quot;#欢迎使用Markdown编辑器&quot; class=&quot;headerlink&quot; title=&quot;欢迎使用Markdown编辑器&quot;&gt;&lt;/a&gt;欢迎使用
      
    
    </summary>
    
      <category term="语言" scheme="http://11wy11.github.io/categories/%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="markdown" scheme="http://11wy11.github.io/tags/markdown/"/>
    
  </entry>
  
  <entry>
    <title>git常用命令</title>
    <link href="http://11wy11.github.io/2019/03/13/git-command/"/>
    <id>http://11wy11.github.io/2019/03/13/git-command/</id>
    <published>2019-03-13T12:41:15.000Z</published>
    <updated>2019-03-14T02:18:56.852Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>强制本地覆盖远程分支   </p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    git push origin *** --force  </span><br><span class="line">    ```  </span><br><span class="line">2. 放弃本地分支，远程分支强制覆盖本地</span><br><span class="line">  </span><br><span class="line">git fetch --all    //只是下载代码到本地，不进行合并操作</span><br><span class="line">git reset --hard origin/分支名如master    //把HEAD指向最新下载的版本</span><br><span class="line">3. 删除远程分支和本地分支</span><br></pre></td></tr></table></figure><p>git branch -a//查看分支<br>git push origin –delete <strong><em>// 删除远程分支<br>git branch -d </em></strong>//删除本地分支</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">4. git diff</span><br><span class="line">    检查文件更改内容</span><br><span class="line">5. 撤销未提交的修改git checkout</span><br></pre></td></tr></table></figure><p>  git checkout app/src/main/../MainActivity </p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">6、git reset</span><br></pre></td></tr></table></figure><p>git log #找到需要退回的commit版本号，可以只复制前几位<br>git reset &lt;刚查找到的版本号&gt;<br><code>`</code><br>7、git log</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;强制本地覆盖远程分支   &lt;/p&gt;
 &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class
      
    
    </summary>
    
      <category term="使用技巧" scheme="http://11wy11.github.io/categories/%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
    
    
      <category term="git" scheme="http://11wy11.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>使用hexo+github创建个人博客并备份源码</title>
    <link href="http://11wy11.github.io/2019/03/09/create-blog-process/"/>
    <id>http://11wy11.github.io/2019/03/09/create-blog-process/</id>
    <published>2019-03-09T13:52:06.000Z</published>
    <updated>2019-03-16T05:46:36.063Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、准备"><a href="#一、准备" class="headerlink" title="一、准备"></a>一、准备</h3><ol><li>安装<a href="https://nodejs.org/en/" target="_blank" rel="noopener">node.js</a></li><li>安装<a href="https://gitforwindows.org/" target="_blank" rel="noopener">git-windows</a></li><li><p>安装hexo-cli</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$npm install hexo-cli -g</span><br></pre></td></tr></table></figure></li><li><p>在GitHub上创建&lt;username&gt;.github.io的仓库</p><pre><code>e.g. 11wy11.github.io</code></pre></li><li><p>配置SSH key<br>打开本机的控制台，以windows系统为例，可以执行win+R 输入cmd打开，执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -keygen -t rsa -C &apos;D:/id.txt&apos;</span><br></pre></td></tr></table></figure><p>然后连续按3次回车，最终会在用户目录下生成一个文件，找到<strong>目录.ssh/id_rsa.pub</strong>文件，用记事本打开全选复制。<br>在你的github上点击头像&gt;设置进入设置页面，选择SSH and GPG keys, 点击<strong>New SSH key</strong>按钮，名称随意填写，将刚复制的内容粘贴到key,添加<br><img src="/2019/03/09/create-blog-process/res2.png" alt="添加ssh key"></p><h3 id="二、搭建流程"><a href="#二、搭建流程" class="headerlink" title="二、搭建流程"></a>二、搭建流程</h3></li><li>本地创建&lt;username&gt;.github.io</li><li><p>在本地&lt;username&gt;.github.io文件夹下初始化hexo项目并安装依赖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo init //初始化工程</span><br><span class="line">npm install //安装依赖</span><br><span class="line">hexo server //启动本地调试器在localhost:4000预览</span><br></pre></td></tr></table></figure></li><li><p>修改默认主题，可以在github上clone其他的主题，如<a href="https://github.com/litten/hexo-theme-yilia" target="_blank" rel="noopener">yilia</a>,<a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">icarus</a>,<a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank" rel="noopener">indigo</a>等</p><ul><li><p>以indigo为例，在本地&lt;username&gt;.github.io文件夹下执行以下命令安装主题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone git@github.com:yscoder/hexo-theme-indigo.git themes/indigo</span><br></pre></td></tr></table></figure></li><li><p>修改工程中的_config.yml配置文件，将themes: landscope改为themes: indigo<br><img src="/2019/03/09/create-blog-process/res1.png" alt="修改配置"></p></li><li><p>依赖安装分别安装Less,Feed,Json-content依赖，执行如下命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-renderer-less --save</span><br><span class="line">$ npm install hexo-generator-feed --save</span><br><span class="line">$ npm install hexo-generator-json-content --save</span><br></pre></td></tr></table></figure></li><li><p>执行<code>hexo s</code>命令启动服务器在localhost:4000查看效果</p></li></ul></li><li>新建文章，使用hexo new  “my-first blog”，会在source/_posts下创建my-first-blog.md的页面文件<br>进行编写</li><li><p>发布博客<br>首先修改工程中的_config.yml配置文件，在最后三行添加以下代码，将username换成自己的git用户名</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: git@github.com:&lt;username&gt;/&lt;username&gt;.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><p> 其次安装hexo-deployer-git 执行 <code>npm install hexo-deployer-git --save</code><br> 在工程文件夹内右键git bash进入命令行 输入hexo g，编译为静态文件，生成public文件夹，使用 hexo d 部署，此时可以访问https://&lt;username&gt;.github.io查看你的博客</p></li><li>备份源码<br> 在工程文件夹内右键git bash进入命令行 输入 touch .gitignore ，生成“.gitignore”文件。<br> 在”.gitignore” 文件里输入你要忽略的文件夹及其文件就可以了。（注意格式）<br> 我的 .gitignore：<pre><code>node_modules/.deploy_gitpublic/.DS_Store Thumbs.dbdb.json  *.log.deploy*/</code></pre>  执行以下命令<pre><code class="git">#git初始化git init#创建hexo分支，用来存放源码git checkout -b hexo#git 文件添加git add .#git 提交git commit -m &quot;init&quot;#添加远程仓库git remote add origin git@github.com:&lt;username&gt;/&lt;username&gt;.github.io.git#push到hexo分支git push origin hexo</code></pre> 执行hexo g -d生成网站并部署到GitHub上<br> 这样一来，在GitHub上的<a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>:&lt;username&gt;/&lt;username&gt;.github.io.git仓库就有两个分支，一个hexo分支用来存放网站的原始文件，一个master分支用来存放生成的静态网页。</li><li>其他设备更新博客步骤：<br> 1、先安装hexo<br> $ npm install -g hexo-cli<br> 2、存在github上的git clone下来<br> git clone -b hexo <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>:&lt;username&gt;/&lt;username&gt;.github.io.git<br> 3、项目文件夹下<br> $ npm install<br> $ npm install hexo-deployer-git<br> 4、重新配置github和coding的公钥<br> 5、编写博客push 到远程分支   <h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3></li><li>有时会出现下载的主题无法上传，首先删除themes/主题文件夹下的<code>.git</code>,使用<code>git rm --cached themes/indigo</code>命令清空后重新上传`</li><li>如果最开始.gitignore文件没有配置正确，可以使用<code>git rm -r --cached .</code>命令清楚缓存文件，重新add,commit,push上传</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一、准备&quot;&gt;&lt;a href=&quot;#一、准备&quot; class=&quot;headerlink&quot; title=&quot;一、准备&quot;&gt;&lt;/a&gt;一、准备&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;安装&lt;a href=&quot;https://nodejs.org/en/&quot; target=&quot;_blank&quot; rel=&quot;
      
    
    </summary>
    
      <category term="工具" scheme="http://11wy11.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="hexo" scheme="http://11wy11.github.io/tags/hexo/"/>
    
      <category term="git" scheme="http://11wy11.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>Vue全局添加组件</title>
    <link href="http://11wy11.github.io/2019/03/09/Vue-global-component/"/>
    <id>http://11wy11.github.io/2019/03/09/Vue-global-component/</id>
    <published>2019-03-09T02:39:22.000Z</published>
    <updated>2019-03-14T11:01:43.749Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一-背景"><a href="#一-背景" class="headerlink" title="一. 背景"></a>一. 背景</h3><p>在项目中有时需要反复用到如区域选择器等组件，每次使用时都需要在对应的vue中添加import,并在component中注册，为了避免多次书写引用代码，可以自定义全局组件，只需要在main.js中一次性注册在vue项目中，可以自定义组件像vue-resource一样使用Vue.use（）方法来使用。</p><h3 id="二-具体实现方法"><a href="#二-具体实现方法" class="headerlink" title="二. 具体实现方法"></a>二. 具体实现方法</h3><p>1、首先建一个自定义组件的文件夹，比如叫loading，在该文件夹下新建一个index.js，一个自定义组件loading.vue,在这个loading.vue里面就是这个组件的具体的内容，</p><p>2、在index.js中，规定使用这个组件的名字，以及使用方法，如：</p><pre><code>import loadingComponent from &apos;./loading.vue&apos;const loading={    install:function(Vue){        Vue.component(&apos;Loading&apos;,loadingComponent)    }  //&apos;Loading&apos;这就是后面可以使用的组件的名字，install是默认的一个方法};export default loading;```</code></pre><p>3、只要在main.js中规定了install方法，就可以像一些公共的插件一样使用Vue.use()来使用：</p><pre><code>import loading from &apos;./loading&apos;Vue.use(loading）</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一-背景&quot;&gt;&lt;a href=&quot;#一-背景&quot; class=&quot;headerlink&quot; title=&quot;一. 背景&quot;&gt;&lt;/a&gt;一. 背景&lt;/h3&gt;&lt;p&gt;在项目中有时需要反复用到如区域选择器等组件，每次使用时都需要在对应的vue中添加import,并在component中注
      
    
    </summary>
    
      <category term="前端" scheme="http://11wy11.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Vue" scheme="http://11wy11.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Oracle配置SDE支持空间查询</title>
    <link href="http://11wy11.github.io/2019/03/09/oracle-st-geometry/"/>
    <id>http://11wy11.github.io/2019/03/09/oracle-st-geometry/</id>
    <published>2019-03-09T01:56:40.000Z</published>
    <updated>2019-03-15T01:30:31.992Z</updated>
    
    <content type="html"><![CDATA[<h3 id="配置oracle外部链接库"><a href="#配置oracle外部链接库" class="headerlink" title="配置oracle外部链接库"></a>配置oracle外部链接库</h3><ol><li>将ArcGIS Desktop安装目录下DatabaseSupport文件夹下的st_shapelib.dll拷贝到装有oracle的服务器上，可以放置在任意地方，这里推荐放在Oracle安装目录下的bin文件夹下。<br> 例如：st_shapelib.dll所在文件夹路径：<br> C:\ProgramFiles(x86)\ArcGIS\Desktop10.2\DatabaseSupport\Oracle\Windows64\st_shapelib.dll<br> 拷贝放置位置：E:\app\503\product\11.2.0\dbhome_1\BIN\ st_shapelib.dll</li><li><p>修改oracle安装目录下的network/admin文件夹下的listener.ora,将步骤1中的st_shapelib.dll路径添加到<br>ENVS”EXTPROC_DLLS=ONLY:E:\app\503\product\11.2.0\dbhome_1\bin\oraclr11.dll;后面</p><pre><code>例如：linstener文件，添加红色字部分</code></pre> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># listener.ora Network Configuration File: D:\app\Administrator\product\11.2.0\dbhome_1\NETWORK\ADMIN\listener.ora</span><br><span class="line"># Generated by Oracle configuration tools.</span><br><span class="line">SID_LIST_LISTENER =</span><br><span class="line">  (SID_LIST =</span><br><span class="line">    (SID_DESC =</span><br><span class="line">      (SID_NAME = CLRExtProc)</span><br><span class="line">      (ORACLE_HOME = E:\app\503\product\11.2.0\dbhome_1)</span><br><span class="line">      (PROGRAM = extproc)</span><br><span class="line">      (ENVS= &quot;EXTPROC_DLLS=ONLY:E:\app\503\product\11.2.0\dbhome_1\bin\oraclr11.dll;E:\app\503\product\11.2.0\dbhome_1\bin\st_shapelib.dll&quot;) # interesting</span><br><span class="line">    )</span><br><span class="line">  )   </span><br><span class="line">LISTENER =</span><br><span class="line">  (DESCRIPTION_LIST =</span><br><span class="line">    (DESCRIPTION =</span><br><span class="line">      (ADDRESS = (PROTOCOL = TCP)(HOST = 503-PC)(PORT = 1521))</span><br><span class="line">  (ADDRESS = (PROTOCOL = IPC)(KEY = EXTPROC1521))</span><br><span class="line">    )</span><br><span class="line">    (DESCRIPTION =</span><br><span class="line">      (ADDRESS = (PROTOCOL = TCP)(HOST = 192.168.1.164)(PORT = 1521))</span><br><span class="line">    )</span><br><span class="line">  )</span><br><span class="line"> </span><br><span class="line">ADR_BASE_LISTENER = E:\app\503</span><br></pre></td></tr></table></figure></li><li><p>修改oracle安装home目录下的hs/admin文件夹下的extproc.ora，具体路径示例：E:\app\503\product\11.2.0\dbhome_1\hs\admin\extproc.ora，将最后一行的SET EXTPROC_DLLS=  设为ANY<br><img src="/2019/03/09/oracle-st-geometry/res1.png" alt="extproc.ora设置"></p></li><li>通过任何一个数据库管理软件，这里以sql-plus为例，使用sde用户登录首先执行：<code>select * from user_libraries</code><br> 查看是否有ST_SHAPELIB并检查路径是否与步骤1中的一致，通常默认为c盘第一次安装Arcgis时的相关路径。结果如下：<br>  <img src="/2019/03/09/oracle-st-geometry/res2.png" alt="extproc.ora设置"><br>  如果路径与步骤1中st_shapelib的路径不一致，执行以下两条命令：<ul><li>Create or replace library st_SHAPELIB  as &lt;步骤1中的st_shapelib路径&gt;<br><img src="/2019/03/09/oracle-st-geometry/res3.png" alt="extproc.ora设置"></li><li>Alter package sde.st_geometry_shapelib_pkg compile reuse settings<br><img src="/2019/03/09/oracle-st-geometry/res4.png" alt="extproc.ora设置"></li></ul></li><li>重启监听器OracleOraDB11g_home1TNSListener，有时也需要重启服务OracleServiceORCL。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;配置oracle外部链接库&quot;&gt;&lt;a href=&quot;#配置oracle外部链接库&quot; class=&quot;headerlink&quot; title=&quot;配置oracle外部链接库&quot;&gt;&lt;/a&gt;配置oracle外部链接库&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;将ArcGIS Desktop安装目录下
      
    
    </summary>
    
      <category term="ArcGIS" scheme="http://11wy11.github.io/categories/ArcGIS/"/>
    
    
      <category term="ArcGIS" scheme="http://11wy11.github.io/tags/ArcGIS/"/>
    
      <category term="Oracle" scheme="http://11wy11.github.io/tags/Oracle/"/>
    
  </entry>
  
</feed>
